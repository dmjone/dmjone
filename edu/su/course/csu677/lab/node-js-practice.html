<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->

<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>

        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Nodejs Practice Questions</title>
        <meta property=" og:image" content="/logo.png">
        <meta property="og:type" content="article">

        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@divyamohan1993">
        <meta name="twitter:creator" content="@divyamohan1993">
        <meta name="twitter:image" content="/logo.png">

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />

        <meta name="author" content="Divya Mohan">
        <meta name="robots" content="index, follow">

    </head>

    <body>

        <script> header_author("dm"); </script>

        <main>
            <article class="agen-tableofcontents">
                <h2 class="text-center">Nodejs Practice Questions</h2>
            </article>

            <article>
                <h3>1. What is Node.js?</h3>
                <p>Node.js is an open-source, cross-platform runtime environment that allows developers to execute JavaScript code outside of a web browser. Built on Chrome's V8 engine, it is designed for building scalable, high-performance network applications using a non-blocking, event-driven architecture.</p>
            </article>

            <article>
                <h3>2. What is the difference between Node.js and JavaScript in the browser?</h3>
                <ul>
                    <li><strong>Execution Environment:</strong> Node.js runs on the server, whereas JavaScript in the browser runs on the client.</li>
                    <li><strong>APIs:</strong> Node.js provides APIs for file systems, networking, and operating system-level tasks, while browser JavaScript offers APIs for DOM manipulation and browser-specific features.</li>
                    <li><strong>Global Objects:</strong> Node.js uses global objects like <code>global</code> and <code>process</code>, while browsers use <code>window</code> or <code>document</code>.</li>
                </ul>
            </article>

            <article>
                <h3>3. What is the role of the package.json file in a Node.js project?</h3>
                <p>The <code>package.json</code> file is a manifest for a Node.js project. It includes metadata about the project, dependencies, scripts, and configuration. It is essential for managing packages and sharing the project.</p>
            </article>

            <article>
                <h3>4. What are some common Node.js modules and their uses?</h3>
                <ul>
                    <li><strong>fs:</strong> Handles file system operations like reading, writing, and deleting files.</li>
                    <li><strong>http:</strong> Creates HTTP servers and clients.</li>
                    <li><strong>path:</strong> Works with file and directory paths.</li>
                    <li><strong>events:</strong> Implements the EventEmitter for handling events.</li>
                    <li><strong>os:</strong> Provides information about the operating system.</li>
                </ul>
            </article>

            <article>
                <h3>5. What is the difference between synchronous and asynchronous programming in Node.js?</h3>
                <ul>
                    <li><strong>Synchronous:</strong> Operations are executed sequentially, blocking the main thread until completion.</li>
                    <li><strong>Asynchronous:</strong> Operations run concurrently without blocking, allowing other tasks to execute using callbacks, promises, or async/await.</li>
                </ul>
            </article>

            <article>
                <h3>6. Explain the concept of an Event Loop in Node.js.</h3>
                <p>The Event Loop is a mechanism that handles asynchronous operations in Node.js. It processes callbacks from the event queue, ensuring non-blocking execution. It cycles through phases such as timers, I/O callbacks, idle preparation, poll, check, and close callbacks.</p>
            </article>

            <article>
                <h3>7. What is the purpose of the require function in Node.js?</h3>
                <p>The <code>require</code> function is used to import modules, libraries, or local files into a Node.js application. For example, <code>const fs = require('fs');</code>.</p>
            </article>

            <article>
                <h3>8. How do you export and import modules in Node.js?</h3>
                <ul>
                    <li><strong>Export:</strong> Use <code>module.exports</code> to expose functions or objects.</li>
                    <li><strong>Import:</strong> Use <code>require()</code> to include the exported module.</li>
                </ul>
                <pre><code class="language-js">// Export
module.exports = { greet: () => console.log("Hello!") };

// Import
const utils = require('./utils');
utils.greet();
</code></pre>
            </article>

            <article>
                <h3>9. What is npm, and how is it used in Node.js?</h3>
                <p>npm (Node Package Manager) is a tool to manage Node.js packages. It is used to install, update, and manage project dependencies.</p>
            </article>

            <article>
                <h3>10. What is the difference between npm install --save and npm install --save-dev?</h3>
                <ul>
                    <li><code>--save:</code> Adds the package as a runtime dependency.</li>
                    <li><code>--save-dev:</code> Adds the package as a development dependency, not required during production.</li>
                </ul>
            </article>

            <article>
                <h3>11. What are callbacks in Node.js, and how are they used?</h3>
                <p>Callbacks are functions passed as arguments to other functions, executed after an asynchronous task completes.</p>
                <pre><code class="language-js">fs.readFile('file.txt', (err, data) => {
  if (err) throw err;
  console.log(data.toString());
});
</code></pre>
            </article>

            <article>
                <h3>12. What are Promises in Node.js, and how do they improve asynchronous code?</h3>
                <p>Promises represent the eventual completion or failure of an asynchronous operation, improving readability over callbacks by avoiding "callback hell."</p>
                <pre><code class="language-js">fs.promises.readFile('file.txt')
  .then(data => console.log(data.toString()))
  .catch(err => console.error(err));
</code></pre>
            </article>

            <article>
                <h3>13. Explain the concept of async/await in Node.js.</h3>
                <p><code>async/await</code> is a syntactic sugar over Promises, enabling asynchronous code to look synchronous for better readability.</p>
                <pre><code class="language-js">async function readFile() {
  try {
    const data = await fs.promises.readFile('file.txt');
    console.log(data.toString());
  } catch (err) {
    console.error(err);
  }
}
readFile();
</code></pre>
            </article>

            <article>
                <h3>14. How does Node.js handle file system operations?</h3>
                <p>Node.js uses the <code>fs</code> module for file system operations:</p>
                <ul>
                    <li><strong>Read:</strong> <code>fs.readFile()</code></li>
                    <li><strong>Write:</strong> <code>fs.writeFile()</code></li>
                    <li><strong>Delete:</strong> <code>fs.unlink()</code></li>
                </ul>
            </article>

            <article>
                <h3>15. What is middleware in the context of Node.js?</h3>
                <p>Middleware in Node.js is a function executed during the request-response cycle in a web application. It is commonly used in Express.js to handle requests, perform authentication, and process responses.</p>
            </article>

            <article>
                <h3>16. What is Express.js, and how is it related to Node.js?</h3>
                <p>Express.js is a web application framework for Node.js, simplifying the process of building robust APIs and web applications by providing utilities like routing, middleware, and HTTP request handling.</p>
            </article>

            <article>
                <h3>17. How can you handle errors in Node.js applications?</h3>
                <ul>
                    <li><strong>Using try-catch:</strong> For synchronous and async/await operations.</li>
                    <li><strong>Error callbacks:</strong> For callback-based code.</li>
                    <li><strong>Error middleware:</strong> In Express.js to centralize error handling.</li>
                </ul>
            </article>

            <article>
                <h3>18. What is a RESTful API, and how can you create one with Node.js?</h3>
                <p>A RESTful API is an architecture for designing networked applications. Using Express.js, you can create RESTful endpoints:</p>
                <pre><code class="language-js">const express = require('express');
const app = express();
app.get('/api/data', (req, res) => res.json({ key: 'value' }));
app.listen(3000);
</code></pre>
            </article>

            <article>
                <h3>19. How do you use environment variables in a Node.js application?</h3>
                <p>Environment variables store configuration values, accessed via <code>process.env</code>. Use libraries like <code>dotenv</code> to manage them.</p>
                <pre><code class="language-js">require('dotenv').config();
console.log(process.env.MY_VARIABLE);
</code></pre>
            </article>

            <article>
                <h3>20. What is the difference between process.nextTick() and setImmediate()?</h3>
                <ul>
                    <li><strong>process.nextTick():</strong> Executes the callback after the current operation, before I/O events.</li>
                    <li><strong>setImmediate():</strong> Executes the callback in the check phase of the Event Loop, after I/O events.</li>
                </ul>
            </article>

            <article>
                <h3>21. What is the purpose of the buffer module in Node.js?</h3>
                <p>The buffer module in Node.js is used to handle binary data directly. It allows reading and writing binary data in streams or file operations without converting to strings.</p>
                <pre><code class="language-js">const buffer = Buffer.from('Hello');
console.log(buffer.toString()); // Outputs 'Hello'</code></pre>
            </article>

            <article>
                <h3>22. What is the difference between spawn, exec, and fork in Node.js?</h3>
                <ul>
                    <li><strong>spawn:</strong> Used to start a new process with a stream for data transfer.</li>
                    <li><strong>exec:</strong> Executes a command and buffers the output (not suitable for large outputs).</li>
                    <li><strong>fork:</strong> Specially designed for spawning new Node.js processes with IPC communication.</li>
                </ul>
            </article>

            <article>
                <h3>23. What are streams in Node.js, and why are they useful?</h3>
                <p>Streams are objects for handling continuous data flows. They are efficient for I/O operations as they process data in chunks rather than loading the entire data into memory.</p>
                <ul>
                    <li><strong>Readable:</strong> For reading data.</li>
                    <li><strong>Writable:</strong> For writing data.</li>
                    <li><strong>Duplex:</strong> For both reading and writing.</li>
                    <li><strong>Transform:</strong> For modifying data during read/write.</li>
                </ul>
            </article>

            <article>
                <h3>24. What are child processes in Node.js?</h3>
                <p>Child processes enable running multiple tasks concurrently by spawning separate processes. They can communicate using IPC (Inter-Process Communication).</p>
                <pre><code class="language-js">const { spawn } = require('child_process');
const child = spawn('ls', ['-lh']);
child.stdout.on('data', data => console.log(data.toString()));</code></pre>
            </article>

            <article>
                <h3>25. What is the difference between process.env and process.argv?</h3>
                <ul>
                    <li><strong>process.env:</strong> Contains environment variables.</li>
                    <li><strong>process.argv:</strong> Contains command-line arguments passed to the Node.js script.</li>
                </ul>
            </article>

            <article>
                <h3>26. Explain clustering in Node.js.</h3>
                <p>Clustering allows you to utilize multi-core CPUs by spawning multiple worker processes running on the same port to share the load. The cluster module handles this functionality.</p>
                <pre><code class="language-js">const cluster = require('cluster');
if (cluster.isMaster) {
  cluster.fork(); // Create worker process
} else {
  console.log('Worker process running');
}</code></pre>
            </article>

            <article>
                <h3>27. What are the differences between CommonJS and ES6 modules?</h3>
                <ul>
                    <li><strong>Syntax:</strong> CommonJS uses <code>require</code> and <code>module.exports</code>, whereas ES6 uses <code>import</code> and <code>export</code>.</li>
                    <li><strong>Execution:</strong> CommonJS modules are loaded synchronously, ES6 modules are loaded asynchronously.</li>
                </ul>
            </article>

            <article>
                <h3>28. What is the use of the crypto module in Node.js?</h3>
                <p>The crypto module provides cryptographic functionality for securing data, such as hashing, encryption, and decryption.</p>
                <pre><code class="language-js">const crypto = require('crypto');
const hash = crypto.createHash('sha256').update('password').digest('hex');
console.log(hash);</code></pre>
            </article>

            <article>
                <h3>29. How does Node.js handle concurrency?</h3>
                <p>Node.js uses the event loop and libuv library to handle concurrency with a single-threaded non-blocking architecture. Long-running tasks, such as I/O, are offloaded to the thread pool or system kernel.</p>
            </article>

            <article>
                <h3>30. What is a namespace in Node.js?</h3>
                <p>Namespaces are used to organize and group related code to avoid global variable conflicts. For example, using modules effectively acts as a namespace.</p>
            </article>

            <article>
                <h3>31. How does the "path" module work in Node.js?</h3>
                <p>The <code>path</code> module provides utilities for working with file and directory paths.</p>
                <pre><code class="language-js">const path = require('path');
const fullPath = path.join(__dirname, 'file.txt');
console.log(fullPath);</code></pre>
            </article>

            <article>
                <h3>32. What are event emitters in Node.js?</h3>
                <p>Event emitters are part of the <code>events</code> module and are used to handle and trigger custom events in Node.js.</p>
                <pre><code class="language-js">const EventEmitter = require('events');
const emitter = new EventEmitter();
emitter.on('greet', () => console.log('Hello!'));
emitter.emit('greet');</code></pre>
            </article>

            <article>
                <h3>33. What is the purpose of the util module in Node.js?</h3>
                <p>The <code>util</code> module provides utility functions like <code>promisify</code> for converting callback-based functions into Promises.</p>
                <pre><code class="language-js">const util = require('util');
const readFile = util.promisify(fs.readFile);
readFile('file.txt').then(data => console.log(data.toString()));</code></pre>
            </article>

            <article>
                <h3>34. How do you implement logging in Node.js?</h3>
                <p>Logging can be implemented using <code>console</code>, third-party libraries like <code>winston</code>, or writing logs to files with <code>fs</code>.</p>
            </article>

            <article>
                <h3>35. What is the difference between readFile and createReadStream?</h3>
                <ul>
                    <li><strong>readFile:</strong> Reads the entire file into memory.</li>
                    <li><strong>createReadStream:</strong> Reads the file in chunks, suitable for large files.</li>
                </ul>
            </article>

            <article>
                <h3>36. What is a microservice, and how does Node.js support it?</h3>
                <p>A microservice is an independent service that performs specific tasks. Node.js supports microservices through lightweight frameworks like Express and its ability to handle multiple APIs efficiently.</p>
            </article>

            <article>
                <h3>37. What is a WebSocket in Node.js?</h3>
                <p>A WebSocket is a protocol for real-time, full-duplex communication. Node.js implements WebSockets using libraries like <code>ws</code>.</p>
                <pre><code class="language-js">const WebSocket = require('ws');
const ws = new WebSocket.Server({ port: 8080 });
ws.on('connection', socket => socket.send('Hello!'));</code></pre>
            </article>

            <article>
                <h3>38. How do you secure a Node.js application?</h3>
                <ul>
                    <li>Validate input to prevent SQL injection and XSS.</li>
                    <li>Use HTTPS for secure communication.</li>
                    <li>Implement authentication and authorization.</li>
                    <li>Sanitize user input.</li>
                    <li>Regularly update dependencies.</li>
                </ul>
            </article>

            <article>
                <h3>39. What is the purpose of the "worker_threads" module?</h3>
                <p>The <code>worker_threads</code> module enables running JavaScript code in parallel threads, useful for CPU-intensive tasks.</p>
                <pre><code class="language-js">const { Worker } = require('worker_threads');
new Worker('./worker.js');</code></pre>
            </article>

            <article>
                <h3>40. What is the difference between middleware and controllers in Node.js?</h3>
                <ul>
                    <li><strong>Middleware:</strong> Functions executed in the request-response cycle for logging, authentication, etc.</li>
                    <li><strong>Controllers:</strong> Handle business logic, process requests, and return responses.</li>
                </ul>
            </article>

            <article>
                <h3>41. What is the difference between "streams" and "buffers" in Node.js?</h3>
                <ul>
                    <li><strong>Buffers:</strong> Temporary memory storage for binary data, representing the complete data set before processing.</li>
                    <li><strong>Streams:</strong> Process data in chunks, enabling efficient handling of large files or continuous data flows.</li>
                </ul>
                <p>Streams are more memory-efficient and are ideal for large-scale data handling, unlike buffers which load the entire data into memory.</p>
            </article>

            <article>
                <h3>42. What is the concept of backpressure in Node.js streams?</h3>
                <p>Backpressure occurs when the writable stream cannot process data as fast as it is received from the readable stream. It ensures the system doesn't overwhelm memory by pausing the data flow until the writable stream is ready.</p>
                <pre><code class="language-js">const readable = fs.createReadStream('largeFile');
const writable = fs.createWriteStream('outputFile');
readable.pipe(writable); // Handles backpressure automatically</code></pre>
            </article>

            <article>
                <h3>43. What are "ticks" and "microtasks" in Node.js?</h3>
                <p>"Ticks" refer to the tasks queued by <code>process.nextTick()</code>, executed before the next Event Loop phase. "Microtasks" include Promises and <code>process.nextTick</code> tasks, which are executed before other asynchronous operations.</p>
                <pre><code class="language-js">
process.nextTick(() => console.log('Tick'));
Promise.resolve().then(() => console.log('Microtask'));
setTimeout(() => console.log('Macro task'), 0);
// Output: Tick, Microtask, Macro task
</code></pre>
            </article>

            <article>
                <h3>44. What is the difference between "readable.pipe()" and "readable.on('data')"? </h3>
                <ul>
                    <li><strong><code>readable.pipe()</code>:</strong> Automatically manages the flow of data between streams and handles backpressure.</li>
                    <li><strong><code>readable.on('data')</code>:</strong> Requires manual implementation of data flow management and backpressure handling.</li>
                </ul>
            </article>

            <article>
                <h3>45. What is the difference between "cluster" and "worker_threads" modules in Node.js?</h3>
                <ul>
                    <li><strong>Cluster:</strong> Spawns multiple instances of the main process to utilize multiple CPU cores.</li>
                    <li><strong>Worker Threads:</strong> Creates lightweight threads for parallel processing within a single Node.js instance.</li>
                </ul>
                <p>Clusters are for multi-process architectures, whereas worker threads are for multi-threaded operations.</p>
            </article>

            <article>
                <h3>46. Explain the term "head-of-line blocking" in the context of Node.js.</h3>
                <p>Head-of-line blocking occurs when one task in the queue blocks the execution of subsequent tasks. In Node.js, this can happen with synchronous operations or improper asynchronous handling, leading to delays in event loop processing.</p>
            </article>

            <article>
                <h3>47. What is the role of libuv in Node.js?</h3>
                <p>libuv is a library that provides the platform-agnostic, non-blocking I/O model in Node.js. It powers the Event Loop, thread pool, and handles low-level operations like file systems, network requests, and timers.</p>
            </article>

            <article>
                <h3>48. What are domain modules in Node.js?</h3>
                <p>The domain module provides a way to handle errors across different asynchronous operations. Although deprecated, it is still found in older applications for managing error-handling boundaries.</p>
                <pre><code class="language-js">const domain = require('domain');
const d = domain.create();
d.on('error', err => console.error('Handled:', err));
d.run(() => { throw new Error('Something went wrong!'); });</code></pre>
            </article>

            <article>
                <h3>49. What is the purpose of the "zlib" module in Node.js?</h3>
                <p>The <code>zlib</code> module provides compression and decompression functionalities using algorithms like Gzip and Deflate. It is useful for reducing data transfer sizes.</p>
                <pre><code class="language-js">const zlib = require('zlib');
const gzip = zlib.createGzip();
fs.createReadStream('file.txt').pipe(gzip).pipe(fs.createWriteStream('file.txt.gz'));</code></pre>
            </article>

            <article>
                <h3>50. What are "sticky sessions," and how are they implemented in Node.js?</h3>
                <p>Sticky sessions ensure a user’s requests are routed to the same server instance in a load-balanced environment. This can be achieved using <code>cookie-based session affinity</code> or libraries like <code>socket.io</code> for stateful connections.</p>
                <pre><code class="language-js">const session = require('express-session');
app.use(session({ secret: 'mySecret', resave: false, saveUninitialized: true }));</code></pre>
            </article>
    </body>

</html>