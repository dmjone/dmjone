<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
	<!--<![endif]-->

	<head>
		<script src="/js/edu_su_common.js"></script>
		<noscript>
			<style>
				html,
				body {
					margin: 0;
					overflow: hidden;
				}
			</style>
			<iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
		</noscript>

		<title>HTTP - CSU677 - Shoolini U</title>
		<meta name="description" content="Learn about HTTP (Hypertext Transfer Protocol), the foundation of data communication on the World Wide Web. Understand the basic structure of HTTP requests and responses, common methods, status codes, headers, and security practices.">

		<meta property=" og:image" content="/logo.png">
		<meta property="og:type" content="article">

		<meta name="twitter:card" content="summary">
		<meta name="twitter:site" content="@divyamohan1993">
		<meta name="twitter:creator" content="@divyamohan1993">
		<meta name="twitter:image" content="/logo.png">

		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width,initial-scale=1" />

		<meta name="author" content="Divya Mohan">
		<meta name="robots" content="index, follow">

	</head>

	<body>

		<script> header_author("dm"); </script>

		<main>
			<article class="agen-tableofcontents">
				<h2 class="text-center">HTTP</h2>
			</article>

			<article>
				<h3>1. Introduction to HTTP</h3>
				<p>HTTP, or Hypertext Transfer Protocol, is the foundation of data communication on the World Wide Web. It defines how messages are formatted and transmitted, and how web servers and browsers should respond to various commands. HTTP is a stateless protocol, meaning each request from a client to a server is independent of any previous requests.</p>
			</article>

			<article>
				<h3>2. Basic Structure of HTTP</h3>
				<p>HTTP operates as a request-response protocol between a client (usually a web browser) and a server. The client sends an HTTP request, and the server returns an HTTP response. Each request and response consists of a header and a body.</p>

				<h4>2.1 HTTP Request</h4>
				<p>An HTTP request is initiated by the client and contains:</p>
				<ul>
					<li><strong>Request Line:</strong> Includes the HTTP method (e.g., GET, POST), the path to the resource, and the HTTP version.</li>
					<li><strong>Headers:</strong> Provide additional information about the request, such as content type, user agent, and cookies.</li>
					<li><strong>Body:</strong> Optional data sent with the request, often used in POST or PUT methods.</li>
				</ul>

				<h4>2.2 HTTP Response</h4>
				<p>An HTTP response is generated by the server and includes:</p>
				<ul>
					<li><strong>Status Line:</strong> Contains the HTTP version, a status code (e.g., 200 OK, 404 Not Found), and a status message.</li>
					<li><strong>Headers:</strong> Provide metadata about the response, such as content type, content length, and cache control.</li>
					<li><strong>Body:</strong> The content requested by the client, which could be an HTML page, JSON data, or an image.</li>
				</ul>

				<h5>2.2.1 Example: Basic HTTP Request and Response</h5>
				<pre><code class="language-http">
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0
Accept: text/html

HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 1234

&lt;html&gt;
&lt;head&gt;&lt;title&gt;Example&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;Hello, World!&lt;/body&gt;
&lt;/html&gt;
</code></pre>
			</article>

			<article>
				<h3>3. HTTP Methods</h3>
				<p>HTTP defines several methods that indicate the desired action to be performed on the identified resource. The most common methods are:</p>

				<h4>3.1 GET</h4>
				<p>The GET method is used to request data from a specified resource. It is the most commonly used method and is typically used to retrieve data from a server. GET requests should only retrieve data and have no other effect on the resource.</p>

				<h4>3.2 POST</h4>
				<p>The POST method is used to submit data to be processed to a specified resource. For example, form data sent to a server. POST requests typically change the state of the server, such as updating a database or triggering a process.</p>

				<h4>3.3 PUT</h4>
				<p>The PUT method is used to update or create a resource at a specified URL. If the resource exists, PUT updates it; if it does not exist, PUT creates it.</p>

				<h4>3.4 DELETE</h4>
				<p>The DELETE method is used to remove the specified resource from the server.</p>

				<h4>3.5 HEAD</h4>
				<p>The HEAD method is similar to GET, but it only requests the headers from the response, not the body. This can be useful for checking if a resource exists or for testing links.</p>
			</article>

			<article>
				<h3>4. HTTP Status Codes</h3>
				<p>HTTP status codes are issued by a server in response to a client's request. They are divided into five categories:</p>

				<h4>4.1 1xx Informational</h4>
				<p>Status codes in the 1xx range are provisional responses, indicating that the request was received and the process is continuing. Example: <strong>100 Continue</strong>.</p>

				<h4>4.2 2xx Success</h4>
				<p>Status codes in the 2xx range indicate that the request was successfully received, understood, and accepted. Example: <strong>200 OK</strong>.</p>

				<h4>4.3 3xx Redirection</h4>
				<p>Status codes in the 3xx range indicate that further action needs to be taken by the client to complete the request. Example: <strong>301 Moved Permanently</strong>.</p>

				<h4>4.4 4xx Client Error</h4>
				<p>Status codes in the 4xx range indicate errors in the request. These are often due to client-side issues, such as a malformed request or unauthorized access. Example: <strong>404 Not Found</strong>.</p>

				<h4>4.5 5xx Server Error</h4>
				<p>Status codes in the 5xx range indicate that the server failed to fulfill a valid request. Example: <strong>500 Internal Server Error</strong>.</p>
			</article>

			<article>
				<h3>5. HTTP Headers</h3>
				<p>HTTP headers provide essential information about the request or response, such as content type, content length, and caching policies. There are several categories of HTTP headers:</p>

				<h4>5.1 General Headers</h4>
				<p>General headers can be used in both requests and responses. They provide information about the message itself rather than the content of the message. Example: <code>Date</code>, <code>Connection</code>.</p>

				<h4>5.2 Request Headers</h4>
				<p>Request headers contain information about the client, such as browser type, preferred content types, and authentication data. Example: <code>User-Agent</code>, <code>Accept</code>, <code>Authorization</code>.</p>

				<h4>5.3 Response Headers</h4>
				<p>Response headers provide additional information about the server's response. Example: <code>Server</code>, <code>Set-Cookie</code>, <code>WWW-Authenticate</code>.</p>

				<h4>5.4 Entity Headers</h4>
				<p>Entity headers contain information about the body of the resource, such as content type, length, and encoding. Example: <code>Content-Type</code>, <code>Content-Length</code>, <code>Content-Encoding</code>.</p>
			</article>

			<article>
				<h3>6. Statelessness in HTTP</h3>
				<p>HTTP is a stateless protocol, meaning that each request is independent, and the server does not retain any memory of previous requests. This characteristic simplifies the protocol but also means that additional mechanisms, such as cookies or sessions, are required to maintain state across multiple requests.</p>

				<h4>6.1 Cookies</h4>
				<p>Cookies are small pieces of data sent by the server to the client, stored on the client-side, and sent back to the server with subsequent requests. They are used to maintain stateful information, such as user sessions or preferences.</p>

				<h4>6.2 Sessions</h4>
				<p>Sessions are a server-side mechanism that store stateful information about the user’s interaction with the server. A session ID is often stored in a cookie and used to retrieve session data on the server during subsequent requests.</p>

				<h5>6.2.1 Example: Session Management with Cookies</h5>
				<pre><code class="language-http">
Set-Cookie: sessionId=abc123; Path=/; HttpOnly
GET /profile HTTP/1.1
Cookie: sessionId=abc123
</code></pre>
			</article>

			<article>
				<h3>7. HTTP Caching</h3>
				<p>HTTP caching is a mechanism used to store copies of resources to reduce the need to fetch them from the server repeatedly. Caching improves performance by reducing latency and server load. The caching behavior is controlled using HTTP headers.</p>

				<h4>7.1 Cache-Control</h4>
				<p>The <code>Cache-Control</code> header specifies caching directives, such as whether a resource can be cached, how long it can be stored, and whether it must be revalidated before use. Example directives include <code>public</code>, <code>private</code>, <code>no-cache</code>, and <code>max-age</code>.</p>

				<h4>7.2 ETag</h4>
				<p>The <code>ETag</code> (Entity Tag) header is used to identify a specific version of a resource. When the resource changes, its ETag value changes as well. Clients can use the <code>If-None-Match</code> header to check if the resource has changed, allowing for conditional requests that improve caching efficiency.</p>

				<h4>7.3 Last-Modified</h4>
				<p>The <code>Last-Modified</code> header indicates the date and time the resource was last modified. Clients can use the <code>If-Modified-Since</code> header in subsequent requests to retrieve the resource only if it has changed since the specified date, reducing unnecessary data transfer.</p>
			</article>

			<article>
				<h3>8. Content Negotiation</h3>
				<p>Content negotiation is a mechanism in HTTP that allows the client and server to agree on the best representation of a resource. This negotiation can occur based on content type, language, encoding, or other characteristics

					.</p>

				<h4>8.1 Accept Header</h4>
				<p>The <code>Accept</code> header allows the client to specify the media types (e.g., <code>text/html</code>, <code>application/json</code>) it can process. The server can then respond with the most appropriate content type based on the client's preferences.</p>

				<h4>8.2 Accept-Language</h4>
				<p>The <code>Accept-Language</code> header specifies the preferred languages for the response. The server can use this information to return content in the most suitable language for the client.</p>

				<h4>8.3 Accept-Encoding</h4>
				<p>The <code>Accept-Encoding</code> header indicates the content encoding (e.g., <code>gzip</code>, <code>deflate</code>) that the client can handle. The server can compress the response accordingly to reduce data size and improve transmission speed.</p>
			</article>

			<article>
				<h3>9. HTTP/1.1 vs. HTTP/2</h3>
				<p>HTTP/1.1 and HTTP/2 are versions of the HTTP protocol, with HTTP/2 being the newer and more efficient version. Understanding the differences between these versions is essential for optimizing web performance.</p>

				<h4>9.1 HTTP/1.1 Features</h4>
				<p>HTTP/1.1 introduced persistent connections, chunked transfer encoding, and additional cache control mechanisms. However, it still requires multiple TCP connections for concurrent requests, which can lead to inefficiencies and bottlenecks.</p>

				<h4>9.2 HTTP/2 Enhancements</h4>
				<p>HTTP/2 addresses the limitations of HTTP/1.1 by introducing multiplexing, header compression, and server push. Multiplexing allows multiple requests and responses to be sent over a single connection, reducing latency and improving performance.</p>

				<h4>9.3 Compatibility and Transition</h4>
				<p>HTTP/2 is fully backward compatible with HTTP/1.1, meaning that HTTP/1.1 clients can still communicate with HTTP/2 servers, although they won't benefit from the performance improvements of HTTP/2.</p>
			</article>

			<article>
				<h3>10. Security in HTTP</h3>
				<p>While HTTP itself does not provide built-in security, it can be combined with other protocols and mechanisms to enhance security in web communication. Understanding these practices is essential for protecting data transmitted over HTTP.</p>

				<h4>10.1 HTTPS (HTTP Secure)</h4>
				<p>HTTPS is the secure version of HTTP, where communication is encrypted using SSL/TLS. It protects data from eavesdropping, tampering, and man-in-the-middle attacks.</p>

				<h4>10.2 Basic Authentication</h4>
				<p>HTTP supports basic authentication, where a client sends a username and password encoded in base64 within the <code>Authorization</code> header. While easy to implement, this method is insecure without HTTPS, as the credentials are sent in plaintext.</p>

				<h4>10.3 Digest Authentication</h4>
				<p>Digest authentication is an improvement over basic authentication. It involves sending a hashed version of the credentials, reducing the risk of interception. However, it is still vulnerable to certain attacks if not combined with HTTPS.</p>
			</article>

			<article>
				<h3>11. RESTful Services and HTTP</h3>
				<p>REST (Representational State Transfer) is an architectural style for designing networked applications, and it heavily relies on HTTP as its communication protocol. RESTful services use standard HTTP methods to perform CRUD (Create, Read, Update, Delete) operations on resources.</p>

				<h4>11.1 Resources and URIs</h4>
				<p>In a RESTful service, resources are identified by Uniform Resource Identifiers (URIs). The URI represents the path to a resource, and the HTTP method defines the action to be performed on that resource.</p>

				<h4>11.2 Statelessness in REST</h4>
				<p>RESTful services are stateless, meaning each HTTP request from a client to a server must contain all the information needed to understand and process the request. The server does not store any state information between requests.</p>

				<h4>11.3 Hypermedia as the Engine of Application State (HATEOAS)</h4>
				<p>HATEOAS is a constraint of REST that enables dynamic navigation to related resources through hyperlinks. In a HATEOAS-compliant service, the client interacts with the application entirely through hypermedia provided dynamically by application servers.</p>
			</article>

			<article>
				<h3>12. Limitations of HTTP</h3>
				<p>While HTTP is a powerful and widely-used protocol, it does have some limitations that developers should be aware of when designing web applications.</p>

				<h4>12.1 Lack of Built-in Security</h4>
				<p>HTTP itself does not provide any security features. This makes it vulnerable to attacks like eavesdropping and tampering. To secure HTTP communication, it must be combined with encryption protocols like SSL/TLS (as in HTTPS).</p>

				<h4>12.2 Statelessness</h4>
				<p>While statelessness simplifies the design of HTTP, it also requires additional mechanisms to maintain state across multiple requests. This often involves the use of cookies, sessions, or tokens, which can add complexity to the application.</p>

				<h4>12.3 Performance Overhead</h4>
				<p>HTTP/1.1's use of multiple TCP connections for concurrent requests can lead to performance bottlenecks, especially on high-latency networks. HTTP/2 addresses some of these issues, but transitioning to HTTP/2 requires both client and server support.</p>
			</article>

		</main>

		<script> copyright("all"); </script>

	</body>

</html>