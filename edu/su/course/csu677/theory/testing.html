<!-------------------------- Â© 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
	<!--<![endif]-->

	<head>
		<script src="/js/edu_su_common.js"></script>
		<noscript>
			<style>
				html,
				body {
					margin: 0;
					overflow: hidden;
				}
			</style>
			<iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
		</noscript>

		<title>Testing - CSU677 - Shoolini U</title>
		<meta name="description" content="Learn about testing, a critical phase in software development that ensures the quality, reliability, and performance of applications. Explore different types of testing, testing methodologies, and best practices for effective testing.">

		<meta property=" og:image" content="/logo.png">
		<meta property="og:type" content="article">

		<meta name="twitter:card" content="summary">
		<meta name="twitter:site" content="@divyamohan1993">
		<meta name="twitter:creator" content="@divyamohan1993">
		<meta name="twitter:image" content="/logo.png">

		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width,initial-scale=1" />

		<meta name="author" content="Divya Mohan">
		<meta name="robots" content="index, follow">

	</head>

	<body>

		<script> header_author("dm"); </script>

		<main>
			<article class="agen-tableofcontents">
				<h2 class="text-center">Testing</h2>
			</article>

			<article>
				<h3>1. Introduction to Software Testing</h3>
				<p>Software testing is a critical process in software development that ensures the quality, functionality, and performance of applications. Testing helps identify and fix bugs, validate that the software meets the requirements, and ensure that it performs well under different conditions. There are various types of testing, each targeting different aspects of the software. This documentation will focus on Unit Testing, End-to-End Testing, and Performance Testing, along with the tools and frameworks commonly used for each.</p>
			</article>

			<article>
				<h3>2. Unit Testing</h3>
				<p>Unit Testing involves testing individual components or units of code, typically functions or methods, in isolation from the rest of the application. The goal is to verify that each unit performs as expected. Unit tests are often automated and run frequently to catch errors early in the development process.</p>

				<h4>2.1 Tools for Unit Testing</h4>
				<p>Several tools and frameworks are available for writing and running unit tests. Two popular ones are Jest and Mocha.</p>

				<h5>2.1.1 Jest</h5>
				<p>Jest is a comprehensive JavaScript testing framework developed by Facebook, designed to work with React applications. It provides a simple and powerful API, built-in mocking, and an easy setup for writing unit tests.</p>

				<h5>Example of a Unit Test Using Jest</h5>
				<pre><code class="language-javascript">
// sum.js
function sum(a, b) {
    return a + b;
}
module.exports = sum;

// sum.test.js
const sum = require('./sum');

test('adds 1 + 2 to equal 3', () => {
    expect(sum(1, 2)).toBe(3);
});
</code></pre>
				<p>This example defines a simple function <code>sum</code> and tests it using Jest to verify that it correctly adds two numbers.</p>

				<h5>2.1.2 Mocha</h5>
				<p>Mocha is a flexible JavaScript test framework that runs on Node.js. It provides a rich set of features for writing asynchronous tests, and it integrates well with other tools like Chai for assertions.</p>

				<h5>Example of a Unit Test Using Mocha</h5>
				<pre><code class="language-javascript">
// sum.js
function sum(a, b) {
    return a + b;
}
module.exports = sum;

// test/sum.test.js
const assert = require('assert');
const sum = require('../sum');

describe('Sum Function', () => {
    it('should return 3 when adding 1 and 2', () => {
        assert.strictEqual(sum(1, 2), 3);
    });
});
</code></pre>
				<p>This example uses Mocha and Node's built-in <code>assert</code> module to test the <code>sum</code> function.</p>

				<h4>2.2 Best Practices for Unit Testing</h4>
				<ul>
					<li>Write tests that are isolated from external dependencies (e.g., databases, APIs) by using mocks and stubs.</li>
					<li>Ensure tests are fast to encourage frequent execution.</li>
					<li>Write tests that are easy to read and understand, as they serve as documentation for the code.</li>
					<li>Adopt a test-driven development (TDD) approach where possible, writing tests before implementing the functionality.</li>
				</ul>
			</article>

			<article>
				<h3>3. End-to-End Testing</h3>
				<p>End-to-End (E2E) Testing involves testing the entire application flow from start to finish, simulating real user scenarios. E2E tests validate that all components of the application work together correctly, ensuring that the software meets user expectations.</p>

				<h4>3.1 Tools for End-to-End Testing</h4>
				<p>Several frameworks are available for performing E2E testing. Two widely-used ones are Cypress and Selenium.</p>

				<h5>3.1.1 Cypress</h5>
				<p>Cypress is a modern E2E testing framework that runs directly in the browser. It provides a simple API, automatic waiting, and powerful debugging capabilities, making it a popular choice for testing modern web applications.</p>

				<h5>Example of an End-to-End Test Using Cypress</h5>
				<pre><code class="language-javascript">
// cypress/integration/sample_spec.js
describe('My First Test', () => {
    it('visits the app and checks the title', () => {
        cy.visit('https://example.com');
        cy.title().should('include', 'Example Domain');
    });
});
</code></pre>
				<p>This example tests whether the title of the page at <code>https://example.com</code> includes the text "Example Domain."</p>

				<h5>3.1.2 Selenium</h5>
				<p>Selenium is a powerful and widely-used framework for automating web browsers. It supports multiple programming languages and can be used to write cross-browser tests. Selenium WebDriver is the core component that interacts with the browser.</p>

				<h5>Example of an End-to-End Test Using Selenium (JavaScript)</h5>
				<pre><code class="language-javascript">
const { Builder, By, until } = require('selenium-webdriver');

(async function example() {
    let driver = await new Builder().forBrowser('firefox').build();
    try {
        await driver.get('https://example.com');
        let title = await driver.getTitle();
        console.log(title);
    } finally {
        await driver.quit();
    }
})();
</code></pre>
				<p>This example uses Selenium WebDriver to open Firefox, navigate to <code>https://example.com</code>, retrieve the page title, and then close the browser.</p>

				<h4>3.2 Best Practices for End-to-End Testing</h4>
				<ul>
					<li>Focus on critical user journeys and scenarios that are most likely to impact users.</li>
					<li>Keep tests as simple as possible, avoiding complex logic in the test scripts themselves.</li>
					<li>Use tools like <code>beforeEach</code> and <code>afterEach</code> in Cypress to set up and clean up state before and after tests.</li>
					<li>Run E2E tests on real devices or browsers to simulate actual user environments.</li>
					<li>Integrate E2E tests into the CI/CD pipeline to catch issues before deployment.</li>
				</ul>
			</article>

			<article>
				<h3>4. Performance Testing</h3>
				<p>Performance Testing evaluates how an application performs under various conditions, such as high traffic, heavy data loads, and extended operation. It helps identify bottlenecks, ensure that the application meets performance requirements, and improve the overall user experience.</p>

				<h4>4.1 Tools for Performance Testing</h4>
				<p>There are several tools available for performance testing, each with different strengths. Lighthouse and JMeter are two popular options.</p>

				<h5>4.1.1 Lighthouse</h5>
				<p>Lighthouse is an open-source tool from Google for auditing the performance of web pages. It provides insights into various aspects such as load times, accessibility, SEO, and best practices, and generates a detailed report with actionable recommendations.</p>

				<h5>Example of Running a Lighthouse Test</h5>
				<pre><code class="language-bash">
# Install Lighthouse globally
npm install -g lighthouse

# Run Lighthouse on a URL
lighthouse https://example.com --output html --output-path report.html
</code></pre>
				<p>This command runs a Lighthouse audit on <code>https://example.com</code> and generates an HTML report.</p>

				<h5>4.1.2 JMeter</h5>
				<p>Apache JMeter is a powerful open-source tool for load testing and measuring the performance of web applications. It allows users to simulate a large number of users interacting with the application to assess its behavior under stress.</p>

				<h5>Example of a Simple JMeter Test Plan</h5>
				<pre><code class="language-xml">
&lt;testPlan>
	&lt;threadGroup>
        &lt;numThreads>10&lt;/numThreads>
        &lt;rampTime>60&lt;/rampTime>
        &lt;loopCount>5&lt;/loopCount>
        &lt;httpRequest>
            &lt;url>https://example.com&lt;/url>
            &lt;method>GET&lt;/method>
        &lt;/httpRequest>
	&lt;/threadGroup>
&lt;/testPlan>
</code></pre>
				<p>This JMeter test plan simulates 10 users sending GET requests to <code>https://example.com</code> over a period of 60 seconds, looping 5 times.</p>

				<h4>4.2 Best Practices for Performance Testing</h4>
				<ul>
					<li>Define clear performance goals and benchmarks before starting tests.</li>
					<li>Test under realistic conditions that reflect actual usage scenarios.</li>
					<li>Run tests on production-like environments to get accurate results.</li>
					<li>Analyze the results to identify bottlenecks and areas for improvement.</li>
					<li>Repeat performance tests regularly, especially after significant code changes or updates.</li>
				</ul>
			</article>

		</main>

		<script> copyright("all"); </script>


	</body>

</html>