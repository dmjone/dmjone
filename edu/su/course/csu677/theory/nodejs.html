<!-------------------------- Â© 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
	<!--<![endif]-->

	<head>
		<script src="/js/edu_su_common.js"></script>
		<noscript>
			<style>
				html,
				body {
					margin: 0;
					overflow: hidden;
				}
			</style>
			<iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
		</noscript>

		<title>Introduction to Node.js - CSU677 - Shoolini U</title>
		<meta name="description" content="Learn the basics of Node.js, a JavaScript runtime environment that allows developers to build server-side applications using JavaScript.">

		<meta property=" og:image" content="/logo.png">
		<meta property="og:type" content="article">

		<meta name="twitter:card" content="summary">
		<meta name="twitter:site" content="@divyamohan1993">
		<meta name="twitter:creator" content="@divyamohan1993">
		<meta name="twitter:image" content="/logo.png">

		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width,initial-scale=1" />

		<meta name="author" content="Divya Mohan">
		<meta name="robots" content="index, follow">

	</head>

	<body>

		<script> header_author("dm"); </script>

		<main>
			<article class="agen-tableofcontents">
				<h2 class="text-center">Node.js</h2>
			</article>

			<article>
				<h3>1. Introduction to Node.js</h3>
				<p>Node.js is a runtime environment that allows you to run JavaScript on the server side. Built on Google Chrome's V8 JavaScript engine, Node.js is designed for building scalable and efficient network applications. It uses an event-driven, non-blocking I/O model, which makes it lightweight and efficient, especially for data-intensive real-time applications that run across distributed devices.</p>
			</article>

			<article>
				<h3>2. Installing Node.js</h3>
				<p>Before you can start developing with Node.js, you need to install it on your system. Node.js comes with a package manager called npm (Node Package Manager), which helps manage libraries and dependencies.</p>

				<h4>2.1 Installation Steps</h4>
				<p>To install Node.js, follow these steps:</p>
				<ul>
					<li><strong>Windows:</strong> Download the installer from the official Node.js website and follow the installation prompts.</li>
					<li><strong>macOS:</strong> Use a package manager like Homebrew: <code>brew install node</code>.</li>
					<li><strong>Linux:</strong> Use a package manager like apt: <code>sudo apt install nodejs</code> and <code>sudo apt install npm</code>.</li>
				</ul>

				<h4>2.2 Verifying Installation</h4>
				<p>After installation, verify that Node.js and npm are installed correctly by running the following commands in your terminal:</p>
				<pre><code class="language-bash">
node -v
npm -v
</code></pre>
				<p>These commands should output the versions of Node.js and npm installed on your system.</p>
			</article>

			<article>
				<h3>3. Node.js Modules</h3>
				<p>Modules are the building blocks of a Node.js application. A module in Node.js is a reusable block of code whose existence does not impact other code. Node.js has a set of built-in modules, such as <code>fs</code> (for file system operations), <code>http</code> (for creating servers), and <code>path</code> (for handling file paths). Additionally, you can create your own modules and import third-party modules using npm.</p>

				<h4>3.1 Using Built-In Modules</h4>
				<p>To use a built-in module, you require it in your application:</p>

				<h5>3.1.1 Example: Using the <code>fs</code> Module</h5>
				<pre><code class="language-javascript">
const fs = require('fs');

// Read a file asynchronously
fs.readFile('example.txt', 'utf8', (err, data) => {
  if (err) {
    console.error(err);
    return;
  }
  console.log(data);
});
</code></pre>
				<p>In this example, the <code>fs</code> module is used to read the contents of a file asynchronously.</p>

				<h4>3.2 Creating Your Own Modules</h4>
				<p>You can create custom modules in Node.js by exporting functions, objects, or variables from a file and importing them into another file.</p>

				<h5>3.2.1 Example: Creating and Using a Custom Module</h5>
				<pre><code class="language-javascript">
// math.js
function add(a, b) {
  return a + b;
}

function subtract(a, b) {
  return a - b;
}

module.exports = {
  add,
  subtract
};

// app.js
const math = require('./math');

console.log(math.add(5, 3)); // Output: 8
console.log(math.subtract(5, 3)); // Output: 2
</code></pre>
				<p>Here, a custom module named <code>math</code> is created with two functions, <code>add</code> and <code>subtract</code>. This module is then imported and used in another file.</p>
			</article>

			<article>
				<h3>4. Creating a Simple Server</h3>
				<p>One of the core functionalities of Node.js is the ability to create a server. The <code>http</code> module is commonly used for this purpose. A Node.js server listens for requests on a specified port and sends responses.</p>

				<h4>4.1 Example: Basic HTTP Server</h4>
				<pre><code class="language-javascript">
const http = require('http');

// Create an HTTP server
const server = http.createServer((req, res) => {
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/plain');
  res.end('Hello, World!\n');
});

// The server listens on port 3000
server.listen(3000, '127.0.0.1', () => {
  console.log('Server running at http://127.0.0.1:3000/');
});
</code></pre>
				<p>This example creates a basic HTTP server that responds with "Hello, World!" when accessed through a browser at <code>http://127.0.0.1:3000/</code>.</p>
			</article>

			<article>
				<h3>5. Asynchronous Programming in Node.js</h3>
				<p>Node.js is designed to handle asynchronous operations efficiently. Asynchronous programming is crucial in Node.js, as it helps manage tasks like I/O operations, which can take time to complete. Node.js uses callbacks, promises, and async/await to handle asynchronous code.</p>

				<h4>5.1 Callbacks</h4>
				<p>A callback is a function passed as an argument to another function, which is then executed after the completion of an asynchronous operation.</p>

				<h5>5.1.1 Example: Callback</h5>
				<pre><code class="language-javascript">
function fetchData(callback) {
  setTimeout(() => {
    callback('Data received');
  }, 2000);
}

fetchData((data) => {
  console.log(data); // Output after 2 seconds: Data received
});
</code></pre>

				<h4>5.2 Promises</h4>
				<p>Promises are a more modern approach to handling asynchronous operations. They represent the eventual completion (or failure) of an asynchronous operation and its resulting value.</p>

				<h5>5.2.1 Example: Promise</h5>
				<pre><code class="language-javascript">
function fetchData() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('Data received');
    }, 2000);
  });
}

fetchData().then((data) => {
  console.log(data); // Output after 2 seconds: Data received
});
</code></pre>

				<h4>5.3 Async/Await</h4>
				<p>Async/await is syntactic sugar built on top of promises, allowing you to write asynchronous code that looks synchronous.</p>

				<h5>5.3.1 Example: Async/Await</h5>
				<pre><code class="language-javascript">
async function fetchData() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('Data received');
    }, 2000);
  });
}

async function displayData() {
  const data = await fetchData();
  console.log(data); // Output after 2 seconds: Data received
}

displayData();
</code></pre>
				<p>In this example, the <code>displayData</code> function waits for the <code>fetchData</code> promise to resolve before logging the data.</p>
			</article>

			<article>
				<h3>6. Working with the File System</h3>
				<p>The <code>fs</code> (file system) module in Node.js provides an API to interact with the file system, allowing you to read, write, update, delete, and rename files. These operations can be performed synchronously or asynchronously.</p>

				<h4>6.1 Reading and Writing Files</h4>
				<p>You can read from and write to files using the <code>fs.readFile</code> and <code>fs.writeFile</code> methods. Both methods have synchronous and asynchronous versions.</p>

				<h5>6.1.1 Example: Reading a File Asynchronously</h5>
				<pre><code class="language-javascript">
const fs = require('fs');

fs.readFile('example.txt', 'utf8', (err, data) => {
  if (err) {
    console.error(err);
    return;
  }
  console.log(data);
});
</code></pre>
				<p>This example reads the content of <code>example.txt</code> asynchronously and logs it to the console.</p>

				<h5>6.1.2 Example: Writing to a File Asynchronously</h5>
				<pre><code class="language-javascript">
const fs = require('fs');

fs.writeFile('example.txt', 'Hello, World!', (err) => {
  if (err) {
    console.error(err);
    return;
  }
  console.log('File has been written');
});
</code></pre>
				<p>In this example, the string "Hello, World!" is written to <code>example.txt</code>. If the file does not exist, it will be created.</p>
			</article>

			<article>
				<h3>7. NPM (Node Package Manager)</h3>
				<p>npm is the default package manager for Node.js. It allows you to install and manage libraries and tools that can be used in your Node.js applications. With npm, you can easily share and reuse code across projects.</p>

				<h4>7.1 Installing Packages</h4>
				<p>To install a package using npm, you

					use the <code>npm install</code> command followed by the package name.</p>

				<h5>7.1.1 Example: Installing Express</h5>
				<pre><code class="language-bash">
npm install express
</code></pre>
				<p>This command installs the Express framework, a popular web application framework for Node.js.</p>

				<h4>7.2 Using Installed Packages</h4>
				<p>After installing a package, you can include it in your application using the <code>require</code> function.</p>

				<h5>7.2.1 Example: Using Express</h5>
				<pre><code class="language-javascript">
const express = require('express');
const app = express();

app.get('/', (req, res) => {
  res.send('Hello, World!');
});

app.listen(3000, () => {
  console.log('Server is running on port 3000');
});
</code></pre>
				<p>This example creates a basic web server using the Express framework, which responds with "Hello, World!" when accessed at <code>http://localhost:3000/</code>.</p>
			</article>

			<article>
				<h3>8. Debugging Node.js Applications</h3>
				<p>Debugging is an essential part of the development process. Node.js provides various tools and methods for debugging, including the built-in <code>debugger</code> keyword, the Node.js inspector, and third-party tools like Visual Studio Code.</p>

				<h4>8.1 Using the Debugger Keyword</h4>
				<p>The <code>debugger</code> keyword can be used to set breakpoints in your code, where execution will pause, allowing you to inspect the state of the application.</p>

				<h5>8.1.1 Example: Using Debugger</h5>
				<pre><code class="language-javascript">
let x = 5;
let y = 10;

debugger;

let z = x + y;
console.log(z);
</code></pre>
				<p>When running this script with a debugger attached, execution will pause at the <code>debugger</code> statement, allowing you to inspect variables and step through the code.</p>

				<h4>8.2 Node.js Inspector</h4>
				<p>The Node.js Inspector is a powerful tool for debugging. You can start your Node.js application with the <code>--inspect</code> flag to enable debugging, and then connect to the debugger using Chrome DevTools or another compatible client.</p>

				<h5>8.2.1 Example: Starting Node.js with Inspector</h5>
				<pre><code class="language-bash">
node --inspect app.js
</code></pre>
				<p>This command starts the application in debug mode, allowing you to connect to it using Chrome DevTools by navigating to <code>chrome://inspect</code> in your browser.</p>
			</article>
		</main>

		<script> copyright("all"); </script>

	</body>

</html>