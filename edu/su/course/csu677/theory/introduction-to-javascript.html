<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>

        <title>Introduction to JavaScript - CSU677 - Shoolini U</title>
        <meta name="description" content="Learn the basics of JavaScript, a versatile programming language used for web development, in CSU677 at Shoolini University.">

        <meta property="og:image" content="/logo.png">
        <meta property="og:type" content="article">

        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@divyamohan1993">
        <meta name="twitter:creator" content="@divyamohan1993">
        <meta name="twitter:image" content="/logo.png">

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />

        <meta name="author" content="Divya Mohan">
        <meta name="robots" content="index, follow">

        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                renderMathInElement(document.body, {
                    // customised options
                    // • auto-render specific keys, e.g.:
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\(', right: '\\)', display: false },
                        { left: '\\[', right: '\\]', display: true }
                    ],
                    // • rendering keys, e.g.:
                    throwOnError: false
                });
            });
        </script>

    </head>

    <body>

        <script> header_author("dm"); </script>

        <main>
            <article class="agen-tableofcontents">
                <h2 class="text-center">
                    Introduction to JavaScript
                </h2>
            </article>

            <article>
                <h3 class="fw-bold">What is JavaScript</h3>
                <p>JavaScript is a versatile programming language that allows developers to create dynamic, interactive, and engaging web experiences. It is a cornerstone of modern web development, enabling everything from simple animations to complex web applications.</p>
                <h4>Characteristics of JavaScript</h4>
                <ul>
                    <li>
                        <strong>Dynamic Typing:</strong>
                        JavaScript is dynamically typed, meaning variables do not need to be declared with a specific type, and their type can change at runtime. This provides flexibility in coding but requires careful handling to avoid type-related errors.
                    </li>
                    <li>
                        <strong>Interpreted Language:</strong>
                        JavaScript is an interpreted language, meaning it is executed line by line by the browser's JavaScript engine without the need for prior compilation. This allows for quick development and testing, as changes can be made and seen instantly.
                    </li>
                    <li>
                        <strong>Event-Driven:</strong>
                        JavaScript is heavily event-driven, meaning it responds to user actions, such as clicks, key presses, or form submissions. This makes it ideal for creating interactive web pages that react to user input.
                    </li>
                    <li>
                        <strong>Prototype-Based:</strong>
                        JavaScript uses prototype-based inheritance, where objects can inherit properties and methods from other objects. This allows for flexible and efficient code reuse, although it differs from the class-based inheritance model found in many other languages.
                    </li>
                    <li>
                        <strong>Asynchronous Capabilities:</strong>
                        JavaScript supports asynchronous programming, allowing developers to perform tasks like data fetching or timers without blocking the main thread. This ensures that web applications remain responsive and can handle multiple tasks simultaneously.
                    </li>
                    <li>
                        <strong>High Integration with HTML/CSS:</strong>
                        JavaScript is tightly integrated with HTML and CSS, allowing developers to manipulate the DOM (Document Object Model) and CSS styles dynamically. This integration is essential for creating interactive and visually appealing web pages.
                    </li>
                    <li>
                        <strong>Cross-Platform Compatibility:</strong>
                        JavaScript is supported by all modern web browsers, making it a truly cross-platform language. Whether on desktops, tablets, or smartphones, JavaScript can run consistently across different devices and operating systems.
                    </li>
                    <li>
                        <strong>Lightweight:</strong>
                        JavaScript is a lightweight language, designed to be executed quickly within web browsers. This makes it ideal for web development, where performance and loading times are critical.
                    </li>
                    <li>
                        <strong>First-Class Functions:</strong>
                        In JavaScript, functions are first-class citizens, meaning they can be assigned to variables, passed as arguments to other functions, and returned from functions. This feature is foundational for JavaScript's functional programming capabilities.
                    </li>
                    <li>
                        <strong>Client-Side Execution:</strong>
                        JavaScript is primarily executed on the client side, meaning it runs directly in the user's browser. This reduces the load on web servers and enables dynamic content updates without needing to reload the entire page.
                    </li>
                </ul>
            </article>

            <article>
                <h3 class="fw-bold">1. Basics of JavaScript</h3>
                <p>The foundation of JavaScript programming consists of core concepts that are essential for building functional scripts.</p>
            </article>
            <article>
                <h4>1.1 Variables and Data Types</h4>
                <p>Variables are like containers that store data for use later in a script. The type of data stored in these containers can vary:</p>

                <article>
                    <h5>1.1.1 Primitive Data Types</h5>
                    <p>Primitive data types are the simplest kinds of data in JavaScript. They include:</p>
                    <ul>
                        <li><strong>String</strong>: Represents text. For example, <code>"Hello, World!"</code>.</li>
                        <li><strong>Number</strong>: Represents numerical values. For example, <code>42</code>.</li>
                        <li><strong>Boolean</strong>: Represents a true or false value. For example, <code>true</code> or <code>false</code>.</li>
                        <li><strong>Null</strong>: Represents the intentional absence of any object value. For example, <code>null</code>.</li>
                        <li><strong>Undefined</strong>: Represents a variable that has been declared but not yet assigned a value. For example, <code>let x;</code> where <code>x</code> is <code>undefined</code>.</li>
                        <li><strong>Symbol</strong>: Represents a unique identifier, often used in advanced programming scenarios.</li>
                    </ul>
                </article>

                <article>
                    <h5>1.1.2 Objects</h5>
                    <p>Objects are collections of key-value pairs, where each key (or property) has a corresponding value. Objects can store multiple pieces of data under one entity:</p>
                    <ul>
                        <li><strong>Properties</strong>: Variables attached to an object. For example, in the object <code>{name: "Alice", age: 30}</code>, <code>name</code> and <code>age</code> are properties.</li>
                        <li><strong>Methods</strong>: Functions attached to an object. For example, if an object <code>person</code> has a method <code>greet</code>, you can call <code>person.greet()</code> to perform a specific action.</li>
                        <li><strong>Nested Objects</strong>: Objects within other objects. For example, <code>{address: {city: "New York", zip: "10001"}}</code>.</li>
                    </ul>
                </article>

                <article>
                    <h5>1.1.3 Arrays</h5>
                    <p>Arrays are special objects used to store lists of values, which are ordered and indexed:</p>
                    <ul>
                        <li><strong>Elements</strong>: Individual items in an array. For example, in the array <code>[1, 2, 3]</code>, <code>1</code>, <code>2</code>, and <code>3</code> are elements.</li>
                        <li><strong>Indexing</strong>: The position of elements in an array, starting from 0. For example, <code>arr[0]</code> returns the first element.</li>
                        <li><strong>Length</strong>: The number of elements in an array, accessible with <code>arr.length</code>.</li>
                        <li><strong>Common Methods</strong>: Actions that can be performed on arrays, like <code>push()</code> (adding an element), <code>pop()</code> (removing the last element), and <code>map()</code> (applying a function to each element).</li>
                    </ul>
                </article>
            </article>

            <article>
                <h4>1.2 Operators</h4>
                <p>Operators are symbols that tell the computer to perform specific operations on variables or values:</p>

                <article>
                    <h5>1.2.1 Arithmetic Operators</h5>
                    <p>Arithmetic operators perform basic mathematical operations:</p>
                    <ul>
                        <li><strong>Addition (+)</strong>: Adds two numbers. For example, <code>5 + 3</code> equals <code>8</code>.</li>
                        <li><strong>Subtraction (-)</strong>: Subtracts one number from another. For example, <code>5 - 3</code> equals <code>2</code>.</li>
                        <li><strong>Multiplication (*)</strong>: Multiplies two numbers. For example, <code>5 * 3</code> equals <code>15</code>.</li>
                        <li><strong>Division (/)</strong>: Divides one number by another. For example, <code>15 / 3</code> equals <code>5</code>.</li>
                        <li><strong>Modulus (%)</strong>: Finds the remainder of division. For example, <code>5 % 2</code> equals <code>1</code>.</li>
                    </ul>
                </article>

                <article>
                    <h5>1.2.2 Assignment Operators</h5>
                    <p>Assignment operators assign values to variables:</p>
                    <ul>
                        <li><strong>Equal (=)</strong>: Assigns the right-hand value to the left-hand variable. For example, <code>let x = 10;</code>.</li>
                        <li><strong>Plus Equal (+=)</strong>: Adds the right-hand value to the left-hand variable and assigns the result to the variable. For example, <code>x += 5</code> is the same as <code>x = x + 5</code>.</li>
                        <li><strong>Minus Equal (-=)</strong>: Subtracts the right-hand value from the left-hand variable and assigns the result to the variable. For example, <code>x -= 3</code> is the same as <code>x = x - 3</code>.</li>
                    </ul>
                </article>

                <article>
                    <h5>1.2.3 Comparison Operators</h5>
                    <p>Comparison operators compare two values and return a Boolean (true or false) result:</p>
                    <ul>
                        <li><strong>Equal to (==)</strong>: Checks if two values are equal. For example, <code>5 == '5'</code> is <code>true</code> (loose comparison).</li>
                        <li><strong>Strictly Equal to (===)</strong>: Checks if two values are equal and of the same type. For example, <code>5 === 5</code> is <code>true</code>, but <code>5 === '5'</code> is <code>false</code> (strict comparison).</li>
                        <li><strong>Not Equal to (!=)</strong>: Checks if two values are not equal. For example, <code>5 != 3</code> is <code>true</code>.</li>
                        <li><strong>Greater than (>)</strong>: Checks if the left-hand value is greater than the right-hand value. For example, <code>5 > 3</code> is <code>true</code>.</li>
                        <li><strong>Less than (<)< /strong>: Checks if the left-hand value is less than the right-hand value. For example, <code>5 < 3</code> is <code>false</code>.</li>
                    </ul>
                </article>

                <article>
                    <h5>1.2.4 Logical Operators</h5>
                    <p>Logical operators combine multiple conditions or invert a condition:</p>
                    <ul>
                        <li><strong>AND (&&)</strong>: Returns true if both conditions are true. For example, <code>true && false</code> is <code>false</code>.</li>
                        <li><strong>OR (||)</strong>: Returns true if at least one condition is true. For example, <code>true || false</code> is <code>true</code>.</li>
                        <li><strong>NOT (!)</strong>: Inverts the condition. For example, <code>!true</code> is <code>false</code>.</li>
                    </ul>
                </article>
            </article>

            <article>
                <h4>1.3 Control Structures</h4>
                <p>Control structures allow us to control the flow of the program, deciding which code should be executed under certain conditions:</p>

                <article>
                    <h5>1.3.1 Conditional Statements</h5>
                    <p>These statements execute different blocks of code based on whether a condition is true or false:</p>
                    <ul>
                        <li><strong>If Statement</strong>: Runs a block of code if a condition is true. For example, <code>if (x > 10) { console.log('x is greater than 10'); }</code>.</li>
                        <li><strong>Else Statement</strong>: Runs a block of code if the preceding <code>if</code> statement's condition is false. For example, <code>if (x > 10) { console.log('x is greater than 10'); } else { console.log('x is 10 or less'); }</code>.</li>
                        <li><strong>Else If Statement</strong>: Tests additional conditions if the previous <code>if</code> or <code>else if</code> conditions are false. For example, <code>if (x > 10) { console.log('x is greater than 10'); } else if (x === 10) { console.log('x is exactly 10'); }</code>.</li>
                        <li><strong>Switch Statement</strong>: Evaluates an expression against multiple possible cases and executes the matching case's block. For example, <code>switch (day) { case 1: console.log('Monday'); break; case 2: console.log('Tuesday'); break; }</code>.</li>
                    </ul>
                </article>

                <article>
                    <h5>1.3.2 Loops</h5>
                    <p>Loops allow us to repeat a block of code multiple times:</p>
                    <ul>
                        <li><strong>For Loop</strong>: Repeats a block of code a specific number of times. For example, <code>for (let i = 0; i < 5; i++) { console.log(i); }</code> will log numbers 0 through 4.</li>
                        <li><strong>While Loop</strong>: Repeats a block of code as long as a condition is true. For example, <code>while (x < 10) { x++; }</code> will increment x until it reaches 10.</li>
                        <li><strong>Do While Loop</strong>: Similar to the <code>while</code> loop, but it executes the block of code at least once, even if the condition is false. For example, <code>do { x++; } while (x < 10);</code>.</li>
                        <li><strong>Break Statement</strong>: Exits the loop early if a certain condition is met. For example, <code>for (let i = 0; i < 10; i++) { if (i === 5) break; }</code> stops the loop when <code>i</code> equals 5.</li>
                        <li><strong>Continue Statement</strong>: Skips the current iteration of the loop and proceeds to the next one. For example, <code>for (let i = 0; i < 10; i++) { if (i === 5) continue; }</code> skips logging the number 5.</li>
                    </ul>
                </article>
            </article>

            <article>
                <h4>1.4 Functions</h4>
                <p>Functions are reusable blocks of code that perform specific tasks. Once defined, they can be called multiple times with different inputs:</p>

                <article>
                    <h5>1.4.1 Function Declaration</h5>
                    <p>A function declaration defines a function with a specific name and can be called later in the code:</p>
                    <ul>
                        <li><strong>Syntax</strong>: The basic syntax is <code>function name(parameters) { // code to be executed }</code>.</li>
                        <li><strong>Calling Functions</strong>: You call a function by using its name followed by parentheses, passing arguments if necessary. For example, <code>greet('Alice');</code> if <code>greet</code> is a function.</li>
                        <li><strong>Return Statement</strong>: The <code>return</code> statement specifies the value that a function should output when it is called. For example, <code>function add(a, b) { return a + b; }</code>.</li>
                    </ul>
                </article>

                <article>
                    <h5>1.4.2 Function Expression</h5>
                    <p>In a function expression, the function is assigned to a variable. This allows for anonymous functions:</p>
                    <ul>
                        <li><strong>Anonymous Functions</strong>: Functions without a name, often used in callbacks. For example, <code>let greet = function() { console.log('Hello!'); };</code>.</li>
                        <li><strong>Immediate Invocation</strong>: An Immediately Invoked Function Expression (IIFE) runs as soon as it is defined. For example, <code>(function() { console.log('Hello World!'); })();</code>.</li>
                        <li><strong>Hoisting Behavior</strong>: Unlike function declarations, function expressions are not hoisted, meaning they cannot be called before they are defined.</li>
                    </ul>
                </article>

                <article>
                    <h5>1.4.3 Arrow Functions</h5>
                    <p>Arrow functions provide a shorter syntax for writing functions and have different behavior with <code>this</code>:</p>
                    <ul>
                        <li><strong>Simplified Syntax</strong>: Arrow functions use <code>=></code> to define the function. For example, <code>const greet = () => { console.log('Hello!'); };</code>.</li>
                        <li><strong>Implicit Return</strong>: If the function body is a single expression, the return keyword can be omitted. For example, <code>const add = (a, b) => a + b;</code>.</li>
                        <li><strong>No <code>this</code> Binding</strong>: Arrow functions do not have their own <code>this</code>, they inherit it from the surrounding context. This makes them particularly useful in callbacks.</li>
                    </ul>
                </article>

                <article>
                    <h5>1.4.4 Parameters and Arguments</h5>
                    <p>Functions can accept inputs called parameters, and the actual values passed to them are called arguments:</p>
                    <ul>
                        <li><strong>Default Parameters</strong>: You can assign default values to parameters in case no argument is provided. For example, <code>function greet(name = 'Guest') { console.log('Hello, ' + name); }</code>.</li>
                        <li><strong>Rest Parameters</strong>: Use <code>...</code> to gather all remaining arguments into an array. For example, <code>function sum(...numbers) { return numbers.reduce((a, b) => a + b); }</code>.</li>
                        <li><strong>Argument Length</strong>: <code>arguments.length</code> gives the number of arguments passed to the function.</li>
                    </ul>
                </article>
            </article>

            <article>
                <h3 class="fw-bold">2. JavaScript Features and Concepts</h3>
                <p>Beyond the basics, JavaScript offers advanced features and concepts that provide powerful tools for developers.</p>
            </article>
            <article>
                <h4>2.1 Objects and Object-Oriented Programming (OOP)</h4>
                <p>Objects in JavaScript are collections of properties and methods, allowing you to model more complex data structures and behaviors:</p>

                <article>
                    <h5>2.1.1 Object Literals</h5>
                    <p>Object literals are a simple and direct way to create objects using curly braces:</p>
                    <ul>
                        <li><strong>Defining an Object</strong>: Objects are created using curly braces <code>{}</code>. For example, <code>const person = {name: "Alice", age: 25};</code>.</li>
                        <li><strong>Accessing Properties</strong>: You can access object properties using dot notation <code>person.name</code> or bracket notation <code>person['name']</code>.</li>
                        <li><strong>Adding/Updating Properties</strong>: You can add or update properties dynamically. For example, <code>person.city = 'New York';</code>.</li>
                        <li><strong>Deleting Properties</strong>: You can remove properties using the <code>delete</code> keyword. For example, <code>delete person.age;</code>.</li>
                    </ul>
                </article>

                <article>
                    <h5>2.1.2 Constructor Functions</h5>
                    <p>Constructor functions are templates for creating multiple similar objects:</p>
                    <ul>
                        <li><strong>Defining a Constructor</strong>: A constructor function uses the <code>function</code> keyword and capitalizes the first letter. For example, <code>function Person(name, age) { this.name = name; this.age = age; }</code>.</li>
                        <li><strong>Creating Instances</strong>: You create new objects by calling the constructor with the <code>new</code> keyword. For example, <code>const alice = new Person('Alice', 25);</code>.</li>
                        <li><strong>Adding Methods</strong>: Methods can be added inside the constructor or to the prototype. For example, <code>Person.prototype.greet = function() { console.log('Hello, ' + this.name); };</code>.</li>
                    </ul>
                </article>

                <article>
                    <h5>2.1.3 Prototypes</h5>
                    <p>Prototypes allow objects to inherit properties and methods from other objects:</p>
                    <ul>
                        <li><strong>Prototype Chain</strong>: Every object in JavaScript has a prototype, which is another object it inherits properties from. This forms a chain up to <code>Object.prototype</code>.</li>
                        <li><strong>Prototype Inheritance</strong>: Objects can share common properties or methods without duplication. For example, <code>Person.prototype.greet = function() { console.log('Hello, ' + this.name); }</code> allows all instances of <code>Person</code> to use <code>greet</code>.</li>
                        <li><strong>Creating New Prototypes</strong>: You can create a new object with a specific prototype using <code>Object.create(prototype)</code>.</li>
                    </ul>
                </article>

                <article>
                    <h5>2.1.4 Classes</h5>
                    <p>ES6 introduced classes as a more intuitive way to work with objects and inheritance:</p>
                    <ul>
                        <li><strong>Class Syntax</strong>: Classes are defined using the <code>class</code> keyword. For example, <code>class Person { constructor(name, age) { this.name = name; this.age = age; } }</code>.</li>
                        <li><strong>Methods in Classes</strong>: Methods are added directly within the class. For example, <code>greet() { console.log('Hello, ' + this.name); }</code>.</li>
                        <li><strong>Inheritance with Classes</strong>: Classes can extend other classes, inheriting their properties and methods. For example, <code>class Employee extends Person { constructor(name, age, jobTitle) { super(name, age); this.jobTitle = jobTitle; } }</code>.</li>
                        <li><strong>Static Methods</strong>: Static methods are called on the class itself, not on instances. For example, <code>static create(name, age) { return new Person(name, age); }</code>.</li>
                    </ul>
                </article>
            </article>

            <article>
                <h4>2.2 Asynchronous JavaScript</h4>
                <p>Asynchronous programming allows JavaScript to perform tasks like fetching data without blocking the main thread:</p>

                <article>
                    <h5>2.2.1 Callbacks</h5>
                    <p>Callbacks are functions passed as arguments to other functions, executed after an operation completes:</p>
                    <ul>
                        <li><strong>Callback Function</strong>: A function passed as an argument to another function. For example, <code>setTimeout(function() { console.log('Hello!'); }, 1000);</code> where the first argument is the callback.</li>
                        <li><strong>Nesting Callbacks</strong>: Callbacks can be nested, leading to "callback hell." For example, <code>getUserData(function(data) { processData(data, function(result) { displayResult(result); }); });</code>.</li>
                        <li><strong>Error Handling in Callbacks</strong>: Errors in callbacks are usually handled by passing an error object as the first argument. For example, <code>callback(err, data);</code>.</li>
                    </ul>
                </article>

                <article>
                    <h5>2.2.2 Promises</h5>
                    <p>Promises provide a cleaner way to handle asynchronous operations, avoiding callback hell:</p>
                    <ul>
                        <li><strong>Creating a Promise</strong>: A promise is created using the <code>new Promise</code> constructor. For example, <code>const promise = new Promise((resolve, reject) => { // asynchronous code });</code>.</li>
                        <li><strong>Chaining Promises</strong>: Promises can be chained using <code>.then()</code> for successive operations. For example, <code>promise.then(result => nextStep(result)).then(finalResult => console.log(finalResult));</code>.</li>
                        <li><strong>Error Handling with Promises</strong>: Errors are caught using <code>.catch()</code>. For example, <code>promise.then(result => nextStep(result)).catch(error => console.error(error));</code>.</li>
                        <li><strong>Promise States</strong>: A promise can be in one of three states: <code>pending</code>, <code>fulfilled</code>, or <code>rejected</code>.</li>
                    </ul>
                </article>

                <article>
                    <h5>2.2.3 Async/Await</h5>
                    <p>Async/Await provides a more readable and synchronous-looking way to handle promises:</p>
                    <ul>
                        <li><strong>Async Functions</strong>: A function declared with <code>async</code> returns a promise and can use <code>await</code>. For example, <code>async function fetchData() { let data = await fetch(url); }</code>.</li>
                        <li><strong>Await Keyword</strong>: Pauses the execution of the async function until the promise resolves. For example, <code>let result = await someAsyncFunction();</code>.</li>
                        <li><strong>Try/Catch with Async/Await</strong>: Errors in async functions are handled using <code>try</code> and <code>catch</code>. For example, <code>try { let data = await fetchData(); } catch (error) { console.error(error); }</code>.</li>
                    </ul>
                </article>
            </article>

            <article>
                <h4>2.3 DOM Manipulation</h4>
                <p>The DOM (Document Object Model) represents the structure of a web page. JavaScript can be used to manipulate the DOM, allowing for dynamic changes to the content and structure of a page:</p>

                <article>
                    <h5>2.3.1 Selecting Elements</h5>
                    <p>To manipulate the DOM, you first need to select the elements you want to change:</p>
                    <ul>
                        <li><strong>getElementById</strong>: Selects an element by its ID. For example, <code>document.getElementById('header');</code>.</li>
                        <li><strong>querySelector</strong>: Selects the first element that matches a CSS selector. For example, <code>document.querySelector('.menu');</code>.</li>
                        <li><strong>querySelectorAll</strong>: Selects all elements that match a CSS selector and returns a NodeList. For example, <code>document.querySelectorAll('.list-item');</code>.</li>
                        <li><strong>getElementsByClassName</strong>: Selects elements by their class name. For example, <code>document.getElementsByClassName('item');</code>.</li>
                    </ul>
                </article>

                <article>
                    <h5>2.3.2 Modifying Elements</h5>
                    <p>Once selected, you can modify elements in various ways:</p>
                    <ul>
                        <li><strong>Changing Content</strong>: Use <code>textContent</code> or <code>innerHTML</code> to change the text or HTML inside an element. For example, <code>element.textContent = 'Hello World';</code>.</li>
                        <li><strong>Changing Attributes</strong>: Use <code>setAttribute</code> to change an element's attributes. For example, <code>element.setAttribute('src', 'image.jpg');</code>.</li>
                        <li><strong>Changing Styles</strong>: Modify an element's style using the <code>style</code> property. For example, <code>element.style.color = 'red';</code>.</li>
                        <li><strong>Adding/Removing Classes</strong>: Use <code>classList.add</code> or <code>classList.remove</code> to add or remove CSS classes. For example, <code>element.classList.add('active');</code>.</li>
                    </ul>
                </article>

                <article>
                    <h5>2.3.3 Event Handling</h5>
                    <p>Events are actions that occur in the browser, like clicks or key presses. JavaScript can handle these events:</p>
                    <ul>
                        <li><strong>Add Event Listener</strong>: Attach an event handler to an element using <code>addEventListener</code>. For example, <code>button.addEventListener('click', () => { console.log('Button clicked!'); });</code>.</li>
                        <li><strong>Event Object</strong>: The event object contains information about the event, accessible in event handlers. For example, <code>event.target</code> refers to the element that triggered the event.</li>
                        <li><strong>Prevent Default Behavior</strong>: Use <code>event.preventDefault()</code> to stop the default action, like submitting a form. For example, <code>link.addEventListener('click', event => { event.preventDefault(); });</code>.</li>
                        <li><strong>Delegating Events</strong>: Event delegation allows handling events at a higher level, useful for elements created dynamically. For example, adding a click event listener to a parent element that checks the clicked child element.</li>
                    </ul>
                </article>

                <article>
                    <h5>2.3.4 Creating and Removing Elements</h5>
                    <p>JavaScript can dynamically add or remove elements from the DOM:</p>
                    <ul>
                        <li><strong>Creating Elements</strong>: Use <code>document.createElement</code> to create a new element. For example, <code>const newDiv = document.createElement('div');</code>.</li>
                        <li><strong>Appending Elements</strong>: Add the created element to the DOM using <code>appendChild</code>. For example, <code>parentElement.appendChild(newDiv);</code>.</li>
                        <li><strong>Removing Elements</strong>: Remove an element from the DOM using <code>removeChild</code> or <code>element.remove()</code>. For example, <code>parentElement.removeChild(childElement);</code>.</li>
                        <li><strong>Replacing Elements</strong>: Replace an existing element with a new one using <code>replaceChild</code>. For example, <code>parentElement.replaceChild(newElement, oldElement);</code>.</li>
                    </ul>
                </article>
            </article>

            <article>
                <h3 class="fw-bold">3. JavaScript in the Browser</h3>
                <p>JavaScript's integration with web browsers enables developers to create interactive and engaging web pages.</p>
            </article>

            <article>
                <h4>3.1 Browser APIs</h4>
                <p>Web browsers provide a variety of APIs (Application Programming Interfaces) that extend the functionality of JavaScript:</p>

                <article>
                    <h5>3.1.1 DOM API</h5>
                    <p>The DOM API allows interaction with the structure of a web page:</p>
                    <ul>
                        <li><strong>DOM Traversal</strong>: Methods for navigating through the DOM, like <code>parentNode</code>, <code>childNodes</code>, <code>firstChild</code>, and <code>lastChild</code>.</li>
                        <li><strong>DOM Manipulation</strong>: Methods for adding, removing, or altering elements in the DOM.</li>
                        <li><strong>DOM Events</strong>: Handling user interactions like clicks, typing, and scrolling.</li>
                        <li><strong>Querying the DOM</strong>: Searching the DOM using methods like <code>getElementById</code>, <code>querySelector</code>, and <code>getElementsByClassName</code>.</li>
                    </ul>
                </article>

                <article>
                    <h5>3.1.2 Fetch API</h5>
                    <p>The Fetch API allows for making network requests to retrieve resources from the server:</p>
                    <ul>
                        <li><strong>Fetching Data</strong>: Using <code>fetch(url)</code> to send a request and receive a response.</li>
                        <li><strong>Parsing JSON</strong>: Converting the response data into a usable format, typically JSON. For example, <code>response.json()</code>.</li>
                        <li><strong>Handling Errors</strong>: Checking the response status and handling errors. For example, using <code>.catch()</code> for failed requests.</li>
                        <li><strong>Asynchronous Requests</strong>: Making requests without blocking the main thread, allowing the rest of the code to execute.</li>
                    </ul>
                </article>

                <article>
                    <h5>3.1.3 Canvas API</h5>
                    <p>The Canvas API allows for drawing graphics on a web page:</p>
                    <ul>
                        <li><strong>Creating a Canvas</strong>: Use the <code>&lt;canvas&gt;</code> element to define a drawing area.</li>
                        <li><strong>Drawing Shapes</strong>: Methods for drawing basic shapes like <code>fillRect</code>, <code>strokeRect</code>, <code>clearRect</code>, and <code>beginPath</code>.</li>
                        <li><strong>Working with Colors</strong>: Setting fill and stroke colors using <code>fillStyle</code> and <code>strokeStyle</code>.</li>
                        <li><strong>Drawing Text</strong>: Methods for drawing text on the canvas using <code>fillText</code> and <code>strokeText</code>.</li>
                        <li><strong>Animating Graphics</strong>: Creating animations by repeatedly drawing and clearing shapes in a loop, often using <code>requestAnimationFrame</code>.</li>
                    </ul>
                </article>

                <article>
                    <h5>3.1.4 Geolocation API</h5>
                    <p>The Geolocation API provides the geographic location of the user's device:</p>
                    <ul>
                        <li><strong>Getting Current Position</strong>: Use <code>navigator.geolocation.getCurrentPosition</code> to obtain the user's latitude and longitude.</li>
                        <li><strong>Handling Position Data</strong>: Process the latitude and longitude to display location-based information or services.</li>
                        <li><strong>Handling Errors</strong>: Catch errors like permission denied or location unavailable using error callbacks.</li>
                        <li><strong>Tracking Position</strong>: Use <code>watchPosition</code> to monitor the user's position as it changes over time.</li>
                    </ul>
                </article>
            </article>

            <article>
                <h4>3.2 Event Loop</h4>
                <p>The event loop is a crucial part of JavaScript's runtime environment, allowing for asynchronous operations to be handled effectively:</p>

                <article>
                    <h5>3.2.1 Call Stack</h5>
                    <p>The call stack keeps track of function calls in a LIFO (Last In, First Out) order:</p>
                    <ul>
                        <li><strong>Function Execution</strong>: When a function is called, it's added to the stack. Once it completes, it's removed from the stack.</li>
                        <li><strong>Stack Overflow</strong>: If the stack gets too large (e.g., due to too many recursive calls), it can cause a stack overflow, crashing the program.</li>
                    </ul>
                </article>

                <article>
                    <h5>3.2.2 Web APIs</h5>
                    <p>Web APIs are browser-provided functionalities that run in the background:</p>
                    <ul>
                        <li><strong>setTimeout and setInterval</strong>: Schedule code to run after a delay or at regular intervals.</li>
                        <li><strong>DOM Events</strong>: Handle user interactions like clicks and keypresses asynchronously.</li>
                        <li><strong>XHR and Fetch</strong>: Perform network requests to fetch resources or send data asynchronously.</li>
                    </ul>
                </article>

                <article>
                    <h5>3.2.3 Task Queue</h5>
                    <p>The task queue holds tasks that are ready to run once the call stack is clear:</p>
                    <ul>
                        <li><strong>Event Callbacks</strong>: User interactions or API calls are placed in the queue to be processed when the stack is empty.</li>
                        <li><strong>Promise Microtasks</strong>: Microtasks like <code>Promise.then()</code> are prioritized in the task queue and run before regular tasks.</li>
                    </ul>
                </article>

                <article>
                    <h5>3.2.4 Handling Events</h5>
                    <p>JavaScript manages events asynchronously, ensuring smooth user interactions:</p>
                    <ul>
                        <li><strong>Event Delegation</strong>: Attaching a single event listener to a parent element to manage all child elements, reducing the number of event listeners.</li>
                        <li><strong>Event Bubbling and Capturing</strong>: Events flow through the DOM in phases, first capturing (from the root to the target) and then bubbling (from the target back up). Use <code>stopPropagation()</code> to prevent bubbling.</li>
                        <li><strong>Event Loop and UI Updates</strong>: UI updates are managed efficiently by the event loop, ensuring the interface remains responsive while processing background tasks.</li>
                    </ul>
                </article>
            </article>

            <article>
                <h4>3.3 Error Handling</h4>
                <p>Effective error handling ensures that JavaScript code can gracefully handle unexpected issues:</p>

                <article>
                    <h5>3.3.1 Try/Catch Statements</h5>
                    <p>Try/Catch blocks are used to handle exceptions (errors) in JavaScript:</p>
                    <ul>
                        <li><strong>Try Block</strong>: Contains code that may throw an error. For example, <code>try { let x = y; }</code> will throw an error if <code>y</code> is undefined.</li>
                        <li><strong>Catch Block</strong>: Executes if an error is thrown in the <code>try</code> block. For example, <code>catch(error) { console.log(error.message); }</code>.</li>
                        <li><strong>Finally Block</strong>: An optional block that runs after the <code>try</code> and <code>catch</code> blocks, regardless of the outcome. Useful for cleanup code.</li>
                    </ul>
                </article>

                <article>
                    <h5>3.3.2 Throwing Errors</h5>
                    <p>You can manually trigger (throw) errors using the <code>throw</code> statement:</p>
                    <ul>
                        <li><strong>Custom Error Messages</strong>: Use <code>throw</code> to create custom error messages. For example, <code>throw new Error('Something went wrong!');</code>.</li>
                        <li><strong>Validating Input</strong>: Throw errors when input validation fails. For example, <code>if (!username) { throw new Error('Username is required'); }</code>.</li>
                        <li><strong>Types of Errors</strong>: JavaScript has built-in error types like <code>TypeError</code>, <code>ReferenceError</code>, and <code>SyntaxError</code>.</li>
                    </ul>
                </article>

                <article>
                    <h5>3.3.3 Debugging Tools</h5>
                    <p>Debugging tools help identify and fix errors in JavaScript code:</p>
                    <ul>
                        <li><strong>Browser Developer Tools</strong>: Most browsers have built-in developer tools for inspecting code, setting breakpoints, and viewing errors.</li>
                        <li><strong>Breakpoints</strong>: Pauses code execution at a specific line, allowing you to inspect the state of the application.</li>
                        <li><strong>Console</strong>: Use <code>console.log()</code> to output values and <code>console.error()</code> to highlight errors.</li>
                        <li><strong>Source Maps</strong>: Maps the minified code to the original source code, making debugging easier in production environments.</li>
                    </ul>
                </article>
            </article>

            <article>
                <h3 class="fw-bold">4. Modern JavaScript Practices</h3>
                <p>With the evolution of JavaScript, modern practices and tools have emerged that enhance development efficiency and code quality.</p>
            </article>

            <article>
                <h4>4.1 ES6+ Features</h4>
                <p>ECMAScript 6 (ES6) and later versions introduced new syntax and features that simplify and improve JavaScript code:</p>

                <article>
                    <h5>4.1.1 Let and Const</h5>
                    <p><code>let</code> and <code>const</code> are block-scoped variables introduced in ES6:</p>
                    <ul>
                        <li><strong>Let</strong>: A variable that can be reassigned but is limited to the block in which it is declared. For example, <code>let count = 1;</code>.</li>
                        <li><strong>Const</strong>: A variable that cannot be reassigned once initialized. For example, <code>const pi = 3.14;</code>.</li>
                        <li><strong>Block Scope</strong>: Variables declared with <code>let</code> or <code>const</code> are not accessible outside the block in which they are defined.</li>
                        <li><strong>Temporal Dead Zone</strong>: A behavior where variables declared with <code>let</code> or <code>const</code> cannot be accessed before their declaration in the code.</li>
                    </ul>
                </article>

                <article>
                    <h5>4.1.2 Template Literals</h5>
                    <p>Template literals provide a more flexible way to work with strings:</p>
                    <ul>
                        <li><strong>String Interpolation</strong>: Embedding expressions within strings using <code>${expression}</code>. For example, <code>let message = `Hello, ${name}`;</code>.</li>
                        <li><strong>Multi-line Strings</strong>: Creating multi-line strings easily by simply adding new lines in the template literal. For example, <code>let text = `Line 1\nLine 2`;</code>.</li>
                        <li><strong>Tagged Templates</strong>: A function that processes a template literal, allowing you to customize the output. For example, <code>function tag(strings, ...values) {}</code>.</li>
                    </ul>
                </article>

                <article>
                    <h5>4.1.3 Destructuring Assignment</h5>
                    <p>Destructuring allows you to extract values from arrays or properties from objects into distinct variables:</p>
                    <ul>
                        <li><strong>Array Destructuring</strong>: Assigning array elements to variables. For example, <code>const [a, b] = [1, 2];</code> assigns <code>a</code> to <code>1</code> and <code>b</code> to <code>2</code>.</li>
                        <li><strong>Object Destructuring</strong>: Extracting object properties into variables. For example, <code>const {name, age} = person;</code> assigns <code>name</code> and <code>age</code> from the <code>person</code> object.</li>
                        <li><strong>Default Values</strong>: Providing default values during destructuring. For example, <code>const {name = 'Guest'} = person;</code>.</li>
                        <li><strong>Nested Destructuring</strong>: Destructuring nested objects or arrays. For example, <code>const {address: {city}} = person;</code>.</li>
                    </ul>
                </article>

                <article>
                    <h5>4.1.4 Modules</h5>
                    <p>Modules allow you to organize and share code across different files, making it easier to manage and maintain:</p>
                    <ul>
                        <li><strong>Exporting Modules</strong>: Export variables, functions, or classes from a module. For example, <code>export const pi = 3.14;</code>.</li>
                        <li><strong>Importing Modules</strong>: Import exported entities into another module. For example, <code>import { pi } from './math.js';</code>.</li>
                        <li><strong>Default Export</strong>: A single export that can be imported without curly braces. For example, <code>export default function() {}</code>.</li>
                        <li><strong>Named Export</strong>: Multiple exports from a module that must be imported with the same name. For example, <code>export { functionA, functionB };</code>.</li>
                        <li><strong>Dynamic Imports</strong>: Importing modules dynamically, often used for lazy loading. For example, <code>import('./module.js').then(module => { /* use module */ });</code>.</li>
                    </ul>
                </article>
            </article>

            <article>
                <h4>4.2 Testing and Debugging</h4>
                <p>Testing ensures that code works as expected, while debugging helps identify and resolve issues:</p>

                <article>
                    <h5>4.2.1 Unit Testing</h5>
                    <p>Unit testing involves testing individual functions or components in isolation:</p>
                    <ul>
                        <li><strong>Test Cases</strong>: Writing test cases for each function to verify its behavior. For example, using a testing framework like Jest to write tests.</li>
                        <li><strong>Mocking</strong>: Simulating external dependencies or functions to isolate the unit being tested. For example, mocking API calls.</li>
                        <li><strong>Assertions</strong>: Verifying that the output of a function matches the expected result. For example, <code>expect(sum(2, 3)).toBe(5);</code>.</li>
                        <li><strong>Test-Driven Development (TDD)</strong>: Writing tests before writing the code, ensuring that code is written to pass the tests.</li>
                    </ul>
                </article>

                <article>
                    <h5>4.2.2 Integration Testing</h5>
                    <p>Integration testing checks how different parts of the application work together:</p>
                    <ul>
                        <li><strong>Testing Interfaces</strong>: Verifying that different modules or components interact correctly. For example, testing the interaction between the front-end and back-end.</li>
                        <li><strong>API Testing</strong>: Ensuring that the API returns the correct data and handles requests as expected. For example, using tools like Postman or testing frameworks.</li>
                        <li><strong>End-to-End Testing</strong>: Simulating a complete user interaction from start to finish to ensure the entire system works as intended.</li>
                        <li><strong>Continuous Integration (CI)</strong>: Automating the testing process as part of the development workflow, ensuring that tests are run on every commit or build.</li>
                    </ul>
                </article>

                <article>
                    <h5>4.2.3 Debugging Tools</h5>
                    <p>Debugging tools are essential for finding and fixing issues in your code:</p>
                    <ul>
                        <li><strong>Browser Developer Tools</strong>: Using the console, inspecting elements, setting breakpoints, and debugging scripts in real-time.</li>
                        <li><strong>Breakpoints</strong>: Pausing code execution at specific lines to inspect variables and the call stack.</li>
                        <li><strong>Watch Expressions</strong>: Monitoring specific variables or expressions to see how their values change over time.</li>
                        <li><strong>Source Maps</strong>: Mapping minified or transpiled code back to the original source code to make debugging easier.</li>
                        <li><strong>Debugging in IDEs</strong>: Integrated Development Environments (IDEs) like VSCode offer powerful debugging features directly in the editor.</li>
                    </ul>
                </article>
            </article>

            <article>
                <h4>4.3 Build Tools and Transpilers</h4>
                <p>Build tools and transpilers automate repetitive tasks and ensure code compatibility across different environments:</p>

                <article>
                    <h5>4.3.1 Webpack</h5>
                    <p>Webpack is a module bundler that compiles JavaScript files and assets for deployment:</p>
                    <ul>
                        <li><strong>Entry Point</strong>: The main file or module from which Webpack starts building the dependency graph. For example, <code>entry: './src/index.js'</code>.</li>
                        <li><strong>Loaders</strong>: Transformations applied to files before bundling. For example, using <code>babel-loader</code> to transpile ES6 code to ES5.</li>
                        <li><strong>Plugins</strong>: Additional features that enhance Webpack's functionality. For example, the <code>HtmlWebpackPlugin</code> generates an HTML file that includes all bundles.</li>
                        <li><strong>Output Configuration</strong>: Specifies where the compiled files should be saved. For example, <code>output: { filename: 'bundle.js', path: __dirname + '/dist' }</code>.</li>
                    </ul>
                </article>

                <article>
                    <h5>4.3.2 Babel</h5>
                    <p>Babel is a transpiler that converts ES6+ code into a version compatible with older browsers:</p>
                    <ul>
                        <li><strong>Presets</strong>: Collections of plugins that enable Babel to transform specific types of syntax. For example, the <code>@babel/preset-env</code> preset converts modern JavaScript into a version that works in older environments.</li>
                        <li><strong>Plugins</strong>: Extend Babel's capabilities to support additional features or syntax. For example, the <code>@babel/plugin-transform-arrow-functions</code> plugin converts arrow functions into regular functions.</li>
                        <li><strong>Polyfills</strong>: Adds support for new JavaScript features in environments that do not support them natively. For example, <code>babel-polyfill</code> provides support for promises in older browsers.</li>
                        <li><strong>Babel Configuration</strong>: Configuring Babel using a <code>.babelrc</code> file or within Webpack. For example, specifying presets and plugins for Babel to use.</li>
                    </ul>
                </article>

                <article>
                    <h5>4.3.3 NPM/Yarn</h5>
                    <p>Package managers that help manage dependencies and scripts in JavaScript projects:</p>
                    <ul>
                        <li><strong>Installing Packages</strong>: Using <code>npm install</code> or <code>yarn add</code> to add dependencies to a project.</li>
                        <li><strong>Package.json</strong>: A file that contains metadata about the project and its dependencies. For example, defining scripts, versioning, and dependencies.</li>
                        <li><strong>Scripts</strong>: Automating tasks by defining scripts in <code>package.json</code>. For example, <code>"scripts": { "start": "webpack-dev-server" }</code>.</li>
                        <li><strong>Versioning</strong>: Managing dependency versions to ensure compatibility. For example, using semver (semantic versioning) to specify version ranges.</li>
                        <li><strong>Lock Files</strong>: Files like <code>package-lock.json</code> or <code>yarn.lock</code> that ensure consistent dependencies across different environments.</li>
                    </ul>
                </article>
            </article>

        </main>

        <script> copyright("all"); </script>


    </body>

</html>