<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>

        <title>Functional Dependencies and Normalization - CSU357 - Shoolini University</title>
        <meta name="description" content="Dive deep into the functional dependencies and normalization. Explore its concepts tailored for CSU357 students at Shoolini University.">

        <meta property="og:image" content="/logo.png">
        <meta property="og:type" content="article">

        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@divyamohan1993">
        <meta name="twitter:creator" content="@divyamohan1993">
        <meta name="twitter:image" content="/logo.png">

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />

        <meta name="author" content="Divya Mohan">
        <meta name="robots" content="index, follow">

        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                renderMathInElement(document.body, {
                    // customised options
                    // • auto-render specific keys, e.g.:
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\(', right: '\\)', display: false },
                        { left: '\\[', right: '\\]', display: true }
                    ],
                    // • rendering keys, e.g.:
                    throwOnError: false
                });
            });
        </script>

        <style>
            ul {
                list-style-type: none;
                padding: 0;
                margin: 0;
            }

            ul li {
                margin: 0;
                padding: 0;
            }
        </style>
    </head>

    <body>

        <script> header_author("gg", "dm"); </script>

        <main>

            <article class="agen-tableofcontents">
                <h2 class="text-center">
                    Functional Dependencies and Normalization
                </h2>
                <div class="d-none contentdate">April, 2024</div>
            </article>

            <article id="normalization-overview">
                <h3>1. Overview of Normalization</h3>
                <p>Normalization involves dividing a database into two or more tables and defining relationships between the tables. The objective is to isolate data so that additions, deletions, and modifications of a field can be made in just one table and then propagated through the rest of the database via the defined relationships.</p>
            </article>
            <article>
                <h4>1.1 Functional Dependencies</h4>
                <p>Functional dependencies are constraints between two sets of attributes in a relation from a database. They are used to ensure that the database is normalized to a certain level. A functional dependency is denoted by X → Y, where X and Y are sets of attributes in a relation. The dependency states that the values of X uniquely determine the values of Y.</p>
            </article>
            <article>
                <h4>1.2 Benefits of Normalization</h4>
                <p>Normalization offers several advantages, including:</p>
                <ul>
                    <li><strong>Reduced Redundancy:</strong> Eliminates duplicate data, leading to efficient storage.</li>
                    <li><strong>Improved Data Integrity:</strong> Ensures data accuracy and consistency.</li>
                    <li><strong>Easier Data Modification:</strong> Simplifies updates, deletions, and insertions.</li>
                </ul>
            </article>
            <article>
                <h4>1.3 Levels of Normalization</h4>
                <p>Normalization is divided into several normal forms, each representing a level of organization that is free of certain types of anomalies. The most common normal forms include:</p>
                <ul>
                    <li><strong>First Normal Form (1NF):</strong> Ensures atomic values and eliminates repeating groups.</li>
                    <li><strong>Second Normal Form (2NF):</strong> Eliminates partial dependencies.</li>
                    <li><strong>Third Normal Form (3NF):</strong> Removes transitive dependencies.</li>
                    <li><strong>Boyce-Codd Normal Form (BCNF):</strong> Ensures every determinant is a candidate key.</li>
                </ul>
            </article>
            <article>
                <h4>Purpose of Normalization</h4>
                <p>The primary purpose of normalization is to reduce redundancy and eliminate undesirable characteristics in a database. </p>
                <ul>
                    <li><strong>Eliminating redundant (useless) data.</strong></li>
                    <li><strong>Ensuring data dependencies make sense</strong> (i.e., data is logically stored).</li>
                </ul>
                <p>By systematically organizing data in a database, normalization helps in ensuring data integrity, reducing update anomalies, and making the database more efficient for querying. It simplifies the schema design, making it easier to maintain and less prone to errors, thereby enhancing the reliability and performance of the database system.</p>
            </article>
            <article>
                <h4>Purpose of Normalization and Characteristics of Suitable Relations</h4>
                <p>The purpose of normalization extends beyond organizing data—it aims to produce a set of suitable relations that effectively support the data requirements of an enterprise. Characteristics of these relations include minimal attributes necessary to support these requirements, logical grouping of closely related attributes, and minimal redundancy. Notably, attributes that form all or part of foreign keys may be an exception to this redundancy rule. The result is a database that is not only easier for users to access and maintain but also occupies minimal storage space, enhancing overall efficiency.</p>
            </article>

            <article id="normal-forms">
                <h3>2. Normal Forms</h3>
                <p>Normal Forms are standards for determining how far a database is on the normalization path. Each normal form represents a level of database normalization that is free of certain types of anomalies and redundancy. Achieving higher normal forms typically involves splitting tables into smaller ones, which can lead to more complex but also more efficient and cleaner database designs.</p>
                <article>
                    <h4>Redundant Data and its Problems</h4>
                    <p>Redundant data in a database can lead to several problems, including:</p>
                    <ul>
                        <li>Data inconsistency: Different copies of the same data may have different values, leading to inconsistencies.</li>
                        <li>Update anomalies: Inserting data into one place may require adding the same data in multiple locations, leading to inconsistencies.</li>
                        <li>Deletion anomalies: Removing data from one place may result in the loss of related data stored elsewhere.</li>
                        <li>Insert anamolies: Inability to add data to the database due to missing related data.</li>
                    </ul>
                    <p>Redundant data in base relations can lead to various problems, including increased storage costs, difficulty in data management, and potential inconsistencies. Update anomalies can arise where changes in one instance of data require multiple updates across the database. Similarly, insert and delete anomalies can result in the loss of valuable information or the creation of incomplete records. Normalization addresses these issues by ensuring that each piece of information is stored only once.</p>
                </article>
                <article>
                    <h4>Data Redundancy and Update Anomalies</h4>
                    <p>The primary goal of relational database design is to organize attributes into relations to minimize data redundancy. This approach brings several benefits, including fewer operations required for updates—thereby reducing the chances for data inconsistencies—and a reduction in the storage space needed. Illustratively, comparing Staff and Branch relations with a StaffBranch relation highlights the redundancy issue: in StaffBranch, branch details are repeated for each staff member, while in a normalized design, branch information is stored once, with only the branch number repeated in the Staff relation. This design minimizes update anomalies, which include problems related to insertion, deletion, and modification of data.</p>
                </article>

                <article>
                    <h4>Functional Dependencies and Normalization</h4>
                    <p>A functional dependency exists when one attribute uniquely determines another attribute within a relation. This concept is fundamental to normalization as it helps in identifying relationships among attributes, which in turn informs the division of data into tables. Functional dependencies are used to identify the primary key of a relation, as they indicate attributes that can uniquely identify records in a table. Understanding functional dependencies is crucial for the process of normalization, as they guide the organization of attributes into relations that meet the criteria of known normal forms.</p>
                </article>
                <article>
                    <h4>Identifying Functional Dependencies</h4>
                    <p>To identify functional dependencies for a given relation, one must analyze the relationships between attributes, determining which attributes or combinations thereof can uniquely determine other attributes. This process involves examining the data usage and constraints inherent to the domain of the database. Identifying functional dependencies is a critical step in normalization, as it helps in understanding how attributes are related and lays the groundwork for structuring tables.</p>
                </article>
            </article>

            <article>
                <h4>2.1 First Normal Form (1NF)</h4>
                <p>A table is in 1NF if it satisfies the following conditions:
                <ul>
                    <li>Contains only atomic (indivisible) values.</li>
                    <li>Each column has a unique name.</li>
                    <li>The order in which data is stored does not affect the database's integrity.</li>
                    <li>All entries in a column are of the same kind.</li>
                </ul>
                </p>
            </article>
            <article>
                <h4>2.2 Second Normal Form (2NF)</h4>
                <p>A table is in 2NF if it is in 1NF and all non-key attributes are fully functional dependent on the primary key. This means:
                <ul>
                    <li>There must be no partial dependency of any column on the primary key.</li>
                    <li>Eliminates redundancy by ensuring that all data is related to the primary key.</li>
                </ul>
                </p>
            </article>
            <article>
                <h4>2.3 Third Normal Form (3NF)</h4>
                <p>A table is in 3NF if it is in 2NF and no transitive dependency exists. Conditions include:
                <ul>
                    <li>All its attributes can only depend on primary keys.</li>
                    <li>There must not be any indirect relationship (transitive dependency) where a non-prime attribute depends on another non-prime attribute.</li>
                </ul>
                </p>
            </article>
            <article>
                <h4>2.4 Boyce-Codd Normal Form (BCNF)</h4>
                <p>A refinement of 3NF, a table is in BCNF if, and only if, it is in 3NF and every determinant is a candidate key. This level deals with certain types of anomaly not handled by 3NF.</p>
            </article>
            <article>
                <h4>2.5 Fourth Normal Form (4NF)</h4>
                <p>A table is in 4NF if it is in BCNF and has no multi-valued dependencies, except possibly those involving candidate keys. Multi-valued dependency occurs when two attributes in a table are independent of each other, but both depend on a third attribute. 4NF is useful for handling complex relationships where one key determines multiple sets of values that are themselves independent. This normalization form helps in further reducing redundancy that is not addressed by BCNF.</p>
            </article>
<article>
    <h4>2.6 Fifth Normal Form (5NF) or Project-Join Normal Form (PJNF)</h4>
    <p>A table is in 5NF, also known as Project-Join Normal Form (PJNF), if it is in 4NF and every join dependency in it is implied by its candidate keys. A join dependency is a generalization of a functional dependency in a relation that involves three or more attributes. 5NF addresses situations where information can be reconstructed from smaller pieces of data (projections) that can be recombined (joined) without loss of information or introduction of redundancy. Tables in 5NF are free from all update anomalies associated with multi-valued facts.</p>
</article>

<article>
    <h4>2.7 Domain-Key Normal Form (DKNF)</h4>
    <p>A table is in Domain-Key Normal Form (DKNF) if every constraint on the table is a logical consequence of the domain constraints and key constraints. It goes beyond 5NF in ensuring that there are no constraints other than domain constraints and key constraints that can determine data validity. DKNF is considered the ultimate form of normalization, where all types of possible anomalies are eliminated. However, achieving DKNF can be difficult in practice, and it is rarely necessary or practical to normalize databases to this level.</p>
</article>

            <article id="denormalization">
                <h3>3. Denormalization</h3>
                <p>Denormalization is the process of trying to improve the read performance of a database by adding redundant data or by grouping data. It is the reverse process of normalization. In some cases, denormalization helps by reducing the number of joins.</p>
            </article>
            <article>
                <h4>3.1 Purpose of Denormalization</h4>
                <p>Denormalization is used to improve the performance of a database system, especially for read-heavy operations. By reducing the number of joins required to retrieve data, denormalization can speed up query processing and enhance the overall performance of the database.</p>
            </article>
            <article>
                <h4>3.2 Advantages of Denormalization</h4>
                <p>Denormalization offers several benefits, including:</p>
                <ul>
                    <li><strong>Improved Query Performance:</strong> Reduces the number of joins, leading to faster query execution.</li>
                    <li><strong>Enhanced Read Operations:</strong> Optimizes read-heavy operations by simplifying data retrieval.</li>
                    <li><strong>Reduced Complexity:</strong> Streamlines data access and retrieval processes, making the database more efficient.</li>
                </ul>
            </article>
            <article>
                <h4>3.3 Implementing Denormalization</h4>
                <p>Denormalization can be implemented by adding redundant data to tables, creating summary tables, or using materialized views. By strategically introducing redundancy, denormalization aims to optimize read performance without compromising data integrity.</p>
            </article>
            <article>
                <h4>3.4 Considerations for Denormalization</h4>
                <p>While denormalization can enhance query performance, it also introduces the risk of data inconsistency due to redundant data. Careful planning and monitoring are essential to ensure that denormalization does not compromise data integrity and that the benefits of improved performance outweigh the potential drawbacks.</p>
            </article>
            <article>
                <h4>3.5 Designing a Relational Database with Normalization</h4>
                <p>When designing a relational database, normalization plays a crucial role in structuring data. By applying normalization principles from the outset, database designers can create a logical and efficient schema that supports robust data integrity and facilitates easy data manipulation and retrieval. It involves analyzing the relationships between data entities and systematically organizing data into tables that minimize redundancy and dependency anomalies.</p>
            </article>

            </article>
            <article id="implementation">
                <h3>4. Implementation in SQL</h3>
                <p>To implement normalization, database designers need to understand the data usage patterns and structure the database accordingly. Here’s how a simple normalization process might look like in SQL for a hypothetical Employee Management System.</p>
                <article>
                    <h4>Normalization Process</h4>
                    <p>The process of normalization involves applying a series of rules or 'normal forms' to ensure that databases are structured optimally. Starting with the identification of functional dependencies, the process sequentially applies the criteria for each normal form, from 1NF to 3NF and beyond, as necessary. This methodical approach helps in grouping attributes into relations that minimize redundancy and dependency anomalies. By following these steps, database designers can achieve a well-structured database schema that facilitates data integrity and efficient data manipulation.</p>
                </article>
            </article>
            <article>
                <h4>4.1 Implementing 1NF</h4>
                <p>Assuming an 'Employees' table that violates 1NF because it contains a list of phone numbers for some employees:</p>
                <pre><code class="language-sql">CREATE TABLE Employees (
    EmployeeID INT PRIMARY KEY,
    Name VARCHAR(100),
    PhoneNumber VARCHAR(100)
);
</code></pre>
                <p>To conform to 1NF, we create a separate table for phone numbers:</p>
                <pre><code class="language-sql">CREATE TABLE PhoneNumbers (
    EmployeeID INT,
    PhoneNumber VARCHAR(100),
    FOREIGN KEY (EmployeeID) REFERENCES Employees(EmployeeID)
);
</code></pre>
            </article>
            <article>
                <h4>4.2 Achieving 2NF and 3NF</h4>
                <p>To achieve 2NF and 3NF, ensure that all non-key attributes are fully dependent on the primary key and that there are no transitive dependencies. If an 'EmployeeAddresses' table has an 'Address' column that depends on 'EmployeeID' but also on 'DepartmentID', we split the table to remove the transitive dependency:</p>
                <pre><code class="language-sql">CREATE TABLE Departments (
    DepartmentID INT PRIMARY KEY,
    Name VARCHAR(100)
);
CREATE TABLE EmployeeAddresses (
EmployeeID INT,
Address VARCHAR(255),
DepartmentID INT,
FOREIGN KEY (EmployeeID) REFERENCES Employees(EmployeeID),
FOREIGN KEY (DepartmentID) REFERENCES Departments(DepartmentID)
);
</code></pre>

            </article>
            <article>
                <h4>4.3 Implementing BCNF</h4>
                <p>Implementing BCNF typically involves more complex restructuring to ensure that every determinant is a candidate key. For a detailed example, one would need to look at specific cases where anomalies occur despite the table being in 3NF, then restructuring the database to eliminate these issues.</p>
            </article>

            <article>
                <h4>4.4 Problems with Non-normalized Relations</h4>
                <p>Relations that do not comply with the rules of 1NF, 2NF, or 3NF are prone to various issues. These include redundancy, which leads to unnecessary duplication of data; update anomalies, where changes to data in one place require changes to data in multiple places; insert anomalies, which can prevent the addition of new data without other required data; and delete anomalies, where the deletion of data in one place can unintentionally affect data in another. By adhering to normalization rules, these problems can be systematically avoided, ensuring a robust and efficient database design.</p>
            </article>

            <article>
                <h4>4.5 Lossless Joins and Dependency Preservation</h4>
                <p>Two important properties in the decomposition process of normalization are lossless joins and dependency preservation. The lossless-join property ensures that we can reconstruct the original relation from the decomposed smaller relations without losing information. This is crucial for maintaining the integrity and completeness of the database. On the other hand, the dependency preservation property ensures that constraints on the original relation can be enforced by applying constraints on each of the decomposed relations. This is essential for maintaining consistent data validation rules across the database, ensuring that all data adheres to the original constraints and business logic.</p>
            </article>

            <article>
                <h4>Representing Form Attributes as 3NF Relations</h4>
                <p>Converting attributes displayed on a form into 3NF relations involves analyzing the form to identify its entities, attributes, and the functional dependencies among them. This analysis helps in determining how to best structure the database tables to reflect the form's data while adhering to the principles of 3NF. By ensuring that each table represents a single concept without redundancy, and that there is no transitive dependency in any table, the data structure can efficiently support form processing and data integrity.</p>
            </article>
        </main>
        <script> copyright("all"); </script>
    </body>

</html>
