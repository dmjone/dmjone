<!-------------------------- ¬© 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>

        <meta name="author" content="Divya Mohan">
        <meta name="robots" content="index, follow">

        <!-- Open Graph for Social Media -->
        <meta property="og:image" content="/logo.png">
        <meta property="og:type" content="article">

        <!-- Twitter Cards -->
        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@divyamohan1993">
        <meta name="twitter:creator" content="@divyamohan1993">
        <meta name="twitter:image" content="/logo.png">

        <!-- Mobile Responsiveness -->
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">



        <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                renderMathInElement(document.body, {
                    // customised options
                    // ‚Ä¢ auto-render specific keys, e.g.:
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\(', right: '\\)', display: false },
                        { left: '\\[', right: '\\]', display: true }
                    ],
                    // ‚Ä¢ rendering keys, e.g.:
                    throwOnError: false
                });
            });
        </script> -->

        <!-- <style>
            main ul {
                list-style-type: none;
                padding: 0;
                margin: 0;
            }

            main ul li {
                margin: 0;
                padding: 0;
            }
        </style> -->
    </head>

    <body>

        <script> header_author("dm"); </script>

        <main>
            <article class="agen-tableofcontents">
                <h2 class="text-center">
                    Revision - Term 2
                </h2>
                <div class="d-none contentdate">2025, February 06</div>
            </article>

            <div class="mb-3 d-flex justify-content-center align-items-center">
                <a href="revision-term-2" class="btn btn-lg btn-outline-primary d-print-none">
                    <i class="bi bi-exclamation-triangle-fill me-2"></i> View Shorter Quicker Summary
                </a>
            </div>


            <article>
                <h3>Fundamental Issues in Software Design</h3>
                <p>Software design faces many challenges. These are called <strong>fundamental issues</strong>. Solving them helps build software that works well, is easy to use, and doesn‚Äôt crash.</p>
                
            </article>
            <article>
                <h3>1. <strong>Meeting User Requirements</h3>
                <ul>
                    <li>We must understand what users need and build the software accordingly.</li>
                    <li><strong>Example</strong>: If you make a doctor app but don‚Äôt include easy access to patient history, doctors won‚Äôt like it.</li>
                    <li><em>Why it matters</em>: If software doesn‚Äôt match user needs, nobody will use it.</li>
                </ul>
                
            </article>
            <article>
                <h3>2. <strong>Maintaining Simplicity</h3>
                <ul>
                    <li>The design should be simple and not overloaded with features.</li>
                    <li><strong>Example</strong>: A farming app with too many graphs will confuse farmers. Use simple charts.</li>
                    <li><em>Why it matters</em>: Complex software causes confusion and errors.</li>
                </ul>
                
            </article>
            <article>
                <h3>3. <strong>Scalability</h3>
                <ul>
                    <li>Software should handle more users and data as it grows.</li>
                    <li><strong>Example</strong>: An online shop should work fast even if 10,000 users visit together.</li>
                    <li><em>Why it matters</em>: Unscalable software becomes slow or crashes as users increase.</li>
                </ul>
                
            </article>
            <article>
                <h3>4. <strong>Performance</h3>
                <ul>
                    <li>The software should run fast and use less memory.</li>
                    <li><strong>Example</strong>: A video editor should render videos quickly, not take forever.</li>
                    <li><em>Why it matters</em>: Slow software makes users angry and they may stop using it.</li>
                </ul>
                
            </article>
            <article>
                <h3>5. <strong>Security</h3>
                <ul>
                    <li>Data should be safe from hackers.</li>
                    <li><strong>Example</strong>: Banking apps must protect money and private info from theft.</li>
                    <li><em>Why it matters</em>: Weak security can lead to hacking and user data loss.</li>
                </ul>
                
            </article>
            <article>
                <h3>6. <strong>Flexibility and Maintainability</h3>
                <ul>
                    <li>Software should be easy to update and fix.</li>
                    <li><strong>Example</strong>: If a clinic app wants to add video calls later, it should be easy to add.</li>
                    <li><em>Why it matters</em>: If software is hard to change, it becomes outdated.</li>
                </ul>
                
            </article>
            <article>
                <h3>7. <strong>Handling Errors and Failures</h3>
                <ul>
                    <li>Software should show helpful error messages and not crash.</li>
                    <li><strong>Example</strong>: If a user enters the wrong date in a flight app, it should say ‚ÄúInvalid date.‚Äù</li>
                    <li><em>Why it matters</em>: Good error handling keeps the app stable and easy to fix.</li>
                </ul>
                
            </article>
            <article>
                <h3>8. <strong>Usability</h3>
                <ul>
                    <li>Software should be easy to learn and use.</li>
                    <li><strong>Example</strong>: Hospital systems should be simple so even non-tech staff can use them.</li>
                    <li><em>Why it matters</em>: Hard-to-use software causes mistakes and wastes time.</li>
                </ul>
                
            </article>
            <article>
                <h3>9. <strong>Interoperability</h3>
                <ul>
                    <li>Software should work well with other software.</li>
                    <li><strong>Example</strong>: A hospital app should share data with other hospitals.</li>
                    <li><em>Why it matters</em>: If software can‚Äôt connect to others, it becomes less useful.</li>
                </ul>
                
            </article>
            <article>
                <h3>10. <strong>Cost and Time Management</h3>
                <ul>
                    <li>The software should be finished on time and within budget.</li>
                    <li><strong>Example</strong>: If a biotech app isn‚Äôt ready for a medical event, the company may lose money.</li>
                    <li><em>Why it matters</em>: Delays and overspending make the project stressful and waste resources.</li>
                </ul>
            </article>
            <article>
                <h3>Cohesion and Coupling</h3>
                <p>In software design, <strong>cohesion</strong> and <strong>coupling</strong> are two important concepts. They help us build software that is <strong>easy to understand, maintain, and update</strong>.</p>
                
            </article>
            <article>
                <h3>Cohesion</h3>
                <p>Cohesion means how well the things inside a module or class <strong>work together to do one clear task</strong>.</p>
                <h4><strong>High Cohesion</strong></h4>
                <ul>
                    <li>All parts of a module are related and do one job only. </li>
                    <li><strong>Good design</strong>: Easy to understand, reuse, and maintain. </li>
                    <li><strong>Example</strong>: <ul>
                            <li>Product Module ‚Üí manages product info </li>
                            <li>Cart Module ‚Üí adds/removes items </li>
                            <li>Payment Module ‚Üí handles payments </li>
                            <li>Account Module ‚Üí manages user login</li>
                        </ul>
                    </li>
                    <li>Each one focuses on its own job. That‚Äôs <strong>high cohesion</strong>.</li>
                </ul>
                <h4><strong>Low Cohesion</strong></h4>
                <ul>
                    <li>A module does <strong>many unrelated things</strong>. </li>
                    <li><strong>Bad design</strong>: Confusing, hard to fix. </li>
                    <li><strong>Example</strong>: <ul>
                            <li>If the Cart Module also handles login and user profile ‚Äî it's doing too much. That‚Äôs <strong>low cohesion</strong>.</li>
                        </ul>
                    </li>
                </ul>
                
            </article>
            <article>
                <h3>Coupling</h3>
                <p>Coupling means how much <strong>one module depends on another</strong>.</p>
                <h4><strong>Low Coupling</strong></h4>
                <ul>
                    <li>Modules are <strong>independent</strong> and use well-defined communication like APIs. </li>
                    <li><strong>Good design</strong>: You can change one module without affecting others. </li>
                    <li><strong>Example</strong>: <ul>
                            <li>You add PayPal in the payment module. </li>
                            <li>Since it‚Äôs separate, <strong>cart and product modules don‚Äôt need to change</strong>. </li>
                            <li>This is <strong>low coupling</strong>.</li>
                        </ul>
                    </li>
                </ul>
                <h4><strong>High Coupling</strong></h4>
                <ul>
                    <li>Modules are <strong>tightly connected</strong> and depend on each other. </li>
                    <li><strong>Bad design</strong>: Changing one module breaks the other. </li>
                    <li><strong>Example</strong>: <ul>
                            <li>If Cart Module contains payment logic, then updating payment affects the cart too. </li>
                            <li>This is <strong>high coupling</strong>.</li>
                        </ul>
                    </li>
                </ul>
                
            </article>
            <article>
                <h3>How They Work Together</h3>
                <ul>
                    <li>
                        <p><strong>High Cohesion + Low Coupling</strong> = Best design<br>Each part does one job and works independently.</p>
                    </li>
                    <li>
                        <p><strong>Low Cohesion + High Coupling</strong> = Worst design<br>Modules do too much and are too dependent on each other.</p>
                    </li>
                </ul>
                
            </article>
            <article>
                <h3>Real-Life Example: Amazon</h3>
                <ul>
                    <li>
                        <p><strong>High Cohesion</strong>: </p>
                        <ul>
                            <li>Product page only shows product info. </li>
                            <li>Cart handles only item selection. </li>
                            <li>Checkout handles only payment.</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Low Coupling</strong>: </p>
                        <ul>
                            <li>You can add new payment options without touching the product or cart modules.</li>
                        </ul>
                    </li>
                </ul>
                
            </article>
            <article>
                <h3>Benefits of High Cohesion &amp; Low Coupling</h3>
                <p>Easy to maintain<br>Easy to test and debug<br>Easy to reuse and update<br>Reduces bugs and confusion</p>
                
                <p>"Good software design aims for high cohesion and low coupling to keep systems clean, modular, and easy to work with."</p>
            </article>
            <article>
                <h3>Function-Oriented Design (FOD)</h3>
                <p>Function-Oriented Design is a way of designing software by <strong>dividing the system into small functions</strong>.<br>Each function does a specific job, and all functions work together to achieve the final goal.</p>
                
            </article>
            <article>
                <h3>General Steps</h3>
                <ol>
                    <li>Start by understanding <strong>what the software should do</strong>. </li>
                    <li>Break down high-level functions into <strong>smaller and detailed sub-functions</strong>.</li>
                </ol>
                
            </article>
            <article>
                <h3>Key Concepts</h3>
                <ol>
                    <li>
                        <p><strong>Divides Software into Functions</strong> </p>
                        <ul>
                            <li>Each function takes input, processes it, and gives output.</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Follows Top-Down Approach</strong> </p>
                        <ul>
                            <li>Start from the main function and break it into smaller parts.</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Uses Data Flow</strong> </p>
                        <ul>
                            <li>Data moves from one function to another. </li>
                            <li>Use <strong>Data Flow Diagrams (DFD)</strong> to show this.</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Focus on Processes, Not Objects</strong> </p>
                        <ul>
                            <li>Unlike Object-Oriented Design, FOD focuses on <strong>tasks</strong>, not classes or objects.</li>
                        </ul>
                    </li>
                </ol>
                
            </article>
            <article>
                <h3>Example: Online Library System</h3>
                <ul>
                    <li>
                        <p><strong>Main Function</strong>: Library System </p>
                    </li>
                    <li>
                        <p><strong>Sub-Functions</strong>:</p>
                        <ul>
                            <li>User Management (register, login)</li>
                            <li>Book Management (add, update, delete)</li>
                            <li>Search Books (by title, author)</li>
                            <li>Borrow/Return Books</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Further Sub-functions</strong>:</p>
                        <ul>
                            <li><code>registerUser()</code>, <code>loginUser()</code></li>
                            <li><code>addBook()</code>, <code>deleteBook()</code></li>
                        </ul>
                    </li>
                </ul>
                
            </article>
            <article>
                <h3>Advantages of FOD</h3>
                <p>Easy to understand<br>Works well for small to medium projects<br>Functions can be reused</p>
                
            </article>
            <article>
                <h3>Disadvantages of FOD</h3>
                <p>Not good for complex systems<br>Difficult to update ‚Äî one change can affect many functions<br>Less secure ‚Äî data is shared between many functions</p>
                
            </article>
            <article>
                <h3>FOD Strategies</h3>
                <h4><strong>Data Flow Diagrams (DFD)</strong></h4>
                <ul>
                    <li>Show <strong>how data moves</strong> through the system. </li>
                    <li>Track how input turns into output using functions.</li>
                </ul>
                <h5><strong>Types of DFD</strong></h5>
                <ul>
                    <li><strong>Logical DFD</strong>: Focuses on <em>what</em> the system does. </li>
                    <li><strong>Physical DFD</strong>: Shows <em>how</em> the system is actually built.</li>
                </ul>
                
            </article>
            <article>
                <h3>DFD Components</h3>
                <ul>
                    <li><strong>Entity</strong>: Source or destination of data (üì¶ Rectangle) </li>
                    <li><strong>Process</strong>: Activity performed on data (‚≠ï Circle) </li>
                    <li><strong>Data Store</strong>: Where data is kept (üü´ Open rectangle) </li>
                    <li><strong>Data Flow</strong>: Arrows showing data movement (‚û°Ô∏è)</li>
                </ul>
                
            </article>
            <article>
                <h3>DFD Levels</h3>
                <ul>
                    <li><strong>Level 0 (Context DFD)</strong>: Shows whole system as one process </li>
                    <li><strong>Level 1</strong>: Breaks system into major modules </li>
                    <li><strong>Level 2</strong>: Shows detailed data flow inside each module</li>
                </ul>
                
            </article>
            <article>
                <h3>Rules for DFD</h3>
                <ol>
                    <li>Every process must have at least one input and one output </li>
                    <li>Data stores must have at least one incoming and one outgoing flow </li>
                    <li>All flows go between a process, data store, or entity ‚Äî <strong>no direct data store to entity</strong></li>
                </ol>
                
            </article>
            <article>
                <h3>Data Dictionary</h3>
                <ul>
                    <li>A <strong>data dictionary</strong> stores <strong>info about data items</strong> used in DFDs. </li>
                    <li>It tells <strong>what data is used, where, and how</strong>.</li>
                </ul>
                <h4><strong>What it stores</strong> (Metadata):</h4>
                <ul>
                    <li>Column names </li>
                    <li>Data types </li>
                    <li>Size </li>
                    <li>Description</li>
                </ul>
                <p><strong>Example Table:</strong></p>
                <table class="table tablt-striped table-bordered">
                    <thead>
                        <tr>
                            <th>Student ID</th>
                            <th>Name</th>
                            <th>Father_Name</th>
                            <th>Course</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>101</td>
                            <td>Jack</td>
                            <td>Abc</td>
                            <td>M.Tech</td>
                        </tr>
                        <tr>
                            <td>102</td>
                            <td>Jerry</td>
                            <td>Xyz</td>
                            <td>MCA</td>
                        </tr>
                    </tbody>
                </table>
                <p><strong>Metadata Example:</strong></p>
                <table class="table tablt-striped table-bordered">
                    <thead>
                        <tr>
                            <th>Attribute</th>
                            <th>Data Type</th>
                            <th>Size</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Student ID</td>
                            <td>int</td>
                            <td>03</td>
                            <td>Student's ID</td>
                        </tr>
                        <tr>
                            <td>Name</td>
                            <td>string</td>
                            <td>20</td>
                            <td>Student's Name</td>
                        </tr>
                        <tr>
                            <td>Father_Name</td>
                            <td>string</td>
                            <td>20</td>
                            <td>Father's Name</td>
                        </tr>
                        <tr>
                            <td>Course</td>
                            <td>varchar</td>
                            <td>10</td>
                            <td>Course Name</td>
                        </tr>
                    </tbody>
                </table>
                
            </article>
            <article>
                <h3>Types of Data Dictionary</h3>
                <h4><strong>Active Data Dictionary</strong></h4>
                <ul>
                    <li>Updates automatically when the database changes </li>
                    <li>Maintained by the database system</li>
                </ul>
                <h4><strong>Passive Data Dictionary</strong></h4>
                <ul>
                    <li>Must be updated <strong>manually</strong> </li>
                    <li>Needs careful handling</li>
                </ul>
            </article>
            <article>
                <h3>Structured Analysis and Structured Design</h3>
                <p>Structured Analysis and Design is a <strong>step-by-step method</strong> to build a system by <strong>breaking it down into smaller parts</strong> using diagrams and logical models.</p>
                
            </article>
            <article>
                <h3>Structured Analysis</h3>
                <p>It focuses on <strong>what the system should do</strong>.
                    It helps understand the current system and define new requirements.</p>
                <h4><strong>Tools Used in Analysis Phase</strong></h4>
                <ul>
                    <li><strong>DFD (Data Flow Diagram)</strong>: Shows how data moves in the system</li>
                    <li><strong>Data Dictionary</strong>: Defines data types and attributes</li>
                    <li><strong>ER Diagram</strong>: Shows relationships between entities (like student‚Äìcourse)</li>
                    <li><strong>Decision Trees / Tables</strong>: Shows decision rules clearly</li>
                    <li><strong>State Transition Diagram</strong>: Shows how system reacts to changes</li>
                    <li><strong>Process Specification (PSPEC)</strong>: Explains logic of each process</li>
                </ul>
                
            </article>
            <article>
                <h3>Structured Design</h3>
                <p>It focuses on <strong>how the system will be built</strong>.
                    It converts analysis into an implementation-ready design.</p>
                <h4><strong>Key Design Elements</strong></h4>
                <ul>
                    <li><strong>Modular Design</strong>: Break system into modules with <strong>high cohesion</strong> and <strong>low coupling</strong></li>
                    <li><strong>Structure Chart</strong>: Shows how modules interact (like a tree)</li>
                    <li><strong>Interface Design</strong>: Focuses on UI/UX and how users interact</li>
                    <li><strong>Database Design</strong>: Tables, relationships, and normalization</li>
                    <li><strong>Control Flow</strong>: How processes and decisions are handled</li>
                </ul>
                
            </article>
            <article>
                <h3>Objectives of Structured Analysis &amp; Design</h3>
                <ul>
                    <li>Understand user needs clearly</li>
                    <li>Break system into smaller parts</li>
                    <li>Define relationships between parts</li>
                    <li>Ensure consistency and completeness</li>
                    <li>Improve communication</li>
                    <li>Support future growth (scalability)</li>
                </ul>
                
            </article>
            <article>
                <h3>Advantages</h3>
                <p>Clear understanding using diagrams
                    Easy to update due to modular structure
                    Better teamwork and communication
                    Efficient use of resources
                    Easy to scale in future</p>
                
            </article>
            <article>
                <h3>Disadvantages</h3>
                <p>Takes more time and documentation
                    Hard to change later (rigid)
                    Not good for fast/agile development</p>
                
                <p>:
                    <strong>"Structured Analysis and Design is best for large, clear projects where detailed planning, logical structure, and good documentation are needed."</strong>
                </p>
            </article>
            <article>
                <h3>UML (Unified Modeling Language)</h3>
                <p>UML is a <strong>visual language</strong> used to <strong>draw diagrams</strong> that show how a software system is designed.</p>
                <ul>
                    <li>UML is <strong>not a programming language</strong> ‚Äî it helps in <strong>understanding and planning</strong> before coding.</li>
                    <li>It is a <strong>standard method</strong>, approved by ISO, used by developers, analysts, and clients.</li>
                    <li>UML helps both <strong>technical</strong> and <strong>non-technical people</strong> understand the system easily.</li>
                </ul>
                
            </article>
            <article>
                <h3>Why UML is Needed</h3>
                <p>Complex systems need clear planning<br>Non-programmers (like clients or managers) can understand the design<br>Saves time by allowing <strong>visual communication and planning</strong></p>
                
            </article>
            <article>
                <h3>Major UML Diagrams (Most Important)</h3>
                <h4>1. <strong>Class Diagram</strong></h4>
                <ul>
                    <li>Shows system‚Äôs <strong>classes, attributes, methods</strong>, and how they‚Äôre related. </li>
                    <li><strong>Most commonly used</strong> in object-oriented design. </li>
                    <li>Example: Classes like <code>User</code>, <code>Post</code>, <code>Comment</code> in a social media site.</li>
                </ul>
                <h4>2. <strong>Use Case Diagram</strong></h4>
                <ul>
                    <li>Shows what <strong>users (actors)</strong> can do with the system. </li>
                    <li>Captures <strong>functional requirements</strong>. </li>
                    <li>Example: In an e-commerce site ‚Äì Browse, Add to Cart, Checkout.</li>
                </ul>
                <h4>3. <strong>Sequence Diagram</strong></h4>
                <ul>
                    <li>Shows how <strong>objects interact over time</strong> in a scenario. </li>
                    <li>Example: Steps of transferring money in a banking app.</li>
                </ul>
                <h4>4. <strong>Activity Diagram</strong></h4>
                <ul>
                    <li>Like a <strong>flowchart</strong>. Shows the <strong>step-by-step process</strong> or workflow. </li>
                    <li>Example: Login process ‚Äì Enter ID ‚Üí Password ‚Üí Authenticate ‚Üí Grant Access.</li>
                </ul>
                
            </article>
            <article>
                <h3>Object-Oriented Concepts Used in UML</h3>
                <ol>
                    <li><strong>Class</strong>: Blueprint of an object </li>
                    <li><strong>Object</strong>: A real-world instance of a class </li>
                    <li><strong>Inheritance</strong>: Child class inherits features from parent </li>
                    <li><strong>Abstraction</strong>: Shows only important details </li>
                    <li><strong>Encapsulation</strong>: Keeps data safe inside the object </li>
                    <li><strong>Polymorphism</strong>: One function behaves differently based on context</li>
                </ol>
                
            </article>
            <article>
                <h3>Tools for Drawing UML Diagrams</h3>
                <ul>
                    <li><strong>Lucidchart</strong> ‚Äì Easy and collaborative </li>
                    <li><strong>Draw.io</strong> ‚Äì Free and works online/offline </li>
                    <li><strong>Visual Paradigm</strong> ‚Äì Full-featured with templates </li>
                    <li><strong>StarUML</strong> ‚Äì Open-source and customizable</li>
                </ul>
                
                <p> "UML helps visualize, plan, and communicate software designs clearly, making development easier for both programmers and non-programmers."</p>
            </article>
            <article>
                <h3>User Interface (UI) Design</h3>
                <p>User Interface Design means <strong>creating the screens and controls</strong> through which the <strong>user interacts with the software</strong>.</p>
                <p>A good UI should be:</p>
                <ul>
                    <li><strong>Attractive</strong></li>
                    <li><strong>Simple to use</strong></li>
                    <li><strong>Quick to respond</strong></li>
                    <li><strong>Easy to understand</strong></li>
                    <li><strong>Consistent on all screens</strong></li>
                </ul>
                
            </article>
            <article>
                <h3>UI Design Principles</h3>
                <ol>
                    <li><strong>Structure</strong> ‚Äì Organize info clearly </li>
                    <li><strong>Simplicity</strong> ‚Äì Keep interface easy and clean </li>
                    <li><strong>Visibility</strong> ‚Äì Show important options clearly </li>
                    <li><strong>Feedback</strong> ‚Äì Inform users of actions (like loading, errors) </li>
                    <li><strong>Tolerance</strong> ‚Äì Allow easy error correction and undo options</li>
                </ol>
                
            </article>
            <article>
                <h3>UI Design Process</h3>
                <h4><strong>Phase 1: User, Task, and Environment Analysis</strong></h4>
                <ul>
                    <li>Understand <strong>who</strong> will use the system </li>
                    <li>Study their <strong>skills, knowledge, and needs</strong> </li>
                    <li>Group users based on their profile</li>
                </ul>
                <h4><strong>Phase 2: Interface Design</strong></h4>
                <ul>
                    <li>Identify <strong>tasks users need to do</strong> </li>
                    <li>Define <strong>objects and actions</strong> for those tasks </li>
                    <li>Plan how users will interact with the interface</li>
                </ul>
                <h4><strong>Phase 3: Interface Construction</strong></h4>
                <ul>
                    <li>Build a <strong>prototype (sample UI)</strong> </li>
                    <li>Use it to test <strong>real-world usability</strong> </li>
                    <li>Keep improving the UI until it's approved</li>
                </ul>
                <h4><strong>Phase 4: Interface Validation</strong></h4>
                <ul>
                    <li>Test if UI works correctly for all tasks </li>
                    <li>Check it handles <strong>real-world use cases and variations</strong></li>
                </ul>
                
                <p>"A well-designed UI improves user satisfaction, increases productivity, and reduces errors in software usage."</p>
            </article>




        </main>

        <script> copyright("all"); </script>

    </body>

</html>