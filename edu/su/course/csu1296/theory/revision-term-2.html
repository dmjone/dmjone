<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>

        <meta name="author" content="Divya Mohan">
        <meta name="robots" content="index, follow">

        <!-- Open Graph for Social Media -->
        <meta property="og:image" content="/logo.png">
        <meta property="og:type" content="article">

        <!-- Twitter Cards -->
        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@divyamohan1993">
        <meta name="twitter:creator" content="@divyamohan1993">
        <meta name="twitter:image" content="/logo.png">

        <!-- Mobile Responsiveness -->
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        

        <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                renderMathInElement(document.body, {
                    // customised options
                    // • auto-render specific keys, e.g.:
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\(', right: '\\)', display: false },
                        { left: '\\[', right: '\\]', display: true }
                    ],
                    // • rendering keys, e.g.:
                    throwOnError: false
                });
            });
        </script> -->

        <!-- <style>
            main ul {
                list-style-type: none;
                padding: 0;
                margin: 0;
            }

            main ul li {
                margin: 0;
                padding: 0;
            }
        </style> -->
    </head>

    <body>

        <script> header_author("dm"); </script>

        <main>
            <article class="agen-tableofcontents">
                <h2 class="text-center">
                    Revision - Term 2
                </h2>
                <div class="d-none contentdate">2025, February 06</div>
            </article>

            <main>
            
            
            
            
            
                <article>
                    <h2>1-Min Overview</h2>
                    <blockquote>
                        <p>These are the <strong>main challenges</strong> a developer faces when designing software.
                            If not handled well, software becomes slow, insecure, confusing, or useless.</p>
                    </blockquote>
                    
                </article>
                <article>
                    <h2>11 Fundamental Issues (Learn with Real-Life Examples)</h2>
                </article>
                <article>
                    <h3>1. Meeting User Requirements</h3>
                    <ul>
                        <li>Understand what users <strong>actually need</strong>.
                            <em>E.g., A doctor’s app must show patient history clearly or it’s useless.</em>
                        </li>
                    </ul>
                    
                </article>
                <article>
                    <h3>2. Maintaining Simplicity</h3>
                    <ul>
                        <li><strong>Don’t overcomplicate</strong> the design.
                            <em>Farmers need easy graphs, not confusing dashboards.</em>
                        </li>
                    </ul>
                    
                </article>
                <article>
                    <h3>3. Scalability</h3>
                    <ul>
                        <li>Can the system <strong>handle more users or data</strong> in the future?
                            <em>E-commerce site built for 100 users may fail at 10,000 if not scalable.</em>
                        </li>
                    </ul>
                    
                </article>
                <article>
                    <h3>4. Performance</h3>
                    <ul>
                        <li>Should run <strong>fast</strong> and <strong>efficiently</strong>.
                            <em>Video editing app must render videos quickly.</em>
                        </li>
                    </ul>
                    
                </article>
                <article>
                    <h3>5. Security</h3>
                    <ul>
                        <li>Protect <strong>data and access</strong> from unauthorized users.
                            <em>Banking app must secure account info from hackers.</em>
                        </li>
                    </ul>
                    
                </article>
                <article>
                    <h3>6. Flexibility &amp; Maintainability</h3>
                    <ul>
                        <li>Easy to <strong>update</strong> or <strong>fix bugs</strong>.
                            <em>Clinic app should easily add online consultation features later.</em>
                        </li>
                    </ul>
                    
                </article>
                <article>
                    <h3>7. Error Handling</h3>
                    <ul>
                        <li>Handle mistakes <strong>gracefully</strong>, not with crashes.
                            <em>Booking system should show "Invalid date" instead of crashing.</em>
                        </li>
                    </ul>
                    
                </article>
                <article>
                    <h3>8. Usability</h3>
                    <ul>
                        <li>Easy to use, even for <strong>non-tech users</strong>.
                            <em>Hospital software should be nurse-friendly.</em>
                        </li>
                    </ul>
                    
                </article>
                <article>
                    <h3>9. Interoperability</h3>
                    <ul>
                        <li>Must <strong>work with other systems</strong>.
                            <em>Hospital software should share patient data with other hospitals.</em>
                        </li>
                    </ul>
                    
                </article>
                <article>
                    <h3>10. Cost and Time Management</h3>
                    <ul>
                        <li>Stay <strong>within budget and deadlines</strong>.
                            <em>Biotech app must be ready before a medical conference.</em>
                        </li>
                    </ul>
                    
                </article>
                <article>
                    <h2>Sample 5-Mark Answer</h2>
                    <blockquote>
                        <p><strong>Q: Explain any 5 fundamental issues in software design.</strong>
                            A:</p>
                        <ol>
                            <li><strong>Meeting User Requirements</strong> – The software must fulfill the actual needs of users.</li>
                            <li><strong>Simplicity</strong> – Simple design helps reduce confusion and errors.</li>
                            <li><strong>Scalability</strong> – Software should handle increasing users/data without crashing.</li>
                            <li><strong>Security</strong> – Sensitive data must be protected from unauthorized access.</li>
                            <li><strong>Maintainability</strong> – Software must be easy to update and fix when needed.</li>
                        </ol>
                    </blockquote>
                    
                </article>
                <article>
                    <h2>Flash Quiz</h2>
                    <ol>
                        <li>Software should be easy to update → <strong>Maintainability</strong></li>
                        <li>Sharing data with other systems → <strong>Interoperability</strong></li>
                        <li>“Invalid date” instead of crash → <strong>Error Handling</strong></li>
                        <li>App slows down with more users → Poor <strong>Scalability</strong></li>
                        <li>Simple design helps avoid confusion → <strong>Simplicity</strong></li>
                        <li>Software must fulfill actual user needs → <strong>Meeting User Requirements</strong></li>
                    </ol>
                </article>
                <article>
                    <h2>1-Minute Overview</h2>
                    <table class="table table-bordered table-striped">
                        <thead>
                            <tr>
                                <th>Concept</th>
                                <th>Meaning</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Cohesion</strong></td>
                                <td>How <strong>focused</strong> a module is on a single task</td>
                            </tr>
                            <tr>
                                <td><strong>Coupling</strong></td>
                                <td>How <strong>dependent</strong> a module is on other modules</td>
                            </tr>
                        </tbody>
                    </table>
                    <p><strong>High Cohesion</strong> + <strong>Low Coupling</strong> = Perfect software design
                        <strong>Low Cohesion</strong> + <strong>High Coupling</strong> = Confusing, buggy design
                    </p>
                    
                </article>
                <article>
                    <h2>COHESION (Stick together = One clear job)</h2>
                </article>
                <article>
                    <h3>Definition:</h3>
                    <blockquote>
                        <p>How tightly the parts of a single module/class <strong>work together</strong> to do <strong>one job</strong>.</p>
                    </blockquote>
                </article>
                <article>
                    <h3>High Cohesion (GOOD):</h3>
                    <ul>
                        <li>One module = One task</li>
                        <li>Easy to understand</li>
                        <li>Easy to test and reuse</li>
                        <li>Changes don't affect unrelated code</li>
                    </ul>
                    <p>Example:
                        A <strong>Shopping Cart</strong> module that only handles cart tasks like add/remove/view items.</p>
                    
                </article>
                <article>
                    <h3>Low Cohesion (BAD):</h3>
                    <ul>
                        <li>Module tries to do <strong>too many unrelated things</strong></li>
                        <li>Difficult to maintain or update</li>
                    </ul>
                    <p>Example:
                        A <strong>Cart</strong> module that also handles login, payments, and product listings.</p>
                    
                </article>
                <article>
                    <h2>COUPLING (Link = Dependency between modules)</h2>
                </article>
                <article>
                    <h3>Definition:</h3>
                    <blockquote>
                        <p>How much one module depends on another to work.</p>
                    </blockquote>
                </article>
                <article>
                    <h3>Low Coupling (GOOD):</h3>
                    <ul>
                        <li>Modules are <strong>independent</strong></li>
                        <li>Easy to update/replace modules</li>
                        <li>Ideal in large systems</li>
                    </ul>
                    <p>Example:
                        <strong>Payment Module</strong> and <strong>Cart Module</strong> communicate via API. You can update payment logic without changing the cart.
                    </p>
                    
                </article>
                <article>
                    <h3>High Coupling (BAD):</h3>
                    <ul>
                        <li>Modules are tightly connected</li>
                        <li>Changing one breaks the other</li>
                        <li>Debugging becomes harder</li>
                    </ul>
                    <p>Example:
                        <strong>Cart</strong> directly handles payment logic like credit card validation, so if payment rules change, cart must change too.
                    </p>
                    
                </article>
                <article>
                    <h2>How They Work Together</h2>
                    <table class="table table-bordered table-striped">
                        <thead>
                            <tr>
                                <th>Combo</th>
                                <th>Effect</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>High Cohesion + Low Coupling</td>
                                <td>Best Design (modular, maintainable, flexible)</td>
                            </tr>
                            <tr>
                                <td>Low Cohesion + High Coupling</td>
                                <td>Worst Design (spaghetti code, high risk of bugs)</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Think:</p>
                    <blockquote>
                        <p>Clean rooms in separate houses (low coupling) doing just their own job (high cohesion).</p>
                    </blockquote>
                    
                </article>
                <article>
                    <h2>Real-Life Example: <strong>Amazon</strong></h2>
                    <table class="table table-bordered table-striped">
                        <thead>
                            <tr>
                                <th>Part</th>
                                <th>Cohesion</th>
                                <th>Coupling</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Product Page</td>
                                <td>High: Only shows product details</td>
                                <td>Low: Doesn’t handle checkout</td>
                            </tr>
                            <tr>
                                <td>Cart</td>
                                <td>High: Only adds/removes items</td>
                                <td>Low: Doesn’t know payment details</td>
                            </tr>
                            <tr>
                                <td>Payment</td>
                                <td>High: Only does transactions</td>
                                <td>Low: Doesn’t know product logic</td>
                            </tr>
                        </tbody>
                    </table>
                    
                </article>
                <article>
                    <h2>Sample 5-Mark Answer</h2>
                    <blockquote>
                        <p><strong>Q: What are Cohesion and Coupling? Explain with examples.</strong>
                            A:</p>
                        <ul>
                            <li><strong>Cohesion</strong> is how focused a module is on doing one task. High cohesion makes modules easier to maintain and reuse.</li>
                            <li><strong>Coupling</strong> is how much one module depends on another. Low coupling allows changes in one module without affecting others.</li>
                            <li>Example: In an e-commerce website, the <strong>Cart module</strong> with high cohesion only manages cart items. It communicates with the <strong>Payment module</strong> through APIs, showing low coupling. This makes the system flexible and easy to modify.</li>
                        </ul>
                    </blockquote>
                    
                </article>
                <article>
                    <h2>Flash Quiz (Last-Min Prep)</h2>
                    <ol>
                        <li>Good design = (dash) → <strong>High Cohesion, Low Coupling</strong></li>
                        <li>Cohesion is → <strong>How tightly tasks in a module relate</strong></li>
                        <li>Coupling is → <strong>How much modules depend on each other</strong></li>
                        <li>Cart + Payment using API = (dash) → <strong>Low Coupling</strong></li>
                        <li>One module, one job = (dash) → <strong>High Cohesion</strong></li>
                        <li>Spaghetti code = (dash) → <strong>Low Cohesion + High Coupling</strong></li>
                        <li>Amazon product page = (dash) → <strong>High Cohesion, Low Coupling</strong></li>
                    </ol>
                </article>
                <article>
                    <h2>1-Min Overview: What is Function-Oriented Design?</h2>
                    <blockquote>
                        <p>A design method where <strong>software is divided into small functions</strong>, each doing a specific task.</p>
                    </blockquote>
                    <ul>
                        <li>Focus is on <strong>what the system should do</strong> (functions), not on objects.</li>
                        <li>Uses a <strong>top-down</strong> design approach.</li>
                        <li>Helps in <strong>breaking large systems into manageable tasks</strong>.</li>
                    </ul>
                    
                </article>
                <article>
                    <h2>General Procedure (Very Short Answer Style)</h2>
                    <ol>
                        <li><strong>Start with what the system does</strong> </li>
                        <li><strong>Break it into high-level functions</strong></li>
                        <li><strong>Break those into smaller sub-functions</strong></li>
                        <li><strong>Connect them using data flow</strong></li>
                    </ol>
                    
                </article>
                <article>
                    <h2>Key Concepts (Must Memorize)</h2>
                    <table class="table table-bordered table-striped">
                        <thead>
                            <tr>
                                <th>Concept</th>
                                <th>Explanation</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Divides system into <strong>functions</strong></td>
                                <td>Each function = 1 task (like login, search)</td>
                            </tr>
                            <tr>
                                <td>Follows <strong>top-down approach</strong></td>
                                <td>Main → sub-function → sub-sub function</td>
                            </tr>
                            <tr>
                                <td>Uses <strong>Data Flow Diagrams (DFDs)</strong></td>
                                <td>Shows how data moves from one function to another</td>
                            </tr>
                            <tr>
                                <td>Focus on <strong>processes</strong>, not objects</td>
                                <td>Opposite of Object-Oriented Design</td>
                            </tr>
                        </tbody>
                    </table>
                    
                </article>
                <article>
                    <h2>Example: Online Library System</h2>
                    <table class="table table-bordered table-striped">
                        <thead>
                            <tr>
                                <th>Level</th>
                                <th>Function</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Main Function</td>
                                <td><code>LibrarySystem()</code></td>
                            </tr>
                            <tr>
                                <td>Sub-Functions</td>
                                <td><code>UserManagement()</code>, <code>BookManagement()</code></td>
                            </tr>
                            <tr>
                                <td>Further Break</td>
                                <td><code>registerUser()</code>, <code>loginUser()</code>, <code>addBook()</code></td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Think: Just keep dividing till each function is easy to implement.</p>
                    
                </article>
                <article>
                    <h2>Advantages</h2>
                    <ul>
                        <li>Easy to Understand </li>
                        <li>Reusable Functions </li>
                        <li>Good for Small/Medium Projects</li>
                    </ul>
                    
                </article>
                <article>
                    <h2>Disadvantages</h2>
                    <ul>
                        <li>Not good for large/complex systems </li>
                        <li>Hard to maintain/modify </li>
                        <li>Less secure (data shared across functions)</li>
                    </ul>
                    
                </article>
                <article>
                    <h2>Design Strategies in FOD</h2>
                    <table class="table table-bordered table-striped">
                        <thead>
                            <tr>
                                <th>Tool</th>
                                <th>Use</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>DFD</strong></td>
                                <td>Shows flow of data between functions</td>
                            </tr>
                            <tr>
                                <td><strong>Data Dictionary</strong></td>
                                <td>Details about data elements</td>
                            </tr>
                            <tr>
                                <td><strong>Pseudo Code</strong></td>
                                <td>Simple code logic in English</td>
                            </tr>
                            <tr>
                                <td><strong>Structure Chart</strong></td>
                                <td>Shows function hierarchy and interaction</td>
                            </tr>
                        </tbody>
                    </table>
                    
                </article>
                <article>
                    <h2>DFD (Data Flow Diagram) – Most Important</h2>
                </article>
                <article>
                    <h3>Components:</h3>
                    <table class="table table-bordered table-striped">
                        <thead>
                            <tr>
                                <th>Symbol</th>
                                <th>Meaning</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Circle</td>
                                <td>Process (e.g., “Login”)</td>
                            </tr>
                            <tr>
                                <td>Rectangle</td>
                                <td>Entity (e.g., “User”)</td>
                            </tr>
                            <tr>
                                <td>Open rectangle</td>
                                <td>Data Store</td>
                            </tr>
                            <tr>
                                <td>Arrow</td>
                                <td>Data Flow</td>
                            </tr>
                        </tbody>
                    </table>
                </article>
                <article>
                    <h3>DFD Levels:</h3>
                    <table class="table table-bordered table-striped">
                        <thead>
                            <tr>
                                <th>Level</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Level 0</strong></td>
                                <td>Big Picture (Context Level)</td>
                            </tr>
                            <tr>
                                <td><strong>Level 1</strong></td>
                                <td>Breaks big system into main functions</td>
                            </tr>
                            <tr>
                                <td><strong>Level 2</strong></td>
                                <td>Breaks main functions into smaller processes</td>
                            </tr>
                        </tbody>
                    </table>
                    
                </article>
                <article>
                    <h2>Data Dictionary</h2>
                    <blockquote>
                        <p>Think: Data <strong>about</strong> data</p>
                    </blockquote>
                </article>
                <article>
                    <h3>Example:</h3>
                    <table class="table table-bordered table-striped">
                        <thead>
                            <tr>
                                <th>Field</th>
                                <th>Type</th>
                                <th>Size</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>StudentID</td>
                                <td>Int</td>
                                <td>3</td>
                                <td>Unique ID of student</td>
                            </tr>
                            <tr>
                                <td>Name</td>
                                <td>String</td>
                                <td>20</td>
                                <td>Name of student</td>
                            </tr>
                        </tbody>
                    </table>
                </article>
                <article>
                    <h3>Types:</h3>
                    <table class="table table-bordered table-striped">
                        <thead>
                            <tr>
                                <th>Type</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Active</strong></td>
                                <td>Auto-updated with DB changes</td>
                            </tr>
                            <tr>
                                <td><strong>Passive</strong></td>
                                <td>Manually updated</td>
                            </tr>
                        </tbody>
                    </table>
                    
                </article>
                <article>
                    <h2>Sample 5-Mark Answer</h2>
                    <blockquote>
                        <p><strong>Q: Explain Function-Oriented Design with its tools.</strong><br>A: Function-Oriented Design divides the system into small functions using a top-down approach. It focuses on processes and data flow. Tools used include Data Flow Diagrams (DFDs) to represent data movement, Data Dictionaries for storing metadata, Pseudo Code for process logic, and Structure Charts for hierarchy. This design is simple and reusable but less suitable for large or complex systems.</p>
                    </blockquote>
                    
                </article>
                <article>
                    <h2>Flash Quiz</h2>
                    <ol>
                        <li>FOD focuses on → <strong>Functions</strong></li>
                        <li>DFD shows → <strong>Data Flow</strong></li>
                        <li>Top-level DFD is → <strong>Level 0</strong></li>
                        <li>Data Dictionary stores → <strong>Metadata</strong></li>
                        <li>Opposite of Function-Oriented Design is → <strong>Object-Oriented Design</strong></li>
                    </ol>
                </article>
                <article>
                    <h2>1-Min Summary</h2>
                    <table class="table table-bordered table-striped">
                        <thead>
                            <tr>
                                <th>Term</th>
                                <th>Meaning</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Structured Analysis</strong></td>
                                <td>Understand what the system should do (requirements)</td>
                            </tr>
                            <tr>
                                <td><strong>Structured Design</strong></td>
                                <td>Decide how the system will be built (design modules, UI, database, etc.)</td>
                            </tr>
                        </tbody>
                    </table>
                    <p><strong>Think like this:</strong> </p>
                    <blockquote>
                        <p>First → Analyze what the user wants (Structured Analysis)<br>Then → Design how to build it (Structured Design)</p>
                    </blockquote>
                    
                </article>
                <article>
                    <h2>Objectives of Structured Analysis &amp; Design (Easy 5-mark Question)</h2>
                    <table class="table table-bordered table-striped">
                        <thead>
                            <tr>
                                <th>Purpose</th>
                                <th>Meaning</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Understand Requirements</td>
                                <td>Know exactly what user needs</td>
                            </tr>
                            <tr>
                                <td>Break Down System</td>
                                <td>Divide system into small, manageable parts</td>
                            </tr>
                            <tr>
                                <td>Define Relationships</td>
                                <td>Connect components logically</td>
                            </tr>
                            <tr>
                                <td>Ensure Completeness</td>
                                <td>Nothing should be left or repeated</td>
                            </tr>
                            <tr>
                                <td>Improve Communication</td>
                                <td>Helps devs and clients understand each other</td>
                            </tr>
                            <tr>
                                <td>Enable Scalability &amp; Maintainability</td>
                                <td>Easier to grow and fix the system later</td>
                            </tr>
                        </tbody>
                    </table>
                    
                </article>
                <article>
                    <h2>Structured Analysis Phase: (What the system should do)</h2>
                </article>
                <article>
                    <h3>Focus: <strong>Understand user’s needs + system behavior</strong></h3>
                </article>
                <article>
                    <h3>Tools Used:</h3>
                    <table class="table table-bordered table-striped">
                        <thead>
                            <tr>
                                <th>Tool</th>
                                <th>Purpose</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Data Flow Diagram (DFD)</strong></td>
                                <td>Shows flow of data (input → process → output)</td>
                            </tr>
                            <tr>
                                <td><strong>Entity-Relationship Diagram (ERD)</strong></td>
                                <td>Shows tables/entities and relationships</td>
                            </tr>
                            <tr>
                                <td><strong>Process Specification (PSPEC)</strong></td>
                                <td>Explains process logic using simple language or flowcharts</td>
                            </tr>
                            <tr>
                                <td><strong>Data Dictionary</strong></td>
                                <td>Explains every data field (e.g., <code>StudentID: Integer</code>)</td>
                            </tr>
                            <tr>
                                <td><strong>Decision Trees / Tables</strong></td>
                                <td>Shows logic or choices made by system</td>
                            </tr>
                            <tr>
                                <td><strong>State Transition Diagrams</strong></td>
                                <td>Shows states and transitions (e.g., Login → Logged In)</td>
                            </tr>
                        </tbody>
                    </table>
                    
                </article>
                <article>
                    <h2>Structured Design Phase: (How the system will work)</h2>
                </article>
                <article>
                    <h3>Focus: <strong>Convert analysis into working design</strong></h3>
                </article>
                <article>
                    <h3>Techniques Used:</h3>
                    <table class="table table-bordered table-striped">
                        <thead>
                            <tr>
                                <th>Component</th>
                                <th>Meaning</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Modular Design</strong></td>
                                <td>Divide system into <strong>modules</strong> with <strong>low coupling, high cohesion</strong></td>
                            </tr>
                            <tr>
                                <td><strong>Structure Chart</strong></td>
                                <td>Tree diagram showing module relationships and data flow</td>
                            </tr>
                            <tr>
                                <td><strong>Interface Design</strong></td>
                                <td>Decide how the <strong>user will interact</strong> (UI/UX)</td>
                            </tr>
                            <tr>
                                <td><strong>Database Design</strong></td>
                                <td>Plan <strong>tables</strong>, <strong>keys</strong>, and <strong>normalization</strong></td>
                            </tr>
                            <tr>
                                <td><strong>Control Flow Design</strong></td>
                                <td>Decide the <strong>order of actions and decisions</strong></td>
                            </tr>
                        </tbody>
                    </table>
                    
                </article>
                <article>
                    <h2>Advantages</h2>
                    <ul>
                        <li>Easy to understand</li>
                        <li>Easy to maintain</li>
                        <li>Improves communication</li>
                        <li>Efficient system design</li>
                        <li>Scalable system structure</li>
                    </ul>
                    
                </article>
                <article>
                    <h2>Disadvantages</h2>
                    <ul>
                        <li>Time-consuming</li>
                        <li>Not suitable for fast/agile projects</li>
                        <li>Hard to change once finalized</li>
                    </ul>
                    
                </article>
                <article>
                    <h2>Sample 5-Mark Answer</h2>
                    <blockquote>
                        <p><strong>Q: What is Structured Analysis and Design?</strong><br>A: Structured Analysis is used to study what the system should do using tools like DFDs and ERDs. Structured Design focuses on how to implement it using modules, structure charts, and interface design. It helps build well-organized, maintainable systems.</p>
                    </blockquote>
                    
                </article>
                <article>
                    <h2>Flash Quiz (20 sec)</h2>
                    <ol>
                        <li>DFD shows → (dash) → <strong>Data Flow</strong></li>
                        <li>ERD shows → (dash) → <strong>Entity Relationships</strong></li>
                        <li>Design phase shows → (dash) → <strong>How to build</strong></li>
                        <li>Structured Design makes system → <strong>Modular</strong></li>
                        <li>PSPEC is used to → <strong>Explain process logic</strong></li>
                        <li>State Transition Diagram shows → <strong>States and transitions</strong></li>
                    </ol>
                </article>
                <article>
                    <h2>1-Minute Overview: What is UML?</h2>
                    <ul>
                        <li><strong>UML</strong> is like the <strong>blueprint</strong> of software. </li>
                        <li>It’s <strong>not a programming language</strong> — it’s a <strong>visual language</strong>. </li>
                        <li>It shows how a system <strong>works</strong>, how users <strong>interact</strong>, and how the parts are <strong>connected</strong>.</li>
                    </ul>
                    <blockquote>
                        <p><strong>Think of UML like a movie storyboard — it helps you plan the story (software) before you shoot (code).</strong></p>
                    </blockquote>
                    
                </article>
                <article>
                    <h2>Why is UML Needed? (Super Important 3-mark Q)</h2>
                    <table class="table table-bordered table-striped">
                        <thead>
                            <tr>
                                <th>Reason</th>
                                <th>Explanation</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Collaboration</td>
                                <td>Teams and business users need a common language</td>
                            </tr>
                            <tr>
                                <td>Communication</td>
                                <td>Explains ideas visually — no need to know code</td>
                            </tr>
                            <tr>
                                <td>Saves Time</td>
                                <td>Everyone understands early — fewer changes later</td>
                            </tr>
                        </tbody>
                    </table>
                    
                </article>
                <article>
                    <h2>Main UML Diagrams You Must Know</h2>
                    <p>Use this trick: <strong>CUAS</strong> = <strong>Class, Use case, Activity, Sequence</strong></p>
                    
                </article>
                <article>
                    <h3>Class Diagram (Structure of Software)</h3>
                    <ul>
                        <li>Shows <strong>classes</strong>, their <strong>attributes</strong>, <strong>methods</strong>, and <strong>relationships</strong></li>
                        <li>Like: <code>User</code>, <code>Post</code>, <code>Comment</code> with connections</li>
                    </ul>
                    <p>Think: <strong>Static Design View</strong><br>🛠 Used in: Object-Oriented Programming</p>
                    
                </article>
                <article>
                    <h3>Use Case Diagram (User ↔ System)</h3>
                    <ul>
                        <li>Shows how <strong>users interact</strong> with system</li>
                        <li>Actors: Human/User or external systems </li>
                        <li>Use Cases: Tasks like “Login”, “Register”, “Checkout”</li>
                    </ul>
                    <p>Think: <strong>Functional View</strong><br>🛠 Used in: Requirement gathering</p>
                    
                </article>
                <article>
                    <h3>Activity Diagram (Flow of Activities)</h3>
                    <ul>
                        <li>Like a <strong>flowchart</strong></li>
                        <li>Shows steps, decisions, and loops</li>
                        <li>Good for modeling processes (e.g., login, payment)</li>
                    </ul>
                    <p>Think: <strong>Workflow View</strong><br>🛠 Used in: Process modeling</p>
                    
                </article>
                <article>
                    <h3>Sequence Diagram (Time-wise Communication)</h3>
                    <ul>
                        <li>Shows <strong>who talks to whom, in what order</strong></li>
                        <li>Helps understand <strong>scenarios</strong> like “Transfer Money” </li>
                        <li>Shows <strong>messages</strong> between objects over time</li>
                    </ul>
                    <p>Think: <strong>Timeline View</strong><br>🛠 Used in: Scenario-based design</p>
                    
                </article>
                <article>
                    <h2>Object-Oriented Concepts in UML (Write These in Theory Questions)</h2>
                    <table class="table table-bordered table-striped">
                        <thead>
                            <tr>
                                <th>Concept</th>
                                <th>Simple Meaning</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Class</td>
                                <td>Blueprint of object</td>
                            </tr>
                            <tr>
                                <td>Object</td>
                                <td>Instance of class</td>
                            </tr>
                            <tr>
                                <td>Inheritance</td>
                                <td>Child inherits from parent</td>
                            </tr>
                            <tr>
                                <td>Abstraction</td>
                                <td>Show only what matters</td>
                            </tr>
                            <tr>
                                <td>Encapsulation</td>
                                <td>Protect data (use private/protected)</td>
                            </tr>
                            <tr>
                                <td>Polymorphism</td>
                                <td>One function, many forms</td>
                            </tr>
                        </tbody>
                    </table>
                    
                </article>
                <article>
                    <h2>🛠 Tools for Making UML Diagrams (Mention 2 if asked)</h2>
                    <ol>
                        <li><strong>Draw.io</strong> – Free, online, easy to use </li>
                        <li><strong>Lucidchart</strong> – Collaborative diagramming </li>
                        <li><strong>StarUML</strong> – Open-source tool </li>
                        <li><strong>Visual Paradigm</strong> – Professional, all-in-one tool</li>
                    </ol>
                    
                </article>
                <article>
                    <h2>Write: Sample 3-Mark Answer</h2>
                    <blockquote>
                        <p><strong>Q: What is a Use Case Diagram?</strong><br>A: A Use Case Diagram shows the <strong>interactions between users (actors) and the system</strong>. It helps identify the <strong>functional requirements</strong> of the system. Each use case represents a task like “Login”, “Place Order”, etc. It is useful during the <strong>requirement analysis</strong> phase.</p>
                    </blockquote>
                    
                </article>
                <article>
                    <h2>Flash Quiz (Last-Minute Recall – 20 sec)</h2>
                    <ol>
                        <li>UML stands for (dash) → <strong>Unified Modeling Language</strong> </li>
                        <li>Use Case Diagrams show (dash) → <strong>User-System Interactions</strong> </li>
                        <li>Class Diagrams show → <strong>Classes, attributes, methods</strong> </li>
                        <li>Activity Diagrams are similar to → <strong>Flowcharts</strong> </li>
                        <li>Sequence Diagrams show → <strong>Time-ordered communication</strong></li>
                    </ol>
                </article>
                <article>
                    <h2>1-Min Summary: What is User Interface Design?</h2>
                    <p><strong>User Interface Design</strong> means:</p>
                    <blockquote>
                        <p>Designing how users interact with software — <strong>the screen they see, the buttons they press, and how smooth everything feels.</strong></p>
                    </blockquote>
                    <p>Imagine your favorite app — if it looks good, works fast, is easy to understand — that’s good UI Design.</p>
                    
                </article>
                <article>
                    <h2>Key Features of a Good UI (Must Memorize)</h2>
                    <p>A good UI is:</p>
                    <table class="table table-bordered table-striped">
                        <thead>
                            <tr>
                                <th>Feature</th>
                                <th>Meaning (Easiest Way)</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Attractive</td>
                                <td>Looks nice and pleasant</td>
                            </tr>
                            <tr>
                                <td>Simple</td>
                                <td>Easy to use, no confusion</td>
                            </tr>
                            <tr>
                                <td>Responsive</td>
                                <td>Works fast, reacts quickly</td>
                            </tr>
                            <tr>
                                <td>Clear</td>
                                <td>You know exactly what to do</td>
                            </tr>
                            <tr>
                                <td>Consistent</td>
                                <td>Same style across all screens</td>
                            </tr>
                        </tbody>
                    </table>
                    
                </article>
                <article>
                    <h2>UI Design Principles (Super Important)</h2>
                    <p>Use this trick: <strong>SSVFT</strong></p>
                    <table class="table table-bordered table-striped">
                        <thead>
                            <tr>
                                <th>Principle</th>
                                <th>Meaning (Remember with Real-Life Example)</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Structure</td>
                                <td>Arrange info clearly (like your notes)</td>
                            </tr>
                            <tr>
                                <td>Simplicity</td>
                                <td>Keep it clean, avoid clutter (like clean room = easy to find stuff)</td>
                            </tr>
                            <tr>
                                <td>Visibility</td>
                                <td>Show only what’s needed (don’t hide things like exam hall instructions)</td>
                            </tr>
                            <tr>
                                <td>Feedback</td>
                                <td>Give response (like “Answer submitted” or “Error!”)</td>
                            </tr>
                            <tr>
                                <td>Tolerance</td>
                                <td>Allow mistakes (Undo button, autosave, etc.)</td>
                            </tr>
                        </tbody>
                    </table>
                    
                </article>
                <article>
                    <h2>4 Phases of UI Design Process (Very Likely Question)</h2>
                    <p>Learn this 4-step cycle: <strong>Analyze → Design → Build → Check</strong></p>
                </article>
                <article>
                    <h3>Phase 1: User, Task, Environment Analysis</h3>
                    <ul>
                        <li>Study the <strong>users</strong> (age, skills, knowledge)</li>
                        <li>Understand <strong>what tasks</strong> they need to do</li>
                        <li>Check <strong>environment</strong> (device, lighting, etc.)</li>
                    </ul>
                    <p>Think: Who will use it? What for? Where?</p>
                    
                </article>
                <article>
                    <h3>Phase 2: Interface Design</h3>
                    <ul>
                        <li>Plan what the <strong>user needs to do</strong></li>
                        <li>Identify <strong>objects</strong> (like "buttons", "menus") and their <strong>actions</strong></li>
                    </ul>
                    <p>Think: What are the parts and what can I do with them?</p>
                    
                </article>
                <article>
                    <h3>Phase 3: Interface Construction</h3>
                    <ul>
                        <li>Build a <strong>prototype</strong> (rough version of UI)</li>
                        <li>Test and improve it again and again until ready</li>
                    </ul>
                    <p>Think: Try–Test–Improve (like drafts before final project)</p>
                    
                </article>
                <article>
                    <h3>Phase 4: Interface Validation</h3>
                    <ul>
                        <li>Final check: Can the user <strong>really use it easily</strong> in real life?</li>
                    </ul>
                    <p>Think: Does it work in real-world use cases?</p>
                    
                </article>
                <article>
                    <h2>How to Write Perfect 3-5 Mark Answers (Template Style)</h2>
                    <blockquote>
                        <p><strong>Q: What are the principles of UI Design?</strong><br>A: The principles of UI Design are:</p>
                        <ol>
                            <li><strong>Structure</strong> – Organize content meaningfully. </li>
                            <li><strong>Simplicity</strong> – Keep interface clean and easy. </li>
                            <li><strong>Visibility</strong> – Show necessary info only. </li>
                            <li><strong>Feedback</strong> – System should give responses. </li>
                            <li><strong>Tolerance</strong> – Allow user mistakes safely.</li>
                        </ol>
                    </blockquote>
                    
                </article>
                <article>
                    <h2>Quick Fill-in-the-Blank Style Practice (Revise in 30 sec)</h2>
                    <ol>
                        <li>UI is the (dash) view that users interact with. → <strong>front-end</strong></li>
                        <li>A good UI should be (dash) and (dash) to understand. → <strong>attractive</strong>, <strong>clear</strong></li>
                        <li>UI design has (dash) main phases. → <strong>4</strong></li>
                        <li>Phase 3 of UI design is called (dash). → <strong>Interface Construction</strong></li>
                        <li>Feedback in UI means (dash). → <strong>showing responses to user actions</strong></li>
                    </ol>
                </article>
            </main>

            <pre id="markdown-raws" class="d-none">
## 1-Min Overview

> These are the **main challenges** a developer faces when designing software.
> If not handled well, software becomes slow, insecure, confusing, or useless.

---

## 11 Fundamental Issues (Learn with Real-Life Examples)

### 1. Meeting User Requirements
- Understand what users **actually need**.
*E.g., A doctor’s app must show patient history clearly or it’s useless.*

---

### 2. Maintaining Simplicity
- **Don’t overcomplicate** the design.
*Farmers need easy graphs, not confusing dashboards.*

---

### 3. Scalability
- Can the system **handle more users or data** in the future?
*E-commerce site built for 100 users may fail at 10,000 if not scalable.*

---

### 4. Performance
- Should run **fast** and **efficiently**.
*Video editing app must render videos quickly.*

---

### 5. Security
- Protect **data and access** from unauthorized users.
*Banking app must secure account info from hackers.*

---

### 6. Flexibility & Maintainability
- Easy to **update** or **fix bugs**.
*Clinic app should easily add online consultation features later.*

---

### 7. Error Handling
- Handle mistakes **gracefully**, not with crashes.
*Booking system should show "Invalid date" instead of crashing.*

---

### 8. Usability
- Easy to use, even for **non-tech users**.
*Hospital software should be nurse-friendly.*

---

### 9. Interoperability
- Must **work with other systems**.
*Hospital software should share patient data with other hospitals.*

---

### 10. Cost and Time Management
- Stay **within budget and deadlines**.
*Biotech app must be ready before a medical conference.*

---

## Sample 5-Mark Answer

> **Q: Explain any 5 fundamental issues in software design.**
> A:
> 1. **Meeting User Requirements** – The software must fulfill the actual needs of users.
> 2. **Simplicity** – Simple design helps reduce confusion and errors.
> 3. **Scalability** – Software should handle increasing users/data without crashing.
> 4. **Security** – Sensitive data must be protected from unauthorized access.
> 5. **Maintainability** – Software must be easy to update and fix when needed.

---

## Flash Quiz

1. Software should be easy to update → **Maintainability**
2. Sharing data with other systems → **Interoperability**
3. “Invalid date” instead of crash → **Error Handling**
4. App slows down with more users → Poor **Scalability**
5. Simple design helps avoid confusion → **Simplicity**
6. Software must fulfill actual user needs → **Meeting User Requirements**



## 1-Minute Overview

| Concept | Meaning |
|----------|--------|
| **Cohesion** | How **focused** a module is on a single task |
| **Coupling** | How **dependent** a module is on other modules |

**High Cohesion** + **Low Coupling** = Perfect software design
**Low Cohesion** + **High Coupling** = Confusing, buggy design

---

## COHESION (Stick together = One clear job)

### Definition:
> How tightly the parts of a single module/class **work together** to do **one job**.

### High Cohesion (GOOD):
- One module = One task
- Easy to understand
- Easy to test and reuse
- Changes don't affect unrelated code

Example:
A **Shopping Cart** module that only handles cart tasks like add/remove/view items.

---

### Low Cohesion (BAD):
- Module tries to do **too many unrelated things**
- Difficult to maintain or update

Example:
A **Cart** module that also handles login, payments, and product listings.

---

## COUPLING (Link = Dependency between modules)

### Definition:
> How much one module depends on another to work.

### Low Coupling (GOOD):
- Modules are **independent**
- Easy to update/replace modules
- Ideal in large systems

Example:
**Payment Module** and **Cart Module** communicate via API. You can update payment logic without changing the cart.

---

### High Coupling (BAD):
- Modules are tightly connected
- Changing one breaks the other
- Debugging becomes harder

Example:
**Cart** directly handles payment logic like credit card validation, so if payment rules change, cart must change too.

---

## How They Work Together

| Combo | Effect |
|-------|--------|
| High Cohesion + Low Coupling | Best Design (modular, maintainable, flexible) |
| Low Cohesion + High Coupling | Worst Design (spaghetti code, high risk of bugs) |

Think:
> Clean rooms in separate houses (low coupling) doing just their own job (high cohesion).

---

## Real-Life Example: **Amazon**

| Part | Cohesion | Coupling |
|------|----------|----------|
| Product Page | High: Only shows product details | Low: Doesn’t handle checkout |
| Cart | High: Only adds/removes items | Low: Doesn’t know payment details |
| Payment | High: Only does transactions | Low: Doesn’t know product logic |

---

## Sample 5-Mark Answer

> **Q: What are Cohesion and Coupling? Explain with examples.**
> A:
> - **Cohesion** is how focused a module is on doing one task. High cohesion makes modules easier to maintain and reuse.
> - **Coupling** is how much one module depends on another. Low coupling allows changes in one module without affecting others.
> - Example: In an e-commerce website, the **Cart module** with high cohesion only manages cart items. It communicates with the **Payment module** through APIs, showing low coupling. This makes the system flexible and easy to modify.

---

## Flash Quiz (Last-Min Prep)

1. Good design = (dash) → **High Cohesion, Low Coupling**
2. Cohesion is → **How tightly tasks in a module relate**
3. Coupling is → **How much modules depend on each other**
4. Cart + Payment using API = (dash) → **Low Coupling**
5. One module, one job = (dash) → **High Cohesion**
6. Spaghetti code = (dash) → **Low Cohesion + High Coupling**
7. Amazon product page = (dash) → **High Cohesion, Low Coupling**


## 1-Min Overview: What is Function-Oriented Design?

> A design method where **software is divided into small functions**, each doing a specific task.

- Focus is on **what the system should do** (functions), not on objects.
- Uses a **top-down** design approach.
- Helps in **breaking large systems into manageable tasks**.

---

## General Procedure (Very Short Answer Style)

1. **Start with what the system does**  
2. **Break it into high-level functions**
3. **Break those into smaller sub-functions**
4. **Connect them using data flow**

---

## Key Concepts (Must Memorize)

| Concept | Explanation |
|--------|-------------|
| Divides system into **functions** | Each function = 1 task (like login, search) |
| Follows **top-down approach** | Main → sub-function → sub-sub function |
| Uses **Data Flow Diagrams (DFDs)** | Shows how data moves from one function to another |
| Focus on **processes**, not objects | Opposite of Object-Oriented Design |

---

## Example: Online Library System

| Level | Function |
|-------|----------|
| Main Function | `LibrarySystem()` |
| Sub-Functions | `UserManagement()`, `BookManagement()` |
| Further Break | `registerUser()`, `loginUser()`, `addBook()` |

Think: Just keep dividing till each function is easy to implement.

---

## Advantages

- Easy to Understand  
- Reusable Functions  
- Good for Small/Medium Projects

---

## Disadvantages

- Not good for large/complex systems  
- Hard to maintain/modify  
- Less secure (data shared across functions)

---

## Design Strategies in FOD

| Tool | Use |
|------|-----|
| **DFD** | Shows flow of data between functions |
| **Data Dictionary** | Details about data elements |
| **Pseudo Code** | Simple code logic in English |
| **Structure Chart** | Shows function hierarchy and interaction |

---

## DFD (Data Flow Diagram) – Most Important

### Components:
| Symbol | Meaning |
|--------|---------|
| Circle | Process (e.g., “Login”) |
| Rectangle | Entity (e.g., “User”) |
| Open rectangle | Data Store |
| Arrow | Data Flow |

### DFD Levels:
| Level | Description |
|-------|-------------|
| **Level 0** | Big Picture (Context Level) |
| **Level 1** | Breaks big system into main functions |
| **Level 2** | Breaks main functions into smaller processes |

---

## Data Dictionary

> Think: Data **about** data

### Example:

| Field        | Type   | Size | Description           |
|--------------|--------|------|------------------------|
| StudentID    | Int    | 3    | Unique ID of student   |
| Name         | String | 20   | Name of student        |

### Types:
| Type | Description |
|------|-------------|
| **Active** | Auto-updated with DB changes |
| **Passive** | Manually updated |

---

## Sample 5-Mark Answer

> **Q: Explain Function-Oriented Design with its tools.**  
> A: Function-Oriented Design divides the system into small functions using a top-down approach. It focuses on processes and data flow. Tools used include Data Flow Diagrams (DFDs) to represent data movement, Data Dictionaries for storing metadata, Pseudo Code for process logic, and Structure Charts for hierarchy. This design is simple and reusable but less suitable for large or complex systems.

---

## Flash Quiz

1. FOD focuses on → **Functions**
2. DFD shows → **Data Flow**
3. Top-level DFD is → **Level 0**
4. Data Dictionary stores → **Metadata**
5. Opposite of Function-Oriented Design is → **Object-Oriented Design**


## 1-Min Summary

| Term | Meaning |
|------|---------|
| **Structured Analysis** | Understand what the system should do (requirements) |
| **Structured Design** | Decide how the system will be built (design modules, UI, database, etc.) |

**Think like this:**  
> First → Analyze what the user wants (Structured Analysis)  
> Then → Design how to build it (Structured Design)

---

## Objectives of Structured Analysis & Design (Easy 5-mark Question)

| Purpose | Meaning |
|---------|---------|
| Understand Requirements | Know exactly what user needs |
| Break Down System | Divide system into small, manageable parts |
| Define Relationships | Connect components logically |
| Ensure Completeness | Nothing should be left or repeated |
| Improve Communication | Helps devs and clients understand each other |
| Enable Scalability & Maintainability | Easier to grow and fix the system later |

---

## Structured Analysis Phase: (What the system should do)

### Focus: **Understand user’s needs + system behavior**

### Tools Used:
| Tool | Purpose |
|------|---------|
| **Data Flow Diagram (DFD)** | Shows flow of data (input → process → output) |
| **Entity-Relationship Diagram (ERD)** | Shows tables/entities and relationships |
| **Process Specification (PSPEC)** | Explains process logic using simple language or flowcharts |
| **Data Dictionary** | Explains every data field (e.g., `StudentID: Integer`) |
| **Decision Trees / Tables** | Shows logic or choices made by system |
| **State Transition Diagrams** | Shows states and transitions (e.g., Login → Logged In) |

---

## Structured Design Phase: (How the system will work)

### Focus: **Convert analysis into working design**

### Techniques Used:

| Component | Meaning |
|-----------|---------|
| **Modular Design** | Divide system into **modules** with **low coupling, high cohesion** |
| **Structure Chart** | Tree diagram showing module relationships and data flow |
| **Interface Design** | Decide how the **user will interact** (UI/UX) |
| **Database Design** | Plan **tables**, **keys**, and **normalization** |
| **Control Flow Design** | Decide the **order of actions and decisions**

---

## Advantages

- Easy to understand
- Easy to maintain
- Improves communication
- Efficient system design
- Scalable system structure

---

## Disadvantages

- Time-consuming
- Not suitable for fast/agile projects
- Hard to change once finalized

---

## Sample 5-Mark Answer

> **Q: What is Structured Analysis and Design?**  
> A: Structured Analysis is used to study what the system should do using tools like DFDs and ERDs. Structured Design focuses on how to implement it using modules, structure charts, and interface design. It helps build well-organized, maintainable systems.

---

## Flash Quiz (20 sec)

1. DFD shows → (dash) → **Data Flow**
2. ERD shows → (dash) → **Entity Relationships**
3. Design phase shows → (dash) → **How to build**
4. Structured Design makes system → **Modular**
5. PSPEC is used to → **Explain process logic**
6. State Transition Diagram shows → **States and transitions**


## 1-Minute Overview: What is UML?

- **UML** is like the **blueprint** of software.  
- It’s **not a programming language** — it’s a **visual language**.  
- It shows how a system **works**, how users **interact**, and how the parts are **connected**.

> **Think of UML like a movie storyboard — it helps you plan the story (software) before you shoot (code).**

---

## Why is UML Needed? (Super Important 3-mark Q)

| Reason | Explanation |
|--------|-------------|
| Collaboration | Teams and business users need a common language |
| Communication | Explains ideas visually — no need to know code |
| Saves Time | Everyone understands early — fewer changes later |

---

## Main UML Diagrams You Must Know

Use this trick: **CUAS** = **Class, Use case, Activity, Sequence**

---

### Class Diagram (Structure of Software)

- Shows **classes**, their **attributes**, **methods**, and **relationships**
- Like: `User`, `Post`, `Comment` with connections

Think: **Static Design View**  
🛠 Used in: Object-Oriented Programming

---

### Use Case Diagram (User ↔ System)

- Shows how **users interact** with system
- Actors: Human/User or external systems  
- Use Cases: Tasks like “Login”, “Register”, “Checkout”

Think: **Functional View**  
🛠 Used in: Requirement gathering

---

### Activity Diagram (Flow of Activities)

- Like a **flowchart**
- Shows steps, decisions, and loops
- Good for modeling processes (e.g., login, payment)

Think: **Workflow View**  
🛠 Used in: Process modeling

---

### Sequence Diagram (Time-wise Communication)

- Shows **who talks to whom, in what order**
- Helps understand **scenarios** like “Transfer Money”  
- Shows **messages** between objects over time

Think: **Timeline View**  
🛠 Used in: Scenario-based design

---

## Object-Oriented Concepts in UML (Write These in Theory Questions)

| Concept       | Simple Meaning |
|---------------|----------------|
| Class        | Blueprint of object |
| Object       | Instance of class |
| Inheritance  | Child inherits from parent |
| Abstraction  | Show only what matters |
| Encapsulation | Protect data (use private/protected) |
| Polymorphism | One function, many forms |

---

## 🛠 Tools for Making UML Diagrams (Mention 2 if asked)

1. **Draw.io** – Free, online, easy to use  
2. **Lucidchart** – Collaborative diagramming  
3. **StarUML** – Open-source tool  
4. **Visual Paradigm** – Professional, all-in-one tool  

---

## Write: Sample 3-Mark Answer

> **Q: What is a Use Case Diagram?**  
> A: A Use Case Diagram shows the **interactions between users (actors) and the system**. It helps identify the **functional requirements** of the system. Each use case represents a task like “Login”, “Place Order”, etc. It is useful during the **requirement analysis** phase.

---

## Flash Quiz (Last-Minute Recall – 20 sec)

1. UML stands for (dash) → **Unified Modeling Language**  
2. Use Case Diagrams show (dash) → **User-System Interactions**  
3. Class Diagrams show → **Classes, attributes, methods**  
4. Activity Diagrams are similar to → **Flowcharts**  
5. Sequence Diagrams show → **Time-ordered communication**


## 1-Min Summary: What is User Interface Design?

**User Interface Design** means:
> Designing how users interact with software — **the screen they see, the buttons they press, and how smooth everything feels.**

Imagine your favorite app — if it looks good, works fast, is easy to understand — that’s good UI Design.

---

## Key Features of a Good UI (Must Memorize)

A good UI is:

| Feature       | Meaning (Easiest Way)                        |
|---------------|-----------------------------------------------|
| Attractive  | Looks nice and pleasant                      |
| Simple      | Easy to use, no confusion                    |
| Responsive  | Works fast, reacts quickly                   |
| Clear       | You know exactly what to do                  |
| Consistent  | Same style across all screens                |

---

## UI Design Principles (Super Important)

Use this trick: **SSVFT**

| Principle     | Meaning (Remember with Real-Life Example)                                |
|---------------|---------------------------------------------------------------------------|
| Structure   | Arrange info clearly (like your notes)                                   |
| Simplicity  | Keep it clean, avoid clutter (like clean room = easy to find stuff)      |
| Visibility  | Show only what’s needed (don’t hide things like exam hall instructions)  |
| Feedback    | Give response (like “Answer submitted” or “Error!”)                      |
| Tolerance   | Allow mistakes (Undo button, autosave, etc.)                             |

---

## 4 Phases of UI Design Process (Very Likely Question)

Learn this 4-step cycle: **Analyze → Design → Build → Check**

### Phase 1: User, Task, Environment Analysis
- Study the **users** (age, skills, knowledge)
- Understand **what tasks** they need to do
- Check **environment** (device, lighting, etc.)

Think: Who will use it? What for? Where?

---

### Phase 2: Interface Design
- Plan what the **user needs to do**
- Identify **objects** (like "buttons", "menus") and their **actions**

Think: What are the parts and what can I do with them?

---

### Phase 3: Interface Construction
- Build a **prototype** (rough version of UI)
- Test and improve it again and again until ready

Think: Try–Test–Improve (like drafts before final project)

---

### Phase 4: Interface Validation
- Final check: Can the user **really use it easily** in real life?

Think: Does it work in real-world use cases?

---

## How to Write Perfect 3-5 Mark Answers (Template Style)

> **Q: What are the principles of UI Design?**  
> A: The principles of UI Design are:
> 1. **Structure** – Organize content meaningfully.  
> 2. **Simplicity** – Keep interface clean and easy.  
> 3. **Visibility** – Show necessary info only.  
> 4. **Feedback** – System should give responses.  
> 5. **Tolerance** – Allow user mistakes safely.

---

## Quick Fill-in-the-Blank Style Practice (Revise in 30 sec)

1. UI is the (dash) view that users interact with. → **front-end**
2. A good UI should be (dash) and (dash) to understand. → **attractive**, **clear**
3. UI design has (dash) main phases. → **4**
4. Phase 3 of UI design is called (dash). → **Interface Construction**
5. Feedback in UI means (dash). → **showing responses to user actions**


            </pre>


        </main>

        <script> copyright("all"); </script>

    </body>

</html>