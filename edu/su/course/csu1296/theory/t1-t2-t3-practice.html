<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
   <!--<![endif]-->

   <head>
      <script src="/js/edu_su_common.js"></script>
      <noscript>
         <style>
            html,
            body {
               margin: 0;
               overflow: hidden;
            }
         </style>
         <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
      </noscript>

      <meta name="author" content="Divya Mohan">
      <meta name="robots" content="index, follow">

      <!-- Open Graph for Social Media -->
      <meta property="og:image" content="/logo.png">
      <meta property="og:type" content="article">

      <!-- Twitter Cards -->
      <meta name="twitter:card" content="summary">
      <meta name="twitter:site" content="@divyamohan1993">
      <meta name="twitter:creator" content="@divyamohan1993">
      <meta name="twitter:image" content="/logo.png">

      <!-- Mobile Responsiveness -->
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">

      <title>Practice T1, T2, T3 - CSU1296 - Shoolini U</title>
      <meta name="description" content="Practice for T1, T2, T3 - CSU1296 - Shoolini U" />



      <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                renderMathInElement(document.body, {
                    // customised options
                    // • auto-render specific keys, e.g.:
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\(', right: '\\)', display: false },
                        { left: '\\[', right: '\\]', display: true }
                    ],
                    // • rendering keys, e.g.:
                    throwOnError: false
                });
            });
        </script> -->

      <!-- <style>
            main ul {
                list-style-type: none;
                padding: 0;
                margin: 0;
            }

            main ul li {
                margin: 0;
                padding: 0;
            }
        </style> -->
   </head>

   <body>

      <script> header_author("dm"); </script>

      <main class="d-none">
         <article class="agen-tableofcontents">
            <h2 class="text-center">
               Practice T1, T2, T3
            </h2>
            <div class="d-none contentdate">2025, May 16</div>
         </article>

         <article>
            <h3>TERM 1</h3>
            <h4>Section A</h4>
            <h4>Q 1. Define the <strong>Agile Manifesto</strong> and mention one of its key principles.</h4>
            <ul>
               <li><strong>Definition:</strong> A declaration of four value-statements and twelve principles advocating iterative development, customer collaboration and adaptability over heavyweight processes.</li>
               <li><strong>One key principle (Principle 1):</strong> “Our highest priority is to satisfy the customer through early and continuous delivery of valuable software.”</li>
            </ul>
            <hr>
            <h4>Q 2. What is <strong>High Cohesion</strong> in software modules?</h4>
            <ul>
               <li><strong>High cohesion</strong> means that all elements (functions, data) in a module relate closely to a single, well-defined task or responsibility.</li>
               <li><strong>Benefit:</strong> Easier to understand, test and maintain because module internals change for only one reason.</li>
            </ul>
            <hr>
            <h4>Q 3. Explain <strong>Low Coupling</strong> with a brief example from an e-commerce platform.</h4>
            <ul>
               <li>
                  <p><strong>Low coupling</strong> means modules depend on each other only through minimal, well-defined interfaces, with no unnecessary knowledge of internals.</p>
               </li>
               <li>
                  <p><strong>Example:</strong></p>
                  <ul>
                     <li>A <strong>Payment</strong> module exposes a <code>processPayment(amount, method)</code> interface.</li>
                     <li>The <strong>Order</strong> module calls that interface but knows nothing about the payment gateway’s internal workflow or database schema.</li>
                  </ul>
               </li>
            </ul>
            <hr>
            <h4>Q 4. Describe the significance of <strong>handling errors</strong> in software development.</h4>
            <ul>
               <li><strong>Early defect detection:</strong> Validates inputs and catches runtime faults before they cascade.</li>
               <li><strong>Reliability &amp; availability:</strong> Prevents crashes and ensures graceful recovery (e.g., retries, fallbacks).</li>
               <li><strong>Security:</strong> Mitigates injection or overflow attacks by validating and sanitizing data.</li>
               <li><strong>User experience:</strong> Provides clear error messages and guidance, reducing user frustration.</li>
            </ul>
            <hr>
            <h4>Section B</h4>
            <h4>Q 5. What does <strong>“Scalability”</strong> mean in the context of software architecture?</h4>
            <ol>
               <li>
                  <p><strong>Definition:</strong> The ability of a system to handle increased load (users, transactions, data) by adding resources with minimal performance degradation.</p>
               </li>
               <li>
                  <p><strong>Types:</strong></p>
                  <ul>
                     <li><strong>Vertical scaling (scale-up):</strong> Upgrading server CPU/RAM.</li>
                     <li><strong>Horizontal scaling (scale-out):</strong> Adding more identical server instances behind a load balancer.</li>
                  </ul>
               </li>
               <li>
                  <p><strong>Design considerations:</strong></p>
                  <ul>
                     <li><strong>Stateless services:</strong> Eases horizontal scaling.</li>
                     <li><strong>Data partitioning (sharding):</strong> Distributes database load.</li>
                     <li><strong>Asynchronous messaging:</strong> Decouples components under high load.</li>
                  </ul>
               </li>
               <li>
                  <p><strong>Example:</strong> An e-commerce cart service replicates across multiple nodes to serve thousands of concurrent shoppers without a central bottleneck.</p>
               </li>
            </ol>
            <hr>
            <h4>Q 6. Choose <strong>one</strong> of the following:</h4>
            <h4>A. Impact of <strong>High Coupling</strong> in a banking‐app project</h4>
            <ul>
               <li><strong>Integration complexity:</strong> Every change in one module (e.g., Accounts) forces retesting of dependent modules (Loans, Payments).</li>
               <li><strong>Maintenance overhead:</strong> Tight interdependencies make locating root-cause of bugs harder and riskier.</li>
               <li><strong>Reduced team parallelism:</strong> Developers must coordinate closely, slowing down feature delivery.</li>
               <li><strong>Risk of ripple effect:</strong> A defect in one component can cascade, causing widespread downtime in critical banking functions.</li>
            </ul>
            <h4>OR</h4>
            <h4>B. How <strong>Sprints</strong> contribute to Agile development &amp; benefits for a mobile-app startup</h4>
            <ol>
               <li>
                  <p><strong>Definition of Sprint:</strong> A fixed time-box (usually 1–4 weeks) during which a cross-functional team delivers a potentially shippable increment.</p>
               </li>
               <li>
                  <p><strong>Contribution:</strong></p>
                  <ul>
                     <li><strong>Focus &amp; cadence:</strong> Clear short-term goals drive daily progress (via stand-ups).</li>
                     <li><strong>Rapid feedback:</strong> Frequent demos expose mismatches between features and user needs.</li>
                     <li><strong>Adaptability:</strong> Backlog reprioritized each sprint based on customer/stakeholder input.</li>
                  </ul>
               </li>
               <li>
                  <p><strong>Startup benefits:</strong></p>
                  <ul>
                     <li><strong>Early market validation:</strong> Release MVP features quickly to real users.</li>
                     <li><strong>Resource efficiency:</strong> Limits wasted effort by stopping low-value work after each sprint.</li>
                     <li><strong>Risk reduction:</strong> Continuous learning and pivoting prevent major rewrites late in development.</li>
                  </ul>
               </li>
            </ol>
            <hr>
            <h4>Section C</h4>
            <h4>Q 7. <strong>Waterfall vs Agile</strong> &amp; <strong>Continuous Integration</strong> benefits</h4>
            <h4>A. When Waterfall is more effective than Agile</h4>
            <ul>
               <li><strong>Stable, unchanging requirements:</strong> e.g., safety-critical avionics software where specs are fixed by regulation.</li>
               <li><strong>Regulatory/compliance constraints:</strong> Heavily documented phases (design, verification) meet audit requirements.</li>
               <li><strong>Hardware–software co-design:</strong> Strict phase gating ensures hardware and software interfaces freeze before integration.</li>
               <li><strong>Large, distributed teams with specialist roles:</strong> Clear phase boundaries reduce coordination overhead.</li>
            </ul>
            <h4>B. Continuous Integration (CI) benefits</h4>
            <ul>
               <li><strong>Early defect detection:</strong> Automated builds and tests run on every commit, catching integration bugs immediately.</li>
               <li><strong>Faster feedback loop:</strong> Developers know within minutes if a change breaks the build.</li>
               <li><strong>Reduced integration risk:</strong> Small, incremental merges are easier to troubleshoot than massive integration at project end.</li>
               <li><strong>Improved code quality:</strong> Enforces unit-test coverage, linting and style checks by CI pipelines.</li>
               <li><strong>Accelerated delivery:</strong> Reliable automated pipelines pave the way for continuous delivery (CD) and frequent releases.</li>
            </ul>
            <hr>
            <h4>Q 8. <strong>Cohesion &amp; Coupling</strong> (alternate 10-mark question)</h4>
            <ol>
               <li>
                  <p><strong>Cohesion</strong></p>
                  <ul>
                     <li><strong>Definition:</strong> Degree to which elements within a module belong together.</li>
                     <li><strong>Types (high→low):</strong> Functional &gt; Sequential &gt; Communicational &gt; Procedural &gt; Logical &gt; Coincidental.</li>
                     <li><strong>Benefit of High Cohesion:</strong> Simplifies reasoning, testing and maintenance since a module changes for one clear reason.</li>
                  </ul>
               </li>
               <li>
                  <p><strong>Coupling</strong></p>
                  <ul>
                     <li><strong>Definition:</strong> Degree of interdependence between modules.</li>
                     <li><strong>Types (low→high):</strong> No coupling &gt; Data coupling &gt; Stamp coupling &gt; Control coupling &gt; Common coupling &gt; Content coupling.</li>
                     <li><strong>Benefit of Low Coupling:</strong> Enables independent module evolution, reduces regression risk and improves reuse.</li>
                  </ul>
               </li>
               <li>
                  <p><strong>Why high cohesion + low coupling?</strong></p>
                  <ul>
                     <li><strong>Maintainability:</strong> Localized changes minimize side effects.</li>
                     <li><strong>Reusability:</strong> Cohesive modules with minimal dependencies can be reused in other contexts.</li>
                     <li><strong>Scalability:</strong> Independent modules can be scaled or replaced without impacting the whole system.</li>
                     <li><strong>Testability:</strong> Isolated units are easier to mock and verify via unit tests.</li>
                  </ul>
               </li>
            </ol>
         </article>
         <article>
            <h3>TERM 2</h3>
            <p><strong>Section A</strong></p>
            <ol>
               <li>
                  <p><strong>Cohesion &amp; Coupling; Role of Design</strong></p>
                  <ul>
                     <li><strong>Cohesion</strong>: Degree to which elements within a module belong together.</li>
                     <li><strong>Coupling</strong>: Degree of interdependence between modules.</li>
                     <li><strong>Role of Design</strong>: Transforms requirements into a modular architecture and detailed blueprints, guiding implementation, easing maintenance and ensuring traceability.</li>
                  </ul>
               </li>
               <li>
                  <p><strong>Importance of UML; Software Quality Management</strong></p>
                  <ul>
                     <li><strong>UML</strong>: A standardized visual language for modeling and communicating system structure and behavior across stakeholders.</li>
                     <li><strong>Software Quality Management</strong>: Systematic planning, assurance and control of processes and products to meet defined quality standards and stakeholder expectations.</li>
                  </ul>
               </li>
               <li>
                  <p><strong>Structured Analysis; Sequence Diagram</strong></p>
                  <ul>
                     <li><strong>Structured Analysis</strong>: Technique using data‐flow diagrams, ER models and process decomposition to map requirements into functional views.</li>
                     <li><strong>Sequence Diagram</strong>: Shows object interactions over time for a use case, clarifying message order and detecting missing requirements.</li>
                  </ul>
               </li>
               <li>
                  <p><strong>Use Case Diagram; Activity Diagram; Actors</strong></p>
                  <ul>
                     <li><strong>Use Case Diagram</strong>: Depicts system boundaries, actors and their functional interactions (use cases).</li>
                     <li><strong>Activity Diagram</strong>: Models workflow, parallelism and decision points within a process.</li>
                     <li><strong>Actors</strong>: External entities (users or systems) that initiate or participate in use cases.</li>
                  </ul>
               </li>
               <li>
                  <p><strong>Function-Oriented Design; Two Advantages</strong></p>
                  <ul>
                     <li><strong>Function-Oriented Design</strong>: Decomposes a system into functions/processes and data flows (e.g. DFDs, structured modules).</li>
                     <li><strong>Advantages</strong>:</li>
                  </ul>
               </li>
               <li>
                  <p><strong>Modularity</strong> – Easier to isolate and modify individual functions.</p>
               </li>
               <li>
                  <p><strong>Reusability</strong> – Well-defined functions can be reused across different systems.</p>
               </li>
            </ol>
            <p><strong>B1. Characteristics of a Good Software Design (5 marks)</strong></p>
            <ol>
               <li>
                  <p><strong>Modularity</strong></p>
                  <ul>
                     <li>System divided into well-defined, loosely coupled modules.</li>
                  </ul>
               </li>
               <li>
                  <p><strong>Abstraction</strong></p>
                  <ul>
                     <li>Hides implementation details behind clear interfaces.</li>
                  </ul>
               </li>
               <li>
                  <p><strong>High Cohesion &amp; Low Coupling</strong></p>
                  <ul>
                     <li>Modules focus on a single responsibility and interact minimally.</li>
                  </ul>
               </li>
               <li>
                  <p><strong>Encapsulation</strong></p>
                  <ul>
                     <li>Data and operations bundled together, preventing unauthorized access.</li>
                  </ul>
               </li>
               <li>
                  <p><strong>Reusability &amp; Extensibility</strong></p>
                  <ul>
                     <li>Components designed for reuse and easy extension without major rewrites.</li>
                  </ul>
               </li>
            </ol>
            <hr>
            <p><strong>B2. Function-Oriented vs Object-Oriented Design (5 marks)</strong></p>
            <table class="table table-bordered table-striped">
               <thead>
                  <tr>
                     <th>Aspect</th>
                     <th>Function-Oriented</th>
                     <th>Object-Oriented</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td><strong>Modularization</strong></td>
                     <td>Functions/procedures on global data</td>
                     <td>Classes encapsulating data &amp; methods</td>
                  </tr>
                  <tr>
                     <td><strong>Abstraction</strong></td>
                     <td>DFDs &amp; structured modules</td>
                     <td>Class &amp; object hierarchies (inheritance)</td>
                  </tr>
                  <tr>
                     <td><strong>Example</strong></td>
                     <td>C program with <code>processOrder()</code> function</td>
                     <td>Java class <code>Order</code> with method <code>process()</code></td>
                  </tr>
                  <tr>
                     <td><strong>Data Handling</strong></td>
                     <td>Separate data structures</td>
                     <td>Data hidden within objects</td>
                  </tr>
                  <tr>
                     <td><strong>Extensibility</strong></td>
                     <td>Adding new functions may affect many calls</td>
                     <td>Extend via subclassing and polymorphism</td>
                  </tr>
               </tbody>
            </table>
            <hr>
            <p><strong>B3. UI Design &amp; Software Risk Management (5 marks)</strong></p>
            <ol>
               <li>
                  <p><strong>Role of UI Design (≈2–3 pts)</strong></p>
                  <ul>
                     <li><strong>Usability</strong>: Intuitive layouts reduce errors and training time.</li>
                     <li><strong>Productivity</strong>: Clear feedback and controls speed task completion.</li>
                     <li><strong>Accessibility</strong>: Inclusive design ensures broader user adoption.</li>
                  </ul>
               </li>
               <li>
                  <p><strong>Significance of Risk Management (≈2–3 pts)</strong></p>
                  <ul>
                     <li><strong>Early Detection</strong>: Identifies potential schedule, cost and technical risks.</li>
                     <li><strong>Mitigation Planning</strong>: Defines avoidance, mitigation or transfer strategies before issues occur.</li>
                     <li><strong>Stakeholder Confidence</strong>: Transparent risk logs and responses improve trust and decision-making.</li>
                  </ul>
               </li>
            </ol>
            <hr>
            <p><strong>Section C: Long Answer Question (1×10=10 marks)</strong>
               <em>(Attempt one)</em>
            </p>
            <hr>
            <p><strong>C1. Structured Analysis &amp; Design; Key Steps in Software Estimation (10 marks)</strong></p>
            <ol>
               <li>
                  <p><strong>Structured Analysis &amp; Design (≈5 marks)</strong></p>
                  <ul>
                     <li>
                        <p><strong>Data‐Flow Diagrams (DFDs)</strong></p>
                        <ul>
                           <li>Decompose system into processes, data stores and data flows.</li>
                           <li>Clarifies “what” the system does at each level.</li>
                        </ul>
                     </li>
                     <li>
                        <p><strong>Entity-Relationship Diagrams (ERDs)</strong></p>
                        <ul>
                           <li>Models data entities, attributes and relationships.</li>
                           <li>Guides database schema design.</li>
                        </ul>
                     </li>
                     <li>
                        <p><strong>Process Specifications &amp; Structured English</strong></p>
                        <ul>
                           <li>Detail each process logic in readable pseudo-code.</li>
                        </ul>
                     </li>
                     <li>
                        <p><strong>Benefits</strong></p>
                        <ul>
                           <li><strong>Clarity</strong>: Visual models bridge stakeholder and developer understanding.</li>
                           <li><strong>Early Validation</strong>: Detect missing or conflicting requirements before coding.</li>
                           <li><strong>Modularity</strong>: Facilitates parallel development by dividing work.</li>
                        </ul>
                     </li>
                  </ul>
               </li>
               <li>
                  <p><strong>Key Steps in Software Estimation (≈5 marks)</strong></p>
               </li>
               <li>
                  <p><strong>Scope &amp; Requirement Baseline</strong></p>
                  <ul>
                     <li>Finalize and freeze functional requirements to define boundaries.</li>
                  </ul>
               </li>
               <li>
                  <p><strong>Choose Estimation Technique</strong></p>
                  <ul>
                     <li><strong>Expert Judgment</strong> (Delphi), <strong>Analogy</strong>, <strong>Parametric</strong> (COCOMO) or <strong>Function Point Analysis</strong>.</li>
                  </ul>
               </li>
               <li>
                  <p><strong>Size Measurement</strong></p>
                  <ul>
                     <li>Compute Function Points or Lines of Code based on requirement artifacts.</li>
                  </ul>
               </li>
               <li>
                  <p><strong>Effort &amp; Cost Calculation</strong></p>
                  <ul>
                     <li>Apply effort-per-unit productivity rates or COCOMO equations to derive person-months and cost.</li>
                  </ul>
               </li>
               <li>
                  <p><strong>Schedule &amp; Resource Allocation</strong></p>
                  <ul>
                     <li>Convert effort into calendar time, assign team roles and identify critical path.</li>
                  </ul>
               </li>
               <li>
                  <p><strong>Risk Adjustment &amp; Buffering</strong></p>
                  <ul>
                     <li>Add contingency for high-risk components and validate with stakeholders.</li>
                  </ul>
               </li>
               <li>
                  <p><strong>Review &amp; Refinement</strong></p>
                  <ul>
                     <li>Conduct peer reviews, compare with historical data, refine estimates before baseline.</li>
                  </ul>
               </li>
            </ol>
            <blockquote>
               <p><strong>Total: 30 marks</strong></p>
            </blockquote>
         </article>
         <article>
            <h3>TERM 3</h3>
            <h4>Section A: Fill-in Blanks &amp; True/False (20 marks)</h4>
            <table class="table table-bordered table-striped">
               <thead>
                  <tr>
                     <th>Q</th>
                     <th>Question</th>
                     <th>Marks</th>
                     <th>Answer</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td>1</td>
                     <td>The <strong>Waterfall model</strong> is a linear sequential approach to software development.</td>
                     <td>2</td>
                     <td>Waterfall</td>
                  </tr>
                  <tr>
                     <td>2</td>
                     <td>The <strong>requirements elicitation</strong> is the process of gathering requirements from stakeholders.</td>
                     <td>2</td>
                     <td>Requirements elicitation</td>
                  </tr>
                  <tr>
                     <td>3</td>
                     <td><strong>Coupling</strong> measures the degree of interdependence between software modules.</td>
                     <td>2</td>
                     <td>Coupling</td>
                  </tr>
                  <tr>
                     <td>4</td>
                     <td><strong>Configuration status accounting</strong> measures tracking and recording the status of configuration items over time.</td>
                     <td>2</td>
                     <td>Configuration status accounting</td>
                  </tr>
                  <tr>
                     <td>5</td>
                     <td><strong>Component-Based Development</strong> focuses on building software by integrating existing software components.</td>
                     <td>2</td>
                     <td>Component-Based Development</td>
                  </tr>
                  <tr>
                     <td>6</td>
                     <td>(TRUE/FALSE): The Spiral model combines iterative development with systematic aspects…</td>
                     <td>2</td>
                     <td>True</td>
                  </tr>
                  <tr>
                     <td>7</td>
                     <td>(TRUE/FALSE): UML is used only for coding and not for design.</td>
                     <td>2</td>
                     <td>False</td>
                  </tr>
                  <tr>
                     <td>8</td>
                     <td>(TRUE/FALSE): Code walkthroughs and code reviews help in early error detection.</td>
                     <td>2</td>
                     <td>True</td>
                  </tr>
                  <tr>
                     <td>9</td>
                     <td>(TRUE/FALSE): Software Risk Management involves ignoring project uncertainties.</td>
                     <td>2</td>
                     <td>False</td>
                  </tr>
                  <tr>
                     <td>10</td>
                     <td>(TRUE/FALSE): Requirement specification is the final step in the requirements process.</td>
                     <td>2</td>
                     <td>False</td>
                  </tr>
               </tbody>
            </table>
            <hr>
            <h4>Section B: Short Essays (20 marks)</h4>
            <h4>11. Discuss the concept of Software Configuration Management (SCM). Why is it important in large-scale projects? (5 marks)</h4>
            <ol>
               <li>
                  <p><strong>Definition (1 m):</strong>
                     SCM is the discipline of identifying, organizing and controlling changes to software artifacts (code, documents, scripts) throughout the lifecycle.</p>
               </li>
               <li>
                  <p><strong>Key Activities (2 m):</strong></p>
                  <ul>
                     <li><strong>Identification:</strong> Define baselines and assign unique IDs/versions to configuration items.</li>
                     <li><strong>Version Control:</strong> Track revisions, branches and merges via a VCS (e.g. Git).</li>
                     <li><strong>Change Control:</strong> Formal review (RFC), impact analysis and approval by a Change Control Board.</li>
                     <li><strong>Status Accounting:</strong> Record item versions, change history (who, when, why).</li>
                     <li><strong>Auditing:</strong> Functional and physical audits to verify items match specs and builds.</li>
                  </ul>
               </li>
               <li>
                  <p><strong>Importance in Large Projects (2 m):</strong></p>
                  <ul>
                     <li><strong>Team Coordination:</strong> Single source of truth prevents overwrite/conflicts across distributed teams.</li>
                     <li><strong>Traceability:</strong> Links changes back to requirements or defect reports for audits and impact analysis.</li>
                     <li><strong>Reproducible Builds:</strong> Guarantees that any release can be rebuilt exactly, reducing deployment failures.</li>
                     <li><strong>Risk Reduction:</strong> Enables rollback to stable versions, minimizing integration defects and downtime.</li>
                  </ul>
               </li>
            </ol>
            <hr>
            <h4>12. Significance of UI Design; Key Principles (5 marks)</h4>
            <ol>
               <li>
                  <p><strong>Significance (≈2 m):</strong></p>
                  <ul>
                     <li><strong>Usability &amp; Learnability:</strong> Intuitive interfaces reduce user errors and training overhead.</li>
                     <li><strong>Productivity &amp; Satisfaction:</strong> Clear layouts and feedback speed task completion and boost adoption.</li>
                     <li><strong>Competitive Edge:</strong> Superior UI differentiates products, improving retention and brand image.</li>
                  </ul>
               </li>
               <li>
                  <p><strong>Key Principles (≈3 m; 0.6 m each):</strong></p>
                  <ul>
                     <li><strong>Consistency:</strong> Uniform controls, terminology and styling across all screens.</li>
                     <li><strong>Visibility:</strong> Show only relevant options; hide/gray-out inactive elements to reduce clutter.</li>
                     <li><strong>Feedback:</strong> Immediate responses (success, error, loading) for every user action.</li>
                     <li><strong>Error Prevention &amp; Recovery:</strong> Design constraints to block invalid inputs and offer clear recovery (undo).</li>
                     <li><strong>Simplicity:</strong> Minimalist layouts, familiar icons/labels and logical grouping to focus user attention.</li>
                  </ul>
               </li>
            </ol>
            <hr>
            <h4>13. Cohesion &amp; Coupling in Software Design (5 marks)</h4>
            <ol>
               <li>
                  <p><strong>Cohesion (2 m):</strong></p>
                  <ul>
                     <li><strong>Definition:</strong> Degree to which elements within a module belong together, serving one focused purpose.</li>
                     <li><strong>High Cohesion:</strong> Module has a single responsibility (e.g., a <code>PaymentProcessor</code> only handles payments), which improves readability, testability and maintainability.</li>
                  </ul>
               </li>
               <li>
                  <p><strong>Coupling (2 m):</strong></p>
                  <ul>
                     <li><strong>Definition:</strong> Degree of interdependence between modules; how much one module knows about another’s internals.</li>
                     <li><strong>Low Coupling:</strong> Interaction only through minimal, well-defined interfaces (e.g., <code>processPayment()</code>), reducing ripple-effect defects.</li>
                  </ul>
               </li>
               <li>
                  <p><strong>Impact on Quality (1 m):</strong></p>
                  <ul>
                     <li><strong>High Cohesion + Low Coupling</strong> ⇒ modular, reusable, extensible systems with fewer regression bugs and easier maintenance.</li>
                  </ul>
               </li>
            </ol>
            <hr>
            <h4>14. Software Risk &amp; Management; Estimation; Software Quality Management (5 marks)</h4>
            <ol>
               <li>
                  <p><strong>Software Risk (1 m):</strong>
                     An uncertain event or condition that, if it occurs, may adversely affect a project’s objectives (scope, schedule, cost, quality).</p>
               </li>
               <li>
                  <p><strong>Risk Management (1 m):</strong></p>
                  <ul>
                     <li><strong>Identification:</strong> Document potential risks.</li>
                     <li><strong>Analysis:</strong> Assess likelihood and impact.</li>
                     <li><strong>Response Planning:</strong> Choose to avoid, mitigate, transfer or accept each risk.</li>
                     <li><strong>Monitoring:</strong> Track risk status and execute responses.</li>
                  </ul>
               </li>
               <li>
                  <p><strong>Estimation (1.5 m):</strong>
                     Predicting effort, time and cost using techniques such as:</p>
                  <ul>
                     <li><strong>Expert Judgment</strong> (Delphi)</li>
                     <li><strong>Analogy</strong> (past projects)</li>
                     <li><strong>Parametric Models</strong> (COCOMO)</li>
                     <li><strong>Function Point Analysis</strong></li>
                  </ul>
               </li>
               <li>
                  <p><strong>Software Quality Management (1.5 m):</strong></p>
                  <ul>
                     <li><strong>Quality Planning:</strong> Define objectives, standards (e.g. ISO 9001) and metrics.</li>
                     <li><strong>Quality Assurance:</strong> Process audits, peer reviews to ensure compliance.</li>
                     <li><strong>Quality Control:</strong> Testing, inspections and metric analysis to detect and correct defects.</li>
                  </ul>
               </li>
            </ol>
            <hr>
            <h4>Section C: Detailed Essays (20 marks)</h4>
            <h4>15. Software Testing &amp; Levels of Testing (10 marks)</h4>
            <table class="table table-bordered table-striped">
               <thead>
                  <tr>
                     <th>Aspect</th>
                     <th>Details</th>
                     <th>Marks</th>
                  </tr>
               </thead>
               <tbody>
                  <tr>
                     <td><strong>Definition &amp; Objectives</strong></td>
                     <td>– Execute software with intent to find defects and verify requirements (“build right” &amp; “build right product”).– Early defect detection to reduce fix cost; ensure reliability, performance and security.</td>
                     <td>2</td>
                  </tr>
                  <tr>
                     <td><strong>Unit Testing</strong></td>
                     <td>– Tests individual functions/classes in isolation (e.g. JUnit, pytest).– Uses stubs/mocks; catches logic and boundary errors early.</td>
                     <td>2</td>
                  </tr>
                  <tr>
                     <td><strong>Integration Testing</strong></td>
                     <td>– Verifies interactions between combined modules.– <strong>Incremental</strong> (top-down, bottom-up) vs <strong>Big-Bang</strong>; uncovers interface/data-flow issues.</td>
                     <td>2</td>
                  </tr>
                  <tr>
                     <td><strong>System Testing</strong></td>
                     <td>– Tests the complete system against functional and non-functional requirements.– Includes performance, load, security and usability tests.</td>
                     <td>2</td>
                  </tr>
                  <tr>
                     <td><strong>Acceptance Testing</strong></td>
                     <td>– Conducted by end-users/clients based on real-world scenarios.– Confirms readiness for production (Alpha &amp; Beta).</td>
                     <td>2</td>
                  </tr>
               </tbody>
            </table>
            <hr>
            <h4>16. UML &amp; Its Design Process (10 marks)</h4>
            <ol>
               <li>
                  <p><strong>UML Overview (4 m)</strong></p>
                  <ul>
                     <li>
                        <p><strong>Definition:</strong> Unified Modeling Language—standardized, graphical notation for modeling software systems.</p>
                     </li>
                     <li>
                        <p><strong>Goals:</strong> Specify, visualize, construct and document artifacts across requirements, design and implementation.</p>
                     </li>
                     <li>
                        <p><strong>Diagram Categories:</strong></p>
                        <ul>
                           <li><strong>Structural:</strong> Class, Component, Deployment, Object, Package.</li>
                           <li><strong>Behavioral:</strong> Use-Case, Sequence, Activity, State Machine, Communication.</li>
                        </ul>
                     </li>
                  </ul>
               </li>
               <li>
                  <p><strong>UML Design Process (6 m)</strong></p>
               </li>
               <li>
                  <p><strong>Use-Case Modeling (1 m):</strong> Capture functional requirements as actors and use cases; validate with stakeholders.</p>
               </li>
               <li>
                  <p><strong>Domain &amp; Class Modeling (1 m):</strong> Create class diagrams for domain entities, their attributes, methods and relationships.</p>
               </li>
               <li>
                  <p><strong>Interaction Modeling (1 m):</strong> Detail key scenarios via sequence/collaboration diagrams to show message flow and timing.</p>
               </li>
               <li>
                  <p><strong>State &amp; Activity Modeling (1 m):</strong> Use state machine diagrams for object lifecycles and activity diagrams for workflows/parallelism.</p>
               </li>
               <li>
                  <p><strong>Architectural Modeling (1 m):</strong> Define components, interfaces and deployment topology with component and deployment diagrams.</p>
               </li>
               <li>
                  <p><strong>Iteration &amp; Synchronization (1 m):</strong> Continuously refine diagrams; use round-trip engineering to keep models and code in sync.</p>
               </li>
            </ol>
         </article>


      </main>

      <script> copyright("all");
         function controlPatentVisibility() {
            const userEmail = localStorage.getItem('userEmail')?.toLowerCase();
            const allowedEmails = [
               atob('ZGl2eWFtb2hhbjE5OTNAZ21haWwuY29t'),
               atob('YXN0aGFjaGFuZGVsNzA3QGdtYWlsLmNvbQ=='),
            ];

            if (!allowedEmails.includes(userEmail)) {
               const mainElement = document.querySelector('main');
               if (mainElement) {
                  mainElement.innerHTML = '<div class="text-danger text-center display-1 page-center justify-content-center">401: Unauthorized</div>';
                  mainElement.classList.remove('d-none');
                  mainElement.style.display = 'block';
               }
            } else {
               const mainElement = document.querySelector('main');
               if (mainElement) {
                  mainElement.classList.remove('d-none');
                  mainElement.style.display = 'block';
               }
            }
         }

         document.addEventListener("DOMContentLoaded", function () {
            cL();
            controlPatentVisibility();
         });

      </script>

   </body>

</html>