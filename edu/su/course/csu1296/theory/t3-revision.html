<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>

        <meta name="author" content="Divya Mohan">
        <meta name="robots" content="index, follow">

        <!-- Open Graph for Social Media -->
        <meta property="og:image" content="/logo.png">
        <meta property="og:type" content="article">

        <!-- Twitter Cards -->
        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@divyamohan1993">
        <meta name="twitter:creator" content="@divyamohan1993">
        <meta name="twitter:image" content="/logo.png">

        <!-- Mobile Responsiveness -->
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <title>Term 3 Revision - CSU1296 - Shoolini U</title>
        <meta name="description" content="Term 3 Revision - CSU1296 - Shoolini U">

        <script type="application/ld+json">
        {
          "@context": "https://schema.org",
          "@type": "TechArticle",
          "headline": "Term 3 Revision - CSU1296 - Shoolini U",
          "description": "Term 3 Revision - CSU1296 - Shoolini U",
          "dateModified": "2025-05-16",
          "author": [
            {
              "@type": "Person",
              "name": "Divya Mohan",
              "url": "https://dmj.one/resume/",
              "sameAs": [
                "https://www.credly.com/users/divyamohan1993",
                "https://www.linkedin.com/in/divyamohan1993/",
                "https://hackerrank.com/divyamohan1993",
                "https://www.coursera.org/learner/divyamohan1993"
              ]
            }
          ],
          "publisher": {
            "@type": "EducationalOrganization",
            "name": "dmj.one",
            "url": "https://dmj.one"
          },
          "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https://dmj.one/edu/su/course/csu1296/theory/t3-revision"
          },          
          "isAccessibleForFree": true,
          "inLanguage": "en-US",
          "license": "https://www.gnu.org/licenses/agpl-3.0.en.html"
        }
        </script>

        <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                renderMathInElement(document.body, {
                    // customised options
                    // • auto-render specific keys, e.g.:
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\(', right: '\\)', display: false },
                        { left: '\\[', right: '\\]', display: true }
                    ],
                    // • rendering keys, e.g.:
                    throwOnError: false
                });
            });
        </script> -->

        <!-- <style>
            main ul {
                list-style-type: none;
                padding: 0;
                margin: 0;
            }

            main ul li {
                margin: 0;
                padding: 0;
            }
        </style> -->
    </head>

    <body>

        <script> header_author("dm"); </script>

        <main>
            <article class="agen-tableofcontents">
                <h2 class="text-center">
                    Term 3 Revision
                </h2>
                <div class="d-none contentdate">2025, May 16</div>
            </article>

            <article>
                <h3><strong>Software Crisis (Meaning)</strong></h3>
                <p>When software demand, complexity, and challenges increase but we still use the same workforce, tools, and methods — it leads to serious problems like delays, poor quality, and unmanageable code. This is called a <strong>Software Crisis</strong>.</p>
                
            </article>
            <article>
                <h3><strong>When It Happens</strong></h3>
                <ul>
                    <li>Project takes too much <strong>time</strong></li>
                    <li>Project goes <strong>over budget</strong></li>
                    <li>Software is <strong>inefficient</strong></li>
                    <li><strong>Poor quality</strong> software</li>
                    <li>Doesn't meet <strong>requirements</strong></li>
                    <li>Code is <strong>hard to manage or maintain</strong></li>
                    <li>Software is <strong>never ready for delivery</strong></li>
                </ul>
                
            </article>
            <article>
                <h3><strong>Main Reasons</strong></h3>
                <ul>
                    <li><strong>Scaling problems</strong></li>
                    <li><strong>High cost</strong></li>
                    <li><strong>Late delivery</strong></li>
                    <li><strong>Unreliable software</strong></li>
                    <li><strong>Low productivity</strong></li>
                    <li>Poor understanding of the <strong>problem or environment</strong></li>
                    <li><strong>Complex problems</strong></li>
                    <li><strong>Duplicated effort</strong> due to lack of automation</li>
                </ul>
                
            </article>
            <article>
                <h3><strong>Solution</strong></h3>
                <p>The best approach is <strong>Software Engineering</strong> because it is:</p>
                <ul>
                    <li><strong>Systematic</strong></li>
                    <li><strong>Disciplined</strong></li>
                    <li><strong>Quantifiable</strong></li>
                </ul>
                <p>Guidelines to solve the crisis:</p>
                <ul>
                    <li>Reduce <strong>budget overruns</strong></li>
                    <li>Improve <strong>software quality</strong></li>
                    <li>Save <strong>development time</strong></li>
                    <li>Use <strong>experienced teams</strong></li>
                </ul>
            </article>
            <article>
                <h3><strong>Generic Software Process Activities</strong></h3>
                <ol>
                    <li>
                        <p><strong>Communication</strong></p>
                        <ul>
                            <li>Talk to customers, developers, and stakeholders</li>
                            <li>Gather <strong>requirements</strong></li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Planning</strong></p>
                        <ul>
                            <li>Define tasks, schedule, resources, risks</li>
                            <li>Estimate and track <strong>project progress</strong></li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Modeling</strong></p>
                        <ul>
                            <li>Create <strong>representations</strong> (like algorithms, flowcharts)</li>
                            <li>Analyze <strong>requirements</strong> and design the system</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Construction</strong></p>
                        <ul>
                            <li><strong>Code</strong> the software</li>
                            <li><strong>Test</strong> the code to ensure correct output and logic</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Deployment</strong></p>
                        <ul>
                            <li>Deliver the product to the <strong>customer</strong></li>
                            <li>Take <strong>feedback</strong> and make corrections if needed</li>
                        </ul>
                    </li>
                </ol>
            </article>
            <article>
                <h3><strong>Software Life Cycle Models</strong></h3>
                <p>They define <strong>phases</strong> and <strong>sequence</strong> to develop software.
                    Popular SDLC models:</p>
                <ul>
                    <li><strong>Waterfall Model</strong></li>
                    <li><strong>Iterative Waterfall Model</strong></li>
                    <li><strong>Incremental Model</strong></li>
                    <li><strong>Agile Model</strong></li>
                    <li><strong>Spiral Model</strong></li>
                    <li><strong>Prototype Model</strong></li>
                </ul>
                
            </article>
            <article>
                <h3><strong>Waterfall Model (Classic)</strong></h3>
                <ul>
                    <li>First widely used model</li>
                    <li><strong>Linear &amp; sequential</strong> — next phase starts only when previous is complete</li>
                    <li><strong>No feedback loops</strong></li>
                    <li><strong>Easy to understand</strong>, good for <strong>small projects</strong></li>
                </ul>
                <h4>Phases and Deliverables:</h4>
                <ol>
                    <li>
                        <p><strong>Requirement Analysis</strong></p>
                        <ul>
                            <li>Understand &amp; validate requirements</li>
                            <li>📄 Deliverable: RUD (Requirements Understanding Document)</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>System Design</strong></p>
                        <ul>
                            <li>Design system as per requirements</li>
                            <li>📄 Deliverables: HLD (High Level), LLD (Low Level)</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Implementation</strong></p>
                        <ul>
                            <li>Write and unit test code</li>
                            <li>📄 Deliverable: Code + results</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>System Testing</strong></p>
                        <ul>
                            <li>Integrate and test system (functional + non-functional)</li>
                            <li>📄 Deliverables: Test cases, reports, defect list</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Deployment</strong></p>
                        <ul>
                            <li>Deploy to real environment, ensure setup works</li>
                            <li>📄 Deliverables: User Manual, Environment Docs</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Maintenance</strong></p>
                        <ul>
                            <li>Fix bugs, add new features</li>
                            <li>📄 Deliverables: Production issues log, updated user manual</li>
                        </ul>
                    </li>
                </ol>
                <h4>Advantages:</h4>
                <ul>
                    <li>Simple, structured</li>
                    <li>Easy maintenance</li>
                    <li>Works for small, fixed-scope projects</li>
                    <li>Clear documentation</li>
                </ul>
                <h4>Disadvantages:</h4>
                <ul>
                    <li><strong>No changes allowed</strong> in middle</li>
                    <li><strong>Late delivery</strong> (no prototypes shown)</li>
                    <li><strong>Poor for large or evolving projects</strong></li>
                    <li><strong>Late testing = late risk discovery</strong></li>
                </ul>
                
            </article>
            <article>
                <h3><strong>Iterative Waterfall Model</strong></h3>
                <ul>
                    <li>Same phases as Waterfall, <strong>but with feedback loops</strong></li>
                    <li>Can go <strong>back to previous phases</strong> to fix issues</li>
                    <li>Errors caught <strong>early in the same phase</strong></li>
                </ul>
                <h4>Advantages:</h4>
                <ul>
                    <li>Easier to fix mistakes</li>
                    <li>Saves time and cost</li>
                    <li>Better for <strong>large &amp; complex projects</strong></li>
                </ul>
                <h4>Limitations:</h4>
                <ul>
                    <li>Not good if requirements are unclear</li>
                    <li>No customer preview/prototype</li>
                    <li>Not ideal for <strong>short or frequently changing projects</strong></li>
                </ul>
            </article>
            <article>
                <h3><strong>Spiral Model (Meta Model)</strong></h3>
                <ul>
                    <li>Combines <strong>iterative</strong> &amp; <strong>waterfall</strong> approaches</li>
                    <li>Each <strong>loop = development phase</strong></li>
                    <li><strong>Risk analysis</strong> is key in every phase</li>
                    <li><strong>Radius = Cost</strong>, <strong>Angle = Progress</strong></li>
                </ul>
                <h4><strong>Phases in Each Loop</strong></h4>
                <ol>
                    <li><strong>Planning</strong></li>
                    <li><strong>Risk Analysis</strong></li>
                    <li><strong>Development &amp; Testing</strong></li>
                    <li><strong>Evaluation</strong> (customer feedback)</li>
                </ol>
                
            </article>
            <article>
                <h3><strong>When to Use Spiral Model</strong></h3>
                <ul>
                    <li>Large, <strong>complex</strong> projects</li>
                    <li><strong>Unclear or changing</strong> requirements</li>
                    <li><strong>High-risk</strong> projects</li>
                    <li>Frequent releases needed</li>
                </ul>
                
            </article>
            <article>
                <h3><strong>Advantages</strong></h3>
                <ul>
                    <li>Handles <strong>risk</strong> very well</li>
                    <li>Allows <strong>requirement changes</strong></li>
                    <li>Produces working software <strong>early</strong></li>
                    <li>High <strong>customer satisfaction</strong></li>
                    <li>Good for <strong>complex and critical</strong> systems</li>
                </ul>
                
            </article>
            <article>
                <h3><strong>Disadvantages</strong></h3>
                <ul>
                    <li>Not suitable for <strong>small or low-risk</strong> projects</li>
                    <li><strong>Costly &amp; complex</strong> process</li>
                    <li>Needs <strong>expertise</strong> in risk handling</li>
                    <li>Time estimation is <strong>difficult</strong></li>
                    <li>May <strong>never end</strong> without clear limits</li>
                    <li>Too much <strong>documentation</strong></li>
                </ul>
                
            </article>
            <article>
                <h3><strong>Win-Win Spiral Model</strong></h3>
                <ul>
                    <li><strong>Enhancement</strong> of Spiral with stakeholder negotiation</li>
                    <li>Ensures both <strong>customer</strong> and <strong>developer</strong> goals are met</li>
                </ul>
                <h4><strong>3 Anchor Points</strong></h4>
                <ol>
                    <li><strong>LCO</strong> – Life Cycle Objectives</li>
                    <li><strong>LCA</strong> – Life Cycle Architecture</li>
                    <li><strong>IOC</strong> – Initial Operational Capability</li>
                </ol>
                
            </article>
            <article>
                <h3><strong>7 Steps in Win-Win Spiral Model</strong></h3>
                <ol>
                    <li>Identify <strong>stakeholders</strong></li>
                    <li>Identify their <strong>win conditions</strong></li>
                    <li><strong>Reconcile</strong> win conditions → set goals &amp; constraints</li>
                    <li><strong>Evaluate</strong> alternatives, manage risks</li>
                    <li>Define <strong>next level product/process</strong>, possibly split into subsystems</li>
                    <li><strong>Validate</strong> product/process</li>
                    <li>Go to next loop with agreed goals</li>
                </ol>
            </article>
            <article>
                <h3><strong>Agile Software Development</strong></h3>
                <ul>
                    <li><strong>Flexible, fast</strong>, and <strong>incremental</strong> approach</li>
                    <li>Focuses more on <strong>working code</strong> than heavy documentation</li>
                    <li>Uses <strong>Sprints</strong> (short, time-boxed iterations)</li>
                    <li>Encourages <strong>team collaboration</strong> and <strong>customer feedback</strong></li>
                    <li>Adapts quickly to <strong>changing requirements</strong></li>
                </ul>
                
            </article>
            <article>
                <h3><strong>Agile Manifesto: 4 Core Values</strong></h3>
                <ol>
                    <li><strong>Individuals and Interactions</strong> over processes/tools</li>
                    <li><strong>Working Software</strong> over documentation</li>
                    <li><strong>Customer Collaboration</strong> over contract negotiation</li>
                    <li><strong>Responding to Change</strong> over following a plan</li>
                </ol>
                
            </article>
            <article>
                <h3><strong>Agile Principles (Key Points)</strong></h3>
                <ul>
                    <li><strong>Early &amp; continuous delivery</strong></li>
                    <li><strong>Welcome change</strong> anytime in project</li>
                    <li><strong>Frequent delivery</strong> of working software</li>
                    <li><strong>Daily collaboration</strong> with business team</li>
                    <li>Build around <strong>motivated individuals</strong></li>
                    <li>Prefer <strong>face-to-face communication</strong></li>
                    <li>Focus on <strong>working solutions</strong>, not effort</li>
                    <li>Maintain <strong>constant pace</strong></li>
                    <li>Aim for <strong>technical excellence</strong></li>
                    <li>Keep it <strong>simple</strong></li>
                    <li>Use <strong>self-organizing teams</strong></li>
                    <li><strong>Reflect &amp; improve</strong> regularly</li>
                </ul>
                
            </article>
            <article>
                <h3><strong>Advantages</strong></h3>
                <ul>
                    <li><strong>Fast deployment</strong></li>
                    <li><strong>Quick response</strong> to change</li>
                    <li><strong>Customer feedback</strong> improves quality</li>
                    <li><strong>Better team communication</strong></li>
                    <li>Higher <strong>technical quality</strong> and <strong>transparency</strong></li>
                </ul>
                
            </article>
            <article>
                <h3><strong>Disadvantages</strong></h3>
                <ul>
                    <li>Less documentation</li>
                    <li>Needs <strong>active customer involvement</strong></li>
                    <li>Harder in <strong>large teams</strong></li>
                    <li>New developers may struggle (needs experience)</li>
                </ul>
            </article>
            <article>
                <h3><strong>Purpose of PSP &amp; TSP</strong></h3>
                <p>Both help improve:</p>
                <ul>
                    <li><strong>Software quality</strong></li>
                    <li><strong>Secure and disciplined processes</strong></li>
                    <li><strong>Process management</strong> at personal and team level</li>
                </ul>
                
            </article>
            <article>
                <h3><strong>TSP (Team Software Process)</strong></h3>
                <ul>
                    <li>Developed by <strong>SEI, Carnegie Mellon</strong></li>
                    <li>Focus: <strong>Team productivity, planning, collaboration, and quality</strong></li>
                </ul>
                <h4><strong>Key Concepts</strong></h4>
                <ul>
                    <li><strong>Structured teamwork</strong> with defined roles (e.g., manager, developer)</li>
                    <li><strong>Iterative cycles</strong> with regular feedback</li>
                    <li><strong>Goal setting</strong> (quality, time, cost)</li>
                    <li><strong>Project planning</strong> with estimates, workload balance</li>
                    <li><strong>Metrics-driven</strong> decisions (defects, effort, productivity)</li>
                    <li><strong>Built-in quality</strong> via reviews, unit tests, tracking</li>
                </ul>
                <h4><strong>TSP Phases</strong></h4>
                <ol>
                    <li><strong>Launch</strong> – Define goals, assign roles, plan</li>
                    <li><strong>Implementation</strong> – Coding, testing, reviews</li>
                    <li><strong>Postmortem</strong> – Analyze results and improve for next time</li>
                </ol>
                <h4><strong>TSP Benefits</strong></h4>
                <ul>
                    <li>Higher <strong>productivity</strong> and <strong>quality</strong></li>
                    <li>Fewer <strong>defects</strong></li>
                    <li>Better <strong>scheduling &amp; estimation</strong></li>
                    <li>Strong <strong>team coordination</strong></li>
                </ul>
                
            </article>
            <article>
                <h3><strong>PSP (Personal Software Process)</strong></h3>
                <ul>
                    <li>Focus: <strong>Individual developer’s process improvement</strong></li>
                    <li>Promotes <strong>self-discipline, quality control, and time management</strong></li>
                </ul>
                <h4><strong>Key Concepts</strong></h4>
                <ul>
                    <li><strong>Self-improvement</strong> in habits and process</li>
                    <li>Track <strong>defects</strong> and use <strong>reviews</strong> for early error detection</li>
                    <li>Estimate <strong>task time</strong> and set <strong>personal goals</strong></li>
                    <li>Record <strong>time and effort data</strong></li>
                    <li>Analyze <strong>productivity</strong> and identify delays</li>
                    <li>Improve personal <strong>process with data insights</strong></li>
                </ul>
                <h4><strong>PSP Phases</strong></h4>
                <ol>
                    <li><strong>Planning</strong> – Task/time estimates</li>
                    <li><strong>Design</strong> – Detailed design to avoid defects</li>
                    <li><strong>Development</strong> – Code with time tracking</li>
                    <li><strong>Testing</strong> – Unit testing and code reviews</li>
                    <li><strong>Postmortem</strong> – Analyze and improve</li>
                </ol>
                
            </article>
            <article>
                <h3><strong>Relationship Between PSP &amp; TSP</strong></h3>
                <ul>
                    <li><strong>PSP = Individual level</strong>, forms the <strong>base</strong> of</li>
                    <li><strong>TSP = Team level</strong>, built on PSP discipline</li>
                    <li>Both use <strong>data and metrics</strong> for continuous improvement</li>
                    <li>PSP → TSP = <strong>Scalable</strong> from personal to team projects</li>
                </ul>
            </article>
            <article>
                <h3><strong>Personal Software Process (PSP) – Example (John)</strong></h3>
                <p><strong>Scenario</strong>: John develops a <em>product review</em> feature for an e-commerce site.</p>
                <ol>
                    <li>
                        <p><strong>Planning</strong></p>
                        <ul>
                            <li>Estimated: 10 hours</li>
                            <li>Tasks: DB design, UI, backend logic, unit testing</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Time Tracking</strong></p>
                        <ul>
                            <li>Actual time: 12 hours</li>
                            <li>Breakdown: DB – 2h, UI – 3h, Backend – 4h, Testing – 2h</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Defect Tracking</strong></p>
                        <ul>
                            <li>Backend caused 5 bugs</li>
                            <li>Fix time: +1 hour</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Postmortem</strong></p>
                        <ul>
                            <li>Underestimated UI time</li>
                            <li>Backend needs better design to reduce bugs</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Improvements</strong></p>
                        <ul>
                            <li>Next time: more design focus, better time estimates</li>
                        </ul>
                    </li>
                </ol>
                
            </article>
            <article>
                <h3><strong>Team Software Process (TSP) – Example (Team Project)</strong></h3>
                <p><strong>Scenario</strong>: John works in a team on a <em>recommendation engine</em>.</p>
                <ol>
                    <li>
                        <p><strong>Team Roles</strong></p>
                        <ul>
                            <li>Team Leader, Developer (John), Quality Manager, Planning Manager</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Planning</strong></p>
                        <ul>
                            <li>
                                <p>Tasks assigned:</p>
                                <ul>
                                    <li>Data: 20h (Data Engineer)</li>
                                    <li>Backend: 15h (John)</li>
                                    <li>UI: 10h (Frontend Dev)</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Team Coordination</strong></p>
                        <ul>
                            <li>Everyone logs hours in shared system</li>
                            <li>Regular review meetings</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Quality Control</strong></p>
                        <ul>
                            <li>Code reviewed by Quality Manager</li>
                            <li>Testing team runs integration/system tests</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Metrics Tracking</strong></p>
                        <ul>
                            <li>
                                <p>Track:</p>
                                <ul>
                                    <li><strong>Defect density</strong></li>
                                    <li><strong>Team velocity</strong></li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Postmortem</strong></p>
                        <ul>
                            <li>John’s backend = low defects (good reviews/testing)</li>
                            <li>Delay: 5h due to UI issues</li>
                            <li>Improvement: Better backend–frontend coordination next time</li>
                        </ul>
                    </li>
                </ol>
            </article>
            <article>
                <h3><strong>Goal:</strong></h3>
                <p>Choose the best SDLC model based on <strong>project needs</strong> (size, complexity, budget, time, etc.)</p>
                
            </article>
            <article>
                <h3><strong>Key Parameters for Model Selection</strong></h3>
                <ol>
                    <li>
                        <p><strong>Requirements Characteristics</strong></p>
                        <ul>
                            <li>Are requirements <strong>clear and stable</strong>?</li>
                            <li>Will they <strong>change frequently</strong>?</li>
                            <li>Are they <strong>complex</strong> or <strong>numerous</strong>?</li>
                            <li>Can they be defined <strong>early</strong>?</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Development Team</strong></p>
                        <ul>
                            <li>Team <strong>size</strong></li>
                            <li>Developers’ <strong>experience</strong> in similar projects and technologies</li>
                            <li>Level of <strong>domain knowledge</strong></li>
                            <li><strong>Understanding</strong> of user requirements</li>
                            <li><strong>Training</strong> availability</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>User Involvement</strong></p>
                        <ul>
                            <li>User’s <strong>expertise</strong> and <strong>experience</strong></li>
                            <li>Will users be involved in <strong>all phases</strong>?</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Project Type &amp; Risk</strong></p>
                        <ul>
                            <li><strong>Project size &amp; duration</strong></li>
                            <li><strong>Budget stability</strong></li>
                            <li><strong>Resource availability</strong></li>
                            <li><strong>Schedule pressure</strong></li>
                            <li><strong>Complexity and risk level</strong></li>
                        </ul>
                    </li>
                </ol>
                
                <p>Based on these factors, models like <strong>Agile</strong> (for changing requirements), <strong>Waterfall</strong> (for clear requirements), or <strong>Spiral</strong> (for high risk) can be selected.</p>
            </article>
            <article>
                <h3><strong>Software Requirement</strong></h3>
                <ul>
                    <li>A <strong>feature</strong>, <strong>function</strong>, or <strong>condition</strong> that the <strong>user needs</strong></li>
                    <li>Must satisfy <strong>contract</strong>, <strong>standard</strong>, or <strong>specification</strong></li>
                </ul>
                
            </article>
            <article>
                <h3><strong>Requirement Engineering</strong></h3>
                <ul>
                    <li>Process of <strong>defining, documenting, and managing</strong> requirements</li>
                    <li>Helps understand what customer wants, analyzes it, checks if it’s feasible, then clearly specifies and validates it</li>
                </ul>
                
            </article>
            <article>
                <h3><strong>Requirement Engineering Process</strong></h3>
                <ol>
                    <li>
                        <p><strong>Feasibility Study</strong></p>
                        <ul>
                            <li>
                                <p>Checks if project is <strong>practical and beneficial</strong></p>
                            </li>
                            <li>
                                <p>Types:</p>
                                <ul>
                                    <li><strong>Technical</strong>: Can tech meet needs?</li>
                                    <li><strong>Operational</strong>: Will it solve the problem?</li>
                                    <li><strong>Economic</strong>: Is it profitable?</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Requirement Elicitation &amp; Analysis</strong></p>
                        <ul>
                            <li>
                                <p>Gather needs from customers, users, stakeholders</p>
                            </li>
                            <li>
                                <p>Common issues:</p>
                                <ul>
                                    <li>Wrong people involved</li>
                                    <li>Users unclear or change minds</li>
                                    <li>Conflicting needs</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Software Requirement Specification (SRS)</strong></p>
                        <ul>
                            <li>
                                <p>Analyst converts user requirements into <strong>technical document</strong></p>
                            </li>
                            <li>
                                <p>Tools used:</p>
                                <ul>
                                    <li><strong>DFD</strong> (Data Flow Diagram): shows data movement</li>
                                    <li><strong>Data Dictionary</strong>: defines terms clearly</li>
                                    <li><strong>E-R Diagram</strong>: shows entities, relationships, attributes</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Requirement Validation</strong></p>
                        <ul>
                            <li>
                                <p>Check if requirements are:</p>
                                <ul>
                                    <li><strong>Feasible</strong>, <strong>Correct</strong>, <strong>Complete</strong>, <strong>Clear</strong></li>
                                </ul>
                            </li>
                            <li>
                                <p>Techniques:</p>
                                <ul>
                                    <li><strong>Reviews/Inspections</strong></li>
                                    <li><strong>Prototyping</strong></li>
                                    <li><strong>Test-case generation</strong></li>
                                    <li><strong>Automated consistency checks</strong></li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ol>
            </article>
            <article>
                <h3><strong>Fundamental Issues in Software Design</strong></h3>
                <ol>
                    <li>
                        <p><strong>Meeting User Requirements</strong></p>
                        <ul>
                            <li>Understand what the <strong>user really needs</strong></li>
                            <li>If needs are missed, software becomes <strong>useless</strong></li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Maintaining Simplicity</strong></p>
                        <ul>
                            <li>Avoid <strong>unnecessary complexity</strong></li>
                            <li>Simple UI = better <strong>usability and fewer errors</strong></li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Scalability</strong></p>
                        <ul>
                            <li>Software should handle <strong>growth</strong> in users/data</li>
                            <li>Poor scalability = <strong>crashes or slowdowns</strong></li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Performance</strong></p>
                        <ul>
                            <li>Must run <strong>fast</strong> and use resources <strong>efficiently</strong></li>
                            <li>Slow software = <strong>frustrated users</strong></li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Security</strong></p>
                        <ul>
                            <li>Protect against <strong>unauthorized access</strong></li>
                            <li>Critical for sensitive domains like <strong>banking</strong></li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Flexibility &amp; Maintainability</strong></p>
                        <ul>
                            <li>Easy to <strong>update</strong>, add features, or <strong>fix bugs</strong></li>
                            <li>Important for long-term <strong>software evolution</strong></li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Handling Errors &amp; Failures</strong></p>
                        <ul>
                            <li>Should show <strong>helpful error messages</strong>, not crash</li>
                            <li>Makes software <strong>reliable and user-friendly</strong></li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Usability</strong></p>
                        <ul>
                            <li>Easy to <strong>learn and use</strong></li>
                            <li>Better usability = <strong>fewer mistakes</strong> and higher <strong>productivity</strong></li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Interoperability</strong></p>
                        <ul>
                            <li>Should work with <strong>other systems/software</strong></li>
                            <li>Essential for <strong>data sharing and integration</strong></li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Cost &amp; Time Management</strong></p>
                    </li>
                </ol>
                <ul>
                    <li>Stay within <strong>budget</strong> and <strong>schedule</strong></li>
                    <li>Helps avoid <strong>delays and overspending</strong></li>
                </ul>
            </article>
            <article>
                <h3><strong>Cohesion</strong></h3>
                <ul>
                    <li><strong>Definition</strong>: How closely related and focused the functions inside a module/class are</li>
                    <li><strong>Goal</strong>: High Cohesion = each module does <strong>one specific task</strong> well</li>
                </ul>
                <h4><strong>High Cohesion</strong></h4>
                <ul>
                    <li>Parts inside the module are <strong>related and focused</strong></li>
                    <li>Easier to <strong>understand, maintain, and reuse</strong></li>
                    <li><em>Example</em>: Separate modules for Product Management, Cart, Checkout in an e-commerce app</li>
                </ul>
                <h4><strong>Low Cohesion</strong></h4>
                <ul>
                    <li>Module handles <strong>unrelated tasks</strong></li>
                    <li>Leads to <strong>confusing and error-prone</strong> code</li>
                    <li><em>Example</em>: Cart module also handling user login or profile tasks</li>
                </ul>
                
            </article>
            <article>
                <h3><strong>Coupling</strong></h3>
                <ul>
                    <li><strong>Definition</strong>: How much one module depends on another</li>
                    <li><strong>Goal</strong>: Low Coupling = modules are <strong>independent</strong></li>
                </ul>
                <h4><strong>Low Coupling</strong></h4>
                <ul>
                    <li>Modules interact via <strong>well-defined interfaces</strong></li>
                    <li>You can change one module without affecting others</li>
                    <li><em>Example</em>: Payment system works independently from Cart or Product modules</li>
                </ul>
                <h4><strong>High Coupling</strong></h4>
                <ul>
                    <li>Modules are <strong>tightly connected</strong></li>
                    <li>Change in one requires changes in others</li>
                    <li><em>Example</em>: Cart logic directly accessing payment gateway internals</li>
                </ul>
                
            </article>
            <article>
                <h3><strong>Cohesion vs Coupling</strong></h3>
                <table class="table table-bordered table-striped">
                    <thead>
                        <tr>
                            <th>Concept</th>
                            <th>Good Practice</th>
                            <th>Poor Practice</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Cohesion</strong></td>
                            <td>High (Focused tasks)</td>
                            <td>Low (Unrelated tasks)</td>
                        </tr>
                        <tr>
                            <td><strong>Coupling</strong></td>
                            <td>Low (Independent modules)</td>
                            <td>High (Tightly linked)</td>
                        </tr>
                    </tbody>
                </table>
                
            </article>
            <article>
                <h3><strong>Combined Best Practice</strong></h3>
                <ul>
                    <li>
                        <p>Aim for <strong>High Cohesion + Low Coupling</strong></p>
                    </li>
                    <li>
                        <p>Results in:</p>
                        <ul>
                            <li>Easier maintenance</li>
                            <li>Higher flexibility &amp; reuse</li>
                            <li>Better testing/debugging</li>
                        </ul>
                    </li>
                </ul>
                
            </article>
            <article>
                <h3><strong>Real Example: Amazon</strong></h3>
                <ul>
                    <li><strong>High Cohesion</strong>: Separate modules for product display, cart, payments, user accounts</li>
                    <li><strong>Low Coupling</strong>: Adding a new payment method doesn’t affect cart or product modules</li>
                </ul>
            </article>
            <article>
                <h3><strong>Function-Oriented Design (FOD)</strong></h3>
                <ul>
                    <li>Software is <strong>divided into functions</strong> performing specific tasks</li>
                    <li>Follows <strong>top-down design</strong> using <strong>data flow</strong></li>
                    <li>Focus is on <strong>processes/actions</strong>, not objects (unlike OOP)</li>
                </ul>
                
            </article>
            <article>
                <h3><strong>General Procedure</strong></h3>
                <ol>
                    <li>Start with <strong>what the system does</strong></li>
                    <li>Break it into <strong>high-level → low-level functions</strong></li>
                </ol>
                
            </article>
            <article>
                <h3><strong>Key Concepts</strong></h3>
                <ul>
                    <li><strong>Functional decomposition</strong></li>
                    <li><strong>Data flows</strong> between modules</li>
                    <li><strong>Top-down design</strong></li>
                    <li>Focus on <strong>input → process → output</strong></li>
                </ul>
                
            </article>
            <article>
                <h3><strong>Example</strong>: Online Library System</h3>
                <ul>
                    <li>Main function: <code>LibrarySystem()</code></li>
                    <li>Sub-functions: <code>UserManagement()</code>, <code>BookManagement()</code>, <code>BorrowBooks()</code></li>
                    <li>Further broken down into: <code>registerUser()</code>, <code>addBook()</code>, etc.</li>
                </ul>
                
            </article>
            <article>
                <h3><strong>Advantages</strong></h3>
                <ul>
                    <li>Easy to understand</li>
                    <li>Good for small/medium projects</li>
                    <li>Reusable functions</li>
                </ul>
            </article>
            <article>
                <h3><strong>Disadvantages</strong></h3>
                <ul>
                    <li>Hard to modify in large systems</li>
                    <li>Poor security (data shared freely)</li>
                    <li>Not suitable for complex applications</li>
                </ul>
                
            </article>
            <article>
                <h3><strong>FOD Strategies</strong></h3>
                <h4>1. <strong>Data Flow Diagrams (DFD)</strong></h4>
                <ul>
                    <li>
                        <p>Show how <strong>data moves</strong> through the system</p>
                    </li>
                    <li>
                        <p>Types:</p>
                        <ul>
                            <li><strong>Logical DFD</strong> – Focus on process</li>
                            <li><strong>Physical DFD</strong> – Focus on implementation</li>
                        </ul>
                    </li>
                </ul>
                <h5>DFD Components:</h5>
                <table class="table table-bordered table-striped">
                    <thead>
                        <tr>
                            <th>Symbol</th>
                            <th>Meaning</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>▭</td>
                            <td><strong>Entity</strong> (source/destination)</td>
                        </tr>
                        <tr>
                            <td>○</td>
                            <td><strong>Process</strong> (action/function)</td>
                        </tr>
                        <tr>
                            <td>=▭=</td>
                            <td><strong>Data Store</strong> (storage)</td>
                        </tr>
                        <tr>
                            <td>→</td>
                            <td><strong>Data Flow</strong> (movement)</td>
                        </tr>
                    </tbody>
                </table>
                <h5>DFD Levels:</h5>
                <ul>
                    <li><strong>Level 0</strong>: Entire system as one process (Context Diagram)</li>
                    <li><strong>Level 1</strong>: Breaks Level 0 into basic modules</li>
                    <li><strong>Level 2</strong>: Further details each module from Level 1</li>
                </ul>
                <h5>DFD Rules:</h5>
                <ol>
                    <li>Every process = 1 input, 1 output</li>
                    <li>Every data store = at least 1 input and 1 output</li>
                    <li>All flows must go to a <strong>process or store</strong></li>
                </ol>
                
                <h4>2. <strong>Data Dictionary</strong></h4>
                <ul>
                    <li>Stores <strong>metadata</strong> (data about data)</li>
                    <li>Describes all elements used in DFDs</li>
                </ul>
                <p><strong>Example</strong>:</p>
                <table class="table table-bordered table-striped">
                    <thead>
                        <tr>
                            <th>Attribute</th>
                            <th>Datatype</th>
                            <th>Size</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Student_ID</td>
                            <td>Int</td>
                            <td>03</td>
                            <td>Unique student ID</td>
                        </tr>
                        <tr>
                            <td>Name</td>
                            <td>String</td>
                            <td>20</td>
                            <td>Student name</td>
                        </tr>
                    </tbody>
                </table>
                <p><strong>Types</strong>:</p>
                <ul>
                    <li><strong>Active</strong>: Auto-updated with DB changes</li>
                    <li><strong>Passive</strong>: Must be updated <strong>manually</strong></li>
                </ul>
            </article>
            <article>
                <h3><strong>Structured Analysis</strong></h3>
                <ul>
                    <li>Focus: <strong>What the system should do</strong></li>
                    <li>Uses <strong>graphical tools</strong> to understand and define system requirements</li>
                </ul>
                <h4><strong>Purpose</strong></h4>
                <ul>
                    <li>Understand <strong>user needs</strong> clearly</li>
                    <li>Break system into <strong>manageable parts</strong></li>
                    <li>Define <strong>logical relationships</strong></li>
                    <li>Ensure <strong>consistency, scalability, maintainability</strong></li>
                </ul>
                
            </article>
            <article>
                <h3><strong>Tools Used in Analysis Phase</strong></h3>
                <table class="table table-bordered table-striped">
                    <thead>
                        <tr>
                            <th>Tool</th>
                            <th>Purpose</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>DFD (Data Flow Diagram)</strong></td>
                            <td>Shows flow of data, processes, stores, entities</td>
                        </tr>
                        <tr>
                            <td><strong>ERD (Entity Relationship Diagram)</strong></td>
                            <td>Shows entities, attributes, and relationships</td>
                        </tr>
                        <tr>
                            <td><strong>Data Dictionary</strong></td>
                            <td>Defines all data elements and attributes</td>
                        </tr>
                        <tr>
                            <td><strong>Process Specification (PSPEC)</strong></td>
                            <td>Describes logic using structured English or flowcharts</td>
                        </tr>
                        <tr>
                            <td><strong>Decision Tree / State Transition Diagram</strong></td>
                            <td>Used for complex logic or state-based modeling</td>
                        </tr>
                    </tbody>
                </table>
                
            </article>
            <article>
                <h3><strong>Structured Design</strong></h3>
                <ul>
                    <li>Focus: <strong>How the system will be built</strong></li>
                    <li>Converts analysis into a working <strong>modular design</strong></li>
                </ul>
                
            </article>
            <article>
                <h3><strong>Tools Used in Design Phase</strong></h3>
                <table class="table table-bordered table-striped">
                    <thead>
                        <tr>
                            <th>Tool</th>
                            <th>Purpose</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Structure Chart</strong></td>
                            <td>Shows module hierarchy and data flow</td>
                        </tr>
                        <tr>
                            <td><strong>Pseudo Code</strong></td>
                            <td>Describes internal logic of modules</td>
                        </tr>
                        <tr>
                            <td><strong>Modular Design</strong></td>
                            <td>Breaks system into cohesive, loosely coupled modules</td>
                        </tr>
                        <tr>
                            <td><strong>Database Design</strong></td>
                            <td>Defines tables, keys, relationships, normalization</td>
                        </tr>
                        <tr>
                            <td><strong>Interface Design</strong></td>
                            <td>Describes how users interact with the system (UI/UX)</td>
                        </tr>
                        <tr>
                            <td><strong>Control Flow Design</strong></td>
                            <td>Specifies decision-making and process flow</td>
                        </tr>
                    </tbody>
                </table>
                
            </article>
            <article>
                <h3><strong>Advantages of SAD</strong></h3>
                <ul>
                    <li>Clear understanding with diagrams</li>
                    <li>Easier <strong>maintenance &amp; debugging</strong></li>
                    <li>Better communication with stakeholders</li>
                    <li>Efficient <strong>resource usage</strong></li>
                    <li>System is <strong>scalable</strong></li>
                </ul>
            </article>
            <article>
                <h3><strong>Disadvantages of SAD</strong></h3>
                <ul>
                    <li><strong>Time-consuming</strong> due to detailed planning</li>
                    <li><strong>Rigid</strong> structure (hard to change once designed)</li>
                    <li>Not ideal for <strong>agile or fast-changing projects</strong></li>
                </ul>
            </article>
            <article>
                <h3><strong>What is UML?</strong></h3>
                <ul>
                    <li><strong>Unified Modeling Language</strong> = <strong>standard visual language</strong> to design and understand software systems</li>
                    <li>Not a programming language — it’s for <strong>visualizing</strong> system <strong>structure</strong> and <strong>behavior</strong></li>
                    <li>Helps <strong>developers</strong>, <strong>analysts</strong>, and <strong>non-technical stakeholders</strong> communicate clearly</li>
                </ul>
                
            </article>
            <article>
                <h3><strong>Why UML is Needed</strong></h3>
                <ul>
                    <li>Large systems involve <strong>multiple teams</strong> → need <strong>clear communication</strong></li>
                    <li>Helps <strong>non-programmers</strong> understand system functionality</li>
                    <li>Saves time by <strong>visualizing structure, logic, and interactions</strong></li>
                </ul>
                
            </article>
            <article>
                <h3><strong>Major UML Diagram Types (With Examples)</strong></h3>
                <table class="table table-bordered table-striped">
                    <thead>
                        <tr>
                            <th>UML Diagram</th>
                            <th>Description</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Class Diagram</strong></td>
                            <td>Shows classes, attributes, methods &amp; relationships</td>
                            <td><code>User</code>, <code>Post</code>, <code>Comment</code> classes in social media</td>
                        </tr>
                        <tr>
                            <td><strong>Use Case Diagram</strong></td>
                            <td>Shows user interactions with the system</td>
                            <td>Browse, Add to Cart, Checkout in e-commerce</td>
                        </tr>
                        <tr>
                            <td><strong>Sequence Diagram</strong></td>
                            <td>Shows object interactions <strong>in order of time</strong></td>
                            <td>Transfer money between accounts</td>
                        </tr>
                        <tr>
                            <td><strong>Activity Diagram</strong></td>
                            <td>Shows workflow or process logic (like a flowchart)</td>
                            <td>Login process steps</td>
                        </tr>
                    </tbody>
                </table>
                
            </article>
            <article>
                <h3><strong>Key Diagrams in Detail</strong></h3>
                <h4>1. <strong>Class Diagram</strong></h4>
                <ul>
                    <li>Most used</li>
                    <li>Shows <strong>static structure</strong>: classes, attributes, methods</li>
                    <li>Displays <strong>relationships</strong>: inheritance, associations</li>
                </ul>
                <h4>2. <strong>Use Case Diagram</strong></h4>
                <ul>
                    <li>Captures <strong>functional requirements</strong></li>
                    <li>Actors (users) interact with <strong>system functions</strong></li>
                </ul>
                <h4>3. <strong>Sequence Diagram</strong></h4>
                <ul>
                    <li>Shows <strong>step-by-step interactions</strong> among objects</li>
                    <li>Focuses on <strong>order and timing</strong> of messages</li>
                </ul>
                <h4>4. <strong>Activity Diagram</strong></h4>
                <ul>
                    <li>Describes <strong>control flow</strong> between activities</li>
                    <li>Supports <strong>sequential &amp; parallel flows</strong></li>
                </ul>
                
            </article>
            <article>
                <h3><strong>Object-Oriented Concepts in UML</strong></h3>
                <table class="table table-bordered table-striped">
                    <thead>
                        <tr>
                            <th>Concept</th>
                            <th>Role in UML</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Class</strong></td>
                            <td>Blueprint of objects</td>
                        </tr>
                        <tr>
                            <td><strong>Object</strong></td>
                            <td>Instance of class, modular system parts</td>
                        </tr>
                        <tr>
                            <td><strong>Inheritance</strong></td>
                            <td>Child inherits from parent</td>
                        </tr>
                        <tr>
                            <td><strong>Abstraction</strong></td>
                            <td>Show essential, hide unnecessary details</td>
                        </tr>
                        <tr>
                            <td><strong>Encapsulation</strong></td>
                            <td>Bind data + restrict access</td>
                        </tr>
                        <tr>
                            <td><strong>Polymorphism</strong></td>
                            <td>Same function, different behaviors</td>
                        </tr>
                    </tbody>
                </table>
                
            </article>
            <article>
                <h3><strong>UML Tools</strong></h3>
                <ul>
                    <li><strong>Lucidchart</strong> – Web-based, real-time collaboration</li>
                    <li><strong>Draw.io</strong> – Free, offline/online, cloud-integrated</li>
                    <li><strong>Visual Paradigm</strong> – Full suite, desktop + online</li>
                    <li><strong>StarUML</strong> – Open-source, extensible via plugins</li>
                </ul>
                
            </article>
            <article>
                <h3><strong>Benefits of UML</strong></h3>
                <ul>
                    <li><strong>Improves clarity</strong> and <strong>communication</strong></li>
                    <li>Helps in <strong>planning</strong>, <strong>design</strong>, and <strong>requirement analysis</strong></li>
                    <li>Saves time and reduces misunderstandings</li>
                </ul>
            </article>
            <article>
                <h3><strong>User Interface (UI) Design</strong></h3>
                <ul>
                    <li>
                        <p>Process of designing the <strong>front-end interface</strong> where users <strong>interact with software</strong></p>
                    </li>
                    <li>
                        <p>A good UI is:</p>
                        <ul>
                            <li><strong>Attractive</strong></li>
                            <li><strong>Simple &amp; Clear</strong></li>
                            <li><strong>Responsive (fast)</strong></li>
                            <li><strong>Consistent</strong> across all screens</li>
                        </ul>
                    </li>
                </ul>
                
            </article>
            <article>
                <h3><strong>UI Design Principles</strong></h3>
                <table class="table table-bordered table-striped">
                    <thead>
                        <tr>
                            <th>Principle</th>
                            <th>Meaning</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Structure</strong></td>
                            <td>Organize info clearly and logically</td>
                        </tr>
                        <tr>
                            <td><strong>Simplicity</strong></td>
                            <td>Keep it minimal and user-friendly</td>
                        </tr>
                        <tr>
                            <td><strong>Visibility</strong></td>
                            <td>Show only what’s needed; don’t overwhelm the user</td>
                        </tr>
                        <tr>
                            <td><strong>Feedback</strong></td>
                            <td>Give response to user actions (e.g., message, animation)</td>
                        </tr>
                        <tr>
                            <td><strong>Tolerance</strong></td>
                            <td>Allow undo/redo; prevent user errors</td>
                        </tr>
                    </tbody>
                </table>
                
            </article>
            <article>
                <h3><strong>User Interface Design Process</strong></h3>
                <h4><strong>Phase 1: User, Task, and Environment Analysis</strong></h4>
                <ul>
                    <li>Understand user <strong>types</strong>, <strong>skills</strong>, <strong>goals</strong>, and <strong>usage conditions</strong></li>
                    <li>Categorize users based on their <strong>profiles</strong></li>
                </ul>
                <h4><strong>Phase 2: Interface Design</strong></h4>
                <ul>
                    <li>Identify tasks users will do</li>
                    <li>Define <strong>objects</strong> and <strong>operations</strong> related to those tasks</li>
                </ul>
                <h4><strong>Phase 3: Interface Construction</strong></h4>
                <ul>
                    <li>Build a <strong>prototype</strong></li>
                    <li>Improve it <strong>iteratively</strong> based on feedback</li>
                    <li>Simulate <strong>real-world</strong> use</li>
                </ul>
                <h4><strong>Phase 4: Interface Validation</strong></h4>
                <ul>
                    <li>Test if UI supports all <strong>user tasks and variations</strong></li>
                    <li>Final check before full deployment</li>
                </ul>
            </article>
            <article>
                <h3><strong>Unified Design Process (UDP)</strong></h3>
                <ul>
                    <li>A <strong>systematic approach</strong> to software design and development</li>
                    <li>Ensures that software is <strong>planned</strong>, <strong>built</strong>, and <strong>delivered</strong> in stages</li>
                    <li>Helps meet <strong>user needs</strong>, manage <strong>risks</strong>, and handle <strong>changing requirements</strong></li>
                </ul>
                
            </article>
            <article>
                <h3><strong>Phases of UDP</strong></h3>
                <table class="table table-bordered table-striped">
                    <thead>
                        <tr>
                            <th>Phase</th>
                            <th>Purpose</th>
                            <th>Example (Pet Grooming App)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>1. Inception</strong></td>
                            <td>Define <strong>project purpose</strong>, goals, users, high-level needs</td>
                            <td>Understand what the app will do (book grooming services)</td>
                        </tr>
                        <tr>
                            <td><strong>2. Elaboration</strong></td>
                            <td>Refine requirements, assess <strong>risks</strong>, plan architecture</td>
                            <td>Detail features (payment, profiles), create system models</td>
                        </tr>
                        <tr>
                            <td><strong>3. Construction</strong></td>
                            <td><strong>Develop software</strong>, perform testing, write documentation</td>
                            <td>Build core features like booking and payments</td>
                        </tr>
                        <tr>
                            <td><strong>4. Transition</strong></td>
                            <td>Deliver, test, and <strong>launch</strong> software</td>
                            <td>Launch app, fix bugs, support users during rollout</td>
                        </tr>
                    </tbody>
                </table>
                
            </article>
            <article>
                <h3><strong>Key Concepts</strong></h3>
                <ol>
                    <li>
                        <p><strong>Iteration and Incremental Development</strong></p>
                        <ul>
                            <li>System is built and improved in <strong>small, testable steps</strong></li>
                            <li>Example: First release = booking; next = ratings, reminders</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Use Cases</strong></p>
                        <ul>
                            <li>Describe <strong>user interactions</strong> with the system</li>
                            <li>Example: User searches, selects groomer, books appointment</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Models and Diagrams</strong></p>
                        <ul>
                            <li>Show system structure, flow, and component interactions</li>
                            <li>Example: Diagram showing how bookings link to users &amp; payments</li>
                        </ul>
                    </li>
                </ol>
                
            </article>
            <article>
                <h3><strong>Benefits of UDP</strong></h3>
                <ul>
                    <li><strong>Clarity</strong>: Clear goals for each phase</li>
                    <li><strong>Flexibility</strong>: Easy to update design mid-process</li>
                    <li><strong>Quality</strong>: Frequent testing = fewer bugs</li>
                    <li><strong>User-focused</strong>: Regular feedback and real user use-cases guide design</li>
                </ul>
            </article>
            <article>
                <h3><strong>What is SCM?</strong></h3>
                <ul>
                    <li><strong>SCM = Managing changes</strong> in software systematically</li>
                    <li>Ensures software components (code, docs, settings) are <strong>organized</strong>, <strong>trackable</strong>, and <strong>controlled</strong></li>
                    <li><strong>Essential</strong> for teams working on large or collaborative software projects</li>
                </ul>
                
            </article>
            <article>
                <h3><strong>Key SCM Processes</strong></h3>
                <table class="table table-bordered table-striped">
                    <thead>
                        <tr>
                            <th>Process</th>
                            <th>Description</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>1. Version Control</strong></td>
                            <td>Tracks every code change using tools like <strong>Git</strong>, <strong>SVN</strong></td>
                            <td>Developer A and B work independently and merge later</td>
                        </tr>
                        <tr>
                            <td><strong>2. Baseline Management</strong></td>
                            <td>Maintains a stable reference point for rollback</td>
                            <td>Version 1.0 = stable; revert if 1.1 fails</td>
                        </tr>
                        <tr>
                            <td><strong>3. Change Management</strong></td>
                            <td>Handles, documents, and approves change requests</td>
                            <td>"Dark mode" requested → reviewed → added safely</td>
                        </tr>
                        <tr>
                            <td><strong>4. Build Management</strong></td>
                            <td>Compiles and automates code building (Jenkins, Maven)</td>
                            <td>Jenkins builds site from latest code</td>
                        </tr>
                        <tr>
                            <td><strong>5. Release Management</strong></td>
                            <td>Plans, tests, and delivers new software versions</td>
                            <td>Testing app on devices before App Store release</td>
                        </tr>
                        <tr>
                            <td><strong>6. Configuration Auditing</strong></td>
                            <td>Checks if software components are correct and authorized</td>
                            <td>Ensures all patches are present before deployment</td>
                        </tr>
                    </tbody>
                </table>
                
            </article>
            <article>
                <h3><strong>Advanced SCM Features</strong></h3>
                <table class="table table-bordered table-striped">
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Branching &amp; Merging</strong></td>
                            <td>Separate lines of work → merged later</td>
                        </tr>
                        <tr>
                            <td><strong>Conflict Resolution</strong></td>
                            <td>Git resolves clashes in code changes</td>
                        </tr>
                        <tr>
                            <td><strong>CI/CD Integration</strong></td>
                            <td>Automates testing + deployment after code updates</td>
                        </tr>
                    </tbody>
                </table>
                
            </article>
            <article>
                <h3><strong>Why SCM is Important</strong></h3>
                <ul>
                    <li><strong>Collaboration</strong>: Prevents code overwrite</li>
                    <li><strong>Change Tracking</strong>: Know who did what and when</li>
                    <li><strong>Risk Management</strong>: Rollback to safe versions</li>
                    <li><strong>Efficiency</strong>: Automated builds &amp; releases save time</li>
                </ul>
                
            </article>
            <article>
                <h3><strong>Real-Life SCM Examples</strong></h3>
                <ul>
                    <li><strong>GitHub</strong>: Open-source code hosting with version control</li>
                    <li><strong>Mobile App Development</strong>: Tracks feature additions (e.g., step counter) while keeping app stable</li>
                </ul>
            </article>
            <article>
                <h3><strong>What is Software Configuration Management (SCM)?</strong></h3>
                <ul>
                    <li><strong>SCM</strong> is the <strong>systematic process</strong> of identifying, organizing, and controlling changes to <strong>Software Configuration Items (SCIs)</strong> (code, documents, test cases, etc.)</li>
                    <li>Ensures <strong>quality, consistency, and traceability</strong> across the software lifecycle</li>
                </ul>
                
            </article>
            <article>
                <h3><strong>IEEE Definition</strong></h3>
                <blockquote>
                    <p><em>SCM is the process of identifying and defining the items in the system, controlling changes throughout their life cycle, tracking status, and verifying completeness and correctness of items.</em></p>
                </blockquote>
                
            </article>
            <article>
                <h3><strong>SCM Objectives</strong></h3>
                <ul>
                    <li>Control <strong>changes</strong> in SCIs</li>
                    <li>Avoid <strong>errors and mismanagement</strong></li>
                    <li>Improve <strong>productivity and traceability</strong></li>
                    <li>Ensure the <strong>software release is stable and verified</strong></li>
                </ul>
                
            </article>
            <article>
                <h3><strong>Key Components of SCM</strong></h3>
                <table class="table table-bordered table-striped">
                    <thead>
                        <tr>
                            <th>Component</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>1. Configuration Identification</strong></td>
                            <td>Identify all SCIs (e.g., code, SRS, test plans), assign unique names</td>
                        </tr>
                        <tr>
                            <td><strong>2. Change Control</strong></td>
                            <td>Manage changes through review, approval, and implementation (per IEEE)</td>
                        </tr>
                        <tr>
                            <td><strong>3. Configuration Status Accounting</strong></td>
                            <td>Track CR status, assigned personnel, time taken, and completeness</td>
                        </tr>
                        <tr>
                            <td><strong>4. Configuration Auditing</strong></td>
                            <td>Verify compliance with standards and check if processes were followed</td>
                        </tr>
                    </tbody>
                </table>
                
            </article>
            <article>
                <h3><strong>Examples of SCIs</strong></h3>
                <ul>
                    <li>Entire documents (SRS, Design Spec)</li>
                    <li>Code files or modules</li>
                    <li>Test cases and plans</li>
                    <li>Operational software or executables</li>
                </ul>
                
            </article>
            <article>
                <h3><strong>Baselines (Per SDLC Phase)</strong></h3>
                <table class="table table-bordered table-striped">
                    <thead>
                        <tr>
                            <th>Phase</th>
                            <th>Baseline</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Requirements</td>
                            <td>SRS (Software Requirement Spec)</td>
                        </tr>
                        <tr>
                            <td>Design</td>
                            <td>Design Specification</td>
                        </tr>
                        <tr>
                            <td>Coding</td>
                            <td>Source Code</td>
                        </tr>
                        <tr>
                            <td>Testing</td>
                            <td>Test Plans, Test Data</td>
                        </tr>
                        <tr>
                            <td>Release</td>
                            <td>Operational Software</td>
                        </tr>
                    </tbody>
                </table>
                
            </article>
            <article>
                <h3><strong>Software Release Management</strong></h3>
                <ul>
                    <li>
                        <p><strong>Release</strong> = Delivery of software configuration items (code, docs, install files)</p>
                    </li>
                    <li>
                        <p>Must define:</p>
                        <ul>
                            <li><strong>What’s new</strong> (version description document)</li>
                            <li><strong>Known issues</strong></li>
                            <li><strong>Installation/upgrade instructions</strong></li>
                        </ul>
                    </li>
                </ul>
                
            </article>
            <article>
                <h3><strong>SCM Plan (What It Contains)</strong></h3>
                <ol>
                    <li><strong>Introduction</strong>: Scope, definitions</li>
                    <li><strong>Management</strong>: Roles, responsibilities, baseline control</li>
                    <li><strong>Activities</strong>: Identification, change control, status accounting, auditing</li>
                    <li><strong>Tools &amp; Techniques</strong>: CM tools and processes</li>
                    <li><strong>Supplier Control</strong>: Vendor software coordination</li>
                    <li><strong>Record Retention</strong>: Archiving logs, documents, approvals</li>
                </ol>
                
            </article>
            <article>
                <h3><strong>Constraints on SCM</strong></h3>
                <ul>
                    <li><strong>Organizational policies</strong></li>
                    <li><strong>Regulatory bodies</strong> (e.g., safety-critical software)</li>
                    <li><strong>Tools/lifecycle models</strong> used</li>
                    <li><strong>Industry standards and best practices</strong></li>
                </ul>
                
            </article>
            <article>
                <h3><strong>Organizational Context</strong></h3>
                <ul>
                    <li>
                        <p>SCM roles may be shared by <strong>developers, QA, or a dedicated SCM team</strong></p>
                    </li>
                    <li>
                        <p>SCM interacts with:</p>
                        <ul>
                            <li><strong>Quality assurance</strong> (for non-conforming items, records)</li>
                            <li><strong>Development &amp; maintenance teams</strong> (for tool support and coordination)</li>
                        </ul>
                    </li>
                </ul>
            </article>
            <article>
                <h3>1. <strong>What is Software Testing?</strong></h3>
                <ul>
                    <li>Process of <strong>evaluating software</strong> to ensure it meets <strong>requirements</strong> and is <strong>defect-free</strong></li>
                </ul>
                
            </article>
            <article>
                <h3>2. <strong>Why It’s Important</strong></h3>
                <ul>
                    <li>Ensures <strong>quality</strong>, <strong>performance</strong>, and <strong>security</strong></li>
                    <li>Reduces <strong>later-stage costs</strong></li>
                    <li>Boosts <strong>user satisfaction</strong></li>
                    <li>Ensures <strong>business needs</strong> are met</li>
                </ul>
                
            </article>
            <article>
                <h3>3. <strong>Manual vs Automation Testing</strong></h3>
                <table class="table table-bordered table-striped">
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>Manual Testing</th>
                            <th>Automation Testing</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Speed</td>
                            <td>Slow</td>
                            <td>Fast</td>
                        </tr>
                        <tr>
                            <td>Human Involvement</td>
                            <td>High</td>
                            <td>Low</td>
                        </tr>
                        <tr>
                            <td>Best For</td>
                            <td>Usability, Exploratory, Ad-hoc</td>
                            <td>Regression, Load, Performance</td>
                        </tr>
                        <tr>
                            <td>Tools Required</td>
                            <td>No</td>
                            <td>Yes (e.g., Selenium, JUnit, Appium)</td>
                        </tr>
                    </tbody>
                </table>
                
            </article>
            <article>
                <h3>4. <strong>STLC (Software Testing Life Cycle)</strong></h3>
                <ol>
                    <li><strong>Requirement Analysis</strong> – Understand what to test</li>
                    <li><strong>Test Planning</strong> – Define scope, strategy, budget</li>
                    <li><strong>Test Case Design</strong> – Write test cases + expected results</li>
                    <li><strong>Test Environment Setup</strong> – Prepare test system</li>
                    <li><strong>Test Execution</strong> – Run tests, log bugs</li>
                    <li><strong>Test Closure</strong> – Analyze results, prepare summary</li>
                </ol>
                
            </article>
            <article>
                <h3>5. <strong>Types of Testing</strong></h3>
                <h4><strong>Functional Testing</strong> ("What system does")</h4>
                <ul>
                    <li><strong>Unit Testing</strong> – Test individual functions</li>
                    <li><strong>Integration Testing</strong> – Test data flow between modules</li>
                    <li><strong>System Testing</strong> – End-to-end system test</li>
                    <li><strong>UAT (User Acceptance Testing)</strong> – Tested by end users</li>
                </ul>
                <h4><strong>Non-Functional Testing</strong> ("How system performs")</h4>
                <ul>
                    <li><strong>Performance Testing</strong> – Speed under load</li>
                    <li><strong>Security Testing</strong> – Prevent unauthorized access</li>
                    <li><strong>Usability Testing</strong> – Ease of use</li>
                    <li><strong>Compatibility Testing</strong> – Across devices/OS/browsers</li>
                </ul>
                <h4><strong>Other Testing Types</strong></h4>
                <ul>
                    <li><strong>Regression</strong> – Check if updates break anything</li>
                    <li><strong>Smoke</strong> – Basic app functionalities</li>
                    <li><strong>Sanity</strong> – Quick check after a small fix</li>
                    <li><strong>Ad-hoc</strong> – Random testing without test cases</li>
                </ul>
                
            </article>
            <article>
                <h3>6. <strong>Common Testing Terms</strong></h3>
                <table class="table table-bordered table-striped">
                    <thead>
                        <tr>
                            <th>Term</th>
                            <th>Meaning</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Test Case</strong></td>
                            <td>Step-by-step instruction with expected result</td>
                        </tr>
                        <tr>
                            <td><strong>Test Suite</strong></td>
                            <td>Group of test cases</td>
                        </tr>
                        <tr>
                            <td><strong>Defect/Bug</strong></td>
                            <td>Error in software</td>
                        </tr>
                        <tr>
                            <td><strong>Test Scenario</strong></td>
                            <td>High-level idea of what to test</td>
                        </tr>
                        <tr>
                            <td><strong>Test Plan</strong></td>
                            <td>Strategy and scope of testing</td>
                        </tr>
                        <tr>
                            <td><strong>Test Coverage</strong></td>
                            <td>% of code covered by tests</td>
                        </tr>
                    </tbody>
                </table>
                
            </article>
            <article>
                <h3>7. <strong>Why Automation Testing?</strong></h3>
                <ul>
                    <li>Saves <strong>time</strong> on repetitive tests</li>
                    <li>Useful for <strong>large apps</strong></li>
                    <li>Ensures <strong>consistency &amp; accuracy</strong></li>
                </ul>
                <h4><strong>Popular Tools</strong></h4>
                <table class="table table-bordered table-striped">
                    <thead>
                        <tr>
                            <th>Tool</th>
                            <th>Purpose</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Selenium</td>
                            <td>Web automation</td>
                        </tr>
                        <tr>
                            <td>JUnit</td>
                            <td>Java unit testing</td>
                        </tr>
                        <tr>
                            <td>JMeter</td>
                            <td>Performance testing</td>
                        </tr>
                        <tr>
                            <td>Appium</td>
                            <td>Mobile testing</td>
                        </tr>
                    </tbody>
                </table>
                <h4><strong>When to Use</strong></h4>
                <ul>
                    <li><strong>Manual</strong>: UI, Exploratory</li>
                    <li><strong>Automation</strong>: Regression, Performance</li>
                </ul>
                
            </article>
            <article>
                <h3>8. <strong>Interview Questions Quick Review</strong></h3>
                <table class="table table-bordered table-striped">
                    <thead>
                        <tr>
                            <th>Question</th>
                            <th>Answer Summary</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Verification vs Validation</strong></td>
                            <td>Verification = building right product; Validation = built right?</td>
                        </tr>
                        <tr>
                            <td><strong>Smoke vs Sanity</strong></td>
                            <td>Smoke = basic build check; Sanity = minor fix check</td>
                        </tr>
                        <tr>
                            <td><strong>Black Box vs White Box</strong></td>
                            <td>Black Box = no code knowledge; White Box = full code knowledge</td>
                        </tr>
                        <tr>
                            <td><strong>Regression Testing</strong></td>
                            <td>Ensures new code doesn't break existing features</td>
                        </tr>
                        <tr>
                            <td><strong>Test Case</strong></td>
                            <td>Document with steps + expected result</td>
                        </tr>
                        <tr>
                            <td><strong>Login Page Test Cases</strong></td>
                            <td>Valid/invalid login, empty fields, masking, attempt limits</td>
                        </tr>
                    </tbody>
                </table>
            </article>


        </main>

        <script> copyright("all"); </script>

    </body>

</html>