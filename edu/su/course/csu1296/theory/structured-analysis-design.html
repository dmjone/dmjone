<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>

        <meta name="author" content="Divya Mohan">
        <meta name="robots" content="index, follow">

        <!-- Open Graph for Social Media -->
        <meta property="og:image" content="/logo.png">
        <meta property="og:type" content="article">

        <!-- Twitter Cards -->
        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@divyamohan1993">
        <meta name="twitter:creator" content="@divyamohan1993">
        <meta name="twitter:image" content="/logo.png">

        <!-- Mobile Responsiveness -->
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <title>Structured Analysis and Design - CSU1296 - Shoolini U</title>
        <meta name="description" content="A comprehensive explanation of Structured Analysis and Design (SAD), covering principles, methodologies, tools like DFDs, ERDs, PSPECs, and flowcharts, with practical examples and a project-based learning approach.">

        <script type="application/ld+json">
        {
          "@context": "https://schema.org",
          "@type": "TechArticle",
          "headline": "Structured Analysis and Design",
          "description": "A comprehensive explanation of Structured Analysis and Design (SAD), covering principles, methodologies, tools like DFDs, ERDs, PSPECs, and flowcharts, with practical examples and a project-based learning approach.",
          "dateModified": "2025-04-04",
          "author": [
            {
              "@type": "Person",
              "name": "Divya Mohan",
              "url": "https://dmj.one/resume/",
              "sameAs": [
                "https://www.credly.com/users/divyamohan1993",
                "https://www.linkedin.com/in/divyamohan1993/",
                "https://hackerrank.com/divyamohan1993",
                "https://www.coursera.org/learner/divyamohan1993"
              ]
            }
          ],
          "publisher": {
            "@type": "EducationalOrganization",
            "name": "dmj.one",
            "url": "https://dmj.one"
          },
          "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https://dmj.one/edu/su/course/csu1296/theory/structured-analysis-design"
          },
          "keywords": [
            "Structured Analysis",
            "Structured Design",
            "Data Flow Diagrams",
            "Entity Relationship Diagram",
            "Data Dictionary",
            "PSPEC",
            "Software Engineering",
            "System Design",
            "Normalization",
            "Modularization",
            "Software Development Models"
          ],
          "articleSection": [
            "Introduction to Structured Analysis and Design",
            "Requirement Analysis",
            "Data Flow Diagrams (DFD)",
            "Entity Relationship Diagram (ERD)",
            "Data Dictionary",
            "Process Specifications (PSPEC)",
            "Structured Design Principles",
            "Structure Chart",
            "Interface, Database & Control Design",
            "Evaluation of Structured Analysis and Design"
          ],
          "isAccessibleForFree": true,
          "inLanguage": "en-US",
          "license": "https://www.gnu.org/licenses/agpl-3.0.en.html"
        }
        </script>


        <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                renderMathInElement(document.body, {
                    // customised options
                    // • auto-render specific keys, e.g.:
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\(', right: '\\)', display: false },
                        { left: '\\[', right: '\\]', display: true }
                    ],
                    // • rendering keys, e.g.:
                    throwOnError: false
                });
            });
        </script> -->

        <!-- <style>
            main ul {
                list-style-type: none;
                padding: 0;
                margin: 0;
            }

            main ul li {
                margin: 0;
                padding: 0;
            }
        </style> -->
    </head>

    <body>

        <script> header_author("dm"); </script>

        <main>
            <article class="agen-tableofcontents">
                <h2 class="text-center">
                    Structured Analysis and Design
                </h2>
                <div class="d-none contentdate">2025, April 04</div>
            </article>

            <article>
                <h3>1. Introduction to Structured Analysis and Design</h3>
                <p>Structured Analysis and Design is a disciplined approach to understand, analyze, and design systems in a logical, graphical, and modular way. It breaks down complex problems into simpler, visual components to ensure clarity, communication, and maintainability.</p>
            </article>

            <article>
                <h4>1.1 What is Structured Analysis and Design?</h4>
                <p>Structured Analysis and Design (SAD) is a two-phase method that first analyzes what a system should do (Structured Analysis), and then transforms that understanding into a logical, implementable system design (Structured Design).</p>
                <p>It is based on <strong>graphical modeling</strong>, <strong>data flow</strong>, <strong>modular decomposition</strong>, and <strong>logical relationships</strong> between system elements.</p>
                <p>Key tools used:</p>
                <ul>
                    <li><strong>Structured Analysis:</strong> Data Flow Diagrams (DFD), Entity-Relationship Diagrams (ERD), Data Dictionary, Decision Trees</li>
                    <li><strong>Structured Design:</strong> Structure Charts, Pseudo Code, Modular Design, Interface and Database Design</li>
                </ul>
            </article>

            <article>
                <h4>1.2 Why is Structured Analysis and Design Needed?</h4>
                <p>Large software systems fail when not structured properly. SAD provides clarity by turning vague requirements into visual, structured, and implementable components. It allows teams to divide responsibility, validate logic early, and make future changes easier.</p>

                <h5>1.2.1 Real-World Analogy</h5>
                <p>Think of constructing a hospital. You wouldn’t begin laying bricks without:</p>
                <ul>
                    <li>Understanding the departments and patient flow (Analysis)</li>
                    <li>Designing a blueprint for rooms, emergency paths, and utility placement (Design)</li>
                </ul>
                <p>Likewise, SAD helps in designing software before coding begins.</p>

                <h5>1.2.2 Benefits</h5>
                <ul>
                    <li><strong>Improves communication</strong> among developers, users, and clients using diagrams</li>
                    <li><strong>Reduces bugs</strong> and rework by validating logic before implementation</li>
                    <li><strong>Ensures scalability</strong> and easier maintenance via modular architecture</li>
                    <li><strong>Optimizes resources</strong> like memory, time, and development cost</li>
                </ul>
            </article>

            <article>
                <h4>1.3 When to Use Structured Analysis and Design?</h4>
                <p>Use SAD when the project:</p>
                <ul>
                    <li>Has <strong>clear, stable requirements</strong> that don’t change frequently</li>
                    <li>Is <strong>large and complex</strong> – e.g., banking systems, hospital management, ERP systems</li>
                    <li>Needs <strong>detailed documentation</strong> for compliance or maintenance</li>
                    <li>Is being built by <strong>multiple teams</strong> requiring strong coordination</li>
                </ul>

                <h5>1.3.1 When NOT to Use</h5>
                <ul>
                    <li>When requirements change frequently (e.g., startups using agile)</li>
                    <li>In very small systems where documentation overhead outweighs the benefits</li>
                    <li>In rapid prototyping where speed matters more than structure</li>
                </ul>
            </article>


            <article>
                <h3>2. Requirement Analysis</h3>
                <p>Requirement Analysis is the first and most critical step in Structured Analysis. It ensures that the system solves the right problem before solving the problem right. It captures <strong>what the system must do</strong>, <strong>what users expect</strong>, and <strong>what limitations must be respected</strong>.</p>
            </article>

            <article>
                <h4>2.1 Identify Functional and Non-Functional Requirements</h4>

                <h5>2.1.1 Functional Requirements</h5>
                <p>These define <strong>specific actions</strong> the system must perform. They are directly tied to user goals.</p>
                <ul>
                    <li>Example: "Allow patients to book appointments online"</li>
                    <li>Think of them as <strong>verbs</strong>: create, update, process, notify</li>
                </ul>

                <h5>2.1.2 Non-Functional Requirements</h5>
                <p>These define <strong>how well</strong> the system performs. They are the <em>quality attributes</em>.</p>
                <ul>
                    <li>Performance (e.g., response time &lt; 2 seconds)</li>
                    <li>Security (e.g., encrypt patient records)</li>
                    <li>Reliability, Availability, Maintainability, Usability (RAMU)</li>
                </ul>

                <h5>2.1.3 Real-World Scenario</h5>
                <p>For an online shopping site:</p>
                <ul>
                    <li><strong>Functional</strong>: Add items to cart, Checkout with payment</li>
                    <li><strong>Non-Functional</strong>: Must work with 99.9% uptime and load under 2s</li>
                </ul>
            </article>

            <article>
                <h4>2.2 Understand User Expectations and System Constraints</h4>

                <h5>2.2.1 User Expectations</h5>
                <p>Focus on the actual needs of users — not what they say, but what they do.</p>
                <ul>
                    <li>Easy navigation (not too many clicks)</li>
                    <li>Mobile accessibility</li>
                    <li>Instant feedback when submitting forms</li>
                </ul>

                <h5>2.2.2 System Constraints</h5>
                <p>Limitations due to environment, policy, technology, or budget.</p>
                <ul>
                    <li>Must run on existing legacy infrastructure</li>
                    <li>Data storage limit: 1 TB</li>
                    <li>Budget under ₹5 lakhs</li>
                </ul>

                <h5>2.2.3 Real-World Analogy</h5>
                <p>If building a bridge, user expectation is smooth and fast travel. Constraint may be soil quality or budget.</p>
                <p>In software, the same principle applies: <strong>build for what users need</strong>, but within what’s possible.</p>
            </article>

            <article>
                <h4>2.3 Clarify Scope and Boundaries</h4>
                <p>Define <strong>what is included</strong> in the system and <strong>what is not</strong>. This prevents scope creep and ensures clear responsibility.</p>

                <h5>2.3.1 Scope</h5>
                <p>Everything the system will support or automate.</p>
                <ul>
                    <li>Example: Patient registration, appointment booking, and bill payment</li>
                </ul>

                <h5>2.3.2 Boundaries</h5>
                <p>Interfaces with external systems or areas not being developed.</p>
                <ul>
                    <li>Example: Payment gateway is external – just integrate, not develop it</li>
                </ul>

                <h5>2.3.3 Visualize Scope with Context Diagram</h5>
                <pre class="mermaid text-center">
graph TB
User((User))
System[Hospital Management System]
Payment[Payment Gateway]
User -->|Books Appointment| System
System -->|Sends Payment Details| Payment
</pre>

                <p>Clarifying scope helps you say “no” to unnecessary features and keeps the project focused.</p>
            </article>

            <article>
                <h3>3. Data Flow Diagrams (DFD)</h3>
                <p>A Data Flow Diagram (DFD) is a graphical tool used in Structured Analysis to visualize how data moves through a system. It focuses on <strong>what the system does with the data</strong>, not how it is implemented.</p>
                <p>DFD simplifies complexity by showing inputs, processes, outputs, and storage in a system using clear, standardized symbols.</p>
            </article>

            <article>
                <h4>3.1 What is a DFD?</h4>
                <p>A DFD represents the flow of data between external entities, processes, and data stores in a system. It helps analysts, users, and developers understand the logic of the system at different levels of detail.</p>

                <h5>3.1.1 Real-World Analogy</h5>
                <p>Imagine a food delivery system:</p>
                <ul>
                    <li>User places an order → (data flows to) → Order Processing</li>
                    <li>Order Processing sends order to Restaurant → Restaurant sends food</li>
                </ul>
                <p>DFD maps this flow logically using symbols instead of technical code.</p>
            </article>

            <article>
                <h4>3.2 DFD Levels: 0, 1, 2</h4>

                <h5>3.2.1 Level 0 – Context Diagram</h5>
                <p>Shows the system as a single process with all external entities. It’s like viewing the entire company from space.</p>
                <pre class="mermaid text-center">
graph TB
User((User))
System[Food Delivery System]
Restaurant((Restaurant))
PaymentGateway((Payment Gateway))
User -->|Order Request| System
System -->|Send Order| Restaurant
System -->|Payment Details| PaymentGateway
</pre>

                <h5>3.2.2 Level 1 – Top-Level Diagram</h5>
                <p>Breaks the system into major sub-processes. Shows how data flows between these sub-processes and external entities.</p>
                <ul>
                    <li>Example: Order Processing, Payment Handling, Notification Service</li>
                </ul>

                <h5>3.2.3 Level 2 – Detailed Functional Decomposition</h5>
                <p>Drills down a Level 1 process into more granular sub-processes. This is where each process's internal logic becomes visible.</p>
                <ul>
                    <li>Order Processing → Validate Order, Check Inventory, Confirm Order</li>
                </ul>
                <p>This hierarchical view allows step-by-step understanding of the system.</p>
            </article>

            <article>
                <h4>3.3 Symbols Used in DFD</h4>
                <div class="table-responsive">
                    <table class="table table-bordered table-striped">
                        <thead>
                            <tr>
                                <th>Symbol</th>
                                <th>Component</th>
                                <th>Meaning</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Rectangle</strong></td>
                                <td>External Entity</td>
                                <td>Outside system boundary (e.g., User, Bank)</td>
                            </tr>
                            <tr>
                                <td><strong>Circle or Rounded Box</strong></td>
                                <td>Process</td>
                                <td>Transforms data (e.g., Validate Login)</td>
                            </tr>
                            <tr>
                                <td><strong>Open-ended Rectangle (Parallel Lines)</strong></td>
                                <td>Data Store</td>
                                <td>Stored data used by the system (e.g., Database)</td>
                            </tr>
                            <tr>
                                <td><strong>Arrow</strong></td>
                                <td>Data Flow</td>
                                <td>Movement of data between components</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <p>Each symbol plays a critical role in visualizing how input is processed into output logically.</p>
            </article>

            <article>
                <h3>4. Entity Relationship Diagram (ERD)</h3>
                <p>An Entity Relationship Diagram (ERD) is a structured visual representation of <strong>data objects (entities)</strong>, their <strong>attributes</strong>, and how they <strong>relate</strong> to each other. It is used in Structured Analysis to model the data layer logically before creating the database.</p>
            </article>

            <article>
                <h4>4.1 Purpose of ERD</h4>
                <p>ERD helps in <strong>understanding, organizing, and communicating</strong> the data requirements of the system. It ensures the database structure reflects real-world business rules and prevents data redundancy or inconsistency.</p>

                <h5>4.1.1 Real-World Analogy</h5>
                <p>In a college system:</p>
                <ul>
                    <li>Student is an Entity</li>
                    <li>Name, Roll No, DOB are Attributes</li>
                    <li>A Student “enrolls” in a Course (Relationship)</li>
                </ul>
                <p>ERD acts as a <strong>blueprint</strong> before building the actual database schema.</p>
            </article>

            <article>
                <h4>4.2 Entities, Attributes, Relationships</h4>

                <h5>4.2.1 Entities</h5>
                <p>An Entity is a real-world object with identifiable properties. It becomes a table in a database.</p>
                <ul>
                    <li><strong>Strong Entity</strong>: Has its own primary key (e.g., Student, Course)</li>
                    <li><strong>Weak Entity</strong>: Depends on another entity for identity (e.g., Enrollment)</li>
                </ul>

                <h5>4.2.2 Attributes</h5>
                <p>Properties that describe an entity.</p>
                <ul>
                    <li><strong>Simple</strong>: Name, Age</li>
                    <li><strong>Composite</strong>: FullName = First + Last</li>
                    <li><strong>Derived</strong>: Age (from DOB)</li>
                    <li><strong>Primary Key</strong>: Unique identifier (e.g., Roll No)</li>
                </ul>

                <h5>4.2.3 Relationships</h5>
                <p>Defines how entities are related.</p>
                <ul>
                    <li><strong>One-to-One (1:1)</strong>: A person has one passport</li>
                    <li><strong>One-to-Many (1:N)</strong>: A teacher teaches many subjects</li>
                    <li><strong>Many-to-Many (M:N)</strong>: Students enroll in multiple courses</li>
                </ul>

                <pre class="mermaid text-center">
erDiagram
    STUDENT ||--o{ ENROLLMENT : enrolls
    COURSE ||--o{ ENROLLMENT : includes
    STUDENT {
      string roll_no PK
      string name
      date dob
    }
    COURSE {
      string course_id PK
      string title
    }
    ENROLLMENT {
      date enrolled_on
    }
</pre>
            </article>

            <article>
                <h4>4.3 Normalization Concepts</h4>
                <p>Normalization is the process of organizing data to minimize redundancy and ensure data integrity.</p>

                <h5>4.3.1 Goals of Normalization</h5>
                <ul>
                    <li>Remove duplicate data</li>
                    <li>Ensure logical data dependencies</li>
                    <li>Reduce data anomalies during insert/update/delete</li>
                </ul>

                <h5>4.3.2 Common Normal Forms</h5>
                <div class="table-responsive">
                    <table class="table table-bordered table-striped">
                        <thead>
                            <tr>
                                <th>Normal Form</th>
                                <th>Condition</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>1NF</strong></td>
                                <td>Atomic values (no repeating groups or arrays)</td>
                            </tr>
                            <tr>
                                <td><strong>2NF</strong></td>
                                <td>1NF + No partial dependency on composite key</td>
                            </tr>
                            <tr>
                                <td><strong>3NF</strong></td>
                                <td>2NF + No transitive dependencies (non-key depending on non-key)</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h5>4.3.3 Real-World Example</h5>
                <p>Without normalization:</p>
                <pre><code class="language-sql">
Student(RollNo, Name, Course1, Course2)
</code></pre>
                <p>After 1NF and 2NF:</p>
                <pre><code class="language-sql">
Student(RollNo, Name)
Enrollment(RollNo, Course)
</code></pre>
                <p>This separation makes querying, updating, and scaling much easier and consistent.</p>
            </article>

            <article>
                <h3>5. Data Dictionary</h3>
                <p>A Data Dictionary is a centralized repository that <strong>defines and describes every data element</strong> used in the system. It acts like a glossary of all variables, fields, and data flows, ensuring clarity, consistency, and control in data usage across the system.</p>
            </article>

            <article>
                <h4>5.1 What is it?</h4>
                <p>It is a reference document that lists all data items—what they mean, how they're used, and how they are related. It is essential for both developers and analysts to speak the same language when designing or implementing a system.</p>

                <h5>5.1.1 Real-World Analogy</h5>
                <p>Just like a medical dictionary helps doctors use consistent terms for symptoms and diagnoses, a data dictionary ensures that everyone in a software team interprets "customer_id" or "status_code" the same way.</p>
            </article>

            <article>
                <h4>5.2 Usage of Data Dictionary</h4>
                <p>It is used to:</p>
                <ul>
                    <li><strong>Standardize</strong> field names and data types across the system</li>
                    <li><strong>Support documentation</strong> and training of new team members</li>
                    <li><strong>Validate input/output</strong> during design and testing</li>
                    <li><strong>Enable future maintenance</strong> by clearly defining each data item</li>
                </ul>

                <h5>5.2.1 Integration with DFD & ERD</h5>
                <p>Every element in a DFD (e.g., data flows, stores, processes) and ERD (e.g., attributes, keys) must be documented in the data dictionary for traceability.</p>
            </article>

            <article>
                <h4>5.3 Includes in Data Dictionary</h4>
                <p>The following are commonly defined for each data item:</p>
                <div class="table-responsive">
                    <table class="table table-bordered table-striped">
                        <thead>
                            <tr>
                                <th>Element</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Name</strong></td>
                                <td>Unique name of the data element</td>
                            </tr>
                            <tr>
                                <td><strong>Alias</strong></td>
                                <td>Alternate name(s) used elsewhere</td>
                            </tr>
                            <tr>
                                <td><strong>Description</strong></td>
                                <td>What the data element represents</td>
                            </tr>
                            <tr>
                                <td><strong>Type</strong></td>
                                <td>Data type (e.g., Integer, String, Date)</td>
                            </tr>
                            <tr>
                                <td><strong>Length</strong></td>
                                <td>Maximum size (e.g., 50 characters)</td>
                            </tr>
                            <tr>
                                <td><strong>Format</strong></td>
                                <td>Expected format (e.g., YYYY-MM-DD)</td>
                            </tr>
                            <tr>
                                <td><strong>Valid Values</strong></td>
                                <td>Allowed values (e.g., status: Active, Inactive)</td>
                            </tr>
                            <tr>
                                <td><strong>Default Value</strong></td>
                                <td>Assigned if user doesn't provide one</td>
                            </tr>
                            <tr>
                                <td><strong>Source</strong></td>
                                <td>Where the data originates from</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h5>5.3.1 Sample Entry</h5>
                <pre><code class="language-json">
{
  "name": "customer_id",
  "alias": ["cust_id", "cid"],
  "description": "Unique identifier for a customer",
  "type": "String",
  "length": 10,
  "format": "CUST#####",
  "valid_values": null,
  "default_value": "CUST00000",
  "source": "User Registration Form"
}
</code></pre>
            </article>

            <article>
                <h3>6. Process Specifications (PSPEC)</h3>
                <p>Process Specification (PSPEC) defines the internal logic of each process in a Data Flow Diagram (DFD). It bridges the gap between what a system should do (functional model) and how each part will do it (logic model).</p>
                <p>PSPEC ensures that processes are <strong>precisely defined</strong>, <strong>unambiguous</strong>, and ready for implementation or testing.</p>
            </article>

            <article>
                <h4>6.1 Structured English</h4>
                <p>Structured English is a limited form of natural language with clearly defined keywords to express logic. It combines the familiarity of English with the precision of programming.</p>

                <h5>6.1.1 Key Elements</h5>
                <ul>
                    <li><strong>Keywords</strong>: IF, THEN, ELSE, WHILE, DO, AND, OR</li>
                    <li><strong>Indentation</strong> for hierarchy and readability</li>
                    <li><strong>Clarity over complexity</strong>: Avoid ambiguous terms</li>
                </ul>

                <h5>6.1.2 Example</h5>
                <pre><code class="language-plaintext">
IF cart is not empty THEN
   CALCULATE total cost
   IF total cost > 1000 THEN
      APPLY 10% discount
   ELSE
      NO discount
ENDIF
</code></pre>

                <h5>6.1.3 When to Use</h5>
                <p>Best for describing <strong>simple logic</strong> in a human-readable but structured format.</p>
            </article>

            <article>
                <h4>6.2 Decision Tables</h4>
                <p>A decision table is a tabular method to represent complex conditional logic, especially when there are multiple rules or combinations of inputs.</p>

                <h5>6.2.1 Structure</h5>
                <div class="table-responsive">
                    <table class="table table-bordered table-striped">
                        <thead>
                            <tr>
                                <th>Conditions</th>
                                <th>Rule 1</th>
                                <th>Rule 2</th>
                                <th>Rule 3</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Amount > 1000</td>
                                <td>Yes</td>
                                <td>No</td>
                                <td>No</td>
                            </tr>
                            <tr>
                                <td>Customer is Premium</td>
                                <td>No</td>
                                <td>Yes</td>
                                <td>No</td>
                            </tr>
                            <tr>
                                <td><strong>Action</strong></td>
                                <td>10% Discount</td>
                                <td>5% Discount</td>
                                <td>No Discount</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h5>6.2.2 When to Use</h5>
                <p>Use decision tables when:</p>
                <ul>
                    <li>Multiple conditions impact the outcome</li>
                    <li>Rules must be audited or validated by non-technical users</li>
                </ul>
            </article>

            <article>
                <h4>6.3 Flowcharts</h4>
                <p>Flowcharts are graphical representations of the logic inside a process. They use standardized symbols to describe the flow of control.</p>

                <h5>6.3.1 Symbols</h5>
                <ul>
                    <li><strong>Oval</strong>: Start/End</li>
                    <li><strong>Rectangle</strong>: Process step</li>
                    <li><strong>Diamond</strong>: Decision point</li>
                    <li><strong>Arrow</strong>: Flow direction</li>
                </ul>

                <h5>6.3.2 Example</h5>
                <pre class="mermaid text-center">
flowchart TD
  Start([Start])
  CheckCart{Cart is Empty?}
  Calc[Calculate Total]
  Discount{Total > 1000?}
  Apply10[Apply 10% Discount]
  NoDisc[No Discount]
  End([End])

  Start --> CheckCart
  CheckCart -- No --> Calc
  CheckCart -- Yes --> End
  Calc --> Discount
  Discount -- Yes --> Apply10 --> End
  Discount -- No --> NoDisc --> End
</pre>

                <h5>6.3.3 When to Use</h5>
                <p>Best for illustrating logic that involves multiple steps, conditions, and loops — especially helpful for visual learners or stakeholders during reviews.</p>
            </article>


            <article>
                <h3>7. Structured Design Principles</h3>
                <p>Structured Design transforms the "what" from Structured Analysis into "how" — creating a well-organized architecture ready for coding. It follows proven principles to ensure the system is <strong>logical, efficient, maintainable, and scalable</strong>.</p>
            </article>

            <article>
                <h4>7.1 High Cohesion & Low Coupling</h4>

                <h5>7.1.1 High Cohesion</h5>
                <p>Cohesion measures how strongly related and focused the functions within a single module are. High cohesion means a module does <strong>one thing well</strong>.</p>
                <ul>
                    <li><strong>Example</strong>: A "Billing" module should only calculate invoices—not handle user logins or inventory</li>
                    <li>High cohesion = simpler debugging, better understanding, easier updates</li>
                </ul>

                <h5>7.1.2 Low Coupling</h5>
                <p>Coupling measures how much one module depends on another. Low coupling means modules can work independently.</p>
                <ul>
                    <li><strong>Example</strong>: Changing the "Notification" module should not break the "Payment" module</li>
                    <li>Low coupling = more modularity, better testing, easier reuse</li>
                </ul>

                <h5>7.1.3 Real-World Analogy</h5>
                <p>In a car: Engine, brakes, and music system are cohesive modules. If you replace the music system, the brakes shouldn't stop working — that's low coupling.</p>
            </article>

            <article>
                <h4>7.2 Modularization</h4>
                <p>Modularization is the process of dividing the system into <strong>independent, logical units (modules)</strong> such that each module handles a specific responsibility.</p>

                <h5>7.2.1 Benefits</h5>
                <ul>
                    <li><strong>Divide and conquer</strong>: Teams can develop and test modules in parallel</li>
                    <li><strong>Improves scalability</strong>: Add new modules without touching old ones</li>
                    <li><strong>Reduces risk</strong>: Bugs in one module don’t affect the entire system</li>
                </ul>

                <h5>7.2.2 Example</h5>
                <p>Online Store Modules: Authentication, Product Catalog, Shopping Cart, Payment, Notification</p>

                <pre class="mermaid text-center">
graph TD
  A[Main System]
  A --> B[Authentication]
  A --> C[Catalog]
  A --> D[Cart]
  A --> E[Payment]
  A --> F[Notifications]
</pre>
            </article>

            <article>
                <h4>7.3 Maintainability & Reusability</h4>

                <h5>7.3.1 Maintainability</h5>
                <p>Structured design ensures the system is easy to fix, update, and improve. This is achieved by using clear documentation, separation of concerns, and consistent naming conventions.</p>
                <ul>
                    <li><strong>Maintainable code</strong> = Less time fixing bugs</li>
                    <li>Modules can be swapped or upgraded without major changes</li>
                </ul>

                <h5>7.3.2 Reusability</h5>
                <p>Design modules in a way that they can be reused in other systems with minimal modification.</p>
                <ul>
                    <li><strong>Example</strong>: A generic “EmailSender” module can be reused in HR, sales, and support systems</li>
                    <li><strong>Reduces cost</strong>: Write once, use many times</li>
                </ul>

                <h5>7.3.3 Practices That Support Reusability</h5>
                <ul>
                    <li>Write generalized logic (parameterized functions)</li>
                    <li>Use interfaces and abstraction to decouple logic</li>
                    <li>Document inputs, outputs, and expected behaviors clearly</li>
                </ul>
            </article>

            <article>
                <h3>8. Structure Chart</h3>
                <p>A Structure Chart is a hierarchical diagram used in Structured Design to represent the organization of modules and their relationships. It shows <strong>which modules call which other modules</strong>, how data flows between them, and how control is transferred.</p>
            </article>

            <article>
                <h4>8.1 What is it?</h4>
                <p>It depicts the breakdown of a system into functional modules. Unlike flowcharts (which focus on logic), a structure chart shows program structure and interactions between procedures, making it essential for top-down design.</p>

                <h5>8.1.1 Real-World Analogy</h5>
                <p>Think of an office:</p>
                <ul>
                    <li>CEO delegates to Managers</li>
                    <li>Managers delegate to Team Leads</li>
                    <li>Team Leads assign tasks to Staff</li>
                </ul>
                <p>A structure chart represents this exact command-and-control hierarchy in software.</p>
            </article>

            <article>
                <h4>8.2 Symbols & Arrows</h4>
                <div class="table-responsive">
                    <table class="table table-bordered table-striped">
                        <thead>
                            <tr>
                                <th>Symbol</th>
                                <th>Meaning</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Rectangle</strong></td>
                                <td>Module or subprogram (e.g., calculateTax)</td>
                            </tr>
                            <tr>
                                <td><strong>Vertical Line</strong></td>
                                <td>Hierarchy: control flow from parent to child module</td>
                            </tr>
                            <tr>
                                <td><strong>Arrow (downward)</strong></td>
                                <td>Control passing (invoking a sub-module)</td>
                            </tr>
                            <tr>
                                <td><strong>Arrow (horizontal with label)</strong></td>
                                <td>Data passed between modules (parameters)</td>
                            </tr>
                            <tr>
                                <td><strong>Double horizontal line</strong></td>
                                <td>Library/Reusable Module</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h5>8.2.1 Example Structure Chart</h5>
                <pre class="mermaid text-center">
graph TD
  A[Main Program]
  A --> B[Input Module]
  A --> C[Process Order]
  A --> D[Generate Invoice]
  C --> E[Check Inventory]
  C --> F[Calculate Total]
  D --> G[Send Email Confirmation]
</pre>
            </article>

            <article>
                <h4>8.3 Helps in</h4>
                <ul>
                    <li><strong>Visualizing modular hierarchy</strong>: Who controls what and where</li>
                    <li><strong>Identifying cohesion and coupling</strong>: Helps in refining modules for best practices</li>
                    <li><strong>Code planning</strong>: Developers know the exact role and scope of each unit</li>
                    <li><strong>Parallel development</strong>: Teams can work on different modules independently</li>
                    <li><strong>Troubleshooting</strong>: Isolates issues to specific module chains</li>
                </ul>

                <h5>8.3.1 Use Case Example</h5>
                <p>In a Payroll System:</p>
                <ul>
                    <li>“Main” calls “Employee Input”, “Salary Calculation”, “Payslip Generation”</li>
                    <li>Each function further breaks down: Tax Calculation, Overtime Handling, Leave Deduction</li>
                </ul>
                <p>This logical hierarchy enables smooth delegation, testing, and integration.</p>
            </article>


            <article>
                <h3>9. Interface, Database & Control Design</h3>
                <p>These three components form the core of how the user interacts with the system (Interface), how the system stores and manages data (Database), and how the logic flows inside the system (Control). A well-designed system ensures all three are aligned, efficient, and user-friendly.</p>
            </article>

            <article>
                <h4>9.1 Interface Design</h4>
                <p>Interface Design defines how users interact with the system through screens, forms, buttons, inputs, and feedback. It emphasizes usability, clarity, and consistency.</p>

                <h5>9.1.1 Key Elements</h5>
                <ul>
                    <li><strong>Input Design</strong>: Forms, dropdowns, buttons</li>
                    <li><strong>Output Design</strong>: Reports, dashboards, confirmation messages</li>
                    <li><strong>Navigation Design</strong>: Menus, breadcrumbs, links</li>
                </ul>

                <h5>9.1.2 Best Practices</h5>
                <ul>
                    <li>Use meaningful labels and group related fields</li>
                    <li>Validate inputs in real-time to reduce errors</li>
                    <li>Ensure accessibility (color contrast, keyboard navigation)</li>
                </ul>

                <h5>9.1.3 Real-World Example</h5>
                <p>ATM Screen Interface: Simple buttons for Withdraw, Deposit, Check Balance — no training needed.</p>
            </article>

            <article>
                <h4>9.2 Database Design</h4>
                <p>Database Design involves organizing the structure of data storage to ensure efficient retrieval, integrity, and minimal redundancy. It is based on the ERD and refined using normalization.</p>

                <h5>9.2.1 Steps in Database Design</h5>
                <ul>
                    <li>Convert ERD into relational tables</li>
                    <li>Apply normalization (up to 3NF typically)</li>
                    <li>Define relationships (1:1, 1:N, M:N with junction tables)</li>
                    <li>Add indexes for performance</li>
                </ul>

                <h5>9.2.2 Best Practices</h5>
                <ul>
                    <li>Use appropriate data types (e.g., INT vs VARCHAR)</li>
                    <li>Set primary and foreign keys</li>
                    <li>Avoid storing derived data unless needed for performance</li>
                </ul>

                <h5>9.2.3 Sample Table Structure</h5>
                <pre><code class="language-sql">
CREATE TABLE Student (
  roll_no VARCHAR(10) PRIMARY KEY,
  name VARCHAR(50),
  dob DATE
);

CREATE TABLE Enrollment (
  roll_no VARCHAR(10),
  course_id VARCHAR(10),
  enrolled_on DATE,
  PRIMARY KEY (roll_no, course_id),
  FOREIGN KEY (roll_no) REFERENCES Student(roll_no)
);
</code></pre>
            </article>

            <article>
                <h4>9.3 Control Flow Design</h4>
                <p>Control Flow Design determines how decisions, processes, and sequences are managed inside the system. It ensures the system reacts properly to user inputs, errors, and process conditions.</p>

                <h5>9.3.1 Includes</h5>
                <ul>
                    <li><strong>Decision logic</strong>: What happens when a condition is met</li>
                    <li><strong>Loops and branching</strong>: For processing multiple or conditional data</li>
                    <li><strong>Error handling</strong>: What to do when things go wrong</li>
                </ul>

                <h5>9.3.2 Flowchart Example</h5>
                <pre class="mermaid text-center">
flowchart TD
  A[Start]
  B{Is user logged in?}
  C[Redirect to Login Page]
  D[Show Dashboard]
  A --> B
  B -- No --> C
  B -- Yes --> D
</pre>

                <h5>9.3.3 Best Practices</h5>
                <ul>
                    <li>Keep logic modular and easy to trace</li>
                    <li>Handle all decision outcomes (avoid fall-through)</li>
                    <li>Include fallback paths for unexpected conditions</li>
                </ul>

                <h5>9.3.4 Real-World Analogy</h5>
                <p>In a restaurant kitchen: Orders are taken, queued, processed, errors are managed (e.g., out of stock), and responses are sent. That's a real-time control flow.</p>
            </article>

            <article>
                <h3>10. Evaluation</h3>
                <p>Evaluating Structured Analysis and Design involves weighing its strengths and weaknesses in real-world scenarios. While it provides structure and clarity for complex systems, it may not fit all environments, especially those needing rapid iterations.</p>
            </article>

            <article>
                <h4>10.1 Advantages of Structured Analysis and Design</h4>
                <ul>
                    <li><strong>Clarity in Requirements</strong>: Graphical models like DFD and ERD make abstract requirements concrete</li>
                    <li><strong>Modular Development</strong>: Encourages breaking systems into manageable, testable units</li>
                    <li><strong>Enhanced Communication</strong>: Diagrams bridge the gap between users, analysts, and developers</li>
                    <li><strong>Ease of Maintenance</strong>: High cohesion and low coupling allow isolated fixes and upgrades</li>
                    <li><strong>Reusability</strong>: Well-designed modules and components can be reused in other projects</li>
                    <li><strong>Better Planning</strong>: Documentation and structured design reduce surprises during implementation</li>
                </ul>
            </article>

            <article>
                <h4>10.2 Disadvantages of Structured Analysis and Design</h4>
                <ul>
                    <li><strong>Time-Consuming</strong>: Requires extensive planning, documentation, and diagrams before coding starts</li>
                    <li><strong>Rigid Process</strong>: Poor fit for fast-changing requirements or agile development environments</li>
                    <li><strong>Heavy Upfront Effort</strong>: Design-first approach demands detailed analysis before seeing results</li>
                    <li><strong>Not Ideal for Small Projects</strong>: Overhead may outweigh benefits in simple systems</li>
                </ul>
            </article>

            <article>
                <h4>10.3 A Project to Practice Structured Analysis and Design</h4>

                <h5>10.3.1 Project: Student Attendance Management System</h5>
                <p>Build a system to manage attendance for a college or school. It should support:</p>
                <ul>
                    <li>Student registration and login</li>
                    <li>Marking attendance by teacher</li>
                    <li>Generating monthly attendance reports</li>
                    <li>Admin controls to manage classes, students, and teachers</li>
                </ul>

                <h5>10.3.2 Apply SAD Techniques</h5>
                <ul>
                    <li><strong>Requirement Analysis</strong>: Define roles, functions (e.g., mark attendance), and constraints (e.g., per class limit)</li>
                    <li><strong>DFD</strong>: Show flow of data from student to attendance report</li>
                    <li><strong>ERD</strong>: Define entities like Student, Class, Attendance, Teacher</li>
                    <li><strong>Data Dictionary</strong>: Standardize all data items (e.g., student_id, date)</li>
                    <li><strong>Structure Chart</strong>: Break system into modules like "Login", "Attendance Processing", "Report Generator"</li>
                    <li><strong>Interface Design</strong>: Create mockups for teacher dashboard, student login</li>
                    <li><strong>Database Design</strong>: Normalize tables and establish keys and relations</li>
                    <li><strong>Control Flow</strong>: Define logic to validate input, handle absences, and generate summaries</li>
                </ul>

                <h5>10.3.3 Tools Suggested</h5>
                <ul>
                    <li>Draw.io / Lucidchart for DFDs and ERDs</li>
                    <li>MySQL / PostgreSQL for database implementation</li>
                    <li>VS Code for interface and backend development</li>
                    <li>Mermaid for documentation inside README</li>
                </ul>
            </article>


            <article>
                <h4>10.4 Conclusion</h4>
                <p>Structured Analysis and Design is a powerful methodology for building complex systems. By following its principles, you can ensure that your system is well-structured, maintainable, and scalable. However, be mindful of its limitations in fast-paced environments.</p>

        </main>

        <script> copyright("all"); </script>

    </body>

</html>