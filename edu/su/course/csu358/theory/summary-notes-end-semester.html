<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
<!--<![endif]-->

<head>
    <script src="/js/edu_su_common.js"></script>
    <noscript>
        <style>
            html,
            body {
                margin: 0;
                overflow: hidden;
            }
        </style>
        <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
    </noscript>

    <title>Quick Summary & Numericals - Computer Graphics ESM</title>
    <meta name="description" content="Quick revision summary for Computer Graphics ESM. Includes ultra-simple one-line definitions and fully solved numericals for DDA, Bresenham, and Clipping algorithms.">

    <meta property="og:image" content="/logo.png">
    <meta property="og:type" content="article">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@divyamohan1993">
    <meta name="twitter:creator" content="@divyamohan1993">
    <meta name="twitter:image" content="/logo.png">

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />

    <meta name="author" content="Divya Mohan">
    <meta name="robots" content="index, follow">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function () {
            renderMathInElement(document.body, {
                // customised options
                // • auto-render specific keys, e.g.:
                delimiters: [
                    { left: '$$', right: '$$', display: true },
                    { left: '$', right: '$', display: false },
                    { left: '\\(', right: '\\)', display: false },
                    { left: '\\[', right: '\\]', display: true }
                ],
                // • rendering keys, e.g.:
                throwOnError: false
            });
        });
    </script>

    <style>
        /* 
        main ul {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }

        main ul li {
            margin: 0;
            padding: 0;
        } 
        */

        /* Prevent line breaks in tables as requested */
        .table td,
        .table th {
            white-space: nowrap;
        }
    </style>


    <!-- JSON-LD Structured Data for SEO -->
    <script type="application/ld+json">
        {
          "@context": "https://schema.org",
          "@type": "Course",
          "name": "Quick Summary & Numericals - Computer Graphics ESM",
          "description": "Quick revision summary for Computer Graphics ESM. Includes ultra-simple one-line definitions and fully solved numericals for DDA, Bresenham, and Clipping algorithms.",
          "url": "https://dmj.one/edu/su/course/csu358/theory/notes-end-semester",
          "dateModified": "2025-11-02",
          "provider": [
            {
              "@type": "EducationalOrganization",
              "name": "dmj.one",
              "url": "https://dmj.one"
            },
            {
              "@type": "EducationalOrganization",
              "name": "Shoolini University",
              "url": "https://shooliniuniversity.com"
            }
          ],
          "offers": {
              "@type": "Offer",
              "category": "Education",
              "price": "0",
              "priceCurrency": "USD",
              "availability": "https://schema.org/InStock",
              "url": "https://dmj.one/edu/su/course/csu358/theory/notes-end-semester"
          },
          "hasCourseInstance": {
              "@type": "CourseInstance",
              "name": "Computer Graphics Notes ESM - CSU358",
              "description": "Comprehensive notes ESM summary on Computer Graphics including CRT displays, raster and random scan techniques, frame buffers, input devices, and line drawing algorithms.",
              "courseMode": "online",
              "startDate": "2025-11-02",
              "courseWorkload": "PT4H",               
              "instructor": [
                {
                  "@type": "Person",
                  "name": "Dr. Sonia",
                  "url": "https://shooliniuniversity.com/faculty/profile/Sonia"
                },
                {
                  "@type": "Person",
                  "name": "Divya Mohan",                                      
                  "url": "https://dmj.one/resume/",
                    "sameAs": [
                        "https://www.credly.com/users/divyamohan1993",
                        "https://www.linkedin.com/in/divyamohan1993/",
                        "https://hackerrank.com/divyamohan1993",
                        "https://www.coursera.org/learner/divyamohan1993"
                    ]
                }
              ],
              "url": "https://dmj.one/edu/su/course/csu358/"
            }
        }
        </script>


</head>

<body>

    <script> header_author("dm"); </script>

    <main>
        <article class="agen-tableofcontents">
            <h2 class="text-center">
                Computer Graphics Notes ESM
            </h2>
            <div class="d-none contentdate">2025, December 14</div>
        </article>

        <article>
            <h3>UNIT 1: INTRODUCTION & HARDWARE</h3>
        </article>

        <article>
            <h4>1. What is Computer Graphics?</h4>
            <p><strong>Simple Definition:</strong> Computer Graphics is the art and science of drawing pictures using computers. It acts as a <strong>translator</strong>: it takes numbers (which computers understand) and turns them into images (which humans understand).</p>
            <p><strong>Core Purpose:</strong> To visualize information. Whether it is a graph, a movie character, or a
                medical scan, graphics make data readable.</p>

        </article>

        <article>
            <h4>2. Applications (Where do we use it?)</h4>
            <ul>
                <li><strong>Entertainment:</strong> Movies (VFX), Games (3D rendering).</li>
                <li><strong>Medical:</strong> MRI and CT Scans (visualizing internal organs).</li>
                <li><strong>CAD/CAM:</strong> Designing buildings and cars before building them.</li>
                <li><strong>Education:</strong> Simulators for pilots (Flight Simulators).</li>
                <li><strong>GUI:</strong> The icons and windows you click on every day.</li>
            </ul>
        </article>

        <article>
            <h4>3. Graphics Hardware (The Tools)</h4>
            <p>Hardware is divided into Input (giving orders) and Output (seeing results).</p>
            <ul>
                <li><strong>Input:</strong> Mouse, Keyboard, Light Pen, Graphic Tablet (Digitizer).</li>
                <li><strong>Output:</strong> Monitors (CRT, LCD, LED), Printers, Plotters (for big engineering
                    drawings).</li>
            </ul>
        </article>

        <article>
            <h4>4. The Frame Buffer (Crucial Exam Concept)</h4>
            <p>The <strong>Frame Buffer</strong> is the memory that holds the picture before it goes to the screen.</p>
            <p><strong>Concept:</strong> The screen is a grid of pixels. The Frame Buffer stores the color code for
                every single pixel.</p>
            <p><strong>Memory Calculation Formula:</strong><br>
                $\text{Memory} = \text{Resolution} \times \text{Color Depth}$</p>
            <p><strong>Example:</strong> For resolution $1024 \times 768$ and 24-bit color:<br>
                $$1024 \times 768 \times 24 \approx 18.8 \text{ million bits} \approx 2.25 \text{ MB}$$</p>
        </article>

        <article>
            <h3>UNIT 2: TRANSFORMATIONS (THE MATH)</h3>
        </article>

        <article>
            <h4>1. What are Transformations?</h4>
            <p>Transformation simply means <strong>changing</strong> an object. We use <strong>Matrix
                    Multiplication</strong> to do this because computers can calculate matrices very fast.</p>
        </article>

        <article>
            <h4>2. 2D Transformations (The Big 5)</h4>
            <p>You must memorize these 5 operations.</p>


            <h5>A. Translation (Moving)</h5>
            <p>Moving an object from point A to point B. We <strong>add</strong> values to coordinates.</p>
            <p>$$x' = x + t_x$$<br>$$y' = y + t_y$$</p>

            <h5>B. Scaling (Resizing)</h5>
            <p>Making an object bigger or smaller. We <strong>multiply</strong> coordinates.</p>
            <p>$$x' = x \cdot s_x$$<br>$$y' = y \cdot s_y$$</p>
            <ul>
                <li>If $s_x, s_y > 1$: Zoom In (Enlarge)</li>
                <li>If $s_x, s_y < 1$: Zoom Out (Shrink)</li>
            </ul>

            <h5>C. Rotation (Spinning)</h5>
            <p>Turning an object around a point by angle $\theta$.</p>
            <p>Without Matrix Formula:</p>
            <p>$$x' = x \cdot \cos\theta - y \cdot \sin\theta$$<br>
                $$y' = x \cdot \sin\theta + y \cdot \cos\theta$$</p>
            <p><strong>Matrix (Counter-Clockwise):</strong></p>
            <p>$$
                \begin{bmatrix}
                \cos\theta & -\sin\theta \\
                \sin\theta & \cos\theta
                \end{bmatrix}
                $$</p>

            <h5>D. Reflection (Mirroring)</h5>
            <p>Flipping an object (like looking in a mirror).</p>
            <p>Without Matrix Formula:</p>
            <p>$$x' = -x \text{ or } y' = -y $$</p>
            <ul>
                <li><strong>X-axis Reflection:</strong> $y$ becomes negative.</li>
                <li><strong>Y-axis Reflection:</strong> $x$ becomes negative.</li>
            </ul>

            <h5>E. Shearing (Slanting)</h5>
            <p>Distorting the shape (like pushing the top of a deck of cards).</p>
            <p>Without Matrix Formula:</p>
            <p>$$x' = x + k_y \cdot y$$<br>$$y' = y + k_x \cdot x$$</p>
            <ul>
                <li><strong>X-direction Shear:</strong> $x$ changes based on $y$.</li>
                <li><strong>Y-direction Shear:</strong> $y$ changes based on $x$.</li>
            </ul>

        </article>

        <article>
            <h4>3. Homogeneous Coordinates</h4>
            <p><strong>Problem:</strong> Translation uses <em>addition</em>, but Scaling/Rotation use
                <em>multiplication</em>. We want to combine them all into one matrix multiplication.
            </p>
            <p><strong>Solution:</strong> Add a dummy coordinate '$1$'.</p>
            <p>Point $(x, y)$ becomes $(x, y, 1)$. This allows us to represent Translation as a matrix multiplication
                too.</p>
        </article>

        <article>
            <h4>4. 3D Transformations</h4>
            <p>This is exactly the same as 2D, just add a $Z$-axis. We use <strong>4×4 Matrices</strong> (using
                homogeneous coordinate $w=1$).</p>
            <p>Point becomes $(x, y, z, 1)$.</p>
            <h4>All formulas of 3d transformatin without matrix</h4>
            <article>
                <h5>A. Translation</h5>
                <p>$$x' = x + t_x$$<br>$$y' = y + t_y$$<br>$$z' = z + t_z$$</p>
            </article>
            <article>
                <h5>B. Scaling</h5>
                <p>$$x' = x \cdot s_x$$<br>$$y' = y \cdot s_y$$<br>$$z' = z \cdot s_z$$</p>
            </article>
            <article>
                <h5>C. Rotation</h5>
                <p><strong>About X-axis:</strong></p>
                <p>$$x' = x$$<br>$$y' = y \cdot \cos\theta - z \cdot \sin\theta$$<br>$$z' = y \cdot \sin\theta + z \cdot
                    \cos\theta$$</p>
                <p><strong>About Y-axis:</strong></p>
                <p>$$x' = z \cdot \sin\theta + x \cdot \cos\theta$$<br>$$y' = y$$<br>$$z' = z \cdot \cos\theta - x \cdot
                    \sin\theta$$</p>
                <p><strong>About Z-axis:</strong></p>
                <p>$$x' = x \cdot \cos\theta - y \cdot \sin\theta$$<br>$$y' = x \cdot \sin\theta + y \cdot
                    \cos\theta$$<br>$$z' = z$$</p>
            </article>
            <article>
                <h5>D. Reflection</h5>
                <p>$$x' = -x \text{ or } y' = -y \text{ or } z' = -z $$</p>
            </article>
            <article>
                <h5>E. Shearing</h5>
                <p>$$x' = x + k_{xy} \cdot y + k_{xz} \cdot z$$<br>$$y' = y + k_{yx} \cdot x + k_{yz} \cdot z$$<br>$$z'
                    = z + k_{zx} \cdot x + k_{zy} \cdot y$$</p>
            </article>
            <article>
                <h5>F. Composite Transformations</h5>
                <p>To combine multiple transformations, multiply their matrices in the <strong>reverse order</strong> of
                    application.</p>
                <p>Example: To first rotate, then translate, use <br>
                    $$\text{Final Matrix} = \text{Translation Matrix} \times \text{Rotation Matrix}$$ </p>
                <p>This way, when you multiply the point, it first gets rotated, then translated.</p>
                <p><strong>Important:</strong> Matrix multiplication is <strong>not commutative</strong>. The order
                    matters!</p>
            </article>
            <article>
                <h5>G. Coordinate Systems</h5>
                <p>In 3D graphics, we often switch between different coordinate systems:</p>
                <ul>
                    <li><strong>World Coordinates:</strong> The global 3D space where all objects live.</li>
                    <li><strong>Camera (View) Coordinates:</strong> The viewpoint of the camera. Transform objects from
                        World to Camera space.</li>
                    <li><strong>Screen Coordinates:</strong> The 2D pixel grid of the display. Transform from Camera to
                        Screen space using Projection.</li>
                </ul>
            </article>
        </article>

        <article>
            <h3>UNIT 3: PROJECTION</h3>
        </article>

        <article>
            <h4>1. What is Projection?</h4>
            <p>Screens are 2D (flat). The world is 3D. Projection is the math used to squash a 3D object onto a 2D
                screen.</p>

        </article>

        <article>
            <h4>2. Parallel Projection</h4>
            <p><strong>Concept:</strong> Light rays travel parallel to each other. There is <strong>no depth</strong>.
            </p>
            <p><strong>Real Life Example:</strong> The shadow of a building at noon.</p>
            <ul>
                <li>Objects do <strong>not</strong> get smaller as they go far away.</li>
                <li>Used in: <strong>Engineering & Architecture (CAD)</strong> because exact measurements are preserved.
                </li>
            </ul>
        </article>

        <article>
            <h4>3. Perspective Projection</h4>
            <p><strong>Concept:</strong> All light rays meet at one point (Center of Projection). This mimics the
                <strong>Human Eye</strong>.
            </p>
            <p><strong>Real Life Example:</strong> Standing on a railway track; the tracks seem to meet at a point in
                the distance (Vanishing Point).</p>
            <ul>
                <li>Objects look <strong>smaller</strong> as they go farther away.</li>
                <li>Used in: <strong>Games, Movies, VR</strong> because it looks realistic.</li>
            </ul>
        </article>

        <article>
            <h3>UNIT 4: VISIBLE SURFACE DETECTION</h3>
        </article>

        <article>
            <h4>1. The Problem</h4>
            <p>When you look at a car, you can't see the engine inside. The metal body covers it. The computer needs to
                know what is in front (visible) and what is behind (hidden) so it doesn't waste time drawing hidden
                things.</p>
        </article>

        <article>
            <h4>2. Z-Buffer Algorithm (Depth Buffer)</h4>
            <p>This is the most popular algorithm used in almost all graphics cards today.</p>
            <p><strong>How it works (The Feynman Explanation):</strong></p>
            <ol>
                <li>Imagine a grid representing your screen pixels.</li>
                <li>Every pixel has a "Depth Card" (Z-Buffer) that starts at Infinity (very far away).</li>
                <li>When the computer wants to draw a pixel of an object, it calculates the distance ($Z$) of that
                    object from the camera.</li>
                <li><strong>Comparison:</strong>
                    <ul>
                        <li>Is the new object <strong>closer</strong> ($Z_{new} &lt; Z_{old}$) than what is currently
                            there?</li>
                        <li><strong>YES:</strong> Paint the new color and write the new $Z$ on the Depth Card.</li>
                        <li><strong>NO:</strong> Ignore it (it's hidden behind something else).</li>
                    </ul>
                </li>
            </ol>
            <p><strong>Pros:</strong> Simple and easy to implement in hardware.<br>
                <strong>Cons:</strong> Takes extra memory.
            </p>

        </article>

        <article>
            <h4>3. A-Buffer (Anti-Aliased Buffer)</h4>
            <p><strong>Concept:</strong> An upgrade to Z-Buffer. Instead of storing just <em>one</em> value per pixel,
                it stores a <strong>list</strong> of data for that pixel.</p>
            <p><strong>Why?</strong> It helps with <strong>Transparency</strong> (seeing through glass) and
                <strong>Anti-aliasing</strong> (smoothing jagged edges).
            </p>
        </article>

        <article>
            <h3>UNIT 5: ANIMATION</h3>
        </article>

        <article>
            <h4>1. What is Animation?</h4>
            <p>Animation is creating the <strong>illusion of motion</strong> by showing a series of still images
                (frames) very quickly. The eye blends them together.</p>
        </article>

        <article>
            <h4>2. Key Techniques</h4>


            <h5>A. Panning</h5>
            <p><strong>Concept:</strong> The camera rotates horizontally (left or right) while standing in one spot.</p>
            <p><strong>Analogy:</strong> Turning your head left and right to see the whole room without moving your
                feet.</p>
            <p><strong>Use:</strong> To follow a character running across the screen or to reveal a large background.
            </p>

            <h5>B. Tweening (In-Betweening)</h5>
            <p><strong>Concept:</strong> The lazy (smart) way to animate.</p>
            <ul>
                <li><strong>Keyframes:</strong> You draw the Start (Frame 1) and the End (Frame 10).</li>
                <li><strong>Tweening:</strong> The computer calculates the math to generate Frames 2 to 9 automatically.
                </li>
            </ul>
            <p><strong>Benefit:</strong> Saves massive amounts of time. Used in Flash/Animate and modern 3D software.
            </p>


        </article>

        <article>
            <h4>3. Types of Animation</h4>
            <ul>
                <li><strong>Frame-by-Frame:</strong> Drawing every single image manually. (Old Disney movies). <em>Slow
                        but artistic.</em></li>
                <li><strong>Keyframe Animation:</strong> Drawing main poses and letting the computer Tween the rest.
                    (Tom & Jerry style).</li>
                <li><strong>Procedural Animation:</strong> Using code/rules to move things. (Example: "If wind blows,
                    move leaves"). Good for particles, water, fire.</li>
                <li><strong>Motion Capture (MoCap):</strong> Put a sensor suit on a human, record their dance, and apply
                    it to a 3D robot. (Avatar movie).</li>
                <li><strong>Morphing:</strong> Smoothly transforming one shape into another (e.g., A man's face turning
                    into a werewolf).</li>
            </ul>
        </article>

        <article>
            <h3>1. What Computer Graphics Is — The Mental Model</h3>
            <p>Computer Graphics is the discipline of converting numerical data into visual representations that humans
                can perceive and interpret.</p>
            <p>Every image displayed on a screen is fundamentally data—geometry, color, and depth—mapped to pixels at
                precise spatial locations and refreshed over time.</p>
            <ul>
                <li><strong>Geometric view</strong>: Objects are represented using vertices, edges, surfaces, vectors,
                    and matrices.</li>
                <li><strong>Sampling view</strong>: Continuous geometry is discretized into pixels using rasterization
                    and stored in the frame buffer.</li>
            </ul>
        </article>

        <article>
            <h3>2. Hardware Basics and the Frame Buffer</h3>
            <p>Input devices such as mouse, keyboard, and tablets generate events and coordinates. Output devices such
                as CRT, LCD, LED displays, plotters, and printers present the final visual output.</p>
            <p>The frame buffer is a contiguous block of memory that stores color values for every pixel.</p>
            <p>If resolution is $W \times H$ and color depth is $b$ bits:</p>
            <p>$$\text{Memory} = W \times H \times b \text{ bits}$$</p>
            <p>Example: $1024 \times 768$ resolution at 24-bit color requires approximately $18\ \text{MB}$.</p>
        </article>

        <article>
            <h3>3. The Graphics Pipeline — Model to Screen</h3>
            <p>The graphics pipeline transforms abstract models into displayed pixels through ordered stages.</p>
            <ul>
                <li><strong>Modeling</strong>: Define objects using meshes or splines.</li>
                <li><strong>Model, World, View transforms</strong>: Position objects and camera.</li>
                <li><strong>Lighting and shading</strong>: Compute surface colors.</li>
                <li><strong>Projection</strong>: Map 3D geometry to 2D.</li>
                <li><strong>Clipping</strong>: Remove geometry outside the view.</li>
                <li><strong>Rasterization</strong>: Convert primitives into fragments.</li>
                <li><strong>Visible-surface determination</strong>: Select nearest fragment per pixel.</li>
                <li><strong>Fragment shading and blending</strong>: Apply textures and transparency.</li>
                <li><strong>Display</strong>: Write pixels to frame buffer.</li>
            </ul>
        </article>

        <article>
            <h3>4. Transformations — How Objects Move and Change</h3>
            <p>Transformations determine how a point changes position, size, or orientation.</p>
            <p>Points are vectors and transformations are matrices.</p>
            <p>For a point $(x,y)$:</p>
            <ul>
                <li><strong>Translation</strong>: $x' = x + T_x,\; y' = y + T_y$</li>
                <li><strong>Scaling</strong>: $x' = S_x x,\; y' = S_y y$</li>
                <li><strong>Rotation</strong>:
                    $$
                    x' = x\cos\theta - y\sin\theta,\quad
                    y' = x\sin\theta + y\cos\theta
                    $$
                </li>
            </ul>
            <p>Homogeneous coordinates represent $(x,y)$ as $(x,y,1)$, enabling all affine transformations using a
                single $3 \times 3$ matrix.</p>
            <p>Composite transformations require matrix multiplication in correct order; order is not commutative.</p>
            <p>Three-dimensional transformations extend this idea using $4 \times 4$ matrices.</p>
        </article>

        <article>
            <h3>5. Projection — Mapping 3D to 2D</h3>
            <p><strong>Parallel projection</strong> uses parallel projection lines and preserves size regardless of
                depth.</p>
            <p><strong>Perspective projection</strong> simulates human vision where distant objects appear smaller:</p>
            <p>$$
                x' = \frac{fx}{z},\quad y' = \frac{fy}{z}
                $$</p>
            <p>Here, $f$ is focal length and $z$ represents depth.</p>
        </article>

        <article>
            <h3>6. Visible-Surface Algorithms</h3>
            <p>For each pixel, the visible surface is the one closest to the camera.</p>
            <ul>
                <li><strong>Z-buffer</strong>: Stores depth per pixel, replacing color only if new depth is smaller.
                </li>
                <li><strong>A-buffer</strong>: Stores lists of fragments per pixel, enabling correct transparency and
                    anti-aliasing.</li>
            </ul>
        </article>

        <article>
            <h3>7. Rasterization — Drawing Primitives</h3>
            <p>Rasterization converts geometric primitives into discrete pixels.</p>
            <ul>
                <li><strong>DDA</strong>: Uses floating-point increments.</li>
                <li><strong>Bresenham</strong>: Uses integer arithmetic and decision parameters.</li>
                <li><strong>Circle rasterization</strong>: Computes one octant and mirrors using symmetry.</li>
            </ul>
        </article>

        <article>
            <h3>8. Clipping — Restricting Geometry to the View</h3>
            <p>Clipping removes parts of geometry outside the viewing region.</p>
            <p><strong>Cohen–Sutherland</strong> assigns 4-bit region codes and performs trivial accept, reject, or
                intersection.</p>
            <p>Vertical boundary intersection:</p>
            <p>$$y = y_1 + m(x_{clip} - x_1)$$</p>
            <p>Horizontal boundary intersection:</p>
            <p>$$x = x_1 + \frac{y_{clip} - y_1}{m}$$</p>
        </article>

        <article>
            <h3>9. Color, Shading, and Lighting</h3>
            <p>Lighting models describe how light interacts with surfaces.</p>
            <ul>
                <li><strong>Flat shading</strong>: One color per polygon.</li>
                <li><strong>Gouraud shading</strong>: Interpolated vertex colors.</li>
                <li><strong>Phong shading</strong>: Per-pixel lighting using interpolated normals.</li>
            </ul>
            <p>Textures map 2D images onto surfaces using interpolation and mipmapping.</p>
        </article>

        <article>
            <h3>10. Animation — Change Over Time</h3>
            <p>Animation is defined as controlled change of properties over time.</p>
            <ul>
                <li><strong>Tweening</strong>: Interpolation between keyframes.</li>
                <li><strong>Morphing</strong>: Shape interpolation.</li>
                <li><strong>Procedural and behavioral animation</strong>: Rule-based motion.</li>
                <li><strong>Motion capture and dynamics</strong>: Real and physics-based motion.</li>
            </ul>
            <p>Panning rotates the camera without translation.</p>
        </article>

        <article>
            <h3>11. Core Algorithms — Pseudocode</h3>
            <pre><code class="language-auto">
DDA Line Algorithm
dx = x2 - x1
dy = y2 - y1
steps = max(|dx|, |dy|)
x_inc = dx / steps
y_inc = dy / steps
for i = 0..steps:
  plot(round(x), round(y))
  x += x_inc
  y += y_inc
</code></pre>

            <pre><code class="language-auto">
Bresenham Line Algorithm (0 ≤ m ≤ 1)
p = 2*dy - dx
for each x:
  if p &lt; 0:
    p += 2*dy
  else:
    p += 2*dy - 2*dx
    y++
</code></pre>
        </article>

        <article>
            <h3>12. Numerical Practice and Intuition</h3>
            <p>Manual numerical problems reinforce understanding of rasterization, transformations, and clipping.</p>
            <p>Practicing step-by-step arithmetic exposes precision issues and edge cases.</p>
        </article>

        <article>
            <h3>13. Pitfalls and Deep Insights</h3>
            <ul>
                <li>Transformation order is critical.</li>
                <li>Integer arithmetic improves efficiency.</li>
                <li>Z-buffer precision depends on depth mapping.</li>
                <li>Transparency requires sorting or accumulation.</li>
                <li>Perspective-correct interpolation avoids distortion.</li>
            </ul>
        </article>

        <article>
            <h3>14. Pareto Learning Focus</h3>
            <p>Mastering pipeline stages, transformations, rasterization, projection, depth buffering, and clipping
                yields most practical understanding.</p>
        </article>

        <article>
            <h3>15. Exam-Speed Mental Shortcuts</h3>
            <ul>
                <li>Check trivial accept/reject before clipping intersections.</li>
                <li>Choose stepping axis based on slope.</li>
                <li>Memorize common rotation results.</li>
                <li>Use homogeneous matrices for compact computation.</li>
            </ul>
        </article>






    </main>

    <script> copyright("all"); </script>

</body>

</html>