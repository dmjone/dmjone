<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>

        <title>Unit 2: Drawing Algorithms - Computer Graphics Notes - CSU358</title>
        <meta name="description" content="Unit 2: Drawing Algorithms. Comprehensive guide on DDA, Bresenham Line & Circle algorithms, and Polygon Filling techniques.">

        <meta property="og:image" content="/logo.png">
        <meta property="og:type" content="article">

        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@divyamohan1993">
        <meta name="twitter:creator" content="@divyamohan1993">
        <meta name="twitter:image" content="/logo.png">

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />

        <meta name="author" content="Divya Mohan">
        <meta name="robots" content="index, follow">

        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                renderMathInElement(document.body, {
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\(', right: '\\)', display: false },
                        { left: '\\[', right: '\\]', display: true }
                    ],
                    throwOnError: false
                });
            });
        </script>



        <!-- JSON-LD Structured Data for SEO -->
        <script type="application/ld+json">
        {
          "@context": "https://schema.org",
          "@type": "Course",
          "name": "Unit 2: Drawing Algorithms - Computer Graphics Notes",
          "description": "Comprehensive guide on Computer Graphics Drawing Algorithms including DDA, Bresenham, and Polygon Filling.",
          "url": "https://dmj.one/edu/su/course/csu358/theory/unit2_drawing_algorithms.html",
          "provider": [
            { "@type": "EducationalOrganization", "name": "dmj.one", "url": "https://dmj.one" },
            { "@type": "EducationalOrganization", "name": "Shoolini University", "url": "https://shooliniuniversity.com" }
          ]
        }
    </script>
    </head>

    <body>
        <script> header_author("dm"); </script>
        <main>

            <article class="agen-tableofcontents">
                <h2 class="text-center">
                    Unit 2: Drawing Algorithms
                </h2>
                <div class="d-none contentdate">2025, December 14</div>
            </article>


            <p class="alert alert-info text-center" role="alert">
                <strong>Exam Strategy:</strong> If asked for an "Algorithm", write the steps in a numbered list exactly as shown below.
            </p>

            <!-- SECTION 1: LINE DRAWING -->
            <article>
                <h2>2.1 Line Drawing Algorithms</h2>

                <h3>A. DDA Algorithm (Digital Differential Analyzer)</h3>
                <p><strong>Concept:</strong> The "Calculator" method. It calculates the next point using floating-point
                    addition
                    (decimals).</p>

                <h4>The Recipe:</h4>
                <ol>
                    <li><strong>Input:</strong> Start $(x_1, y_1)$ and End $(x_2, y_2)$.</li>
                    <li><strong>Calculate Slope:</strong> $dx = x_2 - x_1$, $dy = y_2 - y_1$.</li>
                    <li><strong>Find Steps:</strong> If $|dx| > |dy|$, use $Steps = |dx|$; else $Steps = |dy|$.</li>
                    <li><strong>Calculate Increment:</strong> $X_{inc} = dx / Steps$, $Y_{inc} = dy / Steps$.</li>
                    <li><strong>Loop:</strong> Start at $(x_1, y_1)$. Repeat <em>Steps</em> times:
                        <ul>
                            <li>$x_{next} = x + X_{inc}$</li>
                            <li>$y_{next} = y + Y_{inc}$</li>
                            <li>Round values and plot pixel.</li>
                        </ul>
                    </li>
                </ol>


                <h3>B. Bresenham’s Line Algorithm</h3>
                <p><strong>Concept:</strong> The "Integer" method. Faster because it avoids decimals. It simply asks: "Should I go straight or diagonal?"</p>

                <h4>The Recipe:</h4>
                <ol>
                    <li><strong>Constants:</strong> Calculate $2dy$ and $2dy - 2dx$.</li>
                    <li><strong>Initial Decision ($P_0$):</strong> $P_0 = 2dy - dx$.</li>
                    <li><strong>Loop:</strong> At each step $k$:
                        <ul>
                            <li><strong>If $P_k < 0$:</strong> Plot $(x+1, y)$. <br> Update $P_{k+1} = P_k + 2dy$.</li>
                            <li><strong>If $P_k \ge 0$:</strong> Plot $(x+1, y+1)$. <br> Update $P_{k+1} = P_k + 2dy -
                                2dx$.
                            </li>
                        </ul>
                    </li>
                </ol>                
            </article>

            <!-- REVISION: LINE DRAWING -->
            <article>
                <pre class="mermaid text-center">
mindmap
  root((Line Strategy))
    DDA (Calculator)
      Decimals / Floats
      Rounding Needed
      Slow & Simple
    Bresenham (Integer)
      Integer Math Only
      Decision Var (P)
      Fast & Precise
            </pre>
            </article>

            <!-- SECTION 2: CIRCLE DRAWING -->
            <article>
                <h3>2.2 Mid-Point Circle Algorithm</h3>
                <p class="analogy">
                    <strong>Analogy:</strong> Drawing a circle is hard. So we cheat. We only calculate <strong>1/8th</strong> of the circle (pizza slice) and mirror it 8 times to get the full circle.
                </p>
                <h4>The Recipe:</h4>
                <ol>
                    <li><strong>Start:</strong> $(0, r)$.</li>
                    <li><strong>Initial Decision:</strong> $P_0 = 1 - r$ (assuming integer radius).</li>
                    <li><strong>Loop (while $x < y$):</strong>
                                <ul>
                                    <li>Always increment $x$ ($x = x + 1$).</li>
                                    <li><strong>If $P_k < 0$:</strong> $y$ stays same. <br> Update $P_{k+1} = P_k + 2x +
                                                1$.
                                    </li>
                                    <li><strong>If $P_k \ge 0$:</strong> Decrement $y$ ($y = y - 1$). <br> Update
                                        $P_{k+1} =
                                        P_k + 2x - 2y + 1$.</li>
                                </ul>
                    </li>
                    <li><strong>Plot:</strong> For every point $(x,y)$, plot its 8 reflections: $(y,x), (-x,y), (-y,x)$,
                        etc.</li>
                </ol>

            </article>

            <!-- REVISION: CIRCLE -->
            <article>
                <pre class="mermaid text-center">
mindmap
  root((Circle Hacks))
    The Challenge
      Curves are costly
      Trig is slow
    The Solution
      8-Way Symmetry
      Calc 1 slice
      Mirror 8 times
    The Math
      Mid-Point Algo
      Integer Decisions
            </pre>
            </article>

            <!-- SECTION 3: POLYGON FILLING (CONSOLIDATED) -->
            <article>
                <h2>2.3 Polygon Filling (Coloring the Shapes)</h2>
                <p>How does the computer know which pixels are "inside" a shape to fill it with color?</p>

                <h3>Method 1: The Odd-Even Rule (Parity Rule)</h3>
                <p>Used in simpler shapes.</p>
                <ul>
                    <li><strong>How it works:</strong> Draw a horizontal line (scan line) across the screen. Count the edge
                        intersections.</li>
                    <li><strong>Rule:</strong>
                        <ul>
                            <li><strong>Odd count (1, 3, 5):</strong> You are <strong>inside</strong> (Color ON).</li>
                            <li><strong>Even count (0, 2, 4):</strong> You are <strong>outside</strong> (Color OFF).</li>
                        </ul>
                    </li>
                </ul>

                <h3>Method 2: The Non-Zero Winding Rule</h3>
                <p><em>(Better for complex/overlapping shapes)</em></p>
                <ul>
                    <li><strong>How it works:</strong> Imagine winding a string around the shape.
                        <ul>
                            <li>Give edges a direction.</li>
                            <li>Intersection going <strong>Up</strong> = +1.</li>
                            <li>Intersection going <strong>Down</strong> = -1.</li>
                        </ul>
                    </li>
                    <li><strong>Rule:</strong> If the final sum is $\neq 0$, the point is <strong>Inside</strong>. If 0, it
                        is
                        Outside.</li>
                </ul>

                <h3>Method 3: Scan-Line Fill Algorithm (Using Tables)</h3>
                <p>The efficient way computers actually do it. It doesn't check every pixel; it calculates "spans".</p>                
                    <p>Keywords for Exam: Mention "Edge Tables" to score full marks.
                    </p>
                    <ul>
                        <li><strong>Global Edge Table (GET):</strong> A master list of all polygon edges, sorted by their bottom
                            Y-coordinate.</li>
                        <li><strong>Active Edge Table (AET):</strong> A temporary list of edges that intersect the
                            <em>current</em>
                            scan line being drawn. We only process edges in the AET.
                        </li>
                    </ul>
            </article>

            <!-- REVISION: FILLING -->
            <article>
                <pre class="mermaid text-center">
mindmap
  root((Filling Shapes))
    Inside Tests
      Odd-Even Rule
        Simple Shapes
        Count Edges
      Non-Zero Winding
        Complex Shapes
        Direction check
    The Engine
      Scan-Line Algo
      Edge Tables
      GET to AET
            </pre>
            </article>

            <script> copyright("all"); </script>

        </main>
    </body>

</html>