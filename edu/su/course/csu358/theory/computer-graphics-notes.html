<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
<!--<![endif]-->

<head>
    <script src="/js/edu_su_common.js"></script>
    <noscript>
        <style>
            html,
            body {
                margin: 0;
                overflow: hidden;
            }
        </style>
        <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
    </noscript>

    <title>Computer Graphics Notes - CSU358 - Shoolini U</title>
    <meta name="description" content="Comprehensive notes on topic including CRT displays, raster and random scan techniques, frame buffers, input devices, and line drawing algorithms.">

    <meta property="og:image" content="/logo.png">
    <meta property="og:type" content="article">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@divyamohan1993">
    <meta name="twitter:creator" content="@divyamohan1993">
    <meta name="twitter:image" content="/logo.png">

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />

    <meta name="author" content="Divya Mohan">
    <meta name="robots" content="index, follow">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function () {
            renderMathInElement(document.body, {
                // customised options
                // • auto-render specific keys, e.g.:
                delimiters: [
                    { left: '$$', right: '$$', display: true },
                    { left: '$', right: '$', display: false },
                    { left: '\\(', right: '\\)', display: false },
                    { left: '\\[', right: '\\]', display: true }
                ],
                // • rendering keys, e.g.:
                throwOnError: false
            });
        });
    </script>

    <!-- <style>
            main ul {
                list-style-type: none;
                padding: 0;
                margin: 0;
            }

            main ul li {
                margin: 0;
                padding: 0;
            }
        </style> -->

    <!-- JSON-LD Structured Data for SEO -->
    <script type="application/ld+json">
        {
          "@context": "https://schema.org",
          "@type": "Course",
          "name": "Computer Graphics Notes",
          "description": "Computer Graphics course, part of the CSU358 series, is a free initiative by dmj.one to provide quality education for all. Master Computer Graphics, covering core principles, raster and random scan techniques, frame buffers, input devices, and line drawing algorithms.",
          "url": "https://dmj.one/edu/su/course/csu358/theory/computer-graphics-notes",
          "dateModified": "2025-11-02",
          "provider": [
            {
              "@type": "EducationalOrganization",
              "name": "dmj.one",
              "url": "https://dmj.one"
            },
            {
              "@type": "EducationalOrganization",
              "name": "Shoolini University",
              "url": "https://shooliniuniversity.com"
            }
          ],
          "offers": {
              "@type": "Offer",
              "category": "Education",
              "price": "0",
              "priceCurrency": "USD",
              "availability": "https://schema.org/InStock",
              "url": "https://dmj.one/edu/su/course/csu358/theory/computer-graphics-notes"
          },
          "hasCourseInstance": {
              "@type": "CourseInstance",
              "name": "Computer Graphics Notes - CSU358",
              "description": "Comprehensive notes on Computer Graphics including CRT displays, raster and random scan techniques, frame buffers, input devices, and line drawing algorithms.",
              "courseMode": "online",
              "startDate": "2025-11-02",
              "courseWorkload": "PT4H",               
              "instructor": [
                {
                  "@type": "Person",
                  "name": "Dr. Sonia",
                  "url": "https://shooliniuniversity.com/faculty/profile/Sonia"
                },
                {
                  "@type": "Person",
                  "name": "Divya Mohan",                                      
                  "url": "https://dmj.one/resume/",
                    "sameAs": [
                        "https://www.credly.com/users/divyamohan1993",
                        "https://www.linkedin.com/in/divyamohan1993/",
                        "https://hackerrank.com/divyamohan1993",
                        "https://www.coursera.org/learner/divyamohan1993"
                    ]
                }
              ],
              "url": "https://dmj.one/edu/su/course/csu358/"
            }
        }
        </script>


</head>

<body>

    <script> header_author("dm"); </script>

    <main>
        <article class="agen-tableofcontents">
            <h2 class="text-center">
                Computer Graphics Notes
            </h2>
            <div class="text-center mb-4">
                <img src="img/computer-graphics-notes.png" alt="Computer Graphics Digital Art" class="img-fluid rounded shadow-lg" style="max-height: 400px; width: auto;">
            </div>
            <div class="d-none contentdate">2025, November 02</div>
        </article>

        <div class="mb-3 d-flex justify-content-center align-items-center">
            <a href="summary-computer-graphics-notes" class="btn btn-lg btn-outline-primary d-print-none">
                <i class="bi bi-exclamation-triangle-fill me-2"></i> View Summary
            </a>
        </div>

        <article>
            <h3>Page 1: Computer Graphics: Introduction</h3>
            <p>Computer Graphics (from the two words: <em>Computer</em> + <em>Graphics</em>) introduces how images are generated, manipulated, and displayed using electronic systems.</p>
        </article>

        <article>
            <h4>Computer Graphics</h4>
            <p><strong>Computer</strong> → An electronic device.</p>
            <p><strong>Graphics</strong> → From the Greek word <em>graphikos</em>, meaning “to draw.”</p>
        </article>

        <article>
            <h4>Types of Graphics Devices</h4>
            <ul>
                <li><strong>CRT (Cathode Ray Tube)</strong>: The vacuum tube that generates and directs an electron beam onto a phosphor screen.</li>
                <li><strong>CRT Monitor</strong>: The complete display device that houses a CRT and associated electronics to render images.</li>
            </ul>
        </article>

        <article>
            <h4>CRT Working Principle</h4>
            <p>When an electron beam is emitted from the <strong>electron gun</strong>, it is directed toward the <strong>phosphor-coated screen</strong>. A <strong>focusing anode</strong> narrows the beam, while <strong>electromagnetic deflection coils</strong> (horizontal and vertical) position it at precise locations on the screen.</p>
            <p>The <strong>phosphor coating</strong> emits light when struck by electrons - this phenomenon is called <strong>fluorescence</strong>. Because this light persists only briefly, the image must be redrawn repeatedly - a process called <strong>refreshing</strong>.</p>
        </article>

        <article>
            <h4>Basic Idea</h4>
            <ul>
                <li>The electron gun produces a stream of electrons.</li>
                <li>These electrons are accelerated and focused into a narrow beam.</li>
                <li>The beam is deflected horizontally and vertically to reach specific points on the screen.</li>
                <li>Beam intensity controls the brightness of each pixel.</li>
                <li>The screen is refreshed many times per second (the <strong>refresh rate</strong>).</li>
            </ul>
        </article>

        <article>
            <h4>Diagram (from notebook)</h4>
            <p>Depicts the <strong>electron gun</strong>, <strong>focusing anode</strong>, <strong>horizontal and vertical deflection coils</strong>, and the <strong>phosphor screen</strong> where the image appears.</p>
            <pre class="mermaid text-center">graph TD
    A[Electron Gun]-->B[Focusing Anode]
    B --> C[Deflection Coils Horizontal &amp; Vertical]
    C --> D[Phosphor-Coated Screen]</pre>
        </article>

        <article>
            <h3>Page 2: Types of CRT Displays</h3>
            <p>There are mainly <strong>two types</strong> of CRT displays used in computer graphics:</p>
            <ul>
                <li><strong>Random Scan Display</strong> (also known as <em>Vector Display</em>)</li>
                <li><strong>Raster Scan Display</strong></li>
            </ul>
        </article>

        <article>
            <h4>1. Random Scan Display</h4>
            <ul>
                <li>Also called <strong>Vector Display</strong> or <strong>Stroke Writing Display</strong>.</li>
                <li>Used in older systems like early CAD/CAM and oscilloscopes.</li>
                <li>The electron beam is directed <strong>only along the lines</strong> forming the image.</li>
                <li>The beam directly draws the picture component by component.</li>
                <li>Suitable for <strong>line drawings</strong>, <strong>wireframes</strong>, and <strong>engineering diagrams</strong>.</li>
            </ul>
            <h5>Advantages</h5>
            <ul>
                <li>High resolution.</li>
                <li>Smooth line generation.</li>
            </ul>
            <h5>Disadvantages</h5>
            <ul>
                <li>Not suitable for complex or filled images.</li>
                <li>Limited color and shading support.</li>
            </ul>
        </article>

        <article>
            <h4>2. Raster Scan Display</h4>
            <ul>
                <li>This is the <strong>standard display method</strong> used in modern monitors and TVs.</li>
                <li>The screen is divided into a grid of small dots called <strong>pixels</strong>.</li>
                <li>The electron beam scans the screen <strong>line by line</strong> from <strong>top to bottom</strong>, left to right.</li>
                <li>Each pass is known as a <strong>refresh cycle</strong> or <strong>frame</strong>.</li>
            </ul>
            <h5>Advantages</h5>
            <ul>
                <li>Suitable for displaying images, animations, and colors.</li>
                <li>Supports high detail and realism.</li>
            </ul>
            <h5>Disadvantages</h5>
            <ul>
                <li>Requires large memory (Frame Buffer).</li>
                <li>Resolution depends on pixel density.</li>
            </ul>
        </article>

        <article>
            <h4>Raster vs Random Scan (Comparison Table)</h4>
            <div class="table-responsive">
                <table class="table table-bordered table-striped">
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>Random Scan</th>
                            <th>Raster Scan</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Image Representation</strong></td>
                            <td>Line drawings</td>
                            <td>Pixel-based (bitmap)</td>
                        </tr>
                        <tr>
                            <td><strong>Refresh Type</strong></td>
                            <td>Vector-based refresh</td>
                            <td>Line-by-line refresh</td>
                        </tr>
                        <tr>
                            <td><strong>Memory Requirement</strong></td>
                            <td>Low</td>
                            <td>High</td>
                        </tr>
                        <tr>
                            <td><strong>Use Case</strong></td>
                            <td>CAD, wireframe</td>
                            <td>Games, UI, animation</td>
                        </tr>
                        <tr>
                            <td><strong>Quality</strong></td>
                            <td>Smooth lines</td>
                            <td>Possible aliasing</td>
                        </tr>
                        <tr>
                            <td><strong>Color Support</strong></td>
                            <td>Limited</td>
                            <td>Full color supported</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </article>

        <article>
            <h3>Page 3: Frame Buffer and Display Devices</h3>
        </article>

        <article>
            <h4>Frame Buffer</h4>
            <p>A <strong>frame buffer</strong> is a <strong>memory area</strong> that stores the <strong>intensity (brightness) and color information</strong> for each pixel on the screen.</p>
            <p>It acts as a <strong>digital image storage</strong> before the display is drawn.</p>
            <p>Each location in the frame buffer corresponds to <strong>one pixel</strong> on the screen.</p>
            <p><strong>Example:</strong> If the screen has a resolution of <strong>640×480</strong>, then the frame buffer must store <strong>640 × 480 = 307,200 pixels</strong>.</p>
        </article>

        <article>
            <h4>Bit Depth (Color Resolution)</h4>
            <p>Each pixel can store different levels of color information depending on the <strong>number of bits used per pixel</strong>.</p>
            <div class="table-responsive">
                <table class="table table-bordered table-striped">
                    <thead>
                        <tr>
                            <th>Bits per Pixel</th>
                            <th>Colors Represented</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>1 bit</td>
                            <td>2 colors (black/white)</td>
                        </tr>
                        <tr>
                            <td>4 bits</td>
                            <td>16 colors</td>
                        </tr>
                        <tr>
                            <td>8 bits</td>
                            <td>256 colors</td>
                        </tr>
                        <tr>
                            <td>16 bits</td>
                            <td>65,536 colors</td>
                        </tr>
                        <tr>
                            <td>24 bits</td>
                            <td>16.7 million colors (True Color)</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </article>

        <article>
            <h4>Frame Buffer Example</h4>
            <p>If a display uses <strong>1024×768</strong> resolution and <strong>8-bit color</strong>,</p>
            <p>→ Frame buffer size = <strong>1024 × 768 × 8 bits = 6,291,456 bits ≈ 0.75 MB</strong></p>
            <p>$$1024 \times 768 \times 8\ \text{bits} = 6{,}291{,}456\ \text{bits} \approx 0.75\ \text{MB}$$</p>
        </article>

        <article>
            <h4>Display Devices</h4>
            <ol>
                <li><strong>CRT (Cathode Ray Tube)</strong> – Traditional display with electron gun and phosphor screen.</li>
                <li><strong>LCD (Liquid Crystal Display)</strong> – Uses liquid crystals and a backlight.</li>
                <li><strong>LED Display</strong> – Similar to LCD but uses light-emitting diodes for backlighting.</li>
                <li><strong>Plasma Display</strong> – Uses ionized gas cells (plasma) to produce images.</li>
                <li><strong>OLED Display</strong> – Each pixel emits light individually; better contrast and energy efficiency.</li>
            </ol>
        </article>

        <article>
            <h4>Key Terms</h4>
            <ul>
                <li><strong>Refresh Rate:</strong> Number of times the screen is redrawn per second (e.g., 60Hz, 120Hz).</li>
                <li><strong>Persistence:</strong> Time for a pixel to fade after the beam passes (low persistence = less flicker).</li>
                <li><strong>Resolution:</strong> Number of distinct pixels in each dimension (e.g., 1920×1080).</li>
            </ul>
        </article>

        <article>
            <h3>Page 4: Input Devices &amp; Display Techniques</h3>
            <p>This page lists common input devices used for interaction with graphical systems and summarizes foundational display techniques.</p>
        </article>

        <article>
            <h4>Input Devices in Computer Graphics</h4>
            <p>These are the devices that allow interaction between the user and the graphical system.</p>
            <ol>
                <li><strong>Keyboard</strong>
                    <ul>
                        <li>
                            <p>Used to input alphanumeric data and commands.</p>
                        </li>
                        <li>
                            <p>Commonly used in menu-driven and text-based graphical interfaces.</p>
                        </li>
                    </ul>
                </li>
                <li><strong>Mouse</strong>
                    <ul>
                        <li>
                            <p>A <strong>pointing device</strong> used to move a cursor on the screen.</p>
                        </li>
                        <li>
                            <p>Detects motion and translates it into cursor movement.</p>
                        </li>
                        <li>
                            <p>Actions like <strong>click</strong>, <strong>double-click</strong>, and <strong>drag</strong> are used in GUIs.</p>
                        </li>
                    </ul>
                </li>
                <li><strong>Light Pen</strong>
                    <ul>
                        <li>
                            <p>A <strong>photosensitive pen-like device</strong> that detects light emitted from the CRT screen.</p>
                        </li>
                        <li>
                            <p>When touched to the screen, it identifies the exact position.</p>
                        </li>
                        <li>
                            <p>Used in design and drawing systems.</p>
                        </li>
                    </ul>
                </li>
                <li><strong>Joystick</strong>
                    <ul>
                        <li>
                            <p>Used for interactive control in games or simulations.</p>
                        </li>
                        <li>
                            <p>Allows movement in multiple directions (up, down, left, right).</p>
                        </li>
                    </ul>
                </li>
                <li><strong>Trackball</strong>
                    <ul>
                        <li>
                            <p>A stationary input device with a rotating ball to control pointer movement.</p>
                        </li>
                        <li>
                            <p>Works as an upside-down mouse.</p>
                        </li>
                    </ul>
                </li>
                <li><strong>Scanner</strong>
                    <ul>
                        <li>
                            <p>Converts physical images or documents into digital form.</p>
                        </li>
                    </ul>
                </li>
                <li><strong>Digitizer</strong>
                    <ul>
                        <li>
                            <p>Converts hand-drawn graphics into digital coordinates.</p>
                        </li>
                        <li>
                            <p>Used in CAD and design applications.</p>
                        </li>
                    </ul>
                </li>
            </ol>
        </article>

        <article>
            <h4>Display Techniques</h4>
            <ol>
                <li><strong>Point Plotting</strong>
                    <ul>
                        <li>
                            <p>The simplest display technique.</p>
                        </li>
                        <li>
                            <p>Uses individual pixel plotting to form images.</p>
                        </li>
                        <li>
                            <p>Example: Line or curve drawing algorithms.</p>
                        </li>
                    </ul>
                </li>
                <li><strong>Line Drawing</strong>
                    <ul>
                        <li>
                            <p>A series of plotted points between two coordinates to form straight lines.</p>
                        </li>
                        <li>
                            <p>Common algorithms:</p>
                            <ul>
                                <li>
                                    <p><strong>DDA (Digital Differential Analyzer) Algorithm</strong></p>
                                </li>
                                <li>
                                    <p><strong>Bresenham’s Line Algorithm</strong></p>
                                </li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li><strong>Character Generation</strong>
                    <ul>
                        <li>
                            <p>Used to display text on the screen.</p>
                        </li>
                        <li>
                            <p>Each character is represented as a matrix of pixels (e.g., 5×7 or 8×8 grid).</p>
                        </li>
                    </ul>
                </li>
                <li><strong>Image Display</strong>
                    <ul>
                        <li>
                            <p>Images are displayed by reading pixel values from the <strong>frame buffer</strong> and refreshing the screen repeatedly.</p>
                        </li>
                    </ul>
                </li>
            </ol>
        </article>

        <article>
            <h3>Page 5: Line Drawing Algorithm (DDA Algorithm)</h3>
            <p>The DDA (Digital Differential Analyzer) is a <strong>scan conversion algorithm</strong> used to draw straight lines between two points by computing intermediate positions from the start to the end coordinates.</p>
        </article>

        <article>
            <h4>Concept</h4>
            <p>A line can be represented by the equation:</p>
            <p>$$ y = mx + c $$</p>
            <p>where the <strong>slope</strong> is given by</p>
            <p>$$ m = \frac{y_2 - y_1}{x_2 - x_1} $$</p>
            <p>and the two <strong>endpoints</strong> are \( (x_1, y_1) \) and \( (x_2, y_2) \).</p>
        </article>

        <article>
            <h4>Algorithm Steps</h4>
            <ol>
                <li>
                    <p><strong>Input</strong>: Starting point \( (x_1, y_1) \), ending point \( (x_2, y_2) \).</p>
                </li>
                <li>
                    <p><strong>Compute</strong> differences:</p>
                    <p>$$ \Delta x = x_2 - x_1,\quad \Delta y = y_2 - y_1 $$</p>
                </li>
                <li>
                    <p><strong>Determine steps</strong>:</p>
                    <p>$$ \text{steps} = \max\left(|\Delta x|,\ |\Delta y|\right) $$</p>
                </li>
                <li>
                    <p><strong>Calculate increments</strong>:</p>
                    <p>$$ x_{\text{inc}} = \frac{\Delta x}{\text{steps}},\quad y_{\text{inc}} = \frac{\Delta y}{\text{steps}} $$</p>
                </li>
                <li>
                    <p><strong>Initialize</strong>:</p>
                    <p>$$ x = x_1,\quad y = y_1 $$</p>
                </li>
                <li>
                    <p><strong>Iterate for each step</strong>:</p>
                    <ul>
                        <li>
                            <p>Plot the pixel at \( \big(\mathrm{round}(x),\ \mathrm{round}(y)\big) \).</p>
                        </li>
                        <li>
                            <p>Update:</p>
                            <p>$$ x \leftarrow x + x_{\text{inc}},\quad y \leftarrow y + y_{\text{inc}} $$</p>
                        </li>
                    </ul>
                </li>
            </ol>
        </article>

        <article>
            <h4>Example</h4>
            <p>Draw a line from \( (2, 2) \) to \( (8, 5) \).</p>
            <p>$$ \Delta x = 8 - 2 = 6,\quad \Delta y = 5 - 2 = 3 $$</p>
            <p>$$ \text{steps} = 6 $$</p>
            <p>$$ x_{\text{inc}} = 1,\quad y_{\text{inc}} = 0.5 $$</p>
            <p><strong>Intermediate \((x, y)\) updates (before rounding)</strong>:
                \((2, 2),\ (3, 2.5),\ (4, 3),\ (5, 3.5),\ (6, 4),\ (7, 4.5),\ (8, 5)\).</p>
        </article>

        <article>
            <h4>Advantages</h4>
            <ul>
                <li>
                    <p>Simple and easy to implement.</p>
                </li>
                <li>
                    <p>Handles all types of slopes.</p>
                </li>
            </ul>
        </article>

        <article>
            <h4>Disadvantages</h4>
            <ul>
                <li>
                    <p>Uses floating-point arithmetic (slower than pure integer methods).</p>
                </li>
                <li>
                    <p>Requires rounding of coordinates.</p>
                </li>
            </ul>
        </article>

        <article>
            <h3>Page 6: Bresenham’s Line Drawing Algorithm</h3>
        </article>

        <article>
            <h4>Purpose</h4>
            <p>Bresenham’s algorithm is an <strong>incremental scan conversion algorithm</strong> used to draw a line efficiently using <strong>only integer calculations</strong> - no floating-point arithmetic as in DDA.</p>
        </article>

        <article>
            <h4>Concept</h4>
            <p>For a line between two points \( (x_1, y_1) \) and \( (x_2, y_2) \), the slope is \( m = \frac{\Delta y}{\Delta x} \).</p>
            <ul>
                <li>
                    <p>If \( 0 \le m \le 1 \), the line is gently sloped - advance primarily <strong>in \(x\)</strong>.</p>
                </li>
                <li>
                    <p>If \( m &gt; 1 \), the line is steep - advance primarily <strong>in \(y\)</strong>.</p>
                </li>
            </ul>
            <p>Below is the case \( 0 \le m \le 1 \).</p>
        </article>

        <article>
            <h4>Algorithm Logic (for \(0 \le m \le 1\))</h4>
            <p>Let \( \Delta x = x_2 - x_1 \) and \( \Delta y = y_2 - y_1 \). Define the <strong>decision parameter</strong>:</p>
            <p>$$ p_0 = 2\Delta y - \Delta x $$</p>
            <p>For each increment in \(x\):</p>
            <ul>
                <li>
                    <p>If \( p_k &lt; 0 \): next point \( (x+1,\ y) \); update \( p_{k+1} = p_k + 2\Delta y \).</p>
                </li>
                <li>
                    <p>Else: next point \( (x+1,\ y+1) \); update \( p_{k+1} = p_k + 2\Delta y - 2\Delta x \).</p>
                </li>
            </ul>
            <p>Repeat until \( x = x_2 \).</p>
        </article>

        <article>
            <h4>Algorithm Steps</h4>
            <ol>
                <li>
                    <p><strong>Input</strong> the two endpoints \( (x_1, y_1) \), \( (x_2, y_2) \).</p>
                </li>
                <li>
                    <p><strong>Compute</strong> \( \Delta x = x_2 - x_1 \), \( \Delta y = y_2 - y_1 \).</p>
                </li>
                <li>
                    <p><strong>Initialize</strong> the decision parameter \( p = 2\Delta y - \Delta x \) and set \( x = x_1,\ y = y_1 \).</p>
                </li>
                <li>
                    <p><strong>For</strong> \( x \) from \( x_1 \) to \( x_2 \):</p>
                    <ul>
                        <li>
                            <p>Plot the pixel \( (x, y) \).</p>
                        </li>
                        <li>
                            <p>If \( p &lt; 0 \): set \( p \leftarrow p + 2\Delta y \).</p>
                        </li>
                        <li>
                            <p>Else: set \( y \leftarrow y + 1 \) and \( p \leftarrow p + 2\Delta y - 2\Delta x \).</p>
                        </li>
                        <li>
                            <p>Increment \( x \leftarrow x + 1 \).</p>
                        </li>
                    </ul>
                </li>
            </ol>
        </article>

        <article>
            <h4>Example</h4>
            <p>For the line from \( (2, 2) \) to \( (9, 6) \):</p>
            <p>$$ \Delta x = 9 - 2 = 7,\quad \Delta y = 6 - 2 = 4 $$</p>
            <p>$$ p_0 = 2\Delta y - \Delta x = 8 - 7 = 1 $$</p>
            <div class="table-responsive">
                <table class="table table-bordered table-striped">
                    <thead>
                        <tr>
                            <th>Iteration \(k\)</th>
                            <th>\(p_k\) (before decision)</th>
                            <th>Decision</th>
                            <th>Plotted \((x, y)\)</th>
                            <th>\(p_{k+1}\) (after update)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>0</td>
                            <td>1</td>
                            <td>\(p_k \ge 0 \Rightarrow y \leftarrow y+1\)</td>
                            <td>(2, 2)</td>
                            <td>\(1 + 8 - 14 = -5\)</td>
                        </tr>
                        <tr>
                            <td>1</td>
                            <td>-5</td>
                            <td>\(p_k &lt; 0 \Rightarrow y\ \text{same}\)</td>
                            <td>(3, 3)</td>
                            <td>\(-5 + 8 = 3\)</td>
                        </tr>
                        <tr>
                            <td>2</td>
                            <td>3</td>
                            <td>\(p_k \ge 0 \Rightarrow y \leftarrow y+1\)</td>
                            <td>(4, 3)</td>
                            <td>\(3 + 8 - 14 = -3\)</td>
                        </tr>
                        <tr>
                            <td>3</td>
                            <td>-3</td>
                            <td>\(p_k &lt; 0 \Rightarrow y\ \text{same}\)</td>
                            <td>(5, 4)</td>
                            <td>\(-3 + 8 = 5\)</td>
                        </tr>
                        <tr>
                            <td>4</td>
                            <td>5</td>
                            <td>\(p_k \ge 0 \Rightarrow y \leftarrow y+1\)</td>
                            <td>(6, 4)</td>
                            <td>\(5 + 8 - 14 = -1\)</td>
                        </tr>
                        <tr>
                            <td>5</td>
                            <td>-1</td>
                            <td>\(p_k &lt; 0 \Rightarrow y\ \text{same}\)</td>
                            <td>(7, 5)</td>
                            <td>\(-1 + 8 = 7\)</td>
                        </tr>
                        <tr>
                            <td>6</td>
                            <td>7</td>
                            <td>\(p_k \ge 0 \Rightarrow y \leftarrow y+1\)</td>
                            <td>(8, 5)</td>
                            <td>\(7 + 8 - 14 = 1\)</td>
                        </tr>
                        <tr>
                            <td>7</td>
                            <td>1</td>
                            <td>\(x = x_2\) reached</td>
                            <td>(9, 6)</td>
                            <td>-</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <p>The plotted points (in order) are: \((2,2),(3,3),(4,3),(5,4),(6,4),(7,5),(8,5),(9,6)\).</p>
        </article>

        <article>
            <h4>Advantages</h4>
            <ul>
                <li>
                    <p>Uses only integer arithmetic.</p>
                </li>
                <li>
                    <p>Faster and more efficient than DDA.</p>
                </li>
                <li>
                    <p>Ideal for embedded and low-level graphics systems.</p>
                </li>
            </ul>
        </article>

        <article>
            <h4>Disadvantages</h4>
            <ul>
                <li>
                    <p>Slightly more involved control logic.</p>
                </li>
                <li>
                    <p>Requires adaptations for all slope and octant cases.</p>
                </li>
            </ul>
        </article>

        <article>
            <h3>Page 7: Circle Drawing Algorithm (Mid-Point Circle Algorithm)</h3>
        </article>

        <article>
            <h4>Objective</h4>
            <p>To draw a <strong>circle</strong> using <strong>only integer arithmetic</strong> and <strong>symmetry properties</strong>, avoiding floating-point operations.</p>
        </article>

        <article>
            <h4>Circle Equation</h4>
            <p>The standard equation of a circle with center at the origin \((0,0)\) and radius \(r\) is:</p>
            <p>$$x^2 + y^2 = r^2$$</p>
        </article>

        <article>
            <h4>Concept</h4>
            <p>Instead of calculating every point on the circle, compute points <strong>only in one octant</strong> and use <strong>symmetry</strong> to mirror them to the other seven octants.</p>
            <p>That is, if a point \((x, y)\) lies on the circle, then the following points also lie on it:</p>
            <p>$$(x, y),\ (y, x),\ (-x, y),\ (-y, x),\ (x, -y),\ (y, -x),\ (-x, -y),\ (-y, -x)$$</p>
        </article>

        <article>
            <h4>Algorithm Idea</h4>
            <p>Start from the topmost point \((0, r)\) and move towards the x-axis while deciding whether the next pixel should be:</p>
            <ul>
                <li>
                    <p><strong>East (E)</strong> → \((x + 1, y)\)</p>
                </li>
                <li>
                    <p><strong>South-East (SE)</strong> → \((x + 1, y - 1)\)</p>
                </li>
            </ul>
            <p>The decision is based on the <strong>midpoint</strong> between these two choices.</p>
        </article>

        <article>
            <h4>Decision Parameter</h4>
            <p>Initialize the parameter as:</p>
            <p>$$p_0 = 1 - r$$</p>
            <p>For each step:</p>
            <ul>
                <li>
                    <p>If \(p &lt; 0\): choose <strong>E</strong>, and update</p>
                    <p>$$p_{k+1} = p_k + 2x + 3$$</p>
                </li>
                <li>
                    <p>If \(p \ge 0\): choose <strong>SE</strong>, and update</p>
                    <p>$$p_{k+1} = p_k + 2x - 2y + 5,\quad y = y - 1$$</p>
                </li>
            </ul>
            <p>Increment \(x = x + 1\) after each step. Continue until \(x \ge y\).</p>
        </article>

        <article>
            <h4>Algorithm Steps</h4>
            <ol>
                <li>
                    <p>Input radius \(r\) and center \((x_c, y_c)\).</p>
                </li>
                <li>
                    <p>Initialize:</p>
                    <p>$$x = 0,\quad y = r,\quad p = 1 - r$$</p>
                </li>
                <li>
                    <p>While \(x \le y\):</p>
                    <ul>
                        <li>
                            <p>Plot the eight symmetric points.</p>
                        </li>
                        <li>
                            <p>If \(p &lt; 0\): \(p \leftarrow p + 2x + 3\)</p>
                        </li>
                        <li>
                            <p>Else: \(p \leftarrow p + 2x - 2y + 5,\quad y \leftarrow y - 1\)</p>
                        </li>
                        <li>
                            <p>\(x \leftarrow x + 1\)</p>
                        </li>
                    </ul>
                </li>
            </ol>
        </article>

        <article>
            <h4>Advantages</h4>
            <ul>
                <li>
                    <p>Only integer arithmetic → fast and accurate.</p>
                </li>
                <li>
                    <p>Exploits circle symmetry to reduce computation.</p>
                </li>
            </ul>
        </article>

        <article>
            <h4>Applications</h4>
            <ul>
                <li>
                    <p>Used in <strong>CAD software</strong>, <strong>graphics engines</strong>, and <strong>clock designs</strong>.</p>
                </li>
            </ul>
        </article>

        <article>
            <h3>Page 8: Mid-Point Ellipse Drawing Algorithm</h3>
            <p><strong>Objective:</strong> Draw an <strong>ellipse</strong> efficiently using midpoint decisions and symmetry, avoiding floating-point operations.</p>
        </article>

        <article>
            <h4>Ellipse Equation</h4>
            <p>For an ellipse centered at the origin \((0,0)\):</p>
            <p>$$\frac{x^2}{a^2}+\frac{y^2}{b^2}=1$$</p>
            <p>where <strong>a</strong> is the semi-major axis (along the x-axis) and <strong>b</strong> is the semi-minor axis (along the y-axis).</p>
        </article>

        <article>
            <h4>Concept</h4>
            <p>By symmetry, compute points in one quadrant (\(x\ge 0,\,y\ge 0\)) and mirror to the others. If \((x,y)\) lies on the ellipse, so do:</p>
            <p>$$ (x,y),\ (-x,y),\ (x,-y),\ (-x,-y) $$</p>
        </article>

        <article>
            <h4>Region Division</h4>
            <ul>
                <li>
                    <p><strong>Region&nbsp;1:</strong> slope \(<1\) &rarr; advance primarily in <strong>x</strong> (choose between East (E) and South-East (SE)).</p>
                </li>
                <li>
                    <p><strong>Region&nbsp;2:</strong> slope \(>1\) &rarr; advance primarily in <strong>y</strong> (choose between South (S) and South-East (SE)).</p>
                </li>
            </ul>
        </article>

        <article>
            <h4>Decision Parameters</h4>
            <h5>Region 1 (slope &lt; 1)</h5>
            <p>Initialize the decision parameter at \((x,y)=(0,b)\):</p>
            <p>$$p_1=b^2-a^2b+\frac{1}{4}a^2$$</p>
            <p>Iterate while \(2b^2x &lt; 2a^2y\):</p>
            <ul>
                <li>
                    <p>If \(p_1&lt;0\): move E, \(x\leftarrow x+1\), update</p>
                    <p>$$p_1 \leftarrow p_1 + 2b^2x + b^2$$</p>
                </li>
                <li>
                    <p>Else: move SE, \(x\leftarrow x+1,\ y\leftarrow y-1\), update</p>
                    <p>$$p_1 \leftarrow p_1 + 2b^2x - 2a^2y + b^2$$</p>
                </li>
            </ul>

            <h5>Region 2 (slope &gt; 1)</h5>
            <p>Initialize at the boundary point reached from Region&nbsp;1:</p>
            <p>$$p_2=b^2\!\left(x+\tfrac{1}{2}\right)^2 + a^2\!\left(y-1\right)^2 - a^2b^2$$</p>
            <p>Iterate while \(y\ge 0\):</p>
            <ul>
                <li>
                    <p>If \(p_2&gt;0\): move S, \(y\leftarrow y-1\), update</p>
                    <p>$$p_2 \leftarrow p_2 - 2a^2y + a^2$$</p>
                </li>
                <li>
                    <p>Else: move SE, \(x\leftarrow x+1,\ y\leftarrow y-1\), update</p>
                    <p>$$p_2 \leftarrow p_2 + 2b^2x - 2a^2y + a^2$$</p>
                </li>
            </ul>
        </article>

        <article>
            <h4>Algorithm Steps Summary</h4>
            <ol>
                <li>
                    <p>Input \((a,b)\) and center \((x_c,y_c)\).</p>
                </li>
                <li>
                    <p>Initialize \(x=0,\ y=b,\ p_1= b^2-a^2b+\tfrac{1}{4}a^2\).</p>
                </li>
                <li>
                    <p><strong>Region&nbsp;1:</strong> while \(2b^2x &lt; 2a^2y\), choose E or SE using \(p_1\), update as above and plot the four symmetric points.</p>
                </li>
                <li>
                    <p>Compute \(p_2=b^2(x+\tfrac{1}{2})^2 + a^2(y-1)^2 - a^2b^2\).</p>
                </li>
                <li>
                    <p><strong>Region&nbsp;2:</strong> while \(y\ge 0\), choose S or SE using \(p_2\), update as above and continue plotting symmetric points.</p>
                </li>
            </ol>
        </article>

        <article>
            <h5>Pseudocode (integer arithmetic, symmetry included)</h5>
            <pre><code class="language-auto"># Inputs: a, b, xc, yc
x, y = 0, b
# Region 1 init (multiply by 4 to avoid fractions):
# P1 = 4*b*b - 4*a*a*b + a*a
P1 = 4*b*b - 4*a*a*b + a*a

def plot_symmetry(xc, yc, x, y):
plot(xc + x, yc + y)
plot(xc - x, yc + y)
plot(xc + x, yc - y)
plot(xc - x, yc - y)

# Region 1

plot_symmetry(xc, yc, x, y)
while (2*b*b*x) < (2*a*a*y):
x += 1
if P1 < 0:
# move E
P1 += 8*b*b*x + 4*b*b
else:
# move SE
y -= 1
P1 += 8*b*b*x - 8*a*a*y + 4*b*b
plot_symmetry(xc, yc, x, y)

# Region 2 init (scaled by 4)

# P2 = 4*b*b*(x+0.5)^2 + 4*a*a*(y-1)^2 - 4*a*a*b*b

# Expand to keep integers:

P2 = 4*b*b*(x*x + x) + b*b + 4*a*a*((y-1)*(y-1)) - 4*a*a*b*b

# Region 2

while y >= 0:
if P2 > 0:
# move S
y -= 1
P2 += -8*a*a*y + 4*a*a
else:
# move SE
x += 1
y -= 1
P2 += 8*b*b*x - 8*a*a*y + 4*a*a
plot_symmetry(xc, yc, x, y)</code></pre>

        </article>

        <article>
            <h5>Flow (high-level)</h5>
            <pre class="mermaid text-center">flowchart TD
  A[Start: x=0, y=b, p1=b^2 - a^2 b + a^2/4] --> B{2 b^2 x &lt; 2 a^2 y?}
  B -- Yes --> C{p1 &lt; 0?}
  C -- Yes (E) --> C1[x←x+1; p1←p1 + 2 b^2 x + b^2]
  C -- No (SE) --> C2[x←x+1; y←y-1; p1←p1 + 2 b^2 x - 2 a^2 y + b^2]
  C1 --> B
  C2 --> B
  B -- No --> D["Compute p2=b^2(x+1/2)^2 + a^2(y-1)^2 - a^2 b^2"]
  D --> E{y ≥ 0?}
  E -- Yes --> F{p2 &gt; 0?}
  F -- Yes (S) --> F1[y←y-1; p2←p2 - 2 a^2 y + a^2]
  F -- No (SE) --> F2[x←x+1; y←y-1; p2←p2 + 2 b^2 x - 2 a^2 y + a^2]
  F1 --> E
  F2 --> E
  E -- No --> G[Done]</pre>
        </article>

        <article>
            <h4>Advantages</h4>
            <ul>
                <li>
                    <p>Uses only integer arithmetic (with scaling to eliminate fractions).</p>
                </li>
                <li>
                    <p>Exploits symmetry to minimize computations.</p>
                </li>
            </ul>
        </article>

        <article>
            <h4>Applications</h4>
            <ul>
                <li>
                    <p>3D modeling, orbital plotting, CAD, and image rendering.</p>
                </li>
            </ul>
        </article>

        <article>
            <h3>Page 9: 2D Geometric Transformations</h3>
            <p><strong>Introduction:</strong> Geometric transformations are operations used to modify the <strong>position</strong>, <strong>size</strong>, or <strong>orientation</strong> of an object in a 2D plane. There are three basic transformations: <strong>Translation</strong>, <strong>Scaling</strong>, and <strong>Rotation</strong>.</p>
        </article>

        <article>
            <h4>1. Translation</h4>
            <p>Moves an object from one position to another without changing its shape, size, or orientation.</p>
            <p>$$x' = x + T_x$$</p>
            <p>$$y' = y + T_y$$</p>
            <p>where \((x, y)\) → original point, \((x', y')\) → translated point, and \((T_x, T_y)\) → translation distances.</p>
            <p><strong>Matrix Representation (Homogeneous Coordinates):</strong></p>
            <p>$$
                \begin{bmatrix}
                x' \\
                y' \\
                1
                \end{bmatrix}
                =
                \begin{bmatrix}
                1 & 0 & T_x \\
                0 & 1 & T_y \\
                0 & 0 & 1
                \end{bmatrix}
                \begin{bmatrix}
                x \\
                y \\
                1
                \end{bmatrix}
                $$</p>
        </article>

        <article>
            <h4>2. Scaling</h4>
            <p>Resizes an object by enlarging or shrinking it.</p>
            <p>$$x' = S_x \cdot x$$</p>
            <p>$$y' = S_y \cdot y$$</p>
            <p>where \(S_x, S_y\) are scaling factors (greater than 1 → enlargement, less than 1 → shrink).</p>
            <p><strong>Matrix Representation:</strong></p>
            <p>$$
                \begin{bmatrix}
                x' \\
                y' \\
                1
                \end{bmatrix}
                =
                \begin{bmatrix}
                S_x & 0 & 0 \\
                0 & S_y & 0 \\
                0 & 0 & 1
                \end{bmatrix}
                \begin{bmatrix}
                x \\
                y \\
                1
                \end{bmatrix}
                $$</p>
        </article>

        <article>
            <h4>3. Rotation</h4>
            <p>Rotates an object about the <strong>origin</strong> by an angle \(\theta\) (anticlockwise).</p>
            <p>$$x' = x\cos\theta - y\sin\theta$$</p>
            <p>$$y' = x\sin\theta + y\cos\theta$$</p>
            <p><strong>Matrix Representation:</strong></p>
            <p>$$
                \begin{bmatrix}
                x' \\
                y' \\
                1
                \end{bmatrix}
                =
                \begin{bmatrix}
                \cos\theta & -\sin\theta & 0 \\
                \sin\theta & \cos\theta & 0 \\
                0 & 0 & 1
                \end{bmatrix}
                \begin{bmatrix}
                x \\
                y \\
                1
                \end{bmatrix}
                $$</p>
        </article>

        <article>
            <h3>Page 10: Reflection and Shearing Transformations</h3>
            <p>Reflection creates a mirror image of an object about a specified axis or line; shearing slants an object by shifting one coordinate proportionally to the other. Both are modeled cleanly using homogeneous coordinates.</p>
        </article>

        <article>
            <h4>Reflection</h4>
            <p>Reflection changes orientation but preserves size and shape.</p>

            <h5>About x-axis</h5>
            <p>$$x' = x,\quad y' = -y$$</p>
            <p><strong>Matrix form:</strong></p>
            <p>$$
                \begin{bmatrix}
                x'\\[2pt] y'\\[2pt] 1
                \end{bmatrix}
                =
                \begin{bmatrix}
                1 & 0 & 0\\
                0 & -1 & 0\\
                0 & 0 & 1
                \end{bmatrix}
                \begin{bmatrix}
                x\\[2pt] y\\[2pt] 1
                \end{bmatrix}
                $$</p>

            <h5>About y-axis</h5>
            <p>$$x' = -x,\quad y' = y$$</p>
            <p><strong>Matrix form:</strong></p>
            <p>$$
                \begin{bmatrix}
                x'\\[2pt] y'\\[2pt] 1
                \end{bmatrix}
                =
                \begin{bmatrix}
                -1 & 0 & 0\\
                0 & 1 & 0\\
                0 & 0 & 1
                \end{bmatrix}
                \begin{bmatrix}
                x\\[2pt] y\\[2pt] 1
                \end{bmatrix}
                $$</p>

            <h5>About origin</h5>
            <p>$$x' = -x,\quad y' = -y$$</p>
            <p><strong>Matrix form:</strong></p>
            <p>$$
                \begin{bmatrix}
                x'\\[2pt] y'\\[2pt] 1
                \end{bmatrix}
                =
                \begin{bmatrix}
                -1 & 0 & 0\\
                0 & -1 & 0\\
                0 & 0 & 1
                \end{bmatrix}
                \begin{bmatrix}
                x\\[2pt] y\\[2pt] 1
                \end{bmatrix}
                $$</p>

            <h5>About line \(y=x\)</h5>
            <p>$$x' = y,\quad y' = x$$</p>
            <p><strong>Matrix form:</strong></p>
            <p>$$
                \begin{bmatrix}
                x'\\[2pt] y'\\[2pt] 1
                \end{bmatrix}
                =
                \begin{bmatrix}
                0 & 1 & 0\\
                1 & 0 & 0\\
                0 & 0 & 1
                \end{bmatrix}
                \begin{bmatrix}
                x\\[2pt] y\\[2pt] 1
                \end{bmatrix}
                $$</p>
        </article>

        <article>
            <h4>Shearing</h4>
            <p>Shearing slants an object so that lengths are preserved along axes, but interior angles change.</p>

            <h5>X-direction shear</h5>
            <p>$$x' = x + Sh_x\,y,\quad y' = y$$</p>
            <p><strong>Matrix form:</strong></p>
            <p>$$
                \begin{bmatrix}
                x'\\[2pt] y'\\[2pt] 1
                \end{bmatrix}
                =
                \begin{bmatrix}
                1 & Sh_x & 0\\
                0 & 1 & 0\\
                0 & 0 & 1
                \end{bmatrix}
                \begin{bmatrix}
                x\\[2pt] y\\[2pt] 1
                \end{bmatrix}
                $$</p>

            <h5>Y-direction shear</h5>
            <p>$$x' = x,\quad y' = y + Sh_y\,x$$</p>
            <p><strong>Matrix form:</strong></p>
            <p>$$
                \begin{bmatrix}
                x'\\[2pt] y'\\[2pt] 1
                \end{bmatrix}
                =
                \begin{bmatrix}
                1 & 0 & 0\\
                Sh_y & 1 & 0\\
                0 & 0 & 1
                \end{bmatrix}
                \begin{bmatrix}
                x\\[2pt] y\\[2pt] 1
                \end{bmatrix}
                $$</p>
        </article>

        <article>
            <h4>Combination of Transformations</h4>
            <p>Multiple transforms compose via matrix multiplication. With column vectors, the rightmost transform applies first; order matters.</p>
            <p>$$
                \mathbf{P}' \;=\; \mathbf{T}\,\mathbf{R}\,\mathbf{S}\,\mathbf{P}
                $$</p>
        </article>

        <article>
            <h3>Page 11 - 2D Transformation About an Arbitrary Point</h3>
            <p><strong>Introduction:</strong> Until now, rotation, scaling, and reflection were performed about the origin \((0,0)\). In practice, we often need to transform an object about an arbitrary point \((x_a, y_a)\).</p>
        </article>

        <article>
            <h4>Rotation About an Arbitrary Point \((x_a, y_a)\)</h4>
            <p><strong>Steps:</strong></p>
            <ol>
                <li>
                    <p><strong>Translate</strong> the reference point to the origin: \(T(-x_a, -y_a)\).</p>
                </li>
                <li>
                    <p><strong>Rotate</strong> by \(\theta\) about the origin: \(R(\theta)\).</p>
                </li>
                <li>
                    <p><strong>Translate back</strong> to \((x_a, y_a)\): \(T(x_a, y_a)\).</p>
                </li>
            </ol>
            <p><strong>Composite Matrix:</strong></p>
            <p>$$
                R_{\text{arb}} \;=\; T(x_a, y_a)\; R(\theta)\; T(-x_a, -y_a)
                $$</p>
            <h5>Useful base matrices</h5>
            <p>$$
                T(t_x,t_y)=
                \begin{bmatrix}
                1 & 0 & t_x\\
                0 & 1 & t_y\\
                0 & 0 & 1
                \end{bmatrix},\qquad
                R(\theta)=
                \begin{bmatrix}
                \cos\theta & -\sin\theta & 0\\
                \sin\theta & \cos\theta & 0\\
                0 & 0 & 1
                \end{bmatrix}
                $$</p>
            <h5>Closed form (homogeneous \(3\times 3\))</h5>
            <p>$$
                R_{\text{arb}} \;=\;
                \begin{bmatrix}
                \cos\theta & -\sin\theta & x_a(1-\cos\theta)+y_a\sin\theta\\
                \sin\theta & \cos\theta & y_a(1-\cos\theta)-x_a\sin\theta\\
                0 & 0 & 1
                \end{bmatrix}
                $$</p>
        </article>

        <article>
            <h4>Scaling About an Arbitrary Point \((x_a, y_a)\)</h4>
            <p><strong>Steps:</strong></p>
            <ol>
                <li>
                    <p><strong>Translate</strong> object so that \((x_a, y_a)\) moves to the origin.</p>
                </li>
                <li>
                    <p><strong>Scale</strong> about the origin by \((S_x,S_y)\).</p>
                </li>
                <li>
                    <p><strong>Translate back</strong> to \((x_a, y_a)\).</p>
                </li>
            </ol>
            <p><strong>Composite Matrix:</strong></p>
            <p>$$
                S_{\text{arb}} \;=\; T(x_a, y_a)\; S(S_x,S_y)\; T(-x_a, -y_a)
                $$</p>
            <h5>Useful base matrix</h5>
            <p>$$
                S(S_x,S_y)=
                \begin{bmatrix}
                S_x & 0 & 0\\
                0 & S_y & 0\\
                0 & 0 & 1
                \end{bmatrix}
                $$</p>
            <h5>Closed form (homogeneous \(3\times 3\))</h5>
            <p>$$
                S_{\text{arb}} \;=\;
                \begin{bmatrix}
                S_x & 0 & x_a(1-S_x)\\
                0 & S_y & y_a(1-S_y)\\
                0 & 0 & 1
                \end{bmatrix}
                $$</p>
        </article>

        <article>
            <h4>Example (Scaling)</h4>
            <p>Scale a square of side \(2\) about point \((1,1)\) by a factor \(2\) in both axes.</p>
            <ol>
                <li>
                    <p>Translate by \((-1,-1)\)</p>
                </li>
                <li>
                    <p>Scale by \((2,2)\)</p>
                </li>
                <li>
                    <p>Translate back by \((+1,+1)\)</p>
                </li>
            </ol>
            <p><strong>Result:</strong> Each vertex \(\mathbf{p}\) is mapped as
                \( \mathbf{p}' = \mathbf{c} + S(\mathbf{p}-\mathbf{c}) \)
                with \(\mathbf{c}=(1,1)\) and \(S=\operatorname{diag}(2,2)\), i.e., the distance from \((1,1)\) doubles and the square’s size doubles.</p>
        </article>

        <article>
            <h4>Reflection About an Arbitrary Line</h4>
            <p><strong>Procedure:</strong></p>
            <ol>
                <li>
                    <p><strong>Translate</strong> the line so it passes through the origin.</p>
                </li>
                <li>
                    <p><strong>Rotate</strong> the line to align with an axis (usually the \(x\)-axis).</p>
                </li>
                <li>
                    <p><strong>Reflect</strong> about that axis.</p>
                </li>
                <li>
                    <p><strong>Inverse-rotate</strong> and <strong>inverse-translate</strong> back.</p>
                </li>
            </ol>
            <p><strong>Composite Matrix:</strong></p>
            <p>$$
                R_{\text{line}} \;=\; T(x_a, y_a)\; R(\theta)\; \mathrm{Ref}\; R(-\theta)\; T(-x_a, -y_a)
                $$</p>
            <h5>Closed form for a line through \((x_a,y_a)\) with direction angle \(\theta\)</h5>
            <p>Reflection about a line through the origin at angle \(\theta\) has
                \(2\times2\) part \(M(\theta)=\begin{bmatrix}\cos2\theta & \sin2\theta\\ \sin2\theta & -\cos2\theta\end{bmatrix}\).
                For a line through \((x_a,y_a)\), the homogeneous matrix is</p>
            <p>$$
                \begin{bmatrix}
                \cos 2\theta & \sin 2\theta & x_a(1-\cos2\theta)-y_a\sin2\theta\\
                \sin 2\theta & -\cos 2\theta & y_a(1+\cos2\theta)-x_a\sin2\theta\\
                0 & 0 & 1
                \end{bmatrix}
                $$</p>
        </article>

        <article>
            <h4>Note</h4>
            <p>All composite transformations are achieved via <strong>matrix multiplication</strong>. With column vectors, the rightmost matrix acts first; order matters.</p>
        </article>

        <article>
            <h3>Page 12: 2D Transformation Examples &amp; Matrix Composition</h3>
        </article>

        <article>
            <h4>Example 1: Translate and Rotate a Point</h4>
            <p><strong>Given:</strong> Point \(P(2,3)\); translate by \((T_x,T_y)=(4,2)\); then rotate by \(\theta=90^\circ\) about the origin.</p>

            <h5>Step 1: Translation</h5>
            <p>Transformation matrix and application:</p>
            <p>$$
                T =
                \begin{bmatrix}
                1 & 0 & 4\\
                0 & 1 & 2\\
                0 & 0 & 1
                \end{bmatrix},\quad
                \mathbf{P} =
                \begin{bmatrix}
                2\\[2pt]3\\[2pt]1
                \end{bmatrix},\quad
                \mathbf{P}' = T\,\mathbf{P} =
                \begin{bmatrix}
                6\\[2pt]5\\[2pt]1
                \end{bmatrix}
                $$</p>
            <p>After translation: \(P'(6,5)\).</p>

            <h5>Step 2: Rotation \((90^\circ)\)</h5>
            <p>Rotation matrix and application:</p>
            <p>$$
                R =
                \begin{bmatrix}
                0 & -1 & 0\\
                1 & \phantom{-}0 & 0\\
                0 & \phantom{-}0 & 1
                \end{bmatrix},\qquad
                \mathbf{P}'' = R\,\mathbf{P}' =
                \begin{bmatrix}
                -5\\[2pt]6\\[2pt]1
                \end{bmatrix}
                $$</p>
            <p><strong>Final coordinates:</strong> \(P''(-5,6)\).</p>
        </article>

        <article>
            <h4>Example 2: Scaling followed by Translation</h4>
            <p><strong>Given:</strong> \(P(1,2)\). Scale by \((2,3)\), then translate by \((3,2)\).</p>
            <p>$$
                S =
                \begin{bmatrix}
                2 & 0 & 0\\
                0 & 3 & 0\\
                0 & 0 & 1
                \end{bmatrix},\quad
                T =
                \begin{bmatrix}
                1 & 0 & 3\\
                0 & 1 & 2\\
                0 & 0 & 1
                \end{bmatrix}
                $$</p>
            <p><strong>Composite (apply scale then translate):</strong></p>
            <p>$$
                M = T\,S =
                \begin{bmatrix}
                2 & 0 & 3\\
                0 & 3 & 2\\
                0 & 0 & 1
                \end{bmatrix}
                $$</p>
            <p>Apply to \(P\):</p>
            <p>$$
                \mathbf{P} =
                \begin{bmatrix}
                1\\[2pt]2\\[2pt]1
                \end{bmatrix},\qquad
                \mathbf{P}' = M\,\mathbf{P} =
                \begin{bmatrix}
                5\\[2pt]8\\[2pt]1
                \end{bmatrix}
                $$</p>
            <p><strong>Final result:</strong> \(P'(5,8)\).</p>
        </article>

        <article>
            <h4>Note</h4>
            <p>Matrix composition allows multiple transformations in a single multiplication. <strong>Order matters</strong> (with column vectors, the rightmost matrix acts first):</p>
            <p>$$
                T\,R \;\ne\; R\,T
                $$</p>
        </article>

        <article>
            <h3>Page 13: Homogeneous Coordinates &amp; Transformation Composition Rules</h3>
        </article>

        <article>
            <h4>Homogeneous Coordinates</h4>
            <p>In computer graphics, we represent a 2D point as a 3D vector \((x, y, 1)\) so that translation, rotation, scaling, and reflection can all be expressed as a single matrix multiplication.</p>
            <p>$$
                P(x,y)\;\longrightarrow\;
                \begin{bmatrix}
                x\\
                y\\
                1
                \end{bmatrix}
                $$</p>
        </article>

        <article>
            <h4>Why Homogeneous Coordinates?</h4>
            <p>In standard 2D coordinates, translation cannot be represented by a \(2\times2\) matrix. By augmenting points with a third coordinate (typically \(1\)), translation becomes a linear operation in \(3\times3\) form.</p>
        </article>

        <article>
            <h4>General Transformation Matrix (2D)</h4>
            <p>$$
                \begin{bmatrix}
                x'\\
                y'\\
                1
                \end{bmatrix}
                =
                \begin{bmatrix}
                a & b & T_x\\
                c & d & T_y\\
                0 & 0 & 1
                \end{bmatrix}
                \begin{bmatrix}
                x\\
                y\\
                1
                \end{bmatrix}
                $$</p>
            <div class="table-responsive">
                <table class="table table-bordered table-striped">
                    <thead>
                        <tr>
                            <th>Term</th>
                            <th>Meaning</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>a, b, c, d</td>
                            <td>Rotation, scaling, and shearing parameters (linear part)</td>
                        </tr>
                        <tr>
                            <td>\(T_x, T_y\)</td>
                            <td>Translation parameters</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </article>

        <article>
            <h4>Composition of Transformations</h4>
            <p>Applying multiple transformations corresponds to multiplying their matrices to get one composite matrix. If the order is: 1) Scale, 2) Rotate, 3) Translate, then</p>
            <p>$$
                M \;=\; T \, R \, S
                \quad\Rightarrow\quad
                P' \;=\; M\,P
                $$</p>
            <p>With column vectors, the <em>rightmost</em> matrix acts first.</p>
        </article>

        <article>
            <h4>Properties of Transformation Matrices</h4>
            <ul>
                <li>
                    <p><strong>Non-Commutative:</strong> \(T\,R \ne R\,T\)</p>
                </li>
                <li>
                    <p><strong>Associative:</strong> \((T\,R)\,S = T\,(R\,S)\)</p>
                </li>
                <li>
                    <p><strong>Identity Matrix:</strong></p>
                    <p>$$
                        I =
                        \begin{bmatrix}
                        1 & 0 & 0\\
                        0 & 1 & 0\\
                        0 & 0 & 1
                        \end{bmatrix}
                        $$
                        Applying \(I\) leaves the object unchanged.</p>
                </li>
            </ul>
        </article>

        <article>
            <h4>Example: Scale then Translate</h4>
            <p>If you first <strong>scale</strong> and then <strong>translate</strong>:</p>
            <p>$$
                M \;=\; T \, S \;=\;
                \begin{bmatrix}
                S_x & 0 & T_x\\
                0 & S_y & T_y\\
                0 & 0 & 1
                \end{bmatrix}
                $$</p>
            <p>This matrix scales the object and then moves it to the new position \((T_x, T_y)\).</p>
        </article>

        <article>
            <h3>Page 14: Window to Viewport Transformation</h3>
            <p><strong>Concept:</strong> In computer graphics, a scene is defined in a <em>world coordinate system</em> (logical coordinates), while the display area on the screen is a <em>viewport</em> (device coordinates). To render correctly, we map the chosen world <em>window</em> to a screen <em>viewport</em>. This process is called <strong>Window-to-Viewport Transformation</strong>.</p>
        </article>

        <article>
            <h4>Definitions</h4>
            <p><strong>Window:</strong> Rectangular world area to be displayed, defined by corners \((x_{w_{\min}}, y_{w_{\min}})\) and \((x_{w_{\max}}, y_{w_{\max}})\).</p>
            <p><strong>Viewport:</strong> Rectangular screen area where the image appears, defined by \((x_{v_{\min}}, y_{v_{\min}})\) and \((x_{v_{\max}}, y_{v_{\max}})\).</p>
        </article>

        <article>
            <h4>Mapping Formula</h4>
            <p>For each world point \((x_w, y_w)\), the mapped viewport point \((x_v, y_v)\) is:</p>
            <p>$$
                x_v \;=\; x_{v_{\min}} \;+\; \frac{(x_w - x_{w_{\min}})\,\big(x_{v_{\max}} - x_{v_{\min}}\big)}{\,x_{w_{\max}} - x_{w_{\min}}\,}
                $$</p>
            <p>$$
                y_v \;=\; y_{v_{\min}} \;+\; \frac{(y_w - y_{w_{\min}})\,\big(y_{v_{\max}} - y_{v_{\min}}\big)}{\,y_{w_{\max}} - y_{w_{\min}}\,}
                $$</p>
        </article>

        <article>
            <h4>Explanation</h4>
            <p>The fractions scale world coordinates proportionally into the viewport: conceptually, world coordinates are first normalized to \([0,1]\) and then scaled and shifted to the viewport. <strong>Aspect ratio is preserved only if the window and viewport have the same width-to-height ratio</strong>; otherwise the image will be stretched or compressed.</p>
        </article>

        <article>
            <h4>Example</h4>
            <p><strong>Window:</strong> \((x_{\min},y_{\min})=(10,10)\), \((x_{\max},y_{\max})=(100,100)\)<br>
                <strong>Viewport:</strong> \((x_{\min},y_{\min})=(200,200)\), \((x_{\max},y_{\max})=(400,400)\)<br>
                <strong>Point:</strong> \((55,70)\)
            </p>
            <p>$$
                x_v \;=\; 200 + \frac{(55-10)(400-200)}{100-10}
                \;=\; 200 + \frac{45\cdot 200}{90}
                \;=\; 200 + 100
                \;=\; 300
                $$</p>
            <p>$$
                y_v \;=\; 200 + \frac{(70-10)(400-200)}{100-10}
                \;=\; 200 + \frac{60\cdot 200}{90}
                \;=\; 200 + 133.33\ldots
                \;=\; 333.33\ldots
                $$</p>
            <p><strong>Mapped point:</strong> \((300,\; 333.33\ldots)\)</p>
        </article>

        <article>
            <h4>Applications</h4>
            <ul>
                <li>
                    <p>Used in clipping and scaling operations.</p>
                </li>
                <li>
                    <p>Enables consistent rendering across different display sizes.</p>
                </li>
            </ul>
        </article>

        <article>
            <h3>Page 15: Line Clipping (Cohen–Sutherland Algorithm)</h3>
        </article>

        <article>
            <h4>Objective</h4>
            <p>Determine which portion of a line lies <strong>inside</strong> or <strong>outside</strong> a rectangular clipping window and <strong>clip</strong> the line accordingly.</p>
        </article>

        <article>
            <h4>Concept</h4>
            <p>A <strong>clipping window</strong> is a rectangular area defined by:</p>
            <p>$$\big(x_{\min},\,y_{\min}\big)\ \text{and}\ \big(x_{\max},\,y_{\max}\big)$$</p>
            <p>A line segment may:</p>
            <ul>
                <li>
                    <p>Lie <strong>completely inside</strong> the window (visible)</p>
                </li>
                <li>
                    <p>Lie <strong>completely outside</strong> the window (invisible)</p>
                </li>
                <li>
                    <p><strong>Intersect</strong> the window boundaries (partially visible → clipping needed)</p>
                </li>
            </ul>
        </article>

        <article>
            <h4>Cohen–Sutherland Algorithm</h4>
            <p>Each endpoint is assigned a 4-bit <strong>region code (outcode)</strong>:</p>
            <p>$$\text{Code: }[\,T,\ B,\ R,\ L\,]$$</p>
            <ul>
                <li>
                    <p><strong>T</strong> → above top boundary</p>
                </li>
                <li>
                    <p><strong>B</strong> → below bottom boundary</p>
                </li>
                <li>
                    <p><strong>R</strong> → right of right boundary</p>
                </li>
                <li>
                    <p><strong>L</strong> → left of left boundary</p>
                </li>
            </ul>
        </article>

        <article>
            <h4>Region Code Assignment</h4>
            <div class="table-responsive">
                <table class="table table-bordered table-striped">
                    <thead>
                        <tr>
                            <th>Position</th>
                            <th>Code</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Inside window</td>
                            <td><code>0000</code></td>
                        </tr>
                        <tr>
                            <td>Left</td>
                            <td><code>0001</code></td>
                        </tr>
                        <tr>
                            <td>Right</td>
                            <td><code>0010</code></td>
                        </tr>
                        <tr>
                            <td>Bottom</td>
                            <td><code>0100</code></td>
                        </tr>
                        <tr>
                            <td>Top</td>
                            <td><code>1000</code></td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </article>

        <article>
            <h4>Algorithm Steps</h4>
            <ol>
                <li>
                    <p>Compute region codes for both endpoints \(P_1\) and \(P_2\).</p>
                </li>
                <li>
                    <p><strong>Trivially accept</strong>: if both codes are <code>0000</code>, the line is completely inside.</p>
                </li>
                <li>
                    <p><strong>Trivially reject</strong>: if the bitwise <strong>AND</strong> of the two codes is not <code>0000</code>, the line is completely outside.</p>
                </li>
                <li>
                    <p><strong>Otherwise</strong> (partially inside):</p>
                    <ul>
                        <li>
                            <p>Find the intersection of the segment with the relevant window boundary.</p>
                        </li>
                        <li>
                            <p>Replace the outside endpoint by this intersection point.</p>
                        </li>
                        <li>
                            <p>Recompute its region code and repeat until accepted or rejected.</p>
                        </li>
                    </ul>
                </li>
            </ol>
        </article>

        <article>
            <h4>Example</h4>
            <p>Clipping window: \(x_{\min}=10,\ y_{\min}=10,\ x_{\max}=80,\ y_{\max}=80\).<br>
                Line: \(P_1(5,\,20),\ P_2(90,\,70)\).</p>
            <ul>
                <li>
                    <p>\(P_1\) → code <code>0001</code> (Left)</p>
                </li>
                <li>
                    <p>\(P_2\) → code <code>0010</code> (Right)</p>
                </li>
            </ul>
            <p>Bitwise AND = <code>0000</code> → segment is partially visible. Compute intersections with the left and right boundaries and retain only the visible portion.</p>
        </article>

        <article>
            <h4>Advantages</h4>
            <ul>
                <li>
                    <p>Efficiently accepts or rejects trivial cases.</p>
                </li>
                <li>
                    <p>Works for all line orientations.</p>
                </li>
            </ul>
        </article>

        <article>
            <h4>Limitations</h4>
            <ul>
                <li>
                    <p>Applicable only to <strong>rectangular</strong> clipping windows.</p>
                </li>
                <li>
                    <p>May require multiple iterations for partially visible lines.</p>
                </li>
            </ul>
        </article>

        <article>
            <h3>Page 16: Liang–Barsky Line Clipping Algorithm</h3>
            <p><strong>Introduction:</strong> The <strong>Liang–Barsky algorithm</strong> is an improvement over Cohen–Sutherland. It uses a line’s <strong>parametric form</strong> to compute boundary intersections directly, making it <strong>faster and more efficient</strong>.</p>
        </article>

        <article>
            <h4>Line Equation (Parametric Form)</h4>
            <p>For a segment from \(P_1(x_1,y_1)\) to \(P_2(x_2,y_2)\):</p>
            <p>$$x = x_1 + t(x_2 - x_1),\qquad y = y_1 + t(y_2 - y_1),\qquad 0 \le t \le 1$$</p>
        </article>

        <article>
            <h4>Clipping Window Boundaries</h4>
            <p>Axis-aligned rectangle defined by:</p>
            <p>$$x_{\min},\ x_{\max},\ y_{\min},\ y_{\max}$$</p>
        </article>

        <article>
            <h4>Boundary Conditions</h4>
            <p>To be inside the window, the point must satisfy:</p>
            <p>$$x_{\min} \le x \le x_{\max},\qquad y_{\min} \le y \le y_{\max}$$</p>
            <p>Substitute the parametric forms for \(x\) and \(y\) into these inequalities.</p>
        </article>

        <article>
            <h4>Compute Parameters</h4>
            <p>Let \( \Delta x = x_2 - x_1 \) and \( \Delta y = y_2 - y_1 \). For the four edges, define:</p>
            <p>$$
                p_k \in \{-\Delta x,\ \Delta x,\ -\Delta y,\ \Delta y\},\qquad
                q_k \in \{\,x_1 - x_{\min},\ x_{\max} - x_1,\ y_1 - y_{\min},\ y_{\max} - y_1\,\}
                $$</p>
            <p>Ratios to consider (when \(p_k \ne 0\)):</p>
            <p>$$t = \frac{q_k}{p_k}$$</p>
        </article>

        <article>
            <h4>Algorithm Steps</h4>
            <ol>
                <li>
                    <p>Compute all \(p_k\) and \(q_k\). <strong>Initialize</strong> \(t_1 = 0\), \(t_2 = 1\).</p>
                </li>
                <li>
                    <p>If \(p_k = 0\) and \(q_k &lt; 0\) for any \(k\) → the line is <strong>parallel and outside</strong> → <strong>reject</strong>. If \(p_k=0\) and \(q_k \ge 0\), that boundary imposes no constraint (parallel and inside) → continue.</p>
                </li>
                <li>
                    <p>For all \(p_k &lt; 0\) (potential <strong>entering</strong>), update
                        \( \displaystyle t_1 = \max\!\big(t_1,\ \frac{q_k}{p_k}\big) \).</p>
                </li>
                <li>
                    <p>For all \(p_k &gt; 0\) (potential <strong>leaving</strong>), update
                        \( \displaystyle t_2 = \min\!\big(t_2,\ \frac{q_k}{p_k}\big) \).</p>
                </li>
                <li>
                    <p>If \(t_1 &gt; t_2\) → no overlap of valid parameter range → <strong>reject</strong> (completely outside).</p>
                </li>
                <li>
                    <p>Otherwise, the clipped endpoints are:
                        $$
                        x_{\text{clip1}} = x_1 + t_1(x_2 - x_1),\quad
                        y_{\text{clip1}} = y_1 + t_1(y_2 - y_1)
                        $$
                        $$
                        x_{\text{clip2}} = x_1 + t_2(x_2 - x_1),\quad
                        y_{\text{clip2}} = y_1 + t_2(y_2 - y_1)
                        $$
                        The segment between these two points is the <strong>visible portion</strong>.
                    </p>
                </li>
            </ol>
        </article>

        <article>
            <h4>Advantages</h4>
            <ul>
                <li>
                    <p>Fewer computations than Cohen–Sutherland (direct use of parametric form).</p>
                </li>
                <li>
                    <p>Efficient with arithmetic comparisons and ratios.</p>
                </li>
                <li>
                    <p>Handles floating-point boundaries well.</p>
                </li>
            </ul>
        </article>

        <article>
            <h4>Disadvantages</h4>
            <ul>
                <li>
                    <p>Slightly more intricate to implement conceptually.</p>
                </li>
                <li>
                    <p>Less intuitive to visualize compared to Cohen–Sutherland’s region codes.</p>
                </li>
            </ul>
        </article>

        <article>
            <h3>Page 17: Polygon Clipping (Sutherland–Hodgman Algorithm)</h3>
        </article>

        <article>
            <h4>Objective</h4>
            <p>Clip <strong>polygons</strong> (not just lines) to fit within a <strong>rectangular clipping window</strong>. The Sutherland–Hodgman algorithm clips each polygon edge against one boundary at a time.</p>
        </article>

        <article>
            <h4>Concept</h4>
            <p><strong>Input</strong>: Polygon with vertices \(P_1, P_2, \dots, P_n\)</p>
            <p><strong>Output</strong>: New polygon that lies <strong>inside</strong> the clipping window</p>
            <p>The polygon is clipped sequentially against each boundary, typically in this order:</p>
            <ol>
                <li>
                    <p>Left</p>
                </li>
                <li>
                    <p>Right</p>
                </li>
                <li>
                    <p>Bottom</p>
                </li>
                <li>
                    <p>Top</p>
                </li>
            </ol>
            <p>After all boundaries are processed, the remaining polygon is the <strong>clipped output</strong>.</p>
        </article>

        <article>
            <h4>Cases</h4>
            <p>For each polygon edge, consider the <strong>current vertex</strong> \(S\) and the <strong>next vertex</strong> \(P\) relative to the active clipping boundary:</p>
            <div class="table-responsive">
                <table class="table table-bordered table-striped">
                    <thead>
                        <tr>
                            <th>Case</th>
                            <th>Description</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>1</td>
                            <td>Both inside</td>
                            <td>Add \(P\)</td>
                        </tr>
                        <tr>
                            <td>2</td>
                            <td>\(S\) inside, \(P\) outside</td>
                            <td>Add intersection only</td>
                        </tr>
                        <tr>
                            <td>3</td>
                            <td>\(S\) outside, \(P\) inside</td>
                            <td>Add intersection, then \(P\)</td>
                        </tr>
                        <tr>
                            <td>4</td>
                            <td>Both outside</td>
                            <td>Add nothing</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </article>

        <article>
            <h4>Algorithm Steps</h4>
            <ol>
                <li>
                    <p>Start with the list of input polygon vertices.</p>
                </li>
                <li>
                    <p>For each <strong>clipping boundary</strong> (left, right, bottom, top):</p>
                    <ul>
                        <li>
                            <p>Initialize an empty output list.</p>
                        </li>
                        <li>
                            <p>For each edge \(S \rightarrow P\) in the current polygon list, apply the four cases above.</p>
                        </li>
                        <li>
                            <p>Append resulting points (intersection and/or \(P\)) to the output list.</p>
                        </li>
                        <li>
                            <p>Replace the current polygon list with this output list.</p>
                        </li>
                    </ul>
                </li>
                <li>
                    <p>After all boundaries, the remaining list of vertices forms the <strong>clipped polygon</strong>.</p>
                </li>
            </ol>
        </article>

        <article>
            <h4>Intersection Formula</h4>
            <p>When clipping against a boundary, compute the line–boundary intersection using the segment endpoints \((x_1,y_1)\) and \((x_2,y_2)\).</p>
            <p><strong>Vertical boundary</strong> (e.g., \(x = x_{\min}\)):</p>
            <p>$$x = x_{\min}$$</p>
            <p>$$y = y_1 + (y_2 - y_1)\,\frac{x_{\min} - x_1}{x_2 - x_1}$$</p>
            <p><strong>Horizontal boundary</strong> (e.g., \(y = y_{\max}\)):</p>
            <p>$$y = y_{\max}$$</p>
            <p>$$x = x_1 + (x_2 - x_1)\,\frac{y_{\max} - y_1}{y_2 - y_1}$$</p>
        </article>

        <article>
            <h4>Advantages</h4>
            <ul>
                <li>
                    <p>Works well with a <strong>convex clipping window</strong> (e.g., rectangle).</p>
                </li>
                <li>
                    <p>Simple, boundary-by-boundary clipping process.</p>
                </li>
            </ul>
        </article>

        <article>
            <h4>Limitations</h4>
            <ul>
                <li>
                    <p>The <strong>clipping window must be convex</strong>. For concave clipping regions, this method may fail.</p>
                </li>
                <li>
                    <p>If clipping a concave subject polygon results in <strong>multiple disjoint pieces</strong>, Sutherland–Hodgman produces a single polygonal loop and cannot represent multiple outputs; use Weiler–Atherton in such cases.</p>
                </li>
                <li>
                    <p>Clipping is applied <strong>in sequence</strong> boundary by boundary.</p>
                </li>
            </ul>
        </article>

        <article>
            <h3>Page 18: 3D Transformations</h3>
            <p><strong>Introduction:</strong> 3D transformations extend 2D operations (translation, scaling, rotation, reflection, shearing) into three-dimensional space using homogeneous coordinates \((x, y, z, 1)\). These transformations manipulate objects along the \(x\), \(y\), and \(z\) axes.</p>
        </article>

        <article>
            <h4>3D Translation</h4>
            <p><strong>Formula:</strong> \(x' = x + T_x,\; y' = y + T_y,\; z' = z + T_z\)</p>
            <p><strong>Matrix form:</strong></p>
            <p>$$
                \begin{bmatrix}
                x'\\y'\\z'\\1
                \end{bmatrix}
                =
                \begin{bmatrix}
                1 & 0 & 0 & T_x\\
                0 & 1 & 0 & T_y\\
                0 & 0 & 1 & T_z\\
                0 & 0 & 0 & 1
                \end{bmatrix}
                \begin{bmatrix}
                x\\y\\z\\1
                \end{bmatrix}
                $$</p>
        </article>

        <article>
            <h4>3D Scaling</h4>
            <p><strong>Formula:</strong> \(x' = S_x\,x,\; y' = S_y\,y,\; z' = S_z\,z\)</p>
            <p><strong>Matrix form:</strong></p>
            <p>$$
                \begin{bmatrix}
                x'\\y'\\z'\\1
                \end{bmatrix}
                =
                \begin{bmatrix}
                S_x & 0 & 0 & 0\\
                0 & S_y & 0 & 0\\
                0 & 0 & S_z & 0\\
                0 & 0 & 0 & 1
                \end{bmatrix}
                \begin{bmatrix}
                x\\y\\z\\1
                \end{bmatrix}
                $$</p>
        </article>

        <article>
            <h4>3D Rotation</h4>
            <h5>(a) Rotation about the X-axis</h5>
            <p>$$
                \begin{bmatrix}
                x'\\y'\\z'\\1
                \end{bmatrix}
                =
                \begin{bmatrix}
                1 & 0 & 0 & 0\\
                0 & \cos\theta & -\sin\theta & 0\\
                0 & \sin\theta & \cos\theta & 0\\
                0 & 0 & 0 & 1
                \end{bmatrix}
                \begin{bmatrix}
                x\\y\\z\\1
                \end{bmatrix}
                $$</p>
            <h5>(b) Rotation about the Y-axis</h5>
            <p>$$
                \begin{bmatrix}
                x'\\y'\\z'\\1
                \end{bmatrix}
                =
                \begin{bmatrix}
                \cos\theta & 0 & \sin\theta & 0\\
                0 & 1 & 0 & 0\\
                -\sin\theta & 0 & \cos\theta & 0\\
                0 & 0 & 0 & 1
                \end{bmatrix}
                \begin{bmatrix}
                x\\y\\z\\1
                \end{bmatrix}
                $$</p>
            <h5>(c) Rotation about the Z-axis</h5>
            <p>$$
                \begin{bmatrix}
                x'\\y'\\z'\\1
                \end{bmatrix}
                =
                \begin{bmatrix}
                \cos\theta & -\sin\theta & 0 & 0\\
                \sin\theta & \cos\theta & 0 & 0\\
                0 & 0 & 1 & 0\\
                0 & 0 & 0 & 1
                \end{bmatrix}
                \begin{bmatrix}
                x\\y\\z\\1
                \end{bmatrix}
                $$</p>
        </article>

        <article>
            <h4>Reflection in 3D</h4>
            <h5>About the XY-plane</h5>
            <p>\(x' = x,\; y' = y,\; z' = -z\)</p>
            <p>$$
                \begin{bmatrix}
                x'\\y'\\z'\\1
                \end{bmatrix}
                =
                \begin{bmatrix}
                1 & 0 & 0 & 0\\
                0 & 1 & 0 & 0\\
                0 & 0 & -1 & 0\\
                0 & 0 & 0 & 1
                \end{bmatrix}
                \begin{bmatrix}
                x\\y\\z\\1
                \end{bmatrix}
                $$</p>
            <h5>About the YZ-plane</h5>
            <p>\(x' = -x,\; y' = y,\; z' = z\)</p>
            <p>$$
                \begin{bmatrix}
                -1 & 0 & 0 & 0\\
                0 & 1 & 0 & 0\\
                0 & 0 & 1 & 0\\
                0 & 0 & 0 & 1
                \end{bmatrix}
                $$</p>
            <h5>About the XZ-plane</h5>
            <p>\(x' = x,\; y' = -y,\; z' = z\)</p>
            <p>$$
                \begin{bmatrix}
                1 & 0 & 0 & 0\\
                0 & -1 & 0 & 0\\
                0 & 0 & 1 & 0\\
                0 & 0 & 0 & 1
                \end{bmatrix}
                $$</p>
        </article>

        <article>
            <h4>Shearing in 3D</h4>
            <p>Shearing distorts a 3D object by shifting one coordinate proportionally to others.</p>
            <p><strong>General shear matrix:</strong></p>
            <p>$$
                \begin{bmatrix}
                1 & Sh_{xy} & Sh_{xz} & 0\\
                Sh_{yx} & 1 & Sh_{yz} & 0\\
                Sh_{zx} & Sh_{zy} & 1 & 0\\
                0 & 0 & 0 & 1
                \end{bmatrix}
                $$</p>
        </article>

        <article>
            <h3>Page 19: 3D Projections (Parallel &amp; Perspective)</h3>
            <p><strong>Introduction:</strong> <em>Projection</em> maps a 3D object onto a 2D view plane (the screen) from a given viewpoint. Two primary categories are:</p>
            <ul>
                <li>
                    <p><strong>Parallel Projection</strong></p>
                </li>
                <li>
                    <p><strong>Perspective Projection</strong></p>
                </li>
            </ul>
        </article>

        <article>
            <h4>Parallel Projection</h4>
            <p>All projectors (projection lines) are <strong>parallel</strong> to each other and are either perpendicular or inclined to the projection plane. No vanishing point is formed, so objects <strong>do not diminish</strong> with distance.</p>

            <h5>Types of Parallel Projection</h5>
            <ul>
                <li>
                    <p><strong>Orthographic Projection</strong> - projectors are perpendicular to the plane.</p>
                    <ul>
                        <li>
                            <p><strong>Front View:</strong> projection on the <strong>XY-plane</strong></p>
                        </li>
                        <li>
                            <p><strong>Top View:</strong> projection on the <strong>XZ-plane</strong></p>
                        </li>
                        <li>
                            <p><strong>Side View:</strong> projection on the <strong>YZ-plane</strong></p>
                        </li>
                    </ul>
                </li>
                <li>
                    <p><strong>Oblique Projection</strong> - projectors are inclined to the plane.</p>
                    <ul>
                        <li>
                            <p><strong>Cavalier:</strong> full scale along receding axis (typically \(45^\circ\))</p>
                        </li>
                        <li>
                            <p><strong>Cabinet:</strong> half scale along receding axis (angle \(\approx 63.4^\circ\))</p>
                        </li>
                    </ul>
                </li>
            </ul>

            <h5>Orthographic Projection Matrix (to XY-plane)</h5>
            <p>$$
                \begin{bmatrix}
                1 & 0 & 0 & 0\\
                0 & 1 & 0 & 0\\
                0 & 0 & 0 & 0\\
                0 & 0 & 0 & 1
                \end{bmatrix}
                $$</p>
        </article>

        <article>
            <h4>Perspective Projection</h4>
            <p>Projectors <strong>converge</strong> at a single point (center of projection), producing a realistic sense of depth: distant objects appear smaller.</p>

            <h5>Concept (Center at Origin, Plane \(z=d\))</h5>
            <p>$$
                x'=\frac{x\,d}{z},\qquad
                y'=\frac{y\,d}{z}
                $$</p>
            <p>Objects with smaller \(z\) (closer) appear larger; those with larger \(z\) (farther) appear smaller.</p>

            <h5>Types of Perspective Projection</h5>
            <ul>
                <li>
                    <p><strong>One-point perspective</strong> - convergence along one axis (e.g., roads, tunnels)</p>
                </li>
                <li>
                    <p><strong>Two-point perspective</strong> - convergence along two axes (common in architecture)</p>
                </li>
                <li>
                    <p><strong>Three-point perspective</strong> - convergence along three axes (highly realistic scenes)</p>
                </li>
            </ul>
        </article>

        <article>
            <h4>Comparison</h4>
            <div class="table-responsive">
                <table class="table table-bordered table-striped">
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>Parallel Projection</th>
                            <th>Perspective Projection</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Projection lines</td>
                            <td>Parallel</td>
                            <td>Converge at a point</td>
                        </tr>
                        <tr>
                            <td>Depth perception</td>
                            <td>Not shown</td>
                            <td>Clearly visible</td>
                        </tr>
                        <tr>
                            <td>Realism</td>
                            <td>Less realistic</td>
                            <td>Highly realistic</td>
                        </tr>
                        <tr>
                            <td>Use</td>
                            <td>Engineering drawings</td>
                            <td>Computer graphics, animation</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </article>

        <article>
            <h4>Applications</h4>
            <ul>
                <li>
                    <p>3D modeling and rendering</p>
                </li>
                <li>
                    <p>Architectural visualization</p>
                </li>
                <li>
                    <p>CAD, animation, virtual reality</p>
                </li>
            </ul>
        </article>


    </main>

    <script> copyright("all"); </script>

</body>

</html>