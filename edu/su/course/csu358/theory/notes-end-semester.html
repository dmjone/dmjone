<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
<!--<![endif]-->

<head>
    <script src="/js/edu_su_common.js"></script>
    <noscript>
        <style>
            html,
            body {
                margin: 0;
                overflow: hidden;
            }
        </style>
        <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
    </noscript>

    <title>Computer Graphics Notes ESM - CSU358 - Shoolini U</title>
    <meta name="description" content="Complete End Semester Notes for Computer Graphics (CSU358), covering all units from intro to 3D transformations, projections, and animation.">

    <meta property="og:image" content="/logo.png">
    <meta property="og:type" content="article">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@divyamohan1993">
    <meta name="twitter:creator" content="@divyamohan1993">
    <meta name="twitter:image" content="/logo.png">

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />

    <meta name="author" content="Divya Mohan">
    <meta name="robots" content="index, follow">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function () {
            renderMathInElement(document.body, {
                // customised options
                // • auto-render specific keys, e.g.:
                delimiters: [
                    { left: '$$', right: '$$', display: true },
                    { left: '$', right: '$', display: false },
                    { left: '\\(', right: '\\)', display: false },
                    { left: '\\[', right: '\\]', display: true }
                ],
                // • rendering keys, e.g.:
                throwOnError: false
            });
        });
    </script>

    <!-- <style>
            main ul {
                list-style-type: none;
                padding: 0;
                margin: 0;
            }

            main ul li {
                margin: 0;
                padding: 0;
            }
        </style> -->

    <!-- JSON-LD Structured Data for SEO -->
    <script type="application/ld+json">
        {
          "@context": "https://schema.org",
          "@type": "Course",
          "name": "Computer Graphics Notes ESM ",
          "description": "Computer Graphics ESM Notes Summary provides an overview of comprehensive notes on Computer Graphics including CRT displays, raster and random scan techniques, frame buffers, input devices, and line drawing algorithms.",
          "url": "https://dmj.one/edu/su/course/csu358/theory/notes-end-semester",
          "dateModified": "2025-11-02",
          "provider": [
            {
              "@type": "EducationalOrganization",
              "name": "dmj.one",
              "url": "https://dmj.one"
            },
            {
              "@type": "EducationalOrganization",
              "name": "Shoolini University",
              "url": "https://shooliniuniversity.com"
            }
          ],
          "offers": {
              "@type": "Offer",
              "category": "Education",
              "price": "0",
              "priceCurrency": "USD",
              "availability": "https://schema.org/InStock",
              "url": "https://dmj.one/edu/su/course/csu358/theory/notes-end-semester"
          },
          "hasCourseInstance": {
              "@type": "CourseInstance",
              "name": "Computer Graphics Notes ESM - CSU358",
              "description": "Comprehensive notes ESM summary on Computer Graphics including CRT displays, raster and random scan techniques, frame buffers, input devices, and line drawing algorithms.",
              "courseMode": "online",
              "startDate": "2025-11-02",
              "courseWorkload": "PT4H",               
              "instructor": [
                {
                  "@type": "Person",
                  "name": "Dr. Sonia",
                  "url": "https://shooliniuniversity.com/faculty/profile/Sonia"
                },
                {
                  "@type": "Person",
                  "name": "Divya Mohan",                                      
                  "url": "https://dmj.one/resume/",
                    "sameAs": [
                        "https://www.credly.com/users/divyamohan1993",
                        "https://www.linkedin.com/in/divyamohan1993/",
                        "https://hackerrank.com/divyamohan1993",
                        "https://www.coursera.org/learner/divyamohan1993"
                    ]
                }
              ],
              "url": "https://dmj.one/edu/su/course/csu358/"
            }
        }
        </script>


</head>

<body>

    <script> header_author("dm"); </script>

    <main>
        <article class="agen-tableofcontents">
            <h1 class="text-center">
                Computer Graphics Notes ESM
            </h1>
            <div class="d-none contentdate">2025, December 14</div>
        </article>

        <div class="text-center mb-4" style="position:relative;width:100%;height:250px;overflow:hidden"><img src="../img/notes-end-semester.png" alt="Computer Graphics End Semester Notes Cover" style="position:absolute;top:50%;left:50%;width:100%;height:100%;object-fit:cover;transform:translate(-50%,-50%)"></div>


        <div class="mb-3 d-flex justify-content-center align-items-center flex-wrap">
            <a href="summary-notes-end-semester" class="btn me-3 mt-2 btn-lg btn-outline-primary d-print-none">
                <i class="bi bi-exclamation-triangle-fill me-2"></i> View Summary 1
            </a>
            <a href="summary-notes-end-semester-2" class="btn me-3 mt-2 btn-lg btn-outline-primary d-print-none">
                <i class="bi bi-exclamation-triangle-fill me-2"></i> View Summary 2
            </a>
            <a href="notes-fundamentals" class="btn me-3 mt-2 btn-lg btn-outline-primary d-print-none">
                <i class="bi bi-journal-text me-2"></i> Unit 1: Fundamentals
            </a>
            <a href="notes-drawing-algorithms" class="btn me-3 mt-2 btn-lg btn-outline-primary d-print-none">
                <i class="bi bi-journal-text me-2"></i> Unit 2: Drawing Algos
            </a>
            <a href="notes-transformations" class="btn me-3 mt-2 btn-lg btn-outline-primary d-print-none">
                <i class="bi bi-journal-text me-2"></i> Unit 3: Transformations
            </a>
            <a href="notes-clipping-projection" class="btn me-3 mt-2 btn-lg btn-outline-primary d-print-none">
                <i class="bi bi-journal-text me-2"></i> Unit 4: Clipping & Projection
            </a>
            <a href="notes-vsd-animation" class="btn me-3 mt-2 btn-lg btn-outline-primary d-print-none">
                <i class="bi bi-journal-text me-2"></i> Unit 5: VSD & Animation
            </a>
            <a href="notes-formulas" class="btn me-3 mt-2 btn-lg btn-outline-primary d-print-none">
                <i class="bi bi-calculator me-2"></i> Formula Sheet
            </a>
            <a href="notes-numericals" class="btn me-3 mt-2 btn-lg btn-outline-primary d-print-none">
                <i class="bi bi-calculator me-2"></i> Solved Numericals
            </a>
        </div>

        <article>
            <h3>1. Introduction to Computer Graphics</h3>
            <p>Computer Graphics is a domain of computer science concerned with how computers generate, manipulate, and display visual information. Its fundamental purpose is to convert abstract data and mathematical descriptions into visual representations that humans can perceive and understand.</p>
        </article>

        <article>
            <h4>1.1 Definition of Computer Graphics</h4>
            <p>Computer Graphics deals with the creation, manipulation, and representation of visual images using computers. It focuses on transforming numerical or symbolic data into visual form, typically as pixels on a display device.</p>
            <p>At a conceptual level, Computer Graphics acts as a translator between machines (which understand numbers) and humans (who understand images).</p>
        </article>

        <article>
            <h4>1.2 Importance of Computer Graphics</h4>
            <p>The importance of Computer Graphics arises from the human brain’s ability to process visual information faster and more intuitively than textual or numerical data.</p>
            <ul>
                <li><strong>Intuitive Interaction</strong>: Graphical interfaces allow users to interact naturally with computers through visual elements.</li>
                <li><strong>Enhanced Communication</strong>: Visuals simplify the explanation of complex ideas and improve clarity in presentations.</li>
                <li><strong>Scientific Visualization</strong>: Large and complex datasets can be understood through graphs, models, and simulations.</li>
                <li><strong>Realism in Media</strong>: Realistic movies and games rely on accurate visual rendering.</li>
                <li><strong>Simulation and Training</strong>: Flight simulators and training tools use graphics to safely replicate real-world scenarios.</li>
            </ul>
        </article>

        <article>
            <h4>1.3 Applications of Computer Graphics</h4>
            <p>Computer Graphics finds application wherever visual interpretation improves understanding, realism, or interaction.</p>
        </article>

        <article>
            <h5>1.3.1 Entertainment</h5>
            <p>Used in animation films, 3D modeling, and special effects to create visually rich and believable content.</p>
        </article>

        <article>
            <h5>1.3.2 Education</h5>
            <p>Visual aids and simulation-based learning help learners grasp abstract and dynamic concepts effectively.</p>
        </article>

        <article>
            <h5>1.3.3 Medical Imaging</h5>
            <p>Graphics techniques convert medical scan data such as MRI and CT into interpretable images for diagnosis.</p>
        </article>

        <article>
            <h5>1.3.4 Scientific Visualization</h5>
            <p>Complex scientific data, such as climate models, is visualized to identify patterns and behaviors.</p>
        </article>

        <article>
            <h5>1.3.5 CAD/CAM</h5>
            <p>Computer-Aided Design and Manufacturing enable precise engineering design and architectural planning.</p>
        </article>

        <article>
            <h5>1.3.6 Virtual Reality and Gaming</h5>
            <p>Immersive environments are created by continuously rendering scenes based on user interaction.</p>
        </article>

        <article>
            <h3>2. Graphics Hardware</h3>
            <p>Graphics hardware consists of physical components that enable input, processing, and output of visual data.</p>
        </article>

        <article>
            <h4>2.1 Input Devices</h4>
            <p>Input devices allow users to provide data and commands to the graphics system.</p>
            <ul>
                <li><strong>Mouse</strong>: Used for pointing, selecting, and drawing.</li>
                <li><strong>Keyboard</strong>: Provides textual and command-based input.</li>
                <li><strong>Light Pen</strong>: Enables direct interaction with the screen.</li>
                <li><strong>Graphic Tablet</strong>: Allows precise drawing and design input.</li>
                <li><strong>Scanner</strong>: Converts physical images into digital form.</li>
            </ul>
        </article>

        <article>
            <h4>2.2 Output Devices</h4>
            <p>Output devices display or produce the final visual result generated by the computer.</p>
            <ul>
                <li><strong>CRT</strong>: Uses electron beams to display images.</li>
                <li><strong>LCD / LED Monitors</strong>: Flat-panel displays using liquid crystals and light-emitting diodes.</li>
                <li><strong>Plotters</strong>: Produce large-scale vector drawings.</li>
                <li><strong>Printers</strong>: Generate hard copies of images.</li>
            </ul>
        </article>

        <article>
            <h4>2.3 Frame Buffer</h4>
            <p>The frame buffer is a dedicated memory area that stores the color information of each pixel on the screen.</p>
            <p>Each pixel’s color is represented using a fixed number of bits.</p>
            <p>For a screen resolution of $1024 \times 768$ with 24-bit color depth:</p>
            <p>$$1024 \times 768 \times 24 \text{ bits} \approx 18 \text{ MB}$$</p>
            <p>This memory is continuously read by the display hardware to refresh the screen.</p>
        </article>

        <article>
            <h4>2.4 Graphics Pipeline</h4>
            <p>The graphics pipeline is an ordered sequence of processing stages that convert 3D objects into a 2D image displayed on the screen.</p>
        </article>

        <article>
            <h5>2.4.1 Stages of the Graphics Pipeline</h5>
            <ul>
                <li><strong>Modeling</strong>: Creation of 3D objects using geometric descriptions.</li>
                <li><strong>Transformation</strong>: Positions objects into a common coordinate system.</li>
                <li><strong>Lighting</strong>: Calculates color and brightness based on light sources.</li>
                <li><strong>Projection</strong>: Converts 3D coordinates into 2D screen coordinates.</li>
                <li><strong>Clipping</strong>: Removes parts of objects outside the viewing area.</li>
                <li><strong>Rasterization</strong>: Converts geometric primitives into pixels.</li>
                <li><strong>Display</strong>: Final image is rendered on the output device.</li>
            </ul>
        </article>

        <article>
            <h3>TWEENING – DETAILED NOTES</h3>
        </article>

        <article>
            <h4>1. Introduction</h4>
            <p>Tweening comes from the word <strong>in-betweening</strong>. It is a technique used in animation to create smooth movement by automatically generating frames between two important frames.</p>
            <p>Instead of drawing every single frame manually, the animator defines only the important moments, and the computer fills the gap.</p>
            <p>Tweening is widely used in 2D animation, 3D animation, motion graphics, user interface animations, and computer games.</p>
        </article>
        <div class="alert alert-primary shadow-sm">
            <h5 class="alert-heading"><i class="bi bi-film"></i>Tweening</h5>
            <p class="mb-0"><strong>Q:</strong> What is "Tweening" short for, and what does it do?</p>
            <hr>
            <p class="mb-0 small"><strong>A:</strong> Short for <strong>"In-betweening"</strong>. It automatically generates intermediate frames between two keyframes to create smooth movement.</p>
        </div>

        <article>
            <h4>2. What Are Keyframes?</h4>
            <p>A keyframe is an important frame in animation where something significant happens.</p>
            <p>It defines the starting state and the ending state of an object.</p>
            <p><strong>Think of keyframes as checkpoints.</strong></p>
            <p><strong>Example:</strong></p>
            <ul>
                <li>Keyframe 1: A ball is on the left side of the screen</li>
                <li>Keyframe 2: A ball is on the right side of the screen</li>
            </ul>
            <p>The animator does not draw the ball moving step by step. Tweening creates those middle steps automatically.</p>
        </article>

        <article>
            <h4>3. What Is Tweening?</h4>
            <p>Tweening is the process of generating intermediate frames between two keyframes to create smooth transitions.</p>
            <p>It interpolates (calculates values in between) different properties of an object such as:</p>
            <ul>
                <li>Position</li>
                <li>Size</li>
                <li>Rotation</li>
                <li>Color</li>
                <li>Transparency</li>
                <li>Shape</li>
            </ul>
            <p><strong>Main purpose:</strong> To reduce manual effort and make motion look smooth and natural.</p>
        </article>

        <article>
            <h4>4. How Tweening Works</h4>
            <p>Tweening works using simple mathematics. The computer calculates small changes between two values and applies them frame by frame.</p>
            <p><strong>Example:</strong></p>
            <p>Keyframe 1: Object at $x = 0$</p>
            <p>Keyframe 2: Object at $x = 100$</p>
            <p>If 10 frames are needed in between, the position changes evenly.</p>
            <p>Each frame moves the object by:</p>
            <p>$$\frac{100 - 0}{10} = 10$$</p>
            <p>So the object moves 10 units per frame until it reaches the final position.</p>
        </article>
        <div class="alert alert-info shadow-sm">
            <h5 class="alert-heading"><i class="bi bi-calculator"></i>Interpolation</h5>
            <p class="mb-0"><strong>Q:</strong> If Frame 1 is at x=0 and Frame 10 is at x=100, how much does the object move per frame in a linear tween?</p>
            <hr>
            <p class="mb-0 small"><strong>A:</strong> $\frac{100-0}{10} = 10$ units per frame.</p>
        </div>

        <article>
            <h4>5. Morphing</h4>
            <p>Morphing is a special and more advanced type of tweening.</p>
            <p>In morphing, one shape smoothly transforms into another shape by blending intermediate forms.</p>
            <p><strong>Example:</strong></p>
            <ul>
                <li>A circle gradually turning into a square</li>
                <li>One face changing into another face</li>
            </ul>
            <p>This requires matching points carefully to avoid distortion.</p>
        </article>
        <div class="alert alert-secondary shadow-sm">
            <h5 class="alert-heading"><i class="bi bi-person-bounding-box"></i>Morphing</h5>
            <p class="mb-0"><strong>Q:</strong> How does <strong>Morphing</strong> differ from standard Tweening?</p>
            <hr>
            <p class="mb-0 small"><strong>A:</strong> Morphing transforms one <strong>shape</strong> into another (e.g., circle to square), whereas typical tweening moves/rotates/scales an object.</p>
        </div>

        <article>
            <h4>6. Advantages of Tweening</h4>
            <ul>
                <li><strong>Saves time</strong>: No need to draw every frame manually</li>
                <li><strong>Smooth motion</strong>: Movement looks natural and continuous</li>
                <li><strong>Precise control</strong>: Animators can control speed and direction</li>
                <li><strong>Works in 2D and 3D</strong>: Used across animation types</li>
                <li><strong>Reduces workload</strong>: Less repetitive work for animators</li>
            </ul>
        </article>

        <article>
            <h4>7. Disadvantages of Tweening</h4>
            <ul>
                <li><strong>Unnatural motion</strong>: Poor easing can make animation look robotic</li>
                <li><strong>Shape distortion</strong>: Incorrect point mapping causes visual errors</li>
                <li><strong>Complex actions</strong>: Advanced motion often needs manual correction</li>
            </ul>
        </article>

        <article>
            <h4>8. Real-Life Examples of Tweening</h4>
            <p><strong>Mobile and UI Animations:</strong></p>
            <ul>
                <li>Buttons expanding or shrinking</li>
                <li>Screen transitions</li>
            </ul>

            <p><strong>Cartoons and Animation:</strong></p>
            <ul>
                <li>Character walking cycles</li>
                <li>Facial expressions changing</li>
            </ul>

            <p><strong>Games:</strong></p>
            <ul>
                <li>Camera movement</li>
                <li>Character motion</li>
            </ul>

            <p><strong>Web Animations (CSS / JavaScript):</strong></p>
            <ul>
                <li>Fade-in and fade-out effects</li>
                <li>Sliding menus</li>
            </ul>
        </article>

        <article>
            <h3>PANNING – DETAILED NOTES</h3>
        </article>

        <article>
            <h4>1. Introduction</h4>
            <p>Panning is a camera movement technique used in computer graphics, animation, and cinematography. In panning, the camera moves or rotates horizontally across a scene.</p>
            <p>The important idea is that the camera stays at the same place but changes the direction it is facing.</p>
            <p>This creates the feeling that the viewer is “looking around” the scene.</p>
            <p>Panning is widely used in:</p>
            <ul>
                <li>2D and 3D animation</li>
                <li>User interfaces</li>
                <li>Video games</li>
                <li>Virtual tours</li>
                <li>Cinematic scenes</li>
            </ul>
        </article>

        <article>
            <h4>2. What is Panning?</h4>
            <p><strong>Definition:</strong></p>
            <p>Panning is the horizontal movement of the camera view across a scene from a fixed position. The camera rotates left or right, which shifts what is visible on the screen without moving the camera forward or backward.</p>
            <p><strong>Key idea:</strong> The camera position does not change, only the viewing direction changes.</p>
            <p><strong>Simple Example:</strong></p>
            <p>Imagine you are standing at one place and you turn your head to the left or right. Your feet stay in the same position, but your view changes. This action is called panning.</p>
        </article>
        <div class="alert alert-success shadow-sm">
            <h5 class="alert-heading"><i class="bi bi-camera-video"></i>Panning Logic</h5>
            <p class="mb-0"><strong>Q:</strong> In Panning, does the camera move position?</p>
            <hr>
            <p class="mb-0 small"><strong>A:</strong> <strong>No</strong>. The camera stays fixed but <strong>rotates</strong> (changes direction) to scan the scene.</p>
        </div>

        <article>
            <h4>3. Purpose of Panning</h4>
            <p>Panning is used to control what the viewer sees and where their attention goes.</p>
            <ul>
                <li><strong>Follow moving objects</strong>: Keeps a moving object (like a running character) in view</li>
                <li><strong>Reveal the environment</strong>: Shows different parts of a scene gradually</li>
                <li><strong>Connect subjects</strong>: Moves the viewer’s focus from one object to another</li>
                <li><strong>Create cinematic effect</strong>: Adds drama and smooth visual flow</li>
                <li><strong>Enhance storytelling</strong>: Helps explain context by showing surroundings</li>
                <li><strong>Guide user attention</strong>: Directs focus in games and user interfaces</li>
            </ul>
        </article>

        <article>
            <h4>4. Panning in Computer Graphics</h4>
            <p>In computer graphics, panning is achieved by changing the camera’s viewing parameters instead of moving objects.</p>
            <p>The scene remains the same, but the visible portion of the scene shifts horizontally.</p>
            <p>This is computationally efficient because only the view changes, not the actual object positions.</p>
        </article>

        <article>
            <h4>5. Real-Life Examples of Panning</h4>
            <p><strong>Animation and Movies:</strong></p>
            <ul>
                <li>Camera moving across a landscape</li>
                <li>Following a character walking across the screen</li>
            </ul>

            <p><strong>Video Games:</strong></p>
            <ul>
                <li>Side-scrolling games where the screen moves horizontally</li>
                <li>Camera tracking a player’s movement</li>
            </ul>

            <p><strong>User Interfaces:</strong></p>
            <ul>
                <li>Horizontal scrolling screens</li>
                <li>Image galleries sliding left or right</li>
            </ul>

            <p><strong>Virtual Tours:</strong></p>
            <ul>
                <li>Looking left or right inside a 360° environment</li>
            </ul>
        </article>


        <article>
            <h3>TRANSFORMATIONS – DETAILED NOTES</h3>
        </article>

        <article>
            <h4>1. Introduction</h4>
            <p>In computer graphics, a transformation means changing an object’s position, size, orientation, or shape.</p>
            <p>In simple words, transformations answer questions like:</p>
            <ul>
                <li>Where is the object?</li>
                <li>How big is the object?</li>
                <li>In which direction is it facing?</li>
                <li>How is its shape altered?</li>
            </ul>
            <p>Transformations are applied in both 2D and 3D graphics to move, resize, rotate, or distort objects.</p>
            <p>All transformations are performed mathematically using <strong>matrix multiplication</strong>.</p>
        </article>

        <article>
            <h4>2. Why Matrices Are Used</h4>
            <p>Computers are good at numbers, not shapes. Matrices provide a uniform and efficient way to represent all transformations.</p>
            <p>By multiplying a point with a transformation matrix, the new transformed point is obtained.</p>
        </article>

        <article>
            <h4>3. Types of Transformations</h4>
        </article>

        <article>
            <h5>3.1 Translation</h5>
            <p>Translation moves an object from one position to another without changing its size or orientation.</p>
            <p><strong>Think of sliding an object on the screen.</strong></p>

            <p>If a point $P(x, y)$ is translated by $T_x$ in the x-direction and $T_y$ in the y-direction:</p>

            <p>$$x' = x + T_x$$</p>
            <p>$$y' = y + T_y$$</p>

            <p><strong>Matrix form (2D):</strong></p>
            <p>$$
                \begin{bmatrix}
                x' \\
                y'
                \end{bmatrix}
                =
                \begin{bmatrix}
                1 & 0 \\
                0 & 1
                \end{bmatrix}
                \begin{bmatrix}
                x \\
                y
                \end{bmatrix}
                +
                \begin{bmatrix}
                T_x \\
                T_y
                \end{bmatrix}
                $$</p>

            <p><strong>Use:</strong> Moving objects on the screen.</p>
        </article>

        <article>
            <h5>3.2 Scaling</h5>
            <p>Scaling changes the size of an object.</p>
            <p><strong>Think of zooming in or zooming out.</strong></p>

            <p>If a point $P(x, y)$ is scaled by factors $S_x$ and $S_y$:</p>

            <p>$$x' = x \cdot S_x$$</p>
            <p>$$y' = y \cdot S_y$$</p>

            <p><strong>Matrix form:</strong></p>
            <p>$$
                \begin{bmatrix}
                x' \\
                y'
                \end{bmatrix}
                =
                \begin{bmatrix}
                S_x & 0 \\
                0 & S_y
                \end{bmatrix}
                \begin{bmatrix}
                x \\
                y
                \end{bmatrix}
                $$</p>

            <p><strong>Types of Scaling:</strong></p>
            <ul>
                <li><strong>Uniform scaling</strong>: $S_x = S_y$ (shape remains same)</li>
                <li><strong>Non-uniform scaling</strong>: $S_x \neq S_y$ (shape may stretch)</li>
            </ul>
        </article>

        <article>
            <h5>3.3 Rotation</h5>
            <p>Rotation turns an object around a fixed point, usually the origin.</p>
            <p><strong>Think of rotating a book on a table.</strong></p>

            <p>If a point $P(x, y)$ is rotated by angle $\theta$:</p>

            <p>$$x' = x\cos\theta - y\sin\theta$$</p>
            <p>$$y' = x\sin\theta + y\cos\theta$$</p>

            <p><strong>Matrix form:</strong></p>
            <p>$$
                \begin{bmatrix}
                x' \\
                y'
                \end{bmatrix}
                =
                \begin{bmatrix}
                \cos\theta & -\sin\theta \\
                \sin\theta & \cos\theta
                \end{bmatrix}
                \begin{bmatrix}
                x \\
                y
                \end{bmatrix}
                $$</p>

            <p><strong>Types of Rotation:</strong></p>
            <ul>
                <li><strong>Counterclockwise</strong>: Positive angle</li>
                <li><strong>Clockwise</strong>: Negative angle</li>
            </ul>
        </article>

        <article>
            <h5>3.4 Reflection</h5>
            <p>Reflection creates a mirror image of an object.</p>
            <p><strong>Think of seeing yourself in a mirror.</strong></p>

            <p><strong>Reflection about X-axis:</strong></p>
            <p>$$
                \begin{bmatrix}
                1 & 0 \\
                0 & -1
                \end{bmatrix}
                $$</p>

            <p><strong>Reflection about Y-axis:</strong></p>
            <p>$$
                \begin{bmatrix}
                -1 & 0 \\
                0 & 1
                \end{bmatrix}
                $$</p>

            <p><strong>Reflection about Origin:</strong></p>
            <p>$$
                \begin{bmatrix}
                -1 & 0 \\
                0 & -1
                \end{bmatrix}
                $$</p>
        </article>

        <article>
            <h5>3.5 Shearing</h5>
            <p>Shearing slants or skews the shape of an object.</p>
            <p><strong>Think of pushing the top of a rectangle sideways.</strong></p>

            <p><strong>Shear in X-direction:</strong></p>
            <p>$$
                \begin{bmatrix}
                1 & Sh_x \\
                0 & 1
                \end{bmatrix}
                $$</p>

            <p><strong>Shear in Y-direction:</strong></p>
            <p>$$
                \begin{bmatrix}
                1 & 0 \\
                Sh_y & 1
                \end{bmatrix}
                $$</p>
        </article>

        <article>
            <h4>4. Homogeneous Coordinates</h4>
            <p>Homogeneous coordinates are used to represent translation using matrix multiplication.</p>
            <p>A 2D point $(x, y)$ is written as:</p>
            <p>$$(x, y, 1)$$</p>
            <p>This allows all transformations (translation, scaling, rotation) to be represented using a single matrix format.</p>
        </article>

        <article>
            <h4>5. Composite Transformation</h4>
            <p>Composite transformation means applying more than one transformation to an object.</p>
            <p><strong>Example:</strong> Rotate an object, then translate it.</p>

            <p>$$
                P' = T \cdot R \cdot P
                $$</p>

            <p><strong>Important Rule:</strong></p>
            <p>Matrix multiplication is <strong>not commutative</strong>.</p>
            <p>$$A \cdot B \neq B \cdot A$$</p>

            <p>This means the order of transformations matters and changes the final result.</p>
        </article>
        <div class="alert alert-warning shadow-sm">
            <h5 class="alert-heading"><i class="bi bi-arrow-repeat"></i>Matrix Rule</h5>
            <p class="mb-0"><strong>Q:</strong> Is the order of matrix multiplication important? Why?</p>
            <hr>
            <p class="mb-0 small"><strong>A:</strong> <strong>Yes</strong>. Matrix multiplication is <strong>not commutative</strong> ($A \cdot B \neq B \cdot A$). Rotating then translating gives a different result than translating then rotating.</p>
        </div>

        <article>
            <h3>3D TRANSFORMATIONS, PROJECTION AND VISIBLE SURFACE DETECTION</h3>
        </article>

        <article>
            <h4>1. 3D Transformations</h4>
            <p>3D transformations change the position, size, or orientation of objects in three-dimensional space. Unlike 2D, each point has three coordinates: $(x, y, z)$.</p>
            <p>All 3D transformations are performed using <strong>4×4 matrices</strong> with homogeneous coordinates.</p>
        </article>
        <div class="alert alert-danger shadow-sm">
            <h5 class="alert-heading"><i class="bi bi-box-seam"></i>3D Matrices</h5>
            <p class="mb-0"><strong>Q:</strong> What size matrix is used for <strong>3D transformations</strong> with homogeneous coordinates?</p>
            <hr>
            <p class="mb-0 small"><strong>A:</strong> A <strong>4×4 Matrix</strong>.</p>
        </div>

        <article>
            <h5>1.1 Translation in 3D</h5>
            <p>Translation moves an object from one position to another in 3D space.</p>
            <p><strong>Think of shifting an object left–right, up–down, and forward–backward.</strong></p>

            <p>If a point $P(x, y, z)$ is translated by $(T_x, T_y, T_z)$:</p>
            <p>$$x' = x + T_x$$</p>
            <p>$$y' = y + T_y$$</p>
            <p>$$z' = z + T_z$$</p>
        </article>

        <article>
            <h5>1.2 Scaling in 3D</h5>
            <p>Scaling changes the size of a 3D object.</p>
            <p><strong>Think of enlarging or shrinking a 3D model.</strong></p>

            <p>If a point $P(x, y, z)$ is scaled by $(S_x, S_y, S_z)$:</p>
            <p>$$x' = x \cdot S_x$$</p>
            <p>$$y' = y \cdot S_y$$</p>
            <p>$$z' = z \cdot S_z$$</p>
        </article>

        <article>
            <h5>1.3 Rotation in 3D</h5>
            <p>Rotation in 3D is performed around one of the coordinate axes.</p>

            <p><strong>Rotation about X-axis:</strong></p>
            <p>The object rotates around the X-axis; X remains unchanged.</p>

            <p><strong>Rotation about Y-axis:</strong></p>
            <p>The object rotates around the Y-axis; Y remains unchanged.</p>

            <p><strong>Rotation about Z-axis:</strong></p>
            <p>The object rotates in the XY-plane.</p>

            <p><strong>Example: Rotation about Z-axis by angle $\theta$</strong></p>
            <p>$$
                \begin{bmatrix}
                x' \\
                y' \\
                z'
                \end{bmatrix}
                =
                \begin{bmatrix}
                \cos\theta & -\sin\theta & 0 \\
                \sin\theta & \cos\theta & 0 \\
                0 & 0 & 1
                \end{bmatrix}
                \begin{bmatrix}
                x \\
                y \\
                z
                \end{bmatrix}
                $$</p>
        </article>

        <article>
            <h5>1.4 Reflection in 3D</h5>
            <p>Reflection creates a mirror image of a 3D object about a plane.</p>

            <p><strong>Reflection about XY-plane:</strong></p>
            <p>Only Z-coordinate changes sign.</p>
            <p>$$(x, y, -z)$$</p>

            <p><strong>Reflection about YZ-plane:</strong></p>
            <p>Only X-coordinate changes sign.</p>
            <p>$$( -x, y, z )$$</p>

            <p><strong>Reflection about ZX-plane:</strong></p>
            <p>Only Y-coordinate changes sign.</p>
            <p>$$( x, -y, z )$$</p>
        </article>

        <article>
            <h5>1.5 Shearing in 3D</h5>
            <p>Shearing slants a 3D object along one or more axes.</p>
            <p>3D shearing is more complex and is represented using <strong>4×4 matrices</strong>.</p>
            <p>It is used in advanced modeling and special visual effects.</p>
        </article>

        <article>
            <h4>2. Projection in Computer Graphics</h4>
            <p>Projection is the process of displaying a 3D object on a 2D screen.</p>
            <p>It converts 3D coordinates $(x, y, z)$ into 2D coordinates $(x', y')$.</p>
            <p>This step is essential because screens are two-dimensional.</p>
        </article>

        <article>
            <h5>2.1 Parallel Projection</h5>
            <p>In parallel projection, all projection lines are parallel to each other.</p>

            <p><strong>Features:</strong></p>
            <ul>
                <li>No perspective effect</li>
                <li>Object size does not change with distance</li>
                <li>Used in engineering drawings and CAD</li>
            </ul>
        </article>

        <article>
            <h5>2.2 Perspective Projection</h5>
            <p>In perspective projection, all projection lines meet at a single point called the <strong>center of projection</strong>.</p>
            <p>This matches how human eyes see the real world.</p>

            <p><strong>Features:</strong></p>
            <ul>
                <li>Creates depth</li>
                <li>Distant objects appear smaller</li>
                <li>Produces realistic images</li>
            </ul>

            <p><strong>Basic Concept:</strong></p>
            <p>Objects farther from the viewer have smaller projected coordinates.</p>
        </article>

        <article>
            <h4>3. Visible Surface Detection</h4>
            <p>Visible Surface Detection determines which surfaces of 3D objects are visible from a given viewpoint and which are hidden.</p>
            <p>The computer must draw only the visible surfaces to create a realistic image.</p>
        </article>

        <article>
            <h5>3.1 Why Visible Surface Detection is Needed</h5>
            <ul>
                <li>To remove hidden lines and surfaces</li>
                <li>To generate realistic images</li>
                <li>To reduce unnecessary drawing</li>
                <li>To correctly handle overlapping objects</li>
            </ul>

            <p><strong>Key Idea:</strong> When two objects overlap, the one closer to the viewer hides the one behind it.</p>
        </article>

        <article>
            <h3>Z-BUFFER AND A-BUFFER ALGORITHMS & PROJECTION</h3>
        </article>

        <article>
            <h4>1. Z-Buffer Algorithm (Depth Buffer)</h4>
            <p>The Z-Buffer algorithm is one of the most common methods used to determine which surfaces are visible in a 3D scene.</p>
            <p><strong>Core idea:</strong> For every pixel on the screen, store how far that pixel is from the viewer.</p>
            <p>The letter <strong>Z</strong> represents depth. Smaller Z means the object is closer to the viewer.</p>
        </article>

        <article>
            <h4>2. What is a Z-Buffer?</h4>
            <p>A Z-buffer is a special memory area that stores the depth (z-value) of every pixel on the screen.</p>
            <p>There are two buffers involved:</p>
            <ul>
                <li><strong>Frame Buffer</strong>: Stores the color of pixels</li>
                <li><strong>Z-Buffer</strong>: Stores the depth of pixels</li>
            </ul>
            <p>Only the closest surface at each pixel is displayed.</p>
        </article>

        <article>
            <h4>3. How Z-Buffer Works</h4>
            <p>The Z-buffer algorithm works in a very systematic way.</p>

            <p><strong>Step 1: Initialization</strong></p>
            <ul>
                <li>Z-buffer is initialized with a very large value $(+\infty)$</li>
                <li>Frame buffer is filled with background color</li>
            </ul>

            <p><strong>Step 2: Process Each Polygon</strong></p>
            <ul>
                <li>For every polygon in the scene</li>
                <li>For every pixel covered by that polygon</li>
            </ul>

            <p><strong>Step 3: Depth Comparison</strong></p>
            <ul>
                <li>Compute the pixel’s depth value $z$</li>
                <li>Compare it with stored Z-buffer value</li>
            </ul>

            <p><strong>Decision Rule:</strong></p>
            <ul>
                <li>If $z_{\text{new}} < z_{\text{stored}}$ → pixel is visible</li>
                <li>If $z_{\text{new}} \ge z_{\text{stored}}$ → pixel is hidden</li>
            </ul>

            <p><strong>Update Rule:</strong></p>
            <ul>
                <li>Update Z-buffer with new z-value</li>
                <li>Update frame buffer with pixel color</li>
            </ul>
        </article>

        <article>
            <h4>4. Why Z-Buffer Works</h4>
            <p>At each pixel location, only the closest object matters.</p>
            <p>The Z-buffer ensures that farther objects never overwrite nearer ones.</p>
            <p>This matches how visibility works in the real world.</p>
        </article>

        <article>
            <h4>5. Advantages of Z-Buffer</h4>
            <ul>
                <li><strong>Simple</strong>: Easy to understand and implement</li>
                <li><strong>Fast</strong>: Suitable for real-time rendering</li>
                <li><strong>General</strong>: Works with any scene complexity</li>
                <li><strong>Hardware support</strong>: Used in OpenGL and DirectX</li>
                <li><strong>Ideal for games</strong>: Real-time performance</li>
            </ul>
        </article>

        <article>
            <h4>6. Disadvantages of Z-Buffer</h4>
            <ul>
                <li><strong>Extra memory</strong>: Requires a depth value per pixel</li>
                <li><strong>Transparency issues</strong>: Cannot handle transparent surfaces properly</li>
                <li><strong>Aliasing</strong>: Jagged edges may appear</li>
            </ul>
        </article>

        <article>
            <h4>7. A-Buffer Algorithm (Anti-Aliased Buffer)</h4>
            <p>The A-buffer is an advanced version of the Z-buffer.</p>
            <p><strong>Key idea:</strong> Instead of storing only one surface per pixel, store <strong>all surfaces</strong> that pass through that pixel.</p>
            <p>It is also called the <strong>Accumulation Buffer</strong>.</p>
        </article>

        <article>
            <h4>8. How A-Buffer Works</h4>
            <p>Each pixel stores a list of fragments instead of a single value.</p>

            <p><strong>Each fragment stores:</strong></p>
            <ul>
                <li>Depth $(z)$</li>
                <li>Color</li>
                <li>Opacity $(\alpha)$</li>
                <li>Surface ID</li>
                <li>Coverage value (how much of the pixel is covered)</li>
            </ul>

            <p>After all fragments are collected, the final pixel color is computed using <strong>alpha blending</strong>.</p>
        </article>

        <article>
            <h4>9. Why A-Buffer is Better than Z-Buffer</h4>
            <p>The A-buffer does not discard hidden surfaces immediately.</p>
            <p>Instead, it combines them correctly based on transparency and coverage.</p>
            <p>This results in smoother edges and realistic transparency.</p>
        </article>

        <article>
            <h4>10. Advantages of A-Buffer</h4>
            <ul>
                <li><strong>Supports transparency</strong></li>
                <li><strong>Better anti-aliasing</strong></li>
                <li><strong>Handles multiple surfaces per pixel</strong></li>
                <li><strong>More realistic images</strong></li>
            </ul>
        </article>

        <article>
            <h4>11. Disadvantages of A-Buffer</h4>
            <ul>
                <li><strong>High memory usage</strong></li>
                <li><strong>Slower than Z-buffer</strong></li>
                <li><strong>Complex implementation</strong></li>
            </ul>
        </article>

        <article>
            <h4>12. Projection in Computer Graphics</h4>
            <p>Projection is the process of converting a 3D object into a 2D image.</p>
            <p>This is required because computer screens are two-dimensional.</p>
            <p>Projection converts coordinates:</p>
            <p>$$(x, y, z) \rightarrow (x', y')$$</p>
        </article>

        <article>
            <h4>13. Why Projection is Needed</h4>
            <ul>
                <li>To display 3D scenes on 2D screens</li>
                <li>To create realistic depth perception</li>
                <li>To produce technical drawings and CAD views</li>
            </ul>
            <p>Projection defines how 3D space is viewed and interpreted on the screen.</p>
        </article>

        <article>
            <h3>TYPES OF PROJECTION</h3>
        </article>

        <article>
            <h4>1. Introduction</h4>
            <p>Projection is the method used to display a three-dimensional object on a two-dimensional screen.</p>
            <p>Since screens are flat, projection decides <strong>how depth is represented</strong> and <strong>how objects appear</strong> to the viewer.</p>
            <p>Based on how projection lines behave, projection is divided into two major categories.</p>
        </article>

        <article>
            <h4>2. Classification of Projection</h4>
            <p>Projection is broadly classified into:</p>
            <ul>
                <li><strong>Parallel Projection</strong></li>
                <li><strong>Perspective Projection</strong></li>
            </ul>
        </article>

        <article>
            <h4>3. Parallel Projection</h4>
            <p>In parallel projection, all projection lines are parallel to each other.</p>
            <p>These lines hit the view plane in the same direction.</p>
            <p><strong>Key idea:</strong> Distance from the viewer does not affect the size of the object.</p>

            <p><strong>Easy way to imagine:</strong></p>
            <p>Think of sunlight falling on objects. The rays are parallel, so shadows do not shrink or expand with distance.</p>

            <p><strong>Main Features:</strong></p>
            <ul>
                <li>No perspective or depth effect</li>
                <li>Object size remains constant regardless of distance</li>
                <li>Used in engineering and CAD drawings</li>
                <li>Shapes and dimensions are preserved accurately</li>
            </ul>

            <p><strong>Use Case:</strong></p>
            <p>When accurate measurements matter more than realism.</p>
        </article>

        <article>
            <h4>4. Perspective Projection</h4>
            <p>In perspective projection, all projection lines meet at a single point.</p>
            <p>This point is called the <strong>Center of Projection (COP)</strong>.</p>
            <p>This method closely matches how the human eye sees the real world.</p>

            <p><strong>Easy way to imagine:</strong></p>
            <p>Stand on a straight road. The road appears to narrow and meet at a distant point. That point is a vanishing point.</p>

            <p><strong>Main Features:</strong></p>
            <ul>
                <li>Produces realistic images</li>
                <li>Objects farther away appear smaller</li>
                <li>Creates depth perception</li>
                <li>Uses vanishing points</li>
            </ul>

            <p><strong>Use Case:</strong></p>
            <p>Used in games, movies, simulations, and virtual reality where realism is important.</p>
        </article>

        <article>
            <h3>ANIMATION – DETAILED NOTES</h3>
        </article>

        <article>
            <h4>1. Introduction to Animation</h4>
            <p>Animation is the technique of creating the illusion of motion by displaying a sequence of images, called frames, one after another at high speed.</p>
            <p>The human eye cannot distinguish individual frames when they change rapidly, so the brain perceives continuous motion.</p>
            <p>In computer graphics, animation is created by changing an object’s properties over time, such as:</p>
            <ul>
                <li>Position</li>
                <li>Size</li>
                <li>Color</li>
                <li>Orientation</li>
            </ul>
            <p><strong>Key idea:</strong> Motion = change over time.</p>
        </article>

        <article>
            <h4>2. Frame-by-Frame Animation</h4>
            <p><strong>Definition:</strong></p>
            <p>In frame-by-frame animation, every single frame is drawn or designed manually.</p>
            <p>When these frames are played continuously, smooth motion is created.</p>

            <p><strong>Easy way to understand:</strong></p>
            <p>Like drawing slightly different pictures on each page of a notebook and flipping it quickly.</p>

            <p><strong>Examples:</strong></p>
            <ul>
                <li>Traditional 2D cartoons</li>
                <li>Flipbooks</li>
                <li>Hand-drawn animation</li>
            </ul>

            <p><strong>Pros:</strong></p>
            <ul>
                <li>Full creative control</li>
                <li>Very expressive and smooth motion</li>
            </ul>

            <p><strong>Cons:</strong></p>
            <ul>
                <li>Extremely time-consuming</li>
                <li>Requires high artistic skill</li>
            </ul>
        </article>

        <article>
            <h4>3. Keyframe Animation</h4>
            <p><strong>Definition:</strong></p>
            <p>In keyframe animation, the animator defines only the important frames (keyframes).</p>
            <p>The computer automatically generates the in-between frames.</p>

            <p><strong>Easy way to understand:</strong></p>
            <p>You decide where an object starts and ends. The computer fills the steps in between.</p>

            <p><strong>Examples:</strong></p>
            <ul>
                <li>Character animation in Blender</li>
                <li>Motion graphics in After Effects</li>
            </ul>

            <p><strong>Pros:</strong></p>
            <ul>
                <li>Much faster than frame-by-frame animation</li>
                <li>Easy to change timing and motion</li>
            </ul>

            <p><strong>Cons:</strong></p>
            <ul>
                <li>In-between motion may look artificial</li>
                <li>Requires understanding of timing and easing</li>
            </ul>
        </article>

        <article>
            <h4>4. Procedural Animation</h4>
            <p><strong>Definition:</strong></p>
            <p>Procedural animation generates motion automatically using mathematics, algorithms, or physics rules.</p>
            <p>The animator defines rules, not individual movements.</p>

            <p><strong>Easy way to understand:</strong></p>
            <p>You tell the computer “how things behave,” and it creates the motion.</p>

            <p><strong>Examples:</strong></p>
            <ul>
                <li>Fire and smoke</li>
                <li>Water waves</li>
                <li>Automatic walking cycles</li>
            </ul>

            <p><strong>Pros:</strong></p>
            <ul>
                <li>Saves a lot of manual effort</li>
                <li>Produces natural-looking motion</li>
            </ul>

            <p><strong>Cons:</strong></p>
            <ul>
                <li>Difficult to control exact appearance</li>
                <li>Requires programming or physics knowledge</li>
            </ul>
        </article>

        <article>
            <h4>5. Behavioral Animation</h4>
            <p><strong>Definition:</strong></p>
            <p>Behavioral animation uses rule-based or AI-like logic.</p>
            <p>Objects or characters react automatically to their environment and other objects.</p>

            <p><strong>Easy way to understand:</strong></p>
            <p>Characters make decisions instead of following fixed paths.</p>

            <p><strong>Examples:</strong></p>
            <ul>
                <li>Flocking birds</li>
                <li>Fish swimming in groups</li>
                <li>Crowd simulations</li>
            </ul>

            <p><strong>Pros:</strong></p>
            <ul>
                <li>Very realistic group movement</li>
                <li>Reduces manual animation work</li>
            </ul>

            <p><strong>Cons:</strong></p>
            <ul>
                <li>Complex setup</li>
                <li>Behavior can be unpredictable</li>
            </ul>
        </article>

        <article>
            <h4>6. Motion Capture (MoCap)</h4>
            <p><strong>Definition:</strong></p>
            <p>Motion capture records real human movement using cameras or sensors.</p>
            <p>The captured motion is applied to digital characters.</p>

            <p><strong>Easy way to understand:</strong></p>
            <p>A real person moves, and the computer copies that movement to a character.</p>

            <p><strong>Examples:</strong></p>
            <ul>
                <li>Movies like Avatar</li>
                <li>Games like FIFA and GTA</li>
            </ul>

            <p><strong>Pros:</strong></p>
            <ul>
                <li>Extremely realistic motion</li>
                <li>Saves effort for complex animations</li>
            </ul>

            <p><strong>Cons:</strong></p>
            <ul>
                <li>Expensive equipment</li>
                <li>Captured data needs cleanup</li>
            </ul>
        </article>

        <article>
            <h4>7. Dynamics Animation</h4>
            <p><strong>Definition:</strong></p>
            <p>Dynamics animation is based on physical laws such as gravity, wind, collisions, and friction.</p>
            <p>Motion is calculated using physics simulations.</p>

            <p><strong>Easy way to understand:</strong></p>
            <p>The computer follows real-world physics to move objects.</p>

            <p><strong>Examples:</strong></p>
            <ul>
                <li>Cloth simulation</li>
                <li>Hair movement</li>
                <li>Water splashes</li>
                <li>Breaking objects</li>
            </ul>

            <p><strong>Pros:</strong></p>
            <ul>
                <li>Highly realistic physical motion</li>
                <li>Best for natural effects</li>
            </ul>

            <p><strong>Cons:</strong></p>
            <ul>
                <li>Heavy computation</li>
                <li>Difficult to control exact artistic outcome</li>
            </ul>
        </article>

        <article>
            <h3>DDA, BRESENHAM & TRANSFORMATION — SOLVED PRACTICE NUMERICALS</h3>
        </article>

        <article>
            <h4>1. DDA LINE DRAWING — SOLUTIONS</h4>
        </article>

        <article>
            <h5>Q1. Line from (3,2) to (11,7) using DDA</h5>
            <p><strong>Step 1: Identify start and end points</strong></p>
            <p>Start: $(x_1,y_1)=(3,2)$</p>
            <p>End: $(x_2,y_2)=(11,7)$</p>

            <p><strong>Step 2: Compute differences</strong></p>
            <p>$\Delta x = 11 - 3 = 8$</p>
            <p>$\Delta y = 7 - 2 = 5$</p>

            <p><strong>Step 3: Number of steps</strong></p>
            <p>Steps = max$(|\Delta x|, |\Delta y|) = 8$</p>

            <p><strong>Step 4: Increment values</strong></p>
            <p>$x_{inc} = \frac{8}{8} = 1$</p>
            <p>$y_{inc} = \frac{5}{8} = 0.625$</p>

            <p><strong>Step 5: Generate points</strong></p>
            <ul>
                <li>(3, 2)</li>
                <li>(4, 2.63)</li>
                <li>(5, 3.25)</li>
                <li>(6, 3.88)</li>
                <li>(7, 4.50)</li>
                <li>(8, 5.13)</li>
                <li>(9, 5.75)</li>
                <li>(10, 6.38)</li>
                <li>(11, 7)</li>
            </ul>
        </article>

        <article>
            <h5>Q2. Line from (1,1) to (4,9) using DDA</h5>
            <p><strong>Step 1: Differences</strong></p>
            <p>$\Delta x = 3$, $\Delta y = 8$</p>

            <p><strong>Step 2: Steps</strong></p>
            <p>Steps = 8</p>

            <p><strong>Step 3: Increments</strong></p>
            <p>$x_{inc} = \frac{3}{8} = 0.375$</p>
            <p>$y_{inc} = \frac{8}{8} = 1$</p>

            <p><strong>Step 4: Points</strong></p>
            <ul>
                <li>(1,1)</li>
                <li>(1.38,2)</li>
                <li>(1.75,3)</li>
                <li>(2.13,4)</li>
                <li>(2.50,5)</li>
                <li>(2.88,6)</li>
                <li>(3.25,7)</li>
                <li>(3.63,8)</li>
                <li>(4,9)</li>
            </ul>
        </article>

        <article>
            <h4>2. BRESENHAM LINE DRAWING — SOLUTION</h4>
        </article>

        <article>
            <h5>Q3. Line from (2,3) to (12,8)</h5>
            <p><strong>Step 1: Differences</strong></p>
            <p>$\Delta x = 10$, $\Delta y = 5$</p>

            <p><strong>Step 2: Initial decision parameter</strong></p>
            <p>$p_0 = 2\Delta y - \Delta x = 2(5) - 10 = 0$</p>

            <p><strong>Step 3: Plot points</strong></p>
            <ul>
                <li>(2,3)</li>
                <li>(3,4)</li>
                <li>(4,4)</li>
                <li>(5,5)</li>
                <li>(6,5)</li>
                <li>(7,6)</li>
                <li>(8,6)</li>
                <li>(9,7)</li>
                <li>(10,7)</li>
                <li>(11,8)</li>
                <li>(12,8)</li>
            </ul>
        </article>

        <article>
            <h4>3. BRESENHAM CIRCLE DRAWING — SOLUTIONS</h4>
        </article>

        <article>
            <h5>Q4. First 8 symmetric points for r = 6</h5>
            <p><strong>Initial values:</strong> $(x,y) = (0,6)$</p>

            <p><strong>Symmetric points:</strong></p>
            <ul>
                <li>(0,6)</li>
                <li>(6,0)</li>
                <li>(0,-6)</li>
                <li>(-6,0)</li>
                <li>(4,4)</li>
                <li>(-4,4)</li>
                <li>(4,-4)</li>
                <li>(-4,-4)</li>
            </ul>
        </article>

        <article>
            <h5>Q5. Circle with r = 10 — first 5 points</h5>
            <ul>
                <li>(0,10)</li>
                <li>(1,10)</li>
                <li>(2,10)</li>
                <li>(3,9)</li>
                <li>(4,9)</li>
            </ul>
        </article>

        <article>
            <h4>4. TRANSFORMATION NUMERICALS — SOLUTIONS</h4>
        </article>

        <article>
            <h5>Q6. Translation of Triangle by $T_x=2$, $T_y=5$</h5>
            <p><strong>Formula:</strong> $(x',y') = (x+T_x, y+T_y)$</p>

            <ul>
                <li>A(1,2) → A′(3,7)</li>
                <li>B(4,3) → B′(6,8)</li>
                <li>C(6,1) → C′(8,6)</li>
            </ul>
        </article>

        <article>
            <h5>Q7. Scaling Rectangle by $S_x=2$, $S_y=3$</h5>
            <p><strong>Formula:</strong> $(x',y') = (xS_x, yS_y)$</p>

            <ul>
                <li>P(2,2) → (4,6)</li>
                <li>Q(4,2) → (8,6)</li>
                <li>R(4,5) → (8,15)</li>
                <li>S(2,5) → (4,15)</li>
            </ul>
        </article>

        <article>
            <h5>Q8. Rotate point (5,2) by 90° about origin</h5>
            <p><strong>Formula:</strong></p>
            <p>$x' = -y$, $y' = x$</p>

            <p>Result: $(-2,5)$</p>
        </article>

        <article>
            <h5>Q9. Rotate triangle by 45°</h5>
            <p><strong>Rotation formulas:</strong></p>
            <p>$x' = x\cos45° - y\sin45°$</p>
            <p>$y' = x\sin45° + y\cos45°$</p>

            <p>Using $\cos45°=\sin45°=\frac{1}{\sqrt2}$</p>

            <ul>
                <li>A(1,1) → (0,1.41)</li>
                <li>B(2,3) → (-0.71,3.54)</li>
                <li>C(3,1) → (1.41,2.83)</li>
            </ul>
        </article>

        <article>
            <h5>Q10. Reflect point (4,5) in Y-axis</h5>
            <p><strong>Rule:</strong> $(x,y) → (-x,y)$</p>

            <p>Result: $(-4,5)$</p>
        </article>

        <article>
            <h3>COHEN–SUTHERLAND LINE CLIPPING — SOLVED NUMERICAL</h3>
        </article>

        <article>
            <h4>Problem Statement</h4>
            <p><strong>Line Endpoints:</strong></p>
            <p>$P_1 = (2, 8)$, $P_2 = (18, 20)$</p>

            <p><strong>Clipping Window:</strong></p>
            <p>$x_{min}=5,\; y_{min}=10,\; x_{max}=15,\; y_{max}=25$</p>
        </article>

        <article>
            <h4>(a) Finding Region Codes</h4>
            <p>Cohen–Sutherland assigns a 4-bit code to each point:</p>
            <ul>
                <li>Left = 0001 (1)</li>
                <li>Right = 0010 (2)</li>
                <li>Bottom = 0100 (4)</li>
                <li>Top = 1000 (8)</li>
            </ul>

            <p><strong>For $P_1(2,8)$:</strong></p>
            <ul>
                <li>$x < 5$ → Left=1</li>
                <li>$y < 10$ → Bottom=4</li>
            </ul>
            <p>Region code = $0101_2 = 5$</p>

            <p><strong>For $P_2(18,20)$:</strong></p>
            <ul>
                <li>$x > 15$ → Right = 2</li>
                <li>$y$ is within bounds</li>
            </ul>
            <p>Region code = $0010_2 = 2$</p>
        </article>

        <article>
            <h4>Slope Calculation</h4>
            <p>The slope of the line is:</p>
            <p>
                $$
                m = \frac{y_2 - y_1}{x_2 - x_1}
                = \frac{20 - 8}{18 - 2}
                = \frac{12}{16}
                = \frac{3}{4}
                $$
            </p>
        </article>

        <article>
            <h4>(b) Step-by-Step Clipping</h4>

            <p><strong>Step 1:</strong> $P_1$ has code 5 (Left + Bottom).</p>
            <p>We clip against the <strong>Left boundary</strong> first: $x = 5$.</p>

            <p>Intersection formula:</p>
            <p>
                $$
                y = y_1 + m(x_{clip} - x_1)
                $$
            </p>

            <p>
                $$
                y = 8 + \frac{3}{4}(5 - 2)
                = 8 + \frac{3}{4} \cdot 3
                = 8 + 2.25
                = 10.25
                $$
            </p>

            <p>New point:</p>
            <p>$P_1' = (5, 10.25)$</p>
            <p>This point lies inside the window → region code = 0.</p>

            <hr />

            <p><strong>Step 2:</strong> $P_2$ has code 2 (Right).</p>
            <p>Clip against the <strong>Right boundary</strong>: $x = 15$.</p>

            <p>
                $$
                y = 10.25 + \frac{3}{4}(15 - 5)
                = 10.25 + \frac{3}{4} \cdot 10
                = 10.25 + 7.5
                = 17.75
                $$
            </p>

            <p>New point:</p>
            <p>$P_2' = (15, 17.75)$</p>
            <p>This point also lies inside the window → region code = 0.</p>
        </article>

        <article>
            <h4>(c) Intersection Points</h4>
            <ul>
                <li>With left boundary ($x=5$): $(5, 10.25)$</li>
                <li>With right boundary ($x=15$): $(15, 17.75)$</li>
            </ul>
        </article>

        <article>
            <h4>(d) Final Clipped Line Segment</h4>
            <p>
                <strong>Final visible line segment:</strong><br />
                $[(5,\;10.25)\;\text{to}\;(15,\;17.75)]$
            </p>
        </article>

        <article>
            <h3>COHEN–SUTHERLAND LINE CLIPPING — SOLVED NUMERICAL (Q2)</h3>
        </article>

        <article>
            <h4>Problem Statement</h4>
            <p><strong>Line Endpoints:</strong></p>
            <p>$P_1 = (6, 2)$, $P_2 = (16, 32)$</p>

            <p><strong>Clipping Window:</strong></p>
            <p>$x_{min}=4,\; y_{min}=6,\; x_{max}=20,\; y_{max}=28$</p>
        </article>

        <article>
            <h4>(a) Finding Region Codes</h4>
            <p>Cohen–Sutherland region codes:</p>
            <ul>
                <li>Left = 0001 (1)</li>
                <li>Right = 0010 (2)</li>
                <li>Bottom = 0100 (4)</li>
                <li>Top = 1000 (8)</li>
            </ul>

            <p><strong>For $P_1(6,2)$:</strong></p>
            <ul>
                <li>$y < 6$ → Bottom=4</li>
            </ul>
            <p>Region code = $0100_2 = 4$</p>

            <p><strong>For $P_2(16,32)$:</strong></p>
            <ul>
                <li>$y > 28$ → Top = 8</li>
            </ul>
            <p>Region code = $1000_2 = 8$</p>
        </article>

        <article>
            <h4>Slope Calculation</h4>
            <p>
                $$
                m = \frac{y_2 - y_1}{x_2 - x_1}
                = \frac{32 - 2}{16 - 6}
                = \frac{30}{10}
                = 3
                $$
            </p>
        </article>

        <article>
            <h4>(b) Step-by-Step Clipping</h4>

            <p><strong>Step 1:</strong> $P_1$ has code 4 (Bottom).</p>
            <p>Clip against the <strong>Bottom boundary</strong>: $y = 6$.</p>

            <p>Intersection formula:</p>
            <p>
                $$
                x = x_1 + \frac{y_{clip} - y_1}{m}
                $$
            </p>

            <p>
                $$
                x = 6 + \frac{6 - 2}{3}
                = 6 + \frac{4}{3}
                = 7.3333
                $$
            </p>

            <p>New point:</p>
            <p>$P_1' = (7.3333, 6)$</p>
            <p>This point lies inside the window → region code = 0.</p>

            <hr />

            <p><strong>Step 2:</strong> $P_2$ has code 8 (Top).</p>
            <p>Clip against the <strong>Top boundary</strong>: $y = 28$.</p>

            <p>
                $$
                x = 16 + \frac{28 - 32}{3}
                = 16 - \frac{4}{3}
                = 14.6667
                $$
            </p>

            <p>New point:</p>
            <p>$P_2' = (14.6667, 28)$</p>
            <p>This point also lies inside the window → region code = 0.</p>
        </article>

        <article>
            <h4>(c) Intersection with Top / Bottom Boundary</h4>
            <ul>
                <li><strong>Bottom boundary ($y=6$):</strong> $(7.3333,\;6)$</li>
                <li><strong>Top boundary ($y=28$):</strong> $(14.6667,\;28)$</li>
            </ul>
        </article>

        <article>
            <h4>(d) Final Visible Portion</h4>
            <p>
                <strong>Final clipped line segment:</strong><br />
                $[(7.3333,\;6)\;\text{to}\;(14.6667,\;28)]$
            </p>

            <p>
                <strong>Exact fractional form:</strong><br />
                $\left[\left(\frac{22}{3},\,6\right)\;\text{to}\;\left(\frac{44}{3},\,28\right)\right]$
            </p>
        </article>

        <article>
            <h3>COHEN–SUTHERLAND LINE CLIPPING — SOLVED NUMERICAL (Q3)</h3>
        </article>

        <article>
            <h4>Problem Statement</h4>
            <p><strong>Line Segment:</strong></p>
            <p>$P_1 = (12, 5),\; P_2 = (40, 15)$</p>

            <p><strong>Clipping Window:</strong></p>
            <p>$x_{min}=10,\; y_{min}=10,\; x_{max}=30,\; y_{max}=20$</p>
        </article>

        <article>
            <h4>(a) Region Codes</h4>
            <p>Cohen–Sutherland outcode bit convention:</p>
            <ul>
                <li>Left = 0001 (1)</li>
                <li>Right = 0010 (2)</li>
                <li>Bottom = 0100 (4)</li>
                <li>Top = 1000 (8)</li>
            </ul>

            <p><strong>For $P_1(12,5)$:</strong></p>
            <ul>
                <li>$y < 10$ → Bottom=4</li>
            </ul>
            <p>Region code = $0100_2 = 4$</p>

            <p><strong>For $P_2(40,15)$:</strong></p>
            <ul>
                <li>$x > 30$ → Right = 2</li>
            </ul>
            <p>Region code = $0010_2 = 2$</p>
        </article>

        <article>
            <h4>Slope Calculation</h4>
            <p>
                $$
                m = \frac{y_2 - y_1}{x_2 - x_1}
                = \frac{15 - 5}{40 - 12}
                = \frac{10}{28}
                = \frac{5}{14}
                $$
            </p>
        </article>

        <article>
            <h4>(b) Step-by-Step Clipping</h4>

            <p><strong>Step 1:</strong> $P_1$ has code 4 (Bottom).</p>
            <p>Clip against the <strong>Bottom boundary</strong>: $y = 10$.</p>

            <p>Intersection formula:</p>
            <p>
                $$
                x = x_1 + \frac{y_{clip} - y_1}{m}
                $$
            </p>

            <p>
                $$
                x = 12 + \frac{10 - 5}{5/14}
                = 12 + \frac{5 \times 14}{5}
                = 12 + 14
                = 26
                $$
            </p>

            <p>New point:</p>
            <p>$P_1' = (26, 10)$</p>
            <p>This point lies inside the window → region code = 0.</p>

            <hr />

            <p><strong>Step 2:</strong> $P_2$ has code 2 (Right).</p>
            <p>Clip against the <strong>Right boundary</strong>: $x = 30$.</p>

            <p>Intersection formula:</p>
            <p>
                $$
                y = y_1' + m(x_{clip} - x_1')
                $$
            </p>

            <p>
                $$
                y = 10 + \frac{5}{14}(30 - 26)
                = 10 + \frac{20}{14}
                = 10 + \frac{10}{7}
                = 11.4286
                $$
            </p>

            <p>New point:</p>
            <p>$P_2' = (30, 11.4286)$</p>
            <p>This point lies inside the window → region code = 0.</p>
        </article>

        <article>
            <h4>(c) Intersection Points</h4>
            <ul>
                <li><strong>With bottom boundary ($y=10$):</strong> $(26, 10)$</li>
                <li><strong>With right boundary ($x=30$):</strong> $(30, 11.4286)$</li>
            </ul>
        </article>

        <article>
            <h4>(d) Final Clipped Coordinates</h4>
            <p>
                <strong>Final visible line segment:</strong><br />
                $[(26,\;10)\;\text{to}\;(30,\;11.4286)]$
            </p>

            <p>
                <strong>Exact fractional form:</strong><br />
                $\left[(26,\;10)\;\text{to}\;\left(30,\;\frac{80}{7}\right)\right]$
            </p>
        </article>

        <article>
            <h3>COHEN–SUTHERLAND LINE CLIPPING — SOLVED NUMERICAL (Q4)</h3>
        </article>

        <article>
            <h4>Problem Statement</h4>
            <p><strong>Line Segment:</strong></p>
            <p>$P_1 = (0,0),\; P_2 = (25,35)$</p>

            <p><strong>Clipping Window:</strong></p>
            <p>$x_{min}=5,\; y_{min}=5,\; x_{max}=20,\; y_{max}=30$</p>
        </article>

        <article>
            <h4>(a) Region Codes</h4>
            <p>Cohen–Sutherland outcode convention:</p>
            <ul>
                <li>Left = 0001 (1)</li>
                <li>Right = 0010 (2)</li>
                <li>Bottom = 0100 (4)</li>
                <li>Top = 1000 (8)</li>
            </ul>

            <p><strong>For $P_1(0,0)$:</strong></p>
            <ul>
                <li>$x < 5$ → Left=1</li>
                <li>$y < 5$ → Bottom=4</li>
            </ul>
            <p>Region code = $0101_2 = 5$</p>

            <p><strong>For $P_2(25,35)$:</strong></p>
            <ul>
                <li>$x > 20$ → Right = 2</li>
                <li>$y > 30$ → Top = 8</li>
            </ul>
            <p>Region code = $1010_2 = 10$</p>
        </article>

        <article>
            <h4>Slope Calculation</h4>
            <p>
                $$
                m = \frac{y_2 - y_1}{x_2 - x_1}
                = \frac{35 - 0}{25 - 0}
                = \frac{35}{25}
                = 1.4
                $$
            </p>
        </article>

        <article>
            <h4>(b) Cohen–Sutherland Clipping Steps</h4>

            <p><strong>Step 1:</strong> $P_1$ has code 5 (Left + Bottom).</p>
            <p>Clip against the <strong>Left boundary</strong> first: $x = 5$.</p>

            <p>Intersection formula:</p>
            <p>
                $$
                y = y_1 + m(x_{clip} - x_1)
                $$
            </p>

            <p>
                $$
                y = 0 + 1.4(5 - 0) = 7
                $$
            </p>

            <p>New point:</p>
            <p>$P_1' = (5, 7)$</p>
            <p>This point lies inside the window → region code = 0.</p>

            <hr />

            <p><strong>Step 2:</strong> $P_2$ has code 10 (Top + Right).</p>
            <p>First try clipping against the <strong>Top boundary</strong>: $y = 30$.</p>

            <p>
                $$
                x = x_2 + \frac{y_{clip} - y_2}{m}
                = 25 + \frac{30 - 35}{1.4}
                = 25 - 3.5714
                = 21.4286
                $$
            </p>

            <p>This $x$ value is outside the window $(>20)$, so clipping with Top is invalid.</p>

            <p>Now clip against the <strong>Right boundary</strong>: $x = 20$.</p>

            <p>
                $$
                y = y_2 + m(x_{clip} - x_2)
                = 35 + 1.4(20 - 25)
                = 35 - 7
                = 28
                $$
            </p>

            <p>New point:</p>
            <p>$P_2' = (20, 28)$</p>
            <p>This point lies inside the window → region code = 0.</p>
        </article>

        <article>
            <h4>(c) Intersection Points</h4>
            <ul>
                <li><strong>With left boundary ($x=5$):</strong> $(5, 7)$</li>
                <li><strong>With right boundary ($x=20$):</strong> $(20, 28)$</li>
            </ul>
        </article>

        <article>
            <h4>(d) Final Accepted Line</h4>
            <p>
                <strong>Final clipped line segment:</strong><br />
                $[(5,\;7)\;\text{to}\;(20,\;28)]$
            </p>
        </article>

        <article>
            <h3>COHEN–SUTHERLAND LINE CLIPPING — SOLVED NUMERICAL (Q5)</h3>
        </article>

        <article>
            <h4>Problem Statement</h4>
            <p><strong>Line Segment:</strong></p>
            <p>$P_1 = (8,25),\; P_2 = (40,5)$</p>

            <p><strong>Clipping Window:</strong></p>
            <p>$x_{min}=10,\; y_{min}=10,\; x_{max}=30,\; y_{max}=20$</p>
        </article>

        <article>
            <h4>(a) Region Codes</h4>
            <p>Cohen–Sutherland outcode bit convention:</p>
            <ul>
                <li>Left = 0001 (1)</li>
                <li>Right = 0010 (2)</li>
                <li>Bottom = 0100 (4)</li>
                <li>Top = 1000 (8)</li>
            </ul>

            <p><strong>For $P_1(8,25)$:</strong></p>
            <ul>
                <li>$x < 10$ → Left=1</li>
                <li>$y > 20$ → Top = 8</li>
            </ul>
            <p>Region code = $1001_2 = 9$</p>

            <p><strong>For $P_2(40,5)$:</strong></p>
            <ul>
                <li>$x > 30$ → Right = 2</li>
                <li>$y < 10$ → Bottom=4</li>
            </ul>
            <p>Region code = $0110_2 = 6$</p>
        </article>

        <article>
            <h4>Slope Calculation</h4>
            <p>
                $$
                m = \frac{y_2 - y_1}{x_2 - x_1}
                = \frac{5 - 25}{40 - 8}
                = \frac{-20}{32}
                = -\frac{5}{8}
                = -0.625
                $$
            </p>
        </article>

        <article>
            <h4>(b) Step-by-Step Clipping</h4>

            <p><strong>Step 1:</strong> $P_1$ has code 9 (Left + Top).</p>
            <p>Clip against the <strong>Left boundary</strong> first: $x = 10$.</p>

            <p>
                $$
                y = y_1 + m(x_{clip} - x_1)
                = 25 + (-0.625)(10 - 8)
                = 25 - 1.25
                = 23.75
                $$
            </p>

            <p>New point:</p>
            <p>$P_1' = (10, 23.75)$</p>
            <p>This point is still above the window ($y > 20$) → new code = $1000_2$ (Top).</p>

            <hr />

            <p><strong>Step 2:</strong> Clip this point against the <strong>Top boundary</strong>: $y = 20$.</p>

            <p>
                $$
                x = x_1' + \frac{y_{clip} - y_1'}{m}
                = 10 + \frac{20 - 23.75}{-0.625}
                = 10 + \frac{-3.75}{-0.625}
                = 10 + 6
                = 16
                $$
            </p>

            <p>New point:</p>
            <p>$P_1'' = (16, 20)$</p>
            <p>This point lies inside the window → region code = 0.</p>

            <hr />

            <p><strong>Step 3:</strong> $P_2$ has code 6 (Right + Bottom).</p>
            <p>Clip against the <strong>Right boundary</strong> first: $x = 30$.</p>

            <p>
                $$
                y = y_2 + m(x_{clip} - x_2)
                = 5 + (-0.625)(30 - 40)
                = 5 + 6.25
                = 11.25
                $$
            </p>

            <p>New point:</p>
            <p>$P_2' = (30, 11.25)$</p>
            <p>This point lies inside the window → region code = 0.</p>
        </article>

        <article>
            <h4>(c) Intersection with Right & Bottom Boundaries</h4>
            <ul>
                <li><strong>Right boundary ($x=30$):</strong> $(30, 11.25)$</li>
                <li><strong>Bottom boundary:</strong> Not required in final result (right clipping produced valid point)</li>
            </ul>
        </article>

        <article>
            <h4>(d) Final Clipped Segment</h4>
            <p>
                <strong>Final visible line segment:</strong><br />
                $[(16,\;20)\;\text{to}\;(30,\;11.25)]$
            </p>
        </article>






        <article>
            <h3>Semester Recap</h3>
            <ul>
                <li><strong>Graphics Pipeline Stages</strong>: Modeling \(\rightarrow\) Transformation \(\rightarrow\) Lighting \(\rightarrow\) Projection \(\rightarrow\) Clipping \(\rightarrow\) Rasterization \(\rightarrow\) Display.</li>
                <li><strong>Tweening</strong>: Automatically generating intermediate frames between keyframes to create smooth motion (in-betweening).</li>
                <li><strong>Homogeneous Coordinates</strong>: Using \((x, y, 1)\) for 2D and \((x, y, z, 1)\) for 3D to represent translation as matrix multiplication.</li>
                <li><strong>Matrix Multiplication Rule</strong>: Non-commutative (\(A \cdot B \ne B \cdot A\)); order matters (apply Right-to-Left: \(T \cdot R \cdot S\)).</li>
                <li><strong>Z-Buffer (Depth Buffer)</strong>: Stores depth (\(z\)) of each pixel; if \(z_{\text{new}} < z_{\text{stored}}\), pixel is updated (closer object obscures farther).</li>
                <li><strong>A-Buffer</strong>: Stores a list of fragments per pixel to handle transparency and anti-aliasing.</li>
                <li><strong>Perspective Projection</strong>: All projectors meet at a Center of Projection (COP); creates depth (objects shrink with distance).</li>
                <li><strong>Parallel Projection</strong>: Projectors are parallel (e.g., Orthographic); preserves exact dimensions/scale interactions.</li>
                <li><strong>Cohen-Sutherland Codes</strong>: Top (1000), Bottom (0100), Right (0010), Left (0001); used for trivial accept/reject tests.</li>
                <li><strong>Animation Types</strong>: Keyframe (interpolation), Procedural (physics/rules), Motion Capture (real-world sensors).</li>
            </ul>
        </article>
    </main>

    <script> copyright("all"); </script>

</body>

</html>