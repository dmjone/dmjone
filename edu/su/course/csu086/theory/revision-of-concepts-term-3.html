<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>

        <title>Revision of Concepts - Term 3 - CSU086 - Shoolini U</title>
        <meta name="description" content="Comprehensive revision notes covering compiler design concepts for Term 3, including compiler phases, lexical and syntax analysis, intermediate code generation, optimization techniques, parsing methods, syntax‐directed translation, code generation strategies, and core data structures used in compilers.">

        <script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "TechArticle",
  "headline": "Revision of Concepts - Term 3",
  "description": "Comprehensive revision notes covering compiler design concepts for Term 3, including compiler phases, lexical and syntax analysis, intermediate code generation, optimization techniques, parsing methods, syntax‐directed translation, code generation strategies, and core data structures used in compilers.",
  "dateModified": "2025-05-04",
  "author": [
    {
      "@type": "Person",
      "name": "Divya Mohan",
      "url": "https://dmj.one/resume/",
      "sameAs": [
        "https://www.credly.com/users/divyamohan1993",
        "https://www.linkedin.com/in/divyamohan1993/",
        "https://hackerrank.com/divyamohan1993",
        "https://www.coursera.org/learner/divyamohan1993"
      ]
    }
  ],
  "publisher": {
    "@type": "EducationalOrganization",
    "name": "dmj.one",
    "url": "https://dmj.one"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://dmj.one/edu/su/course/csu086/theory/revision-of-concepts-term-3"
  },
  "keywords": [
    "Compiler Design",
    "Lexical Analysis",
    "Syntax Analysis",
    "Semantic Analysis",
    "Intermediate Code Generation",
    "Code Optimization",
    "Syntax Directed Translation",
    "Three Address Code",
    "Quadruples",
    "Triples",
    "Control Flow Graph",
    "Basic Blocks",
    "Directed Acyclic Graph",
    "Loop Optimization",
    "Register Allocation",
    "Context-Free Grammar"
  ],
  "articleSection": [
    "Compilers and Translators",
    "Phases of the Compiler",
    "Lexical Analysis (Scanner)",
    "Syntax Analysis (Parsing)",
    "Semantic Analysis",
    "Intermediate Code Generation",
    "Code Optimization",
    "Code Generation",
    "Symbol Table",
    "Error Handling in Compiler",
    "Syntax Directed Translation",
    "Syntax Directed Program Evaluation",
    "Syntax Trees",
    "Three Address Code",
    "Quadruples in Intermediate Code",
    "Triples in Intermediate Code",
    "Translation of Assignment Statements",
    "Basic Blocks and Flow Graphs",
    "Directed Acyclic Graph (DAG)",
    "Induction Variable Elimination",
    "Common Sub-Expression Elimination",
    "Loop Unrolling",
    "Loop Jamming (Fusion)",
    "Peephole Optimization",
    "Issues in Code Generator Design",
    "A Simple Code Generator",
    "Register Allocation and Assignment",
    "Context-Free Grammar",
    "Parser Generators (YACC)"
  ],
  "isAccessibleForFree": true,
  "inLanguage": "en-US",
  "license": "https://www.gnu.org/licenses/agpl-3.0.en.html"
}
</script>


        <meta name="author" content="Divya Mohan">
        <meta name="robots" content="index, follow">

        <!-- Open Graph for Social Media -->
        <meta property="og:image" content="/logo.png">
        <meta property="og:type" content="article">

        <!-- Twitter Cards -->
        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@divyamohan1993">
        <meta name="twitter:creator" content="@divyamohan1993">
        <meta name="twitter:image" content="/logo.png">

        <!-- Mobile Responsiveness -->
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                renderMathInElement(document.body, {
                    // customised options
                    // • auto-render specific keys, e.g.:
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\(', right: '\\)', display: false },
                        { left: '\\[', right: '\\]', display: true }
                    ],
                    // • rendering keys, e.g.:
                    throwOnError: false
                });
            });
        </script> -->

        <!-- <style>
            main ul {
                list-style-type: none;
                padding: 0;
                margin: 0;
            }

            main ul li {
                margin: 0;
                padding: 0;
            }
        </style> -->

        <style>
            @media screen {
                h3 {
                    color: red;
                    text-transform: uppercase;
                }
            }
        </style>




    </head>

    <body>

        <script> header_author("dm"); </script>

        <main>
            <article class="agen-tableofcontents">
                <h2 class="text-center">
                    Revision of Concepts - Term 3
                </h2>
                <div class="d-none contentdate">2025, May 4</div>
            </article>

            <article class="d-none">
                <div class="mt-3 d-flex flex-wrap gap-2 justify-content-center">
                    <a href="first-follow-leftfactoring-parsetable" target="_blank" class="btn btn-outline-primary d-flex align-items-center gap-2">
                        <i class="bi bi-book"></i> Revise Examples
                    </a>
                    <a href="term-2-set-1" target="_blank" class="btn btn-outline-warning d-flex align-items-center gap-2">
                        <i class="bi bi-journal-text"></i> Term 2 - Set 1
                    </a>
                    <a href="term-2-set-2" target="_blank" class="btn btn-outline-info d-flex align-items-center gap-2">
                        <i class="bi bi-journal-check"></i> Term 2 - Set 2
                    </a>
                    <a href="term-2-set-3" target="_blank" class="btn btn-outline-success d-flex align-items-center gap-2">
                        <i class="bi bi-journal-richtext"></i> Term 2 - Set 3
                    </a>
                    <a href="term-2-set-4" target="_blank" class="btn btn-outline-danger d-flex align-items-center gap-2">
                        <i class="bi bi-journal-code"></i> Term 2 - Set 4
                    </a>
                </div>
            </article>

            <article>

                <article>
                    <h3 class="text-center">Compilers and Translators</h3>
                    <p><strong>Compiler</strong> is a program that translates high-level language (like C, Java) into machine code (binary) in one go, so the CPU can execute it.</p>
                    <p><strong>Translator</strong> is a general term for any software that converts code from one language to another (e.g., compiler, interpreter, assembler).</p>
                </article>

                <article>
                    <h4>Types of Translators</h4>
                    <ul>
                        <li><strong>Compiler</strong>: Converts entire program to machine code <em>before</em> execution. Example: C compiler.</li>
                        <li><strong>Interpreter</strong>: Translates and runs code <em>line by line</em>. Slower than compiler. Example: Python interpreter.</li>
                        <li><strong>Assembler</strong>: Converts assembly language to machine code. One-to-one translation.</li>
                        <li><strong>Preprocessor</strong>: Handles macro substitution and file inclusion <em>before</em> actual compilation. Example: <code>#include</code> in C.</li>
                    </ul>
                </article>

                <article>
                    <h4>Why Compiler is Important?</h4>
                    <ul>
                        <li>Checks for <strong>syntax errors</strong>.</li>
                        <li>Converts to efficient machine code.</li>
                        <li>Improves <strong>execution speed</strong>.</li>
                        <li>Generates helpful <strong>error messages</strong>.</li>
                    </ul>
                </article>

                <article>
                    <h4>Phases of Compiler</h4>
                    <p>(Just name them if time is less)</p>
                    <ul>
                        <li>Lexical Analysis</li>
                        <li>Syntax Analysis</li>
                        <li>Semantic Analysis</li>
                        <li>Intermediate Code Generation</li>
                        <li>Code Optimization</li>
                        <li>Code Generation</li>
                        <li>Error Handling</li>
                    </ul>
                </article>

                <article>
                    <h4>One-Line Summary</h4>
                    <p>A compiler is a translator that converts the entire high-level program into machine code, enabling fast and efficient execution.</p>
                </article>

            </article>
            <article>
                <article>
                    <h3 class="text-center">Phases of the Compiler</h3>
                    <p>A compiler works in multiple phases, each handling a specific task to convert high-level code into machine code.</p>
                </article>

                <article>
                    <h4>Lexical Analysis (Scanner)</h4>
                    <ul>
                        <li>Breaks code into <strong>tokens</strong> (keywords, identifiers, etc.)</li>
                        <li>Removes <strong>whitespace</strong> and <strong>comments</strong></li>
                        <li>Uses <strong>finite automata</strong></li>
                        <li>Example: <code>int a = 5;</code> → <code>int</code>, <code>a</code>, <code>=</code>, <code>5</code>, <code>;</code></li>
                    </ul>
                </article>

                <article>
                    <h4>Syntax Analysis (Parser)</h4>
                    <ul>
                        <li>Checks <strong>grammar</strong> using <strong>CFG (Context-Free Grammar)</strong></li>
                        <li>Builds <strong>parse tree</strong></li>
                        <li>Detects syntax errors like missing <code>)</code> or <code>{}</code></li>
                    </ul>
                </article>

                <article>
                    <h4>Semantic Analysis</h4>
                    <ul>
                        <li>Checks <strong>meaning</strong> of the code (e.g., type checking)</li>
                        <li>Ensures variables are <strong>declared before use</strong></li>
                        <li>Builds <strong>symbol table</strong></li>
                    </ul>
                </article>

                <article>
                    <h4>Intermediate Code Generation</h4>
                    <ul>
                        <li>Converts code to an <strong>intermediate form</strong></li>
                        <li>Easy to optimize and translate to machine code</li>
                        <li>Example: Three-address code like <code>t1 = a + b</code></li>
                    </ul>
                </article>

                <article>
                    <h4>Code Optimization</h4>
                    <ul>
                        <li>Improves intermediate code to make it <strong>faster</strong> or <strong>smaller</strong></li>
                        <li>Example: Removes <strong>common subexpressions</strong>, <strong>dead code</strong></li>
                    </ul>
                </article>

                <article>
                    <h4>Code Generation</h4>
                    <ul>
                        <li>Converts optimized code to <strong>machine code</strong></li>
                        <li>Assigns <strong>registers</strong>, <strong>memory locations</strong></li>
                        <li>Final executable code is produced</li>
                    </ul>
                </article>

                <article>
                    <h4>Error Handling</h4>
                    <ul>
                        <li>Reports and recovers from <strong>errors</strong> in all phases</li>
                        <li>Types: <strong>Lexical</strong>, <strong>Syntax</strong>, <strong>Semantic</strong>, <strong>Runtime</strong></li>
                    </ul>
                </article>

                <article>
                    <h4>One-Line Summary</h4>
                    <p>The compiler processes source code through lexical, syntax, semantic analysis, code generation and optimization to produce efficient machine code.</p>
                </article>
            </article>
            <article>
                <article>
                    <h3 class="text-center">Lexical Analysis (Scanner)</h3>
                    <ul>
                        <li>It is the <strong>first phase</strong> of a compiler.</li>
                        <li>It <strong>reads source code</strong> character by character and converts it into <strong>tokens</strong>.</li>
                        <li>A <strong>token</strong> is the smallest unit like <strong>keywords, identifiers, operators, constants</strong>.</li>
                        <li>Removes <strong>whitespaces</strong> and <strong>comments</strong>.</li>
                    </ul>
                </article>

                <article>
                    <h4>Main Tasks</h4>
                    <ul>
                        <li><strong>Tokenization</strong> – splits code into tokens.<br>
                            Example: <code>int x = 10;</code> → <code>int</code>, <code>x</code>, <code>=</code>, <code>10</code>, <code>;</code>
                        </li>
                        <li><strong>Lexeme</strong> – actual text matched by a token.<br>
                            Example: In token <code>id</code>, lexeme is <code>x</code>
                        </li>
                        <li><strong>Pattern</strong> – rule to recognize lexeme (defined using <strong>regular expressions</strong>).</li>
                        <li><strong>Symbol Table Creation</strong> – stores variables, constants, function names, etc.</li>
                        <li><strong>Error Reporting</strong> – detects invalid characters or symbols.</li>
                    </ul>
                </article>

                <article>
                    <h4>Tool Used</h4>
                    <ul>
                        <li><strong>Finite Automata</strong> to recognize tokens using <strong>regular expressions</strong>.</li>
                    </ul>
                </article>

                <article>
                    <h4>One-Line Summary</h4>
                    <p>Lexical analysis converts source code into tokens, removes irrelevant data, and helps build the foundation for parsing.</p>
                </article>
            </article>
            <article>

                <article>
                    <h3 class="text-center">Syntax Analysis (Parsing)</h3>
                    <ul>
                        <li>It is the <strong>second phase</strong> of the compiler.</li>
                        <li>Takes tokens from the lexical analyzer and checks their <strong>grammar</strong> using <strong>Context-Free Grammar (CFG)</strong>.</li>
                        <li>Builds a <strong>parse tree</strong> or <strong>syntax tree</strong>.</li>
                        <li>Detects <strong>syntax errors</strong> like missing brackets, semicolons, etc.</li>
                    </ul>
                </article>

                <article>
                    <h4>Main Tasks</h4>
                    <ul>
                        <li><strong>Check grammatical structure</strong> of code.<br>
                            Example: Validates if <code>if (x > 0) { x = x - 1; }</code> is syntactically correct.
                        </li>
                        <li><strong>Generate Parse Tree</strong> – hierarchical structure representing the syntax.</li>
                        <li><strong>Error Handling</strong> – identifies and recovers from syntax errors.</li>
                    </ul>
                </article>

                <article>
                    <h4>Tools Used</h4>
                    <ul>
                        <li><strong>Top-Down Parsers</strong>: Recursive Descent, Predictive Parser</li>
                        <li><strong>Bottom-Up Parsers</strong>: Shift-Reduce, LR Parser</li>
                    </ul>
                </article>

                <article>
                    <h4>Parse Tree Example</h4>
                    <p>For the expression <code>a + b * c</code>, the parse tree enforces that <code>*</code> has higher precedence than <code>+</code>, yielding:</p>
                    <pre class="">.
      +
     / \
    a   *
       / \
      b   c
  </pre>
                </article>

                <article>
                    <h4>One-Line Summary</h4>
                    <p>Syntax analysis verifies the grammar of the program using CFG and constructs a parse tree to represent its structure.</p>
                </article>
            </article>
            <article>
                <article>
                    <h3 class="text-center">Intermediate Code Generation</h3>
                    <p>It is the <strong>4th phase</strong> of the compiler.</p>
                    <p>Converts high-level source code into an <strong>intermediate representation (IR)</strong>.</p>
                    <p>IR is <strong>machine-independent</strong>, easy to optimize and translate to final machine code.</p>
                </article>

                <article>
                    <h4>Purpose</h4>
                    <ul>
                        <li>Acts as a <strong>bridge</strong> between front-end (syntax, semantics) and back-end (machine code).</li>
                        <li>Makes code <strong>portable</strong> across architectures.</li>
                        <li>Simplifies <strong>optimization</strong>.</li>
                    </ul>
                </article>

                <article>
                    <h4>Common Forms of IR</h4>
                    <p><strong>Three Address Code (TAC)</strong> – uses temporary variables.</p>
                    <pre><code class="">t1 = b * c  
t2 = a + t1</code></pre>
                    <p>2. <strong>Quadruples</strong> – four fields: (operator, arg1, arg2, result)</p>
                    <pre><code class="">(+ , a , b , t1)</code></pre>
                    <p>3. <strong>Triples</strong> – similar to quadruples but reference previous instructions by position</p>
                    <pre><code class="">(+, 0, 1)  <!-- 0 and 1 refer to earlier instructions --></code></pre>
                </article>

                <article>
                    <h4>One-Line Summary</h4>
                    <p>Intermediate Code Generation creates a portable and optimized form of the program using Three Address Code, Quadruples, or Triples.</p>
                </article>

            </article>
            <article>


                <article>
                    <h3 class="text-center">Code Optimization</h3>
                    <p>It is the <strong>5th phase</strong> of the compiler.</p>
                    <p>Improves the <strong>intermediate code</strong> to make the final machine code <strong>faster</strong> or <strong>smaller</strong>, without changing the output.</p>
                </article>

                <article>
                    <h4>Types of Optimization</h4>
                    <ul>
                        <li><strong>Machine-Independent Optimization</strong> (before code generation)
                            <p>Based on code logic, not hardware.</p>
                        </li>
                        <li><strong>Machine-Dependent Optimization</strong> (after code generation)
                            <p>Based on CPU architecture, registers, etc.</p>
                        </li>
                    </ul>
                </article>

                <article>
                    <h4>Common Optimization Techniques</h4>
                    <ul>
                        <li><strong>Constant Folding</strong>
                            <p>Pre-calculates constant expressions.<br>
                                <code>x = 3 * 2 → x = 6</code>
                            </p>
                        </li>
                        <li><strong>Dead Code Elimination</strong>
                            <p>Removes unreachable or unused code.<br>
                                <code>if (false) { code } → Removed</code>
                            </p>
                        </li>
                        <li><strong>Common Subexpression Elimination</strong>
                            <p>Reuses repeated calculations.<br>
                                <code>a = b + c; d = b + c; → reuse b + c</code>
                            </p>
                        </li>
                        <li><strong>Loop Optimization</strong>
                            <p>Speeds up loops:</p>
                            <ul>
                                <li><strong>Loop Unrolling</strong> – repeats body to reduce jump</li>
                                <li><strong>Loop Invariant Code Motion</strong> – move code outside loop</li>
                                <li><strong>Induction Variable Elimination</strong> – remove redundant loop variables</li>
                                <li><strong>Loop Jamming</strong> – merge loops</li>
                            </ul>
                        </li>
                        <li><strong>Peephole Optimization</strong>
                            <p>Replaces small patterns with efficient ones at instruction level.</p>
                        </li>
                    </ul>
                </article>

                <article>
                    <h4>One-Line Summary</h4>
                    <p>Optimization improves code speed and reduces size using techniques like dead code removal, loop optimizations, and common subexpression elimination.</p>
                </article>

            </article>
            <article>


                <article>
                    <h3 class="text-center">Code Generation</h3>
                    <p>It is the <strong>6th phase</strong> of the compiler.</p>
                    <p>Converts optimized intermediate code into <strong>target machine code</strong> (assembly or binary).</p>
                    <p>Final phase before execution.</p>
                </article>

                <article>
                    <h4>Main Tasks</h4>
                    <ul>
                        <li><strong>Instruction Selection</strong>: Choose correct machine instructions for each operation.</li>
                        <li><strong>Register Allocation</strong>: Assign variables to CPU <strong>registers</strong> (faster) or <strong>memory</strong> (slower) based on availability.</li>
                        <li><strong>Instruction Scheduling</strong>: Reorder instructions to reduce delays (pipeline stalls, cache efficiency).</li>
                        <li><strong>Handling Variables</strong>: Assign memory addresses or registers for variables.</li>
                    </ul>
                </article>

                <article>
                    <h4>Example</h4>
                    <pre><code class="">t1 = a + b  
t2 = t1 * c</code></pre>
                    <p>Possible x86-style Assembly:</p>
                    <pre><code class="">MOV R1, [a]  
ADD R1, [b]  
MUL R1, [c]  
MOV [t2], R1</code></pre>
                </article>

                <article>
                    <h4>Challenges</h4>
                    <ul>
                        <li>Use <strong>minimal instructions</strong> and <strong>limited registers</strong>.</li>
                        <li>Maintain <strong>correctness</strong> while maximizing <strong>efficiency</strong>.</li>
                    </ul>
                </article>

                <article>
                    <h4>One-Line Summary</h4>
                    <p>Code generation translates intermediate code into machine-level instructions using optimal registers and minimal memory operations.</p>
                </article>
            </article>
            <article>
                <article>
                    <h3 class="text-center">Symbol Table</h3>
                    <p>A <strong>data structure</strong> used by the compiler to <strong>store information</strong> about identifiers (variables, functions, etc.).</p>
                    <p>Created and used during <strong>lexical, syntax, and semantic analysis</strong>.</p>
                </article>

                <article>
                    <h4>Stores</h4>
                    <ul>
                        <li><strong>Variable names</strong></li>
                        <li><strong>Function names</strong></li>
                        <li><strong>Data types</strong></li>
                        <li><strong>Memory locations</strong></li>
                        <li><strong>Scope information</strong></li>
                    </ul>
                </article>

                <article>
                    <h4>Purpose</h4>
                    <ol>
                        <li><strong>Quick Lookup</strong> – find info about identifiers</li>
                        <li><strong>Scope Management</strong> – manage local/global variables</li>
                        <li><strong>Type Checking</strong> – verify data types</li>
                        <li><strong>Error Detection</strong> – check for multiple declarations, undeclared use</li>
                    </ol>
                </article>

                <article>
                    <h4>Example Entry</h4>
                    <div class="table-responsive">
                        <table class="table table-bordered table-striped">
                            <thead>
                                <tr>
                                    <th>Name</th>
                                    <th>Type</th>
                                    <th>Scope</th>
                                    <th>Address</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><code>x</code></td>
                                    <td>int</td>
                                    <td>global</td>
                                    <td>1000</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </article>

                <article>
                    <h4>Operations</h4>
                    <ul>
                        <li><strong>Insert()</strong> – add new identifier</li>
                        <li><strong>Lookup()</strong> – search existing identifier</li>
                        <li><strong>Update()</strong> – modify information</li>
                    </ul>
                </article>

                <article>
                    <h4>One-Line Summary</h4>
                    <p>The symbol table stores all identifier details for quick lookup, scope checking, and semantic validation during compilation.</p>
                </article>

            </article>
            <article>


                <article>
                    <h3 class="text-center">Error Handling in Compiler</h3>
                    <p>Every phase of the compiler can detect <strong>errors</strong>. Error handling means detecting, reporting, and <strong>recovering</strong> from these errors so compilation can continue.</p>
                </article>

                <article>
                    <h4>Types of Errors</h4>
                    <ul>
                        <li><strong>Lexical Errors</strong>
                            <p>Invalid token/character.<br>
                                Example: <code>@a = 5;</code></p>
                        </li>
                        <li><strong>Syntax Errors</strong>
                            <p>Violation of grammar rules.<br>
                                Example: Missing <code>)</code> or <code>{</code></p>
                        </li>
                        <li><strong>Semantic Errors</strong>
                            <p>Meaning-related issues.<br>
                                Example: Using an <strong>undeclared variable</strong></p>
                        </li>
                        <li><strong>Logical/Runtime Errors</strong> (not handled by compiler)
                            <p>Example: Division by zero</p>
                        </li>
                    </ul>
                </article>

                <article>
                    <h4>Phases that Handle Errors</h4>
                    <ul>
                        <li><strong>Lexical Analyzer</strong> → Lexical Errors</li>
                        <li><strong>Syntax Analyzer</strong> → Syntax Errors</li>
                        <li><strong>Semantic Analyzer</strong> → Semantic Errors</li>
                    </ul>
                </article>

                <article>
                    <h4>Error Recovery Techniques</h4>
                    <ul>
                        <li><strong>Panic Mode Recovery</strong>
                            <p>Skip input until a safe point (e.g., <code>;</code>). Simple, fast.</p>
                        </li>
                        <li><strong>Phrase-Level Recovery</strong>
                            <p>Replace or insert tokens to fix errors.</p>
                        </li>
                        <li><strong>Error Productions</strong>
                            <p>Extend grammar to handle common mistakes.</p>
                        </li>
                        <li><strong>Global Correction</strong>
                            <p>Tries to fix errors with minimum changes (costly).</p>
                        </li>
                    </ul>
                </article>

                <article>
                    <h4>One-Line Summary</h4>
                    <p>Error handling detects, reports, and recovers from lexical, syntax, and semantic errors using recovery strategies like panic mode and phrase-level fixes.</p>
                </article>

            </article>
            <article>


                <article>
                    <h3 class="text-center">Lexical Analysis: Role of the Lexical Analyzer</h3>
                    <p>The <strong>lexical analyzer</strong> (or <strong>scanner</strong>) is the <strong>first phase</strong> of the compiler. It reads the <strong>source code</strong> character by character and groups it into <strong>tokens</strong>.</p>
                </article>

                <article>
                    <h4>Main Roles</h4>
                    <ul>
                        <li><strong>Tokenization</strong>
                            <p>Converts character stream into <strong>tokens</strong> (e.g., <code>int</code>, <code>=</code>, <code>;</code>). Each token has a <strong>type</strong> and <strong>lexeme</strong>.</p>
                        </li>
                        <li><strong>Remove Whitespace and Comments</strong>
                            <p>Skips irrelevant data not needed for syntax analysis.</p>
                        </li>
                        <li><strong>Error Detection</strong>
                            <p>Detects <strong>invalid characters or symbols</strong> early.</p>
                        </li>
                        <li><strong>Symbol Table Entry</strong>
                            <p>Stores identifiers, constants, etc., into the <strong>symbol table</strong>.</p>
                        </li>
                        <li><strong>Communicates with Parser</strong>
                            <p>Passes a <strong>stream of tokens</strong> to the syntax analyzer.</p>
                        </li>
                        <li><strong>Pattern Matching</strong>
                            <p>Uses <strong>regular expressions</strong> and <strong>finite automata</strong> to recognize token patterns.</p>
                        </li>
                    </ul>
                </article>

                <article>
                    <h4>Example</h4>
                    <p>Source Code: <code>int a = 5;</code></p>
                    <ul>
                        <li><code>int</code> → keyword</li>
                        <li><code>a</code> → identifier</li>
                        <li><code>=</code> → operator</li>
                        <li><code>5</code> → constant</li>
                        <li><code>;</code> → delimiter</li>
                    </ul>
                </article>

                <article>
                    <h4>One-Line Summary</h4>
                    <p>The lexical analyzer converts source code into tokens, removes irrelevant data, detects errors, and passes the token stream to the parser.</p>
                </article>

            </article>
            <article>


                <article>
                    <h3 class="text-center">Tokens in Compiler Design</h3>
                    <p>A <strong>token</strong> is the <strong>smallest meaningful unit</strong> in the source code, identified by the <strong>lexical analyzer</strong>. It is a <strong>pair</strong>: (<em>token type</em>, <em>lexeme</em>).</p>
                </article>

                <article>
                    <h4>Components of a Token</h4>
                    <ul>
                        <li><strong>Token Type</strong> – Category (e.g., keyword, identifier, operator)</li>
                        <li><strong>Lexeme</strong> – Actual string from source code<br>
                            Example: In <code>int a = 5;</code>, <code>int</code> is a token, lexeme is <code>"int"</code>
                        </li>
                    </ul>
                </article>

                <article>
                    <h4>Common Token Types</h4>
                    <div class="table-responsive">
                        <table class="table table-bordered table-striped">
                            <thead>
                                <tr>
                                    <th>Token Type</th>
                                    <th>Example</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Keyword</td>
                                    <td><code>int</code>, <code>if</code></td>
                                </tr>
                                <tr>
                                    <td>Identifier</td>
                                    <td><code>x</code>, <code>count</code></td>
                                </tr>
                                <tr>
                                    <td>Operator</td>
                                    <td><code>+</code>, <code>=</code></td>
                                </tr>
                                <tr>
                                    <td>Constant</td>
                                    <td><code>10</code>, <code>3.14</code></td>
                                </tr>
                                <tr>
                                    <td>Punctuation</td>
                                    <td><code>;</code>, <code>,</code></td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </article>

                <article>
                    <h4>Example</h4>
                    <p>For the code <code>float total = 100.5;</code> Tokens generated:</p>
                    <ul>
                        <li><code>float</code> → keyword</li>
                        <li><code>total</code> → identifier</li>
                        <li><code>=</code> → operator</li>
                        <li><code>100.5</code> → constant</li>
                        <li><code>;</code> → punctuation</li>
                    </ul>
                </article>

                <article>
                    <h4>One-Line Summary</h4>
                    <p>Tokens are the basic building blocks of source code, categorized by type and used by the compiler to understand program structure.</p>
                </article>

            </article>
            <article>


                <article>
                    <h3 class="text-center">Pattern in Compiler Design</h3>
                    <p>A <strong>pattern</strong> is a rule or description that defines the <strong>structure of a token</strong>. It tells the <strong>lexical analyzer</strong> what a valid token <strong>looks like</strong>.</p>
                </article>

                <article>
                    <h4>Definition</h4>
                    <blockquote>
                        A pattern is a set of <strong>strings</strong> that belong to a <strong>token class</strong>, usually described using <strong>regular expressions</strong>.
                    </blockquote>
                </article>

                <article>
                    <h4>Example Patterns</h4>
                    <div class="table-responsive">
                        <table class="table table-bordered table-striped">
                            <thead>
                                <tr>
                                    <th>Token Type</th>
                                    <th>Pattern</th>
                                    <th>Example Lexeme</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Identifier</td>
                                    <td><code>[a-zA-Z][a-zA-Z0-9]*</code></td>
                                    <td><code>sum1</code>, <code>total</code></td>
                                </tr>
                                <tr>
                                    <td>Integer</td>
                                    <td><code>[0-9]+</code></td>
                                    <td><code>10</code>, <code>456</code></td>
                                </tr>
                                <tr>
                                    <td>Keyword</td>
                                    <td>Exact match (e.g., <code>int</code>)</td>
                                    <td><code>int</code>, <code>if</code></td>
                                </tr>
                                <tr>
                                    <td>Operator</td>
                                    <td><code>[+\-*/]</code></td>
                                    <td><code>+</code>, <code>*</code></td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </article>

                <article>
                    <h4>Relation</h4>
                    <ul>
                        <li><strong>Lexeme</strong>: Actual input string (e.g., <code>abc123</code>).</li>
                        <li><strong>Pattern</strong>: Rule to match (e.g., <code>[a-zA-Z][a-zA-Z0-9]*</code>).</li>
                        <li><strong>Token</strong>: Final output (<code>&lt;id, abc123&gt;</code>).</li>
                    </ul>
                </article>

                <article>
                    <h4>One-Line Summary</h4>
                    <p>A pattern defines the structure of valid tokens using rules like regular expressions, helping the lexical analyzer recognize them.</p>
                </article>

            </article>
            <article>


                <article>
                    <h3 class="text-center">Lexemes in Compiler Design</h3>
                    <p>A <strong>lexeme</strong> is the <strong>actual sequence of characters</strong> in the source code that <strong>matches a pattern</strong> and forms a <strong>token</strong>.</p>
                </article>

                <article>
                    <h4>Definition</h4>
                    <blockquote>
                        A lexeme is the <strong>actual text</strong> (substring) that matches a <strong>token pattern</strong> and is extracted by the <strong>lexical analyzer</strong>.
                    </blockquote>
                </article>

                <article>
                    <h4>Example</h4>
                    <p>For the code: <code>int x = 5;</code></p>
                    <ul>
                        <li><code>int</code> → token type: <strong>keyword</strong>, lexeme: <code>"int"</code></li>
                        <li><code>x</code> → token type: <strong>identifier</strong>, lexeme: <code>"x"</code></li>
                        <li><code>5</code> → token type: <strong>constant</strong>, lexeme: <code>"5"</code></li>
                        <li><code>=</code> → token type: <strong>operator</strong>, lexeme: <code>"="</code></li>
                        <li><code>;</code> → token type: <strong>delimiter</strong>, lexeme: <code>";"</code></li>
                    </ul>
                </article>

                <article>
                    <h4>Relation to Token and Pattern</h4>
                    <ul>
                        <li><strong>Pattern</strong>: Rule for matching (e.g., <code>[a-zA-Z]+</code>)</li>
                        <li><strong>Lexeme</strong>: Actual match in source (e.g., <code>x</code>)</li>
                        <li><strong>Token</strong>: <code>&lt;identifier, x&gt;</code></li>
                    </ul>
                </article>

                <article>
                    <h4>One-Line Summary</h4>
                    <p>A lexeme is the exact text from the source code that matches a token pattern and is used to create a token.</p>
                </article>

            </article>
            <article>


                <article>
                    <h3 class="text-center">What is a Parser?</h3>
                    <p>A <strong>parser</strong> is a component of the compiler that checks whether the given input string (program) follows the grammar of the programming language. It takes <strong>tokens from the lexical analyzer</strong> and builds a <strong>parse tree</strong> or <strong>syntax tree</strong>.</p>
                </article>

                <article>
                    <h4>Types of Parsers</h4>
                    <p>There are two main categories:</p>
                </article>

                <article>
                    <h4>Top-Down Parsers</h4>
                    <p>They start from the <strong>start symbol</strong> and try to derive the <strong>input string</strong>.</p>
                    <ul>
                        <li><strong>Recursive Descent Parser</strong>
                            <ul>
                                <li>Uses recursive functions</li>
                                <li>May require backtracking</li>
                            </ul>
                        </li>
                        <li><strong>Predictive Parser (LL(1))</strong>
                            <ul>
                                <li>No backtracking</li>
                                <li>Uses a <strong>lookahead symbol</strong> and parsing table</li>
                            </ul>
                        </li>
                    </ul>
                </article>

                <article>
                    <h4>Bottom-Up Parsers</h4>
                    <p>They start from the <strong>input string</strong> and try to reduce it to the <strong>start symbol</strong>.</p>
                    <ul>
                        <li><strong>LR(0) Parser</strong> – uses states and parsing table</li>
                        <li><strong>SLR Parser</strong> – uses FOLLOW sets</li>
                        <li><strong>LALR Parser</strong> – combines LR(1) power with smaller table</li>
                        <li><strong>Canonical LR(1) Parser</strong> – most powerful, uses full lookahead</li>
                    </ul>
                </article>

                <article>
                    <h4>Comparison Table</h4>
                    <div class="table-responsive">
                        <table class="table table-bordered table-striped">
                            <thead>
                                <tr>
                                    <th>Type</th>
                                    <th>Direction</th>
                                    <th>Derivation</th>
                                    <th>Examples</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Top-Down</td>
                                    <td>Left → Right</td>
                                    <td>Leftmost</td>
                                    <td>Recursive Descent, LL(1)</td>
                                </tr>
                                <tr>
                                    <td>Bottom-Up</td>
                                    <td>Left → Right</td>
                                    <td>Rightmost (in reverse)</td>
                                    <td>LR(0), SLR, LALR, LR(1)</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </article>

                <article>
                    <h4>One-Line Conclusion</h4>
                    <p>Parsers verify syntax and build program structure: <strong>Top-Down</strong> is simpler but limited, <strong>Bottom-Up</strong> is more powerful and used in production compilers.</p>
                </article>

            </article>
            <article>


                <article>
                    <h3 class="text-center">Derivation</h3>
                    <p>Derivation shows how a string is generated from the start symbol of a grammar using production rules.</p>
                </article>

                <article>
                    <h4>Types of Derivation</h4>
                    <ul>
                        <li><strong>Leftmost Derivation</strong>: Replace the leftmost non-terminal first.</li>
                        <li><strong>Rightmost Derivation</strong>: Replace the rightmost non-terminal first.</li>
                    </ul>
                </article>

                <article>
                    <h4>Example Derivation</h4>
                    <p>Grammar:</p>
                    <pre><code class="">S → aSb | ε</code></pre>
                    <p>Derive string <code>aabb</code> (leftmost):</p>
                    <pre><code class="">S → aSb
→ aaSbb
→ aaεbb = aabb</code></pre>
                </article>

                <article>
                    <h3>Parse Tree</h3>
                    <p>A parse tree is a tree diagram showing how a string is derived using grammar rules.</p>
                </article>

                <article>
                    <h4>Structure of Parse Tree</h4>
                    <ul>
                        <li><strong>Root node</strong>: start symbol.</li>
                        <li><strong>Internal nodes</strong>: non-terminals.</li>
                        <li><strong>Leaf nodes</strong>: terminals or ε.</li>
                        <li>Shows the hierarchical structure of the derivation.</li>
                    </ul>
                </article>

                <article>
                    <h4>Example Parse Tree</h4>
                    <p>Grammar:</p>
                    <pre><code class="">S → aSb | ε</code></pre>
                    <p>String: <code>aabb</code></p>
                    <pre><code class="">
        S
      / | \
     a  S  b
        /|\
       a S b
          |
          ε
  </code></pre>
                </article>

                <article>
                    <h3>Difference between Derivation and Parse Tree</h3>
                    <div class="table-responsive">
                        <table class="table table-bordered table-striped">
                            <thead>
                                <tr>
                                    <th>Feature</th>
                                    <th>Derivation</th>
                                    <th>Parse Tree</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Output</td>
                                    <td>Sequence of steps</td>
                                    <td>Tree structure</td>
                                </tr>
                                <tr>
                                    <td>Type</td>
                                    <td>Text format</td>
                                    <td>Graphical format</td>
                                </tr>
                                <tr>
                                    <td>Use</td>
                                    <td>Shows order of rule use</td>
                                    <td>Shows structure clearly</td>
                                </tr>
                                <tr>
                                    <td>Variants</td>
                                    <td>Leftmost / Rightmost</td>
                                    <td>One tree per derivation</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </article>

            </article>
            <article>


                <article>
                    <h3 class="text-center">Ambiguity in Grammar</h3>
                    <p>A grammar is <strong>ambiguous</strong> if there exists <strong>more than one parse tree</strong> or <strong>more than one leftmost/rightmost derivation</strong> for the <strong>same input string</strong>.</p>
                </article>

                <article>
                    <h4>Example</h4>
                    <p>Grammar:</p>
                    <pre><code class="">E → E + E | E * E | (E) | id</code></pre>
                    <p>String: <code>id + id * id</code></p>
                    <p>Two parse trees are possible:</p>
                    <ol>
                        <li><code>(id + id) * id</code> (addition first)</li>
                        <li><code>id + (id * id)</code> (multiplication first)</li>
                    </ol>
                    <p>Both interpretations yield different meanings ⇒ grammar is <strong>ambiguous</strong>.</p>
                </article>

                <article>
                    <h4>Why Ambiguity is Bad?</h4>
                    <ul>
                        <li>Compiler <strong>gets confused</strong>.</li>
                        <li>No <strong>unique meaning</strong> to expressions.</li>
                        <li>Cannot <strong>generate correct intermediate code</strong>.</li>
                    </ul>
                </article>

                <article>
                    <h4>Solution</h4>
                    <p>Remove ambiguity by rewriting the grammar using precedence and associativity rules.</p>
                    <p>Unambiguous grammar for arithmetic expressions:</p>
                    <pre><code class="">E → E + T | T  
T → T * F | F  
F → (E) | id</code></pre>
                    <p>This ensures <code>*</code> has higher precedence than <code>+</code> and eliminates ambiguity.</p>
                </article>

            </article>
            <article>


                <article>
                    <h3 class="text-center">Bottom-Up Parser: Shift-Reduce Parsing</h3>
                    <p>Bottom-up parser starts from the input and tries to reduce it to the start symbol using grammar rules. Shift-Reduce Parsing is the most common bottom-up parsing method.</p>
                </article>

                <article>
                    <h4>Four Operations</h4>
                    <ul>
                        <li><strong>Shift</strong>: Move symbol from input to stack.</li>
                        <li><strong>Reduce</strong>: Replace stack contents using a grammar rule (e.g., <code>E → E + E</code>).</li>
                        <li><strong>Accept</strong>: Input is parsed successfully.</li>
                        <li><strong>Error</strong>: Input string cannot be parsed.</li>
                    </ul>
                </article>

                <article>
                    <h4>Example</h4>
                    <p>Grammar:</p>
                    <pre><code class="">E → E + E  
E → id</code></pre>
                    <p>Input: <code>id + id</code></p>
                    <div class="table-responsive">
                        <table class="table table-bordered table-striped">
                            <thead>
                                <tr>
                                    <th>Stack</th>
                                    <th>Input</th>
                                    <th>Action</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>―</td>
                                    <td><code>id + id</code></td>
                                    <td>Shift</td>
                                </tr>
                                <tr>
                                    <td><code>id</code></td>
                                    <td><code>+ id</code></td>
                                    <td>Reduce (<code>E → id</code>)</td>
                                </tr>
                                <tr>
                                    <td><code>E</code></td>
                                    <td><code>+ id</code></td>
                                    <td>Shift</td>
                                </tr>
                                <tr>
                                    <td><code>E +</code></td>
                                    <td><code>id</code></td>
                                    <td>Shift</td>
                                </tr>
                                <tr>
                                    <td><code>E + id</code></td>
                                    <td>―</td>
                                    <td>Reduce (<code>E → id</code>)</td>
                                </tr>
                                <tr>
                                    <td><code>E + E</code></td>
                                    <td>―</td>
                                    <td>Reduce (<code>E → E + E</code>)</td>
                                </tr>
                                <tr>
                                    <td><code>E</code></td>
                                    <td>―</td>
                                    <td>Accept</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </article>

                <article>
                    <h4>Notes</h4>
                    <ul>
                        <li>Works <strong>bottom-up</strong>, from leaf to root.</li>
                        <li>Uses a <strong>stack</strong> and <strong>input buffer</strong>.</li>
                        <li>Efficient and widely used in compilers.</li>
                    </ul>
                </article>

            </article>
            <article>


                <article>
                    <h3 class="text-center">Operator Precedence Parsing</h3>
                    <p>It is a <strong>bottom-up parsing</strong> method used for <strong>expressions with operators</strong>. It uses <strong>operator precedence</strong> to decide when to <strong>shift</strong> or <strong>reduce</strong>.</p>
                </article>

                <article>
                    <h4>Conditions</h4>
                    <ul>
                        <li>Grammar must have <strong>no ε-productions</strong>.</li>
                        <li>Grammar must have <strong>no two adjacent non-terminals</strong>.</li>
                    </ul>
                </article>

                <article>
                    <h4>Core Idea</h4>
                    <p>Define <strong>precedence relations</strong> between terminals:</p>
                    <ul>
                        <li><code>a &lt;· b</code> → ‘a’ has <strong>lower precedence</strong>, so <strong>shift</strong>.</li>
                        <li><code>a =· b</code> → <strong>same level</strong>, used for <strong>parentheses</strong>.</li>
                        <li><code>a ·&gt; b</code> → ‘a’ has <strong>higher precedence</strong>, so <strong>reduce</strong>.</li>
                    </ul>
                </article>

                <article>
                    <h4>Operator Precedence Table (Example)</h4>
                    <div class="table-responsive">
                        <table class="table table-bordered table-striped">
                            <thead>
                                <tr>
                                    <th> </th>
                                    <th>+</th>
                                    <th>*</th>
                                    <th>id</th>
                                    <th>(</th>
                                    <th>)</th>
                                    <th>$</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <th>+</th>
                                    <td>&gt;</td>
                                    <td>&lt;</td>
                                    <td>&lt;</td>
                                    <td>&lt;</td>
                                    <td>&gt;</td>
                                    <td>&gt;</td>
                                </tr>
                                <tr>
                                    <th>*</th>
                                    <td>&gt;</td>
                                    <td>&gt;</td>
                                    <td>&lt;</td>
                                    <td>&lt;</td>
                                    <td>&gt;</td>
                                    <td>&gt;</td>
                                </tr>
                                <tr>
                                    <th>id</th>
                                    <td>&gt;</td>
                                    <td>&gt;</td>
                                    <td> </td>
                                    <td> </td>
                                    <td>&gt;</td>
                                    <td>&gt;</td>
                                </tr>
                                <tr>
                                    <th>(</th>
                                    <td>&lt;</td>
                                    <td>&lt;</td>
                                    <td>&lt;</td>
                                    <td>&lt;</td>
                                    <td>=</td>
                                    <td> </td>
                                </tr>
                                <tr>
                                    <th>)</th>
                                    <td>&gt;</td>
                                    <td>&gt;</td>
                                    <td> </td>
                                    <td> </td>
                                    <td>&gt;</td>
                                    <td>&gt;</td>
                                </tr>
                                <tr>
                                    <th>$</th>
                                    <td>&lt;</td>
                                    <td>&lt;</td>
                                    <td>&lt;</td>
                                    <td>&lt;</td>
                                    <td> </td>
                                    <td>A</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </article>

                <article>
                    <h4>Example</h4>
                    <p>Input: <code>id + id * id</code></p>
                    <p>Parser actions based on table:</p>
                    <ol>
                        <li>Shift <code>id</code></li>
                        <li>Shift <code>+</code></li>
                        <li>Shift <code>id</code></li>
                        <li>Shift <code>*</code></li>
                        <li>Shift <code>id</code></li>
                        <li>Reduce <code>id * id</code> first (since <code>* ·&gt; +</code>)</li>
                        <li>Then reduce <code>id + (id * id)</code></li>
                    </ol>
                </article>

                <article>
                    <h4>One-Line Summary</h4>
                    <p>Operator precedence parsing efficiently handles expression parsing by using a precedence table to decide shifts and reduces.</p>
                </article>

            </article>
            <article>


                <article>
                    <h3 class="text-center">Top-Down Parsers: Recursive Descent & Predictive Parser</h3>
                    <p>Top-down parsers start from the start symbol and try to derive the input string using grammar rules.</p>
                </article>

                <article>
                    <h4>Recursive Descent Parser</h4>
                    <p>It is a top-down parser built using a set of recursive functions, one for each non-terminal. It tries to match the input with grammar rules from the start symbol. Backtracking may be needed if the first choice fails.</p>
                    <p>Example Grammar:</p>
                    <pre><code class="">E → T + E | T  
T → id</code></pre>
                    <p>Corresponding functions:</p>
                    <pre><code class="">def E():
    T()
    if next_token == '+':
        match('+')
        E()</code></pre>
                    <ul>
                        <li><strong>Pros</strong>: Simple to implement</li>
                        <li><strong>Cons</strong>: Slow if backtracking happens</li>
                    </ul>
                </article>

                <article>
                    <h4>Predictive Parser</h4>
                    <p>A type of recursive descent parser without backtracking. Uses a lookahead symbol to predict the correct production. Requires LL(1) grammar: no left recursion and grammar must be left-factored.</p>
                    <p>Example Grammar:</p>
                    <pre><code class="">E  → T E'  
E' → + T E' | ε  
T  → id</code></pre>
                    <p>Parser uses a table built from FIRST and FOLLOW sets to decide productions, driving a stack + lookahead mechanism to parse input like <code>id + id</code>.</p>
                </article>

                <article>
                    <h4>Comparison</h4>
                    <div class="table-responsive">
                        <table class="table table-bordered table-striped">
                            <thead>
                                <tr>
                                    <th>Feature</th>
                                    <th>Recursive Descent</th>
                                    <th>Predictive Parser</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Backtracking</td>
                                    <td>Yes</td>
                                    <td>No</td>
                                </tr>
                                <tr>
                                    <td>LL(1) grammar needed?</td>
                                    <td>No</td>
                                    <td>Yes</td>
                                </tr>
                                <tr>
                                    <td>Speed</td>
                                    <td>Slower</td>
                                    <td>Faster</td>
                                </tr>
                                <tr>
                                    <td>Implementation</td>
                                    <td>Recursive functions</td>
                                    <td>Table-driven or code</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </article>

            </article>
            <article>


                <article>
                    <h3 class="text-center">LR Parsers: LR(0) Parser</h3>
                    <p>LR(0) is a <strong>bottom-up parser</strong> that reads left to right, constructs a rightmost derivation in reverse (hence LR), and uses 0 lookahead.</p>
                    <p>It uses:</p>
                    <ul>
                        <li>a <strong>stack</strong></li>
                        <li>a <strong>state machine (DFA)</strong></li>
                        <li>a <strong>parsing table (ACTION + GOTO)</strong></li>
                    </ul>
                </article>

                <article>
                    <h4>What is LR(0) Parser?</h4>
                    <p>A parser that performs bottom-up analysis with no lookahead, using a stack, DFA states, and parsing tables to recognize grammar.</p>
                </article>

                <article>
                    <h4>Key Concepts</h4>
                    <ul>
                        <li><strong>Items</strong>: Grammar rules with a dot (<code>.</code>) showing how much has been parsed.<br>
                            Example: <code>E → E . + T</code> means the prefix <code>E</code> is recognized.
                        </li>
                        <li><strong>States</strong>: Sets of items representing parser configurations.</li>
                        <li><strong>Parsing Table</strong>:
                            <ul>
                                <li><strong>ACTION</strong>: shift, reduce, accept, error</li>
                                <li><strong>GOTO</strong>: next state after reduction</li>
                            </ul>
                        </li>
                    </ul>
                </article>

                <article>
                    <h4>Steps in LR(0) Parsing</h4>
                    <ol>
                        <li>Construct the set of <strong>items</strong> and corresponding <strong>states</strong>.</li>
                        <li>Build the <strong>ACTION</strong> and <strong>GOTO</strong> tables.</li>
                        <li>Parse the input using a <strong>stack</strong> and the parsing tables.</li>
                    </ol>
                </article>

                <article>
                    <h4>Example</h4>
                    <p>Grammar:</p>
                    <pre><code class="">S → A  
A → aA | b</code></pre>
                    <p>Items example:</p>
                    <ul>
                        <li><code>A → .aA</code></li>
                        <li><code>A → a.A</code></li>
                        <li><code>A → aA.</code></li>
                    </ul>
                    <p>The parsing table is constructed based on these items and their state transitions.</p>
                </article>

                <article>
                    <h4>Advantages and Disadvantages</h4>
                    <ul>
                        <li><strong>Advantages</strong>:
                            <ul>
                                <li>Handles a wider class of grammars than LL(1).</li>
                                <li>Suitable for real programming language syntax.</li>
                            </ul>
                        </li>
                        <li><strong>Disadvantages</strong>:
                            <ul>
                                <li>Cannot resolve reduce/reduce or shift/reduce conflicts without modifications.</li>
                                <li>Requires careful grammar design to avoid conflicts.</li>
                            </ul>
                        </li>
                    </ul>
                </article>

                <article>
                    <h4>Summary</h4>
                    <ul>
                        <li><strong>L</strong> = Left-to-right scan</li>
                        <li><strong>R</strong> = Rightmost derivation in reverse</li>
                        <li><strong>0</strong> = No lookahead</li>
                    </ul>
                </article>

            </article>
            <article>


                <article>
                    <h3 class="text-center">SLR (Simple LR) Parser</h3>
                    <p>SLR stands for <strong>Simple LR</strong> parser. It is a type of <strong>bottom-up parser</strong>, more powerful than LR(0) but simpler than canonical LR(1).</p>
                </article>

                <article>
                    <h4>Key Features</h4>
                    <ul>
                        <li>Reads <strong>Left-to-right (L)</strong></li>
                        <li>Produces <strong>Rightmost derivation in reverse (R)</strong></li>
                        <li>Uses <strong>1 lookahead symbol</strong></li>
                    </ul>
                </article>

                <article>
                    <h4>How it Works</h4>
                    <ol>
                        <li>Build LR(0) items and states.</li>
                        <li>Create parsing table with <strong>ACTION</strong> and <strong>GOTO</strong>.</li>
                        <li>Use <strong>FOLLOW sets</strong> to resolve reduce actions.</li>
                    </ol>
                    <p>Difference from LR(0): LR(0) reduces in all states blindly. SLR uses the FOLLOW set to allow a reduce only when the next symbol is valid.</p>
                </article>

                <article>
                    <h4>Example Grammar</h4>
                    <pre><code class="">S → A  
A → aA | b</code></pre>
                    <p>Procedure:</p>
                    <ul>
                        <li>Build items as in LR(0).</li>
                        <li>Compute <strong>FOLLOW(A)</strong> = {<code>$</code>, <code>a</code>, <code>b</code>}.</li>
                        <li>Apply reduction <code>A → b</code> only if the lookahead symbol is in FOLLOW(A).</li>
                    </ul>
                </article>

                <article>
                    <h4>Advantages and Limitations</h4>
                    <ul>
                        <li><strong>Advantages</strong>:
                            <ul>
                                <li>Simpler than LR(1).</li>
                                <li>Parses more grammars than LL(1) and LR(0).</li>
                            </ul>
                        </li>
                        <li><strong>Limitations</strong>:
                            <ul>
                                <li>Cannot resolve some shift/reduce conflicts.</li>
                                <li>Less powerful than canonical LR(1) and LALR.</li>
                            </ul>
                        </li>
                    </ul>
                </article>

                <article>
                    <h4>One-Line Summary</h4>
                    <p>SLR = LR(0) enhanced with FOLLOW sets for smarter reduces; it offers better parsing power than LR(0) while remaining simpler than full LR(1).</p>
                </article>

            </article>
            <article>


                <article>
                    <h3 class="text-center">Canonical LR(1) Parser</h3>
                    <p>The Canonical LR(1) parser is the most powerful LR parser, using 1 lookahead symbol per item to eliminate conflicts while performing bottom-up parsing.</p>
                </article>

                <article>
                    <h4>Key Features</h4>
                    <ul>
                        <li>Reads <strong>Left-to-right (L)</strong>.</li>
                        <li>Constructs a <strong>Rightmost derivation in reverse (R)</strong>.</li>
                        <li>Uses <strong>1 lookahead symbol (1)</strong> in each item.</li>
                        <li>Resolves both <strong>shift/reduce</strong> and <strong>reduce/reduce</strong> conflicts when possible.</li>
                    </ul>
                </article>

                <article>
                    <h4>Construction Steps</h4>
                    <ol>
                        <li>Augment grammar with new start rule <code>S′ → S</code>.</li>
                        <li>Compute <strong>LR(1) items</strong>: productions with a dot and a lookahead set.</li>
                        <li>Build the <strong>DFA</strong> of item sets (states) using <code>closure</code> and <code>goto</code> operations.</li>
                        <li>Construct the <strong>ACTION</strong> and <strong>GOTO</strong> tables from the DFA.</li>
                    </ol>
                </article>

                <article>
                    <h4>LR(1) Item Example</h4>
                    <p>For grammar:</p>
                    <pre><code class="">E → E + T | T  
T → T * F | F  
F → ( E ) | id</code></pre>
                    <p>An LR(1) item might be:</p>
                    <pre><code class="">E → E + • T , {<code>+</code>, <code>)</code>, <code>$</code>}</code></pre>
                    <p>This indicates we expect to see <code>T</code> next, with lookahead one of <code>+</code>, <code>)</code>, or end-of-input.</p>
                </article>

                <article>
                    <h4>Advantages and Disadvantages</h4>
                    <ul>
                        <li><strong>Advantages</strong>:
                            <ul>
                                <li>Handles the largest class of deterministic context-free grammars.</li>
                                <li>Minimal conflicts for well-formed language grammars.</li>
                            </ul>
                        </li>
                        <li><strong>Disadvantages</strong>:
                            <ul>
                                <li>Produces very <strong>large parsing tables</strong>.</li>
                                <li>Complex to implement and compute.</li>
                            </ul>
                        </li>
                    </ul>
                </article>

                <article>
                    <h4>Use in Practice</h4>
                    <p>Rarely used directly due to table size; LALR(1) merges compatible states to reduce table size while retaining most power. Canonical LR(1) remains the theoretical standard for conflict-free parsing.</p>
                </article>

                <article>
                    <h4>One-Line Summary</h4>
                    <p>Canonical LR(1) uses one-symbol lookahead in each item to achieve conflict-free bottom-up parsing at the cost of large parsing tables.</p>
                </article>

            </article>
            <article>


                <article>
                    <h3 class="text-center">Parser Generator: YACC</h3>
                    <p>YACC stands for <strong>Yet Another Compiler Compiler</strong>. It is a tool used to automatically generate parsers for programming languages.</p>
                </article>

                <article>
                    <h4>How it Works</h4>
                    <ul>
                        <li>You write <strong>grammar rules</strong> in YACC format (usually in BNF).</li>
                        <li>YACC generates a <strong>parser</strong> (usually LALR) in <strong>C language</strong>.</li>
                        <li>It works with a lexical analyzer like <strong>Lex</strong>.</li>
                    </ul>
                </article>

                <article>
                    <h4>YACC File Structure</h4>
                    <pre><code class="">%{
   // Declarations
%}

%%
// Grammar Rules (with actions)

%%
// C code (main function etc.) </code></pre>

                </article>

                <article>
                    <h4>Example Grammar in YACC</h4>
                    <pre><code class="">%%
E : E '+' T   { printf("add\n"); }
  | T         ;
T : 'id'      ;
%%</code></pre>
                    <p>Input: <code>id + id</code></p>
                    <p>Output: <code>add</code></p>
                </article>

                <article>
                    <h4>Advantages</h4>
                    <ul>
                        <li>Automates parser generation</li>
                        <li>Handles complex grammars</li>
                        <li>Reduces manual coding errors</li>
                    </ul>
                </article>

                <article>
                    <h4>Used In</h4>
                    <ul>
                        <li>Compilers (C, Java, etc.)</li>
                        <li>Interpreters</li>
                        <li>Tools like Bison (enhanced version of YACC)</li>
                    </ul>
                </article>

                <article>
                    <h4>One-Line Summary</h4>
                    <p>YACC is a tool to generate parsers automatically using grammar rules, making compiler design easier and faster.</p>
                </article>
            </article>
            <article>
                <article>
                    <h3 class="text-center">Syntax Directed Translation (SDT)</h3>
                    <p>Syntax Directed Translation (SDT) is a method used in compiler design to attach meaning—such as actions or translations—to the grammar rules of a language. It helps the compiler to generate code, check types, or evaluate values while parsing.</p>
                </article>

                <article>
                    <h4>What is SDT?</h4>
                    <p>SDT means:</p>
                    <ul>
                        <li><strong>For every grammar rule</strong>, we attach semantic rules (code)</li>
                        <li><strong>These semantic rules</strong> are based on the attributes of symbols in the grammar</li>
                    </ul>
                </article>

                <article>
                    <h4>Types of SDT</h4>
                    <h5>S-attributed SDT</h5>
                    <p>Only synthesized attributes are used (bottom-up approach).<br />
                        Example: expression evaluation.</p>
                    <h5>L-attributed SDT</h5>
                    <p>Uses both synthesized and inherited attributes; works in top-down parsing.<br />
                        Example: type checking, symbol table management.</p>
                </article>

                <article>
                    <h4>Attributes</h4>
                    <ul>
                        <li><strong>Synthesized attribute</strong>: computed from child nodes</li>
                        <li><strong>Inherited attribute</strong>: taken from parent or sibling nodes</li>
                    </ul>
                </article>

                <article>
                    <h4>Example: Expression Evaluation</h4>
                    <p>Consider the grammar:</p>
                    <pre><code>E → E1 + T
E → T
T → num
</code></pre>
                    <p>Attach SDT rules:</p>
                    <pre><code>E → E1 + T     { E.val = E1.val + T.val }
E → T          { E.val = T.val }
T → num        { T.val = num.lexval }
</code></pre>
                    <p>This computes the value of an expression like <code>3 + 5 + 2</code>.</p>
                </article>

                <article>
                    <h4>Application of SDT</h4>
                    <ul>
                        <li>Expression evaluation</li>
                        <li>Intermediate code generation</li>
                        <li>Type checking</li>
                        <li>Symbol table construction</li>
                    </ul>
                </article>

                <article>
                    <h4>Conclusion</h4>
                    <p>SDT is a powerful tool in compiler design that connects grammar rules with actions, enabling code generation, type checking, and value evaluation during parsing.</p>
                </article>

            </article>
            <article>


                <article>
                    <h3 class="text-center">Syntax Directed Program Evaluation</h3>
                    <p>Syntax Directed Program Evaluation uses grammar rules combined with attached actions to evaluate a program—such as calculating values, checking types, or generating code—during parsing. It relies on Syntax Directed Definitions (SDD), which pair grammar productions with semantic rules.</p>
                </article>

                <article>
                    <h4>Key Concepts</h4>
                    <ul>
                        <li><strong>Grammar</strong> defines the program’s structure</li>
                        <li><strong>Semantic rules</strong> define the meaning or action</li>
                        <li><strong>Attributes</strong> (synthesized &amp; inherited) carry values during parsing</li>
                    </ul>
                </article>

                <article>
                    <h4>Steps in Program Evaluation</h4>
                    <ol>
                        <li>Define a grammar for the language</li>
                        <li>Attach semantic rules to each grammar production</li>
                        <li>Parse the input, applying rules to evaluate the program step-by-step</li>
                    </ol>
                </article>

                <article>
                    <h4>Example: Simple Arithmetic Evaluation</h4>
                    <p>Grammar:</p>
                    <pre><code>E → E1 + T
E → T
T → num
</code></pre>
                    <p>Semantic Rules (SDD):</p>
                    <pre><code>E → E1 + T     { E.val = E1.val + T.val }
E → T          { E.val = T.val }
T → num        { T.val = num.lexval }
</code></pre>
                    <p>For input <code>2 + 3 + 4</code>, evaluation proceeds:</p>
                    <pre><code>
T.val = 2
E.val = 2

T.val = 3
E1.val = 2, T.val = 3
E.val = 5

T.val = 4
E1.val = 5, T.val = 4
E.val = 9 </code></pre>

                    <p>Final result: <strong>9</strong></p>
                </article>

                <article>
                    <h4>Used For</h4>
                    <ul>
                        <li>Arithmetic evaluation</li>
                        <li>Type checking</li>
                        <li>Generating intermediate code</li>
                        <li>Checking variable declarations</li>
                    </ul>
                </article>

                <article>
                    <h4>Conclusion</h4>
                    <p>Syntax Directed Program Evaluation enables compilers to execute actions tied to grammar rules during parsing, facilitating value computation, correctness verification, and code generation.</p>
                </article>

            </article>
            <article>


                <article>
                    <h3 class="text-center">Different Schemes and Implementation of Syntax Directed Translation</h3>
                    <p>Syntax Directed Translation (SDT) can be implemented using different schemes based on how and when the actions (semantic rules) are executed during parsing.</p>
                </article>

                <article>
                    <h4>Postfix SDT (Action after rule)</h4>
                    <p>All actions are written at the end of production rules. Used in bottom-up parsing (like LR parsers).</p>
                    <pre><code>E → E1 + T   { print('+') }
E → T
T → num     { print(num.val) }
</code></pre>
                    <p>For input <code>2 + 3</code>, output: <code>2 3 +</code> (like postfix evaluation)</p>
                </article>

                <article>
                    <h4>Embedded SDT (Action inside rule)</h4>
                    <p>Actions can be placed anywhere in the production (not just at end). Useful in top-down parsing (like LL parsers).</p>
                    <pre><code>E → { print('(') } E1 + T { print(')') }
</code></pre>
                    <p>Adds brackets while parsing; good for formatting or generating nested structure.</p>
                </article>

                <article>
                    <h4>S-attributed SDT</h4>
                    <p>Uses only synthesized attributes; works with bottom-up parsers; easy to implement.</p>
                    <p>Example: In <code>E → E1 + T</code>, the value of <code>E</code> is calculated from <code>E1.val</code> and <code>T.val</code>.</p>
                </article>

                <article>
                    <h4>L-attributed SDT</h4>
                    <p>Uses both inherited and synthesized attributes; works with top-down parsers; supports context-sensitive information like type or scope.</p>
                    <p>Example: Passing type information from parent to child in declarations.</p>
                </article>

                <article>
                    <h3>Implementation Methods</h3>
                    <p>Different approaches to compute attributes and execute semantic actions:</p>
                </article>

                <article>
                    <h4>Using Parse Tree</h4>
                    <p>Build the parse tree first, then compute attributes in post-order traversal.</p>
                </article>

                <article>
                    <h4>During Parsing (On-the-fly)</h4>
                    <p>No separate parse tree; compute attribute values while parsing.</p>
                </article>

                <article>
                    <h4>Using Stack</h4>
                    <p>Attach attributes to symbols on the parser’s stack (in bottom-up parsers).</p>
                </article>

                <article>
                    <h4>Using Recursive Functions</h4>
                    <p>Use function return values to simulate synthesized attributes, and function parameters for inherited attributes.</p>
                </article>

                <article>
                    <h4>Conclusion</h4>
                    <p>SDT schemes vary by the placement of semantic actions and choice of parser. S-attributed schemes suit bottom-up parsing, while L-attributed schemes support top-down parsing with inherited information. Implementation can be done on-the-fly, via parse trees, stacks, or recursive routines.</p>
                </article>
            </article>
            <article>

                <article>
                    <h3 class="text-center">Intermediate Code Generation</h3>
                    <p>Intermediate Code Generation is a phase in compiler design where the source code is converted into a simple, machine-independent code. This intermediate code acts as a bridge between the source program and the final machine code.</p>
                </article>

                <article>
                    <h4>Why Use Intermediate Code?</h4>
                    <ul>
                        <li>Makes the compiler <strong>portable</strong> (reuse for multiple machines)</li>
                        <li>Facilitates <strong>optimization</strong></li>
                        <li>Simplifies <strong>error handling</strong></li>
                    </ul>
                </article>

                <article>
                    <h4>Properties of Intermediate Code</h4>
                    <ul>
                        <li>Easy to understand</li>
                        <li>Close to machine code but independent of any specific CPU</li>
                        <li>Preserves the structure of the original code</li>
                    </ul>
                </article>

                <article>
                    <h4>Types of Intermediate Representations</h4>
                    <h5>1.3.1 Three-Address Code (TAC)</h5>
                    <p>Most popular IR. Each instruction has at most three parts (two operands and one result):</p>
                    <pre><code>t1 = a + b
t2 = t1 * c</code></pre>
                    <p>Easy to optimize and translate.</p>

                    <h5>1.3.2 Postfix (Reverse Polish) Notation</h5>
                    <p>Operators appear after operands, eliminating the need for parentheses:</p>
                    <pre><code>ab+    &rarr; means a + b</code></pre>

                    <h5>1.3.3 Syntax Trees / DAGs</h5>
                    <p>Tree structures representing operations and operands. Directed Acyclic Graphs (DAGs) help remove common subexpressions.</p>
                </article>

                <article>
                    <h4>Example (Using TAC)</h4>
                    <p>Source Code:</p>
                    <pre><code>a = b + c * d;</code></pre>
                    <p>Intermediate Code (TAC):</p>
                    <pre><code>t1 = c * d
t2 = b + t1
a = t2</code></pre>
                    <p>Each complex statement is broken into simple steps.</p>
                </article>

                <article>
                    <h4>Conclusion</h4>
                    <p>Intermediate Code Generation produces a machine-independent representation, enhancing compiler portability and optimization. Three-Address Code is the most widely used format for this purpose.</p>
                </article>

            </article>
            <article>


                <article>
                    <h3 class="text-center">Syntax Trees</h3>
                    <p>A Syntax Tree is a tree representation of the syntactic structure of source code according to grammar rules. It is also called an Abstract Syntax Tree (AST) because it shows only the essential parts of the program without extra grammar symbols.</p>
                </article>

                <article>
                    <h4>Why Use Syntax Trees?</h4>
                    <ul>
                        <li>Helps in understanding program structure</li>
                        <li>Used in intermediate code generation</li>
                        <li>Facilitates code optimization</li>
                    </ul>
                </article>

                <article>
                    <h4>Features of Syntax Trees</h4>
                    <ul>
                        <li>Internal nodes represent operators</li>
                        <li>Leaf nodes represent operands (variables or constants)</li>
                        <li>Omits extra symbols like parentheses, commas, and semicolons</li>
                    </ul>
                </article>

                <article>
                    <h4>Example</h4>
                    <p>For the expression:</p>
                    <pre><code>a + b * c</code></pre>
                    <p>The syntax tree is:</p>
                    <pre><code>    +
   / \
  a   *
     / \
    b   c
</code></pre>
                    <p>This tree reflects operator precedence: <code>b * c</code> is evaluated before adding to <code>a</code>.</p>
                </article>

                <article>
                    <h4>Usage of Syntax Trees</h4>
                    <ul>
                        <li>Generating Three-Address Code</li>
                        <li>Performing semantic analysis and type checking</li>
                        <li>Building Directed Acyclic Graphs (DAGs) for optimization</li>
                    </ul>
                </article>

                <article>
                    <h4>Conclusion</h4>
                    <p>Syntax Trees provide a clear, abstract representation of program structure. They are fundamental in compiler design for analysis, translation, and optimization tasks.</p>
                </article>


            </article>
            <article>


                <article>
                    <h3 class="text-center">Three Address Code (TAC)</h3>
                    <p>Three Address Code (TAC) is a type of intermediate code used in compilers. Each instruction in TAC has at most three parts: one operator, two operands, and one result. It breaks complex expressions into simple steps using temporary variables.</p>
                </article>

                <article>
                    <h4>Format of TAC</h4>
                    <p>The general form of a TAC instruction is:</p>
                    <pre><code>x = y op z</code></pre>
                    <p>Where:</p>
                    <ul>
                        <li><strong>x</strong> is the result</li>
                        <li><strong>op</strong> is an operator</li>
                        <li><strong>y</strong> and <strong>z</strong> are operands (variables or constants)</li>
                    </ul>
                </article>

                <article>
                    <h4>Types of TAC Instructions</h4>
                    <ul>
                        <li>
                            <strong>Assignment</strong>
                            <pre><code>x = y</code></pre>
                        </li>
                        <li>
                            <strong>Binary Operation</strong>
                            <pre><code>x = y + z</code></pre>
                        </li>
                        <li>
                            <strong>Unary Operation</strong>
                            <pre><code>x = -y</code></pre>
                        </li>
                        <li>
                            <strong>Conditional Jump</strong>
                            <pre><code>if x &lt; y goto L1</code></pre>
                        </li>
                        <li>
                            <strong>Unconditional Jump</strong>
                            <pre><code>goto L2</code></pre>
                        </li>
                        <li>
                            <strong>Label Definition</strong>
                            <pre><code>L1:</code></pre>
                        </li>
                        <li>
                            <strong>Function Call / Return</strong> (optional in advanced compilers)
                        </li>
                    </ul>
                </article>

                <article>
                    <h4>Example</h4>
                    <p>Given the statement:</p>
                    <pre><code>a = b + c * d</code></pre>
                    <p>The step-by-step TAC is:</p>
                    <pre><code>t1 = c * d
t2 = b + t1
a = t2</code></pre>
                    <p>Each temporary variable (<code>t1</code>, <code>t2</code>) holds part of the computation.</p>
                </article>

                <article>
                    <h4>Why Use TAC?</h4>
                    <ul>
                        <li>Easy to generate from the syntax tree</li>
                        <li>Facilitates code optimization</li>
                        <li>Simplifies final machine code generation</li>
                        <li>Independent of specific machine architectures</li>
                    </ul>
                </article>

                <article>
                    <h4>Conclusion</h4>
                    <p>Three Address Code breaks complex statements into simple instructions with at most three components. It serves as a widely used intermediate representation in compiler design, making translation and optimization tasks more straightforward.</p>
                </article>

            </article>
            <article>


                <article>
                    <h3 class="text-center">Quadruples in Intermediate Code</h3>
                    <p>Quadruples represent intermediate code in compilers using a four-column format. Each instruction is stored as a tuple:</p>
                    <pre><code>(op, arg1, arg2, result)</code></pre>
                    <p>This layout structures Three Address Code (TAC) instructions for easier processing.</p>
                </article>

                <article>
                    <h4>Format of Quadruple</h4>
                    <div class="table-responsive">
                        <table class="table table-bordered table-striped">
                            <thead>
                                <tr>
                                    <th>Operator</th>
                                    <th>Argument 1</th>
                                    <th>Argument 2</th>
                                    <th>Result</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>op</td>
                                    <td>arg1</td>
                                    <td>arg2</td>
                                    <td>result</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </article>

                <article>
                    <h4>Example</h4>
                    <p>For the expression:</p>
                    <pre><code>a = b + c * d</code></pre>
                    <p>Step-by-step TAC:</p>
                    <pre><code>t1 = c * d
t2 = b + t1
a = t2</code></pre>
                    <p>Corresponding quadruples:</p>
                    <div class="table-responsive">
                        <table class="table table-bordered table-striped">
                            <thead>
                                <tr>
                                    <th>Operator</th>
                                    <th>Arg1</th>
                                    <th>Arg2</th>
                                    <th>Result</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>*</td>
                                    <td>c</td>
                                    <td>d</td>
                                    <td>t1</td>
                                </tr>
                                <tr>
                                    <td>+</td>
                                    <td>b</td>
                                    <td>t1</td>
                                    <td>t2</td>
                                </tr>
                                <tr>
                                    <td>=</td>
                                    <td>t2</td>
                                    <td>—</td>
                                    <td>a</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </article>

                <article>
                    <h4>Advantages of Quadruples</h4>
                    <ul>
                        <li>Easy to implement</li>
                        <li>Clear separation of operation and operands</li>
                        <li>Facilitates code optimization</li>
                    </ul>
                </article>

                <article>
                    <h4>Used For</h4>
                    <ul>
                        <li>Intermediate code representation</li>
                        <li>Optimization</li>
                        <li>Final code generation</li>
                    </ul>
                </article>

                <article>
                    <h4>Conclusion</h4>
                    <p>Quadruples provide a structured four-field representation—operator, two operands, and result—making intermediate code clear and optimizable for subsequent machine code generation.</p>
                </article>

            </article>
            <article>


                <article>
                    <h3 class="text-center">Triples in Intermediate Code</h3>
                    <p>Triples are a way to represent intermediate code similar to quadruples, but without a separate result field. Instead, results are implicitly referenced by the instruction’s index.</p>
                </article>

                <article>
                    <h4>Format of Triples</h4>
                    <p>Each instruction is written as:</p>
                    <pre><code>(index) (operator, argument1, argument2)</code></pre>
                    <p>No explicit result field—subsequent instructions refer back by index.</p>
                </article>

                <article>
                    <h4>Example</h4>
                    <p>For the expression:</p>
                    <pre><code>a = b + c * d</code></pre>
                    <p>Step-by-step TAC:</p>
                    <pre><code>t1 = c * d
t2 = b + t1
a  = t2</code></pre>
                    <p>Corresponding triples:</p>
                    <div class="table-responsive">
                        <table class="table table-bordered table-striped">
                            <thead>
                                <tr>
                                    <th>Index</th>
                                    <th>Operator</th>
                                    <th>Arg1</th>
                                    <th>Arg2</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>(0)</td>
                                    <td>*</td>
                                    <td>c</td>
                                    <td>d</td>
                                </tr>
                                <tr>
                                    <td>(1)</td>
                                    <td>+</td>
                                    <td>b</td>
                                    <td>(0)</td>
                                </tr>
                                <tr>
                                    <td>(2)</td>
                                    <td>=</td>
                                    <td>a</td>
                                    <td>(1)</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </article>

                <article>
                    <h4>Advantages of Triples</h4>
                    <ul>
                        <li>Saves space by avoiding explicit temporary-result fields</li>
                        <li>Easy to reference intermediate results via indices</li>
                        <li>Compact representation for simple optimizations</li>
                    </ul>
                </article>

                <article>
                    <h4>Disadvantages of Triples</h4>
                    <ul>
                        <li>Instruction reordering is difficult because indices change</li>
                        <li>Less convenient for advanced optimizations like common subexpression elimination</li>
                    </ul>
                </article>

                <article>
                    <h4>Conclusion</h4>
                    <p>Triples offer a compact intermediate-code representation by referring to previous instructions by index rather than naming result variables. This format reduces storage but can complicate certain optimizations.</p>
                </article>

            </article>
            <article>


                <article>
                    <h3 class="text-center">Translation of Assignment Statements</h3>
                    <p>Assignment statements are one of the most common types in any programming language. In compiler design, assignment statements are translated into intermediate code using syntax directed translation and three address code (TAC).</p>
                </article>

                <article>
                    <h4>General Format</h4>
                    <p><code>variable = expression;</code></p>
                    <p>The expression can include:</p>
                    <ul>
                        <li>Arithmetic operations</li>
                        <li>Variables</li>
                        <li>Constants</li>
                    </ul>
                </article>

                <article>
                    <h4>Goal of Translation</h4>
                    <p>Break down the expression into simpler steps using temporary variables, then assign the final result to the target variable.</p>
                </article>

                <article>
                    <h4>Example 1</h4>
                    <p>Source Code:</p>
                    <pre><code>a = b + c * d;</code></pre>
                    <p>Step-by-step TAC:</p>
                    <pre><code>t1 = c * d
t2 = b + t1
a = t2</code></pre>
                </article>

                <article>
                    <h4>Example 2</h4>
                    <p>Source Code:</p>
                    <pre><code>x = (a + b) - (c + d);</code></pre>
                    <p>Step-by-step TAC:</p>
                    <pre><code>t1 = a + b
t2 = c + d
t3 = t1 - t2
x = t3</code></pre>
                </article>

                <article>
                    <h4>How It Works in Compiler</h4>
                    <ol>
                        <li>Parse the expression using grammar</li>
                        <li>Apply syntax directed translation rules</li>
                        <li>Generate TAC or quadruples/triples</li>
                        <li>Store intermediate results using temporary variables</li>
                    </ol>
                </article>

                <article>
                    <h4>Why Translate Assignment Statements?</h4>
                    <ul>
                        <li>Prepare code for optimization</li>
                        <li>Make code machine-independent</li>
                        <li>Simplify the code generation phase</li>
                    </ul>
                </article>

                <article>
                    <h4>Conclusion</h4>
                    <p>Translating assignment statements into intermediate code with temporary variables and respecting operator precedence is essential in compiler design for correct, efficient, and optimized code generation.</p>
                </article>

            </article>
            <article>


                <article>
                    <h3 class="text-center">Basic Blocks and Flow Graphs</h3>
                    <p>Basic Blocks are straight-line sequences of instructions with only one entry and one exit. Flow Graphs (or Control Flow Graphs) depict the flow of control between these blocks.</p>
                </article>

                <article>
                    <h4>What is a Basic Block?</h4>
                    <p>A Basic Block is a sequence of instructions that has:</p>
                    <ul>
                        <li>No jump into the middle</li>
                        <li>No jump out except at the end</li>
                        <li>No branches within it</li>
                    </ul>
                    <p>It has a single entry point and a single exit point: all instructions execute in order without interruption.</p>
                </article>

                <article>
                    <h4>Identifying Basic Blocks</h4>
                    <ol>
                        <li>The first statement is a leader (starts a block).</li>
                        <li>Any target of a jump is a leader.</li>
                        <li>Any statement following a jump is a leader.</li>
                    </ol>
                    <p>Each basic block begins at a leader and includes all statements up to (but not including) the next leader.</p>
                </article>

                <article>
                    <h4>Example</h4>
                    <pre><code>1: a = b + c
2: if a &gt; 0 goto 5
3: d = a - 1
4: goto 6
5: d = a + 1
6: print d
</code></pre>
                    <p>Basic Blocks:</p>
                    <ul>
                        <li>B1: 1</li>
                        <li>B2: 2</li>
                        <li>B3: 3, 4</li>
                        <li>B4: 5</li>
                        <li>B5: 6</li>
                    </ul>
                </article>

                <article>
                    <h4>What is a Flow Graph?</h4>
                    <p>A Flow Graph (CFG) is a graphical representation where:</p>
                    <ul>
                        <li>Nodes represent basic blocks</li>
                        <li>Edges represent possible control transfer (e.g., goto or conditional branch)</li>
                    </ul>
                </article>

                <article>
                    <h4>Flow Graph for the Example</h4>
                    <pre class="mermaid text-center">
flowchart TD
    B1["B1: a = b + c"] --> B2["B2: if a > 0 goto 5"]
    B2 -->|T| B4["B4: d = a + 1"]
    B2 -->|F| B3["B3: d = a - 1; goto 6"]
    B3 --> B5["B5: print d"]
    B4 --> B5
</pre>
                </article>

                <article>
                    <h4>Uses of Basic Blocks &amp; Flow Graphs</h4>
                    <ul>
                        <li>Code optimization (e.g., dead code elimination, loop transformation)</li>
                        <li>Identification of loops and branches</li>
                        <li>Clarifying program structure for analysis</li>
                    </ul>
                </article>

                <article>
                    <h4>Conclusion</h4>
                    <p>Basic Blocks provide modular units of straight-line code, and Flow Graphs illustrate how control moves between them. Both are fundamental for optimization and efficient code generation in compilers.</p>
                </article>

            </article>
            <article>


                <article>
                    <h3 class="text-center">DAG (Directed Acyclic Graph)</h3>
                    <p>A DAG is a graph used to represent expressions or basic blocks in a way that helps remove redundant computations, optimize code, and find common sub-expressions.</p>
                </article>

                <article>
                    <h4>Why “Directed Acyclic”?</h4>
                    <ul>
                        <li><strong>Directed</strong>: arrows show the direction of computation</li>
                        <li><strong>Acyclic</strong>: no cycles (it never loops back)</li>
                    </ul>
                </article>

                <article>
                    <h4>Nodes in a DAG</h4>
                    <ul>
                        <li>An <strong>operation</strong> (e.g., +, *, -)</li>
                        <li>A <strong>value</strong> or <strong>variable</strong></li>
                    </ul>
                </article>

                <article>
                    <h4>Example</h4>
                    <p>Consider the code:</p>
                    <pre><code>a = b + c  
d = b + c  
e = a + d</code></pre>
                    <p>Here, <code>b + c</code> is computed twice. A DAG avoids this by sharing the node.</p>
                </article>

                <article>
                    <h4>DAG Representation</h4>
                    <pre><code>.  (+)
   / \
  b   c
   \ /
    X
   / \
  a   d
    \ /
    (+)
    / \
   a   d
    |
    e
</code></pre>
                    <p>• The node for <code>b + c</code> is reused for both <code>a</code> and <code>d</code>.<br />
                        • <code>e = a + d</code> uses the existing <code>a</code> and <code>d</code> nodes.</p>
                </article>

                <article>
                    <h4>Uses of DAG</h4>
                    <ul>
                        <li>Eliminate common subexpressions</li>
                        <li>Dead code removal</li>
                        <li>Efficient code generation</li>
                        <li>Basic block optimization</li>
                    </ul>
                </article>

                <article>
                    <h4>Conclusion</h4>
                    <p>A DAG helps the compiler optimize expressions by removing repeated calculations. It clearly shows dependencies between operations, enabling smarter and faster code generation.</p>
                </article>

            </article>
            <article>


                <article>
                    <h3 class="text-center">Code Optimization</h3>
                    <p>Code optimization is the process of improving intermediate code to make the final code run faster and use fewer resources, without changing its output.</p>
                </article>

                <article>
                    <h4>Principle Sources of Optimization</h4>
                    <ul>
                        <li><strong>Elimination of Common Subexpressions</strong>: Avoid calculating the same thing multiple times.
                            <pre><code>// Before optimization
a = b + c;
d = b + c;
// After optimization
t = b + c;
a = t;
d = t;
    </code></pre>
                        </li>
                        <li><strong>Dead Code Elimination</strong>: Remove code that never affects the output.
                            <pre><code>// Before
x = 5;
x = 6;
// After
x = 6;
    </code></pre>
                        </li>
                        <li><strong>Constant Folding and Propagation</strong>: Evaluate constant expressions at compile time.
                            <pre><code>// Before
x = 3 + 4;
// After
x = 7;
    </code></pre>
                        </li>
                        <li><strong>Loop Optimization</strong> (focus area): Optimize loops to gain significant performance improvements.</li>
                    </ul>
                </article>

                <article>
                    <h4>Loop Optimization</h4>
                    <p>Loops execute multiple times, so optimizing them yields large performance gains.</p>
                </article>

                <article>
                    <h5>Loop Invariant Code Motion</h5>
                    <p>Move calculations that do not change inside the loop to before the loop.</p>
                    <pre><code>// Before
for (i = 0; i < n; i++) {
    x = a + b;  // invariant
    ... 
}
// After
x = a + b;
for (i = 0; i < n; i++) {
    ...
}
</code></pre>
                </article>

                <article>
                    <h5>Strength Reduction</h5>
                    <p>Replace expensive operations with equivalent cheaper ones.</p>
                    <pre><code>// Before
for (i = 0; i < n; i++) {
    y = i * 2;
}
// After
for (i = 0; i < n; i++) {
    y = i + i;
}
</code></pre>
                </article>

                <article>
                    <h5>Loop Unrolling</h5>
                    <p>Reduce loop control overhead by replicating the loop body multiple times.</p>
                    <pre><code>// Before
for (i = 0; i < 4; i++) {
    sum += a[i];
}
// After
sum += a[0] + a[1] + a[2] + a[3];
</code></pre>
                </article>

                <article>
                    <h5>Induction Variable Elimination</h5>
                    <p>Remove unnecessary variables that follow a predictable pattern.</p>
                    <pre><code>// Before
for (i = 0; i < n; i++) {
    t = 5 * i;
    ...
}
// After
t = 0;
for (i = 0; i < n; i++) {
    ...
    t += 5;
}
</code></pre>
                </article>

                <article>
                    <h4>Conclusion</h4>
                    <p>Code optimization enhances performance without altering output. Loop optimization—by moving invariant code, reducing strength of operations, unrolling loops, and eliminating induction variables—provides the greatest benefit in repetitive structures.</p>
                </article>

            </article>
            <article>


                <article>
                    <h3 class="text-center">Induction Variable Elimination</h3>
                    <p>Induction Variable Elimination is a loop optimization technique used in compilers to remove unnecessary variables that change in a predictable, linear pattern (arithmetic progression).</p>
                </article>

                <article>
                    <h4>What Is an Induction Variable?</h4>
                    <p>An induction variable is one that increases or decreases by a fixed amount in each loop iteration.</p>
                    <pre><code>for (i = 0; i < n; i++) {
    j = 2 * i;
}
</code></pre>
                    <p>Here, <code>i</code> is a basic induction variable; <code>j</code> is a derived induction variable (depends on <code>i</code>).</p>
                </article>

                <article>
                    <h4>What Is Elimination?</h4>
                    <p>Elimination removes the extra induction variable (e.g., <code>j</code>) and replaces its uses directly with the expression in terms of the basic variable (<code>i</code>).</p>
                </article>

                <article>
                    <h4>Example</h4>
                    <p><strong>Before Optimization:</strong></p>
                    <pre><code>for (i = 0; i < n; i++) {
    j = 2 * i;
    a[j] = i;
}
</code></pre>
                    <p><strong>After Eliminating Induction Variable:</strong></p>
                    <pre><code>for (i = 0; i < n; i++) {
    a[2 * i] = i;
}
</code></pre>
                    <p>The variable <code>j</code> is removed since its value can be computed inline.</p>
                </article>

                <article>
                    <h4>Why Eliminate Induction Variables?</h4>
                    <ul>
                        <li>Reduces memory usage</li>
                        <li>Lowers register pressure</li>
                        <li>Makes code faster and simpler</li>
                        <li>Facilitates other optimizations like loop unrolling</li>
                    </ul>
                </article>

                <article>
                    <h4>Conclusion</h4>
                    <p>Induction Variable Elimination simplifies loops by removing redundant variables that follow a linear pattern, thereby reducing overhead and improving performance of the generated code.</p>
                </article>

            </article>
            <article>


                <article>
                    <h3 class="text-center">Common Sub-Expression Elimination</h3>
                    <p>Common Sub-Expression Elimination (CSE) is a code optimization technique used to avoid recalculating the same expression multiple times.</p>
                </article>

                <article>
                    <h4>What Is a Common Sub-Expression?</h4>
                    <p>An expression like <code>a + b</code> is common if it appears more than once and the variables <code>a</code> and <code>b</code> have not changed between occurrences.</p>
                </article>

                <article>
                    <h4>Goal of CSE</h4>
                    <ul>
                        <li>Detect repeated expressions</li>
                        <li>Compute once, then reuse the result</li>
                    </ul>
                </article>

                <article>
                    <h4>Example (Before Optimization)</h4>
                    <pre><code>x = a + b;
y = a + b;
z = x + y;
</code></pre>
                    <p>Here, <code>a + b</code> is calculated twice.</p>
                </article>

                <article>
                    <h4>After Eliminating Common Sub-Expression</h4>
                    <pre><code>t = a + b;
x = t;
y = t;
z = x + y;
</code></pre>
                    <p>The expression <code>a + b</code> is computed once, stored in <code>t</code>, and reused.</p>
                </article>

                <article>
                    <h4>Benefits of CSE</h4>
                    <ul>
                        <li>Reduces redundant computations</li>
                        <li>Improves execution speed</li>
                        <li>Reduces code size</li>
                        <li>Saves CPU cycles and registers</li>
                    </ul>
                </article>

                <article>
                    <h4>How the Compiler Performs CSE</h4>
                    <ol>
                        <li>Build a DAG (Directed Acyclic Graph)</li>
                        <li>Detect nodes with the same operands and operator</li>
                        <li>Replace repeated sub-expressions with a single computed value</li>
                    </ol>
                </article>

                <article>
                    <h4>Conclusion</h4>
                    <p>Common Sub-Expression Elimination removes duplicate calculations by computing the expression once and reusing it, resulting in faster, smaller, and more optimized code.</p>
                </article>

            </article>
            <article>


                <article>
                    <h3 class="text-center">Loop Unrolling</h3>
                    <p>Loop Unrolling is a loop optimization technique where multiple iterations of the loop body are executed in one loop cycle, reducing loop-control overhead (increments, comparisons, branches).</p>
                </article>

                <article>
                    <h4>Goal of Loop Unrolling</h4>
                    <ul>
                        <li>Reduce the number of jump and comparison instructions</li>
                        <li>Improve execution speed</li>
                        <li>Enable greater instruction-level parallelism and better pipelining</li>
                    </ul>
                </article>

                <article>
                    <h4>Example (Before Unrolling)</h4>
                    <pre><code>for (i = 0; i < 4; i++) {
    sum += a[i];
}
</code></pre>
                    <p>This executes four iterations, each with loop-control overhead.</p>
                </article>

                <article>
                    <h4>Example (After Full Unrolling)</h4>
                    <pre><code>sum += a[0];
sum += a[1];
sum += a[2];
sum += a[3];
</code></pre>
                    <p>Loop control is completely removed, eliminating branch and increment costs.</p>
                </article>

                <article>
                    <h4>Partial Unrolling Example</h4>
                    <pre><code>for (i = 0; i < n; i += 2) {
    sum += a[i];
    sum += a[i + 1];
}
</code></pre>
                    <p>Performs two iterations per loop, halving the loop-control overhead.</p>
                </article>

                <article>
                    <h4>Advantages of Loop Unrolling</h4>
                    <ul>
                        <li>Fewer jump and comparison instructions</li>
                        <li>Improved CPU performance and throughput</li>
                        <li>Enhanced opportunities for instruction-level parallelism</li>
                    </ul>
                </article>

                <article>
                    <h4>Disadvantages of Loop Unrolling</h4>
                    <ul>
                        <li>Increased code size (may cause cache pressure)</li>
                        <li>Less flexible when iteration count <code>n</code> is unknown or large</li>
                        <li>Requires handling of leftover iterations if <code>n</code> not divisible by unroll factor</li>
                    </ul>
                </article>

                <article>
                    <h4>Conclusion</h4>
                    <p>Loop unrolling optimizes performance by reducing loop-control instructions. It is most effective when iteration counts are known or fixed, and is widely used in high-performance and embedded systems.</p>
                </article>

            </article>
            <article>


                <article>
                    <h3 class="text-center">Loop Jamming (Loop Fusion)</h3>
                    <p>Loop Jamming, or Loop Fusion, is a loop optimization where two or more loops with the same iteration range are combined into a single loop.</p>
                </article>

                <article>
                    <h4>Goal of Loop Jamming</h4>
                    <ul>
                        <li>Reduce loop-control overhead</li>
                        <li>Improve cache performance</li>
                        <li>Minimize memory accesses</li>
                        <li>Enhance execution speed and efficiency</li>
                    </ul>
                </article>

                <article>
                    <h4>Example (Before Jamming)</h4>
                    <pre><code>for (i = 0; i < n; i++) {
    a[i] = b[i] + c[i];
}

for (i = 0; i < n; i++) {
d\[i] = a\[i] \* 2;
} </code></pre>

                    <p>Two separate loops iterate over the same range.</p>
                </article>

                <article>
                    <h4>Example (After Loop Jamming)</h4>
                    <pre><code>for (i = 0; i < n; i++) {
    a[i] = b[i] + c[i];
    d[i] = a[i] * 2;
}
</code></pre>
                    <p>Both operations run in a single loop, reducing overhead.</p>
                </article>

                <article>
                    <h4>Advantages of Loop Jamming</h4>
                    <ul>
                        <li>Fewer loop-control instructions</li>
                        <li>Better locality of reference (improved cache usage)</li>
                        <li>Reduced register pressure</li>
                    </ul>
                </article>

                <article>
                    <h4>When to Use Loop Jamming</h4>
                    <ul>
                        <li>Loops must share the same iteration range</li>
                        <li>Loop bodies must be independent or safely ordered</li>
                    </ul>
                </article>

                <article>
                    <h4>Conclusion</h4>
                    <p>Loop Jamming merges loops with identical ranges to cut overhead and boost performance, making it a key compiler optimization for array-based computations.</p>
                </article>


            </article>
            <article>


                <article>
                    <h3 class="text-center">Peephole Optimization</h3>
                    <p>Peephole Optimization is a local code optimization technique where the compiler examines a small window (“peephole”) of consecutive instructions and replaces inefficient patterns with better ones.</p>
                </article>

                <article>
                    <h4>Key Idea</h4>
                    <ul>
                        <li>Inspect a few instructions at a time</li>
                        <li>Replace unnecessary or slow code with faster, smaller alternatives</li>
                    </ul>
                </article>

                <article>
                    <h4>Types of Peephole Optimizations</h4>
                    <h5>Redundant Instruction Elimination</h5>
                    <pre><code>MOV R1, R2
MOV R2, R1   → REMOVE second instruction
</code></pre>

                    <h5>Algebraic Simplification</h5>
                    <pre><code>MUL R1, 2  → Replace with: ADD R1, R1
</code></pre>

                    <h5>Strength Reduction</h5>
                    <pre><code>MUL R1, 8  → Replace with: SHL R1, 3  (shift left by 3)
</code></pre>

                    <h5>Unreachable Code Removal</h5>
                    <pre><code>GOTO L1
...
L1:  → REMOVE code between GOTO and L1
</code></pre>

                    <h5>Jump Optimization</h5>
                    <pre><code>GOTO L1
L1: ...    → REMOVE GOTO, let control fall through naturally
</code></pre>
                </article>

                <article>
                    <h4>Example (Before Optimization)</h4>
                    <pre><code>
MOV A, B
MOV B, A   → Both instructions cancel each other, so can be removed
</code></pre>
                </article>

                <article>
                    <h4>Why It’s Called “Peephole”?</h4>
                    <p>The compiler “peeks” through a small window of instructions (the peephole) to apply local improvements.</p>
                </article>

                <article>
                    <h4>Conclusion</h4>
                    <p>Peephole Optimization performs fast, localized cleanup of generated code by simplifying small instruction sequences, enhancing performance and reducing code size just before final code generation.</p>
                </article>

            </article>
            <article>


                <article>
                    <h3 class="text-center">Issues in the Design of Code Generator</h3>
                    <p>A code generator is the part of a compiler that converts intermediate code into machine code or assembly code. Designing an efficient code generator involves addressing several key issues to ensure correct, fast, and optimized output.</p>
                </article>

                <article>
                    <h4>Input to the Code Generator</h4>
                    <ul>
                        <li>Must handle the correct intermediate representation (e.g., three-address code, DAG)</li>
                        <li>Should support all language constructs (loops, conditions, function calls, etc.)</li>
                    </ul>
                </article>

                <article>
                    <h4>Target Program Generation</h4>
                    <ul>
                        <li>Generate correct and efficient machine instructions</li>
                        <li>Adhere to the target architecture’s features (registers, addressing modes, calling conventions)</li>
                    </ul>
                </article>

                <article>
                    <h4>Instruction Selection</h4>
                    <ul>
                        <li>Choose the best machine instruction for each intermediate operation</li>
                        <li>For example, prefer <code>INC X</code> instead of <code>ADD X, 1</code> when supported</li>
                    </ul>
                </article>

                <article>
                    <h4>Register Allocation and Assignment</h4>
                    <ul>
                        <li>Map program variables to a limited set of CPU registers</li>
                        <li>Minimize memory accesses by keeping hot values in registers</li>
                        <li>Use spill code only when registers are exhausted</li>
                    </ul>
                </article>

                <article>
                    <h4>Evaluation Order</h4>
                    <ul>
                        <li>Determine the sequence in which subexpressions are evaluated</li>
                        <li>Respect operator precedence and associativity</li>
                        <li>Aim to minimize register pressure and instruction dependencies</li>
                    </ul>
                </article>

                <article>
                    <h4>Handling of Subscripts and Addressing</h4>
                    <ul>
                        <li>Generate efficient code for array accesses, pointers, and structure fields</li>
                        <li>Compute memory addresses correctly using base, index, and offset calculations</li>
                    </ul>
                </article>

                <article>
                    <h4>Code Generator Efficiency</h4>
                    <ul>
                        <li>Produce short code (fewer instructions)</li>
                        <li>Produce fast code (fewer CPU cycles)</li>
                        <li>Avoid unnecessary instructions and redundancies</li>
                    </ul>
                </article>

                <article>
                    <h4>Machine Independence</h4>
                    <ul>
                        <li>Design the generator to be adaptable to different target machines</li>
                        <li>Isolate machine-specific details to allow retargeting with minimal changes</li>
                    </ul>
                </article>

                <article>
                    <h4>Conclusion</h4>
                    <p>Effective code generator design requires careful handling of input representations, instruction selection, register management, evaluation order, and target-specific constraints. The ultimate goal is to produce correct, optimized machine code that fully utilizes the target architecture’s capabilities.</p>
                </article>

            </article>
            <article>


                <article>
                    <h3 class="text-center">A Simple Code Generator</h3>
                    <p>A simple code generator is a basic compiler component that converts intermediate code (like Three Address Code) into target machine code or assembly instructions. It operates under assumptions of unlimited registers, minimal register management, and fixed instruction formats.</p>
                </article>

                <article>
                    <h4>Input</h4>
                    <p>Three Address Code (TAC) of the form:</p>
                    <pre><code>x = y op z</code></pre>
                </article>

                <article>
                    <h4>Output</h4>
                    <p>Machine instructions or assembly code corresponding to each TAC statement.</p>
                </article>

                <article>
                    <h4>Example</h4>
                    <p><strong>Given TAC:</strong></p>
                    <pre><code>t1 = a + b
t2 = t1 * c
d  = t2
</code></pre>
                    <p><strong>Generated Assembly-like Code:</strong></p>
                    <pre><code>MOV R1, a      ; Load a into R1
ADD R1, b      ; R1 = a + b
MOV R2, R1     ; Copy result to R2
MUL R2, c      ; R2 = (a + b) * c
MOV d, R2      ; Store final result in d
</code></pre>
                </article>

                <article>
                    <h4>Steps in a Simple Code Generator</h4>
                    <ol>
                        <li><strong>Instruction Selection</strong>: Choose the appropriate machine instruction for each TAC operation.</li>
                        <li><strong>Operand Handling</strong>: Load operands into registers if necessary.</li>
                        <li><strong>Instruction Emission</strong>: Output the final machine instruction in the correct syntax.</li>
                    </ol>
                </article>

                <article>
                    <h4>Assumptions</h4>
                    <ul>
                        <li>Unlimited registers are available.</li>
                        <li>No need for register spilling or complex allocation.</li>
                        <li>No advanced optimizations are performed.</li>
                    </ul>
                </article>

                <article>
                    <h4>Conclusion</h4>
                    <p>A simple code generator directly translates each TAC statement into equivalent machine code, serving as the foundational step before implementing register allocation and further optimizations in a full compiler.</p>
                </article>

            </article>
            <article>


                <article>
                    <h3 class="text-center">Register Allocation and Assignment</h3>
                    <p>Register Allocation and Assignment is the process by which the compiler manages the limited number of CPU registers during machine code generation to minimize memory access and improve performance.</p>
                </article>

                <article>
                    <h4>Register Allocation</h4>
                    <p>Decides which variables or values should be kept in registers.</p>
                    <ul>
                        <li>Goal: Minimize memory access by keeping frequently used values in registers.</li>
                    </ul>
                </article>

                <article>
                    <h4>Register Assignment</h4>
                    <p>Chooses which specific register (e.g., R1, R2) is assigned to each allocated variable or value, based on availability.</p>
                </article>

                <article>
                    <h4>Why It Is Needed</h4>
                    <ul>
                        <li>Registers are very fast but limited in number.</li>
                        <li>Effective allocation and assignment make code faster and smaller.</li>
                    </ul>
                </article>

                <article>
                    <h4>Example</h4>
                    <p><strong>Given TAC:</strong></p>
                    <pre><code>t1 = a + b
t2 = t1 * c
d  = t2
</code></pre>
                    <p><strong>Assuming only 2 registers (R1 and R2):</strong></p>
                    <pre><code>MOV R1, a
ADD R1, b      ; t1 in R1
MOV R2, c
MUL R1, R2     ; t2 in R1
MOV d, R1
</code></pre>
                    <p>Here, <code>t1</code> and <code>t2</code> share <code>R1</code>, and <code>c</code> is loaded into <code>R2</code> for the multiplication.</p>
                </article>

                <article>
                    <h4>Techniques Used</h4>
                    <ul>
                        <li><strong>Graph Coloring Algorithm</strong>
                            <ul>
                                <li>Variables are nodes; an edge connects simultaneously live variables.</li>
                                <li>Registers correspond to colors; color the graph with the minimum number of colors.</li>
                            </ul>
                        </li>
                        <li><strong>Live Variable Analysis</strong>
                            <ul>
                                <li>Determines which variables are active (“live”) at each program point.</li>
                            </ul>
                        </li>
                    </ul>
                </article>

                <article>
                    <h4>Challenges</h4>
                    <ul>
                        <li>Limited register count.</li>
                        <li>Conflicts due to overlapping variable lifetimes.</li>
                        <li>Need for <strong>spilling</strong>: storing registers to memory when registers are exhausted.</li>
                    </ul>
                </article>

                <article>
                    <h4>Conclusion</h4>
                    <p>Register Allocation determines which variables stay in registers, and Register Assignment maps them to specific registers. Together, they reduce memory accesses and enhance final code performance.</p>
                </article>

            </article>
            <article>


                <article>
                    <h3 class="text-center">Context-Free Grammar (CFG)</h3>
                    <p>A Context-Free Grammar (CFG) is a formal grammar used to describe the syntax of programming languages. It defines rules that specify how valid strings (statements) in a language are formed.</p>
                </article>

                <article>
                    <h4>Definition of CFG</h4>
                    <p>A CFG is defined as a 4-tuple: <strong>G = (V, T, P, S)</strong>, where:</p>
                    <ul>
                        <li><strong>V</strong>: Set of variables (non-terminals)</li>
                        <li><strong>T</strong>: Set of terminals (language symbols)</li>
                        <li><strong>P</strong>: Set of production rules</li>
                        <li><strong>S</strong>: Start symbol</li>
                    </ul>
                </article>

                <article>
                    <h4>Structure of Production Rules</h4>
                    <p>Each production has the form:</p>
                    <pre><code>A → α</code></pre>
                    <p>Where:</p>
                    <ul>
                        <li><strong>A</strong> is a non-terminal</li>
                        <li><strong>α</strong> is a string of terminals and/or non-terminals</li>
                    </ul>
                </article>

                <article>
                    <h4>Example Grammar</h4>
                    <p>CFG for simple arithmetic expressions:</p>
                    <pre><code>E → E + T | T  
T → T * F | F  
F → ( E ) | id
</code></pre>
                    <ul>
                        <li>Terminals: <code>+</code>, <code>*</code>, <code>(</code>, <code>)</code>, <code>id</code></li>
                        <li>Non-terminals: <code>E</code>, <code>T</code>, <code>F</code></li>
                        <li>Start symbol: <code>E</code></li>
                    </ul>
                </article>

                <article>
                    <h4>Example String</h4>
                    <p>The string <code>id + id * id</code> is generated by this CFG and is valid according to its rules.</p>
                </article>

                <article>
                    <h4>Use of CFG in Compiler Design</h4>
                    <ul>
                        <li>Describes the syntax of programming languages</li>
                        <li>Used in syntax analysis (parsing)</li>
                        <li>Helps build parse trees for validation</li>
                    </ul>
                </article>

                <article>
                    <h4>Conclusion</h4>
                    <p>Context-Free Grammars define how valid code is structured using production rules. They are essential for parsing and syntax checking in compilers, ensuring that programs follow the correct syntax.</p>
                </article>



        </main>

        <script> copyright("all"); </script>

    </body>

</html>