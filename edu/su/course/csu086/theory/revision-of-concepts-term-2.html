<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>

        <title>Revision of Concepts - Term 2 - CSU086 - Shoolini U</title>
        <meta name="description" content="A comprehensive, student-friendly guide covering recursive grammars, parsing techniques (LL(1), Top-Down, Bottom-Up), handling recursion, non-determinism, and parse table construction. Includes detailed explanations with examples, step-by-step derivation, and simplification for academic revision.">

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "TechArticle",
  "headline": "Term 2 Revision",
  "description": "A comprehensive, student-friendly guide covering recursive grammars, parsing techniques (LL(1), Top-Down, Bottom-Up), handling recursion, non-determinism, and parse table construction. Includes detailed explanations with examples, step-by-step derivation, and simplification for academic revision.",
  "dateModified": "2025-04-06",
  "author": [
    {
      "@type": "Person",
      "name": "Divya Mohan",
      "url": "https://dmj.one/resume/",
      "sameAs": [
        "https://www.credly.com/users/divyamohan1993",
        "https://www.linkedin.com/in/divyamohan1993/",
        "https://hackerrank.com/divyamohan1993",
        "https://www.coursera.org/learner/divyamohan1993"
      ]
    }
  ],
  "publisher": {
    "@type": "EducationalOrganization",
    "name": "dmj.one",
    "url": "https://dmj.one"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://dmj.one/edu/su/course/csu086/theory/revision-of-concepts-term-2"
  },
  "keywords": [
    "LL(1) Parser",
    "Recursive Grammar",
    "Left Recursion",
    "Right Recursion",
    "Indirect Recursion",
    "Left Factoring",
    "FIRST and FOLLOW Sets",
    "Top-Down Parser",
    "Bottom-Up Parser",
    "Parse Table",
    "Compiler Design",
    "Determinism in Grammar",
    "Non-Determinism",
    "Recursive Descent Parser"
  ],
  "articleSection": [
    "Recursive Grammars",
    "Left and Right Recursion",
    "Indirect Recursion and Handling",
    "Determinism vs Non-Determinism",
    "Parser and Parser Architecture",
    "Top-Down and Bottom-Up Parsers",
    "Recursive Descent and LL(1)",
    "FIRST() and FOLLOW() Sets",
    "Parse Table Construction",
    "LL(1) Conditions and Derivation Proof"
  ],
  "isAccessibleForFree": true,
  "inLanguage": "en-US",
  "license": "https://www.gnu.org/licenses/agpl-3.0.en.html"
}
</script>


        <meta name="author" content="Divya Mohan">
        <meta name="robots" content="index, follow">

        <!-- Open Graph for Social Media -->
        <meta property="og:image" content="/logo.png">
        <meta property="og:type" content="article">

        <!-- Twitter Cards -->
        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@divyamohan1993">
        <meta name="twitter:creator" content="@divyamohan1993">
        <meta name="twitter:image" content="/logo.png">

        <!-- Mobile Responsiveness -->
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                renderMathInElement(document.body, {
                    // customised options
                    // • auto-render specific keys, e.g.:
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\(', right: '\\)', display: false },
                        { left: '\\[', right: '\\]', display: true }
                    ],
                    // • rendering keys, e.g.:
                    throwOnError: false
                });
            });
        </script> -->

        <!-- <style>
            main ul {
                list-style-type: none;
                padding: 0;
                margin: 0;
            }

            main ul li {
                margin: 0;
                padding: 0;
            }
        </style> -->

        <style>
            @media screen {
                h3 {
                    color: red;
                    text-transform: uppercase;
                }
            }
        </style>




    </head>

    <body>

        <script> header_author("dm"); </script>

        <main>
            <article class="agen-tableofcontents">
                <h2 class="text-center">
                    Revision of Concepts - Term 2
                </h2>
                <div class="d-none contentdate">2025, April 6</div>
            </article>

            <article>                
                <div class="mt-3 d-flex flex-wrap gap-2 justify-content-center">
                    <a href="first-follow-leftfactoring-parsetable" target="_blank" class="btn btn-outline-warning d-flex align-items-center gap-2">
                        <i class="bi bi-book"></i> Revise Examples
                    </a>
                    <a href="term-2-set-1" target="_blank" class="btn btn-outline-warning d-flex align-items-center gap-2">
                        <i class="bi bi-journal-text"></i> Term 2 - Set 1
                    </a>
                    <a href="term-2-set-2" target="_blank" class="btn btn-outline-info d-flex align-items-center gap-2">
                        <i class="bi bi-journal-check"></i> Term 2 - Set 2
                    </a>
                    <a href="term-2-set-3" target="_blank" class="btn btn-outline-success d-flex align-items-center gap-2">
                        <i class="bi bi-journal-richtext"></i> Term 2 - Set 3
                    </a>
                    <a href="term-2-set-4" target="_blank" class="btn btn-outline-danger d-flex align-items-center gap-2">
                        <i class="bi bi-journal-code"></i> Term 2 - Set 4
                    </a>
                </div>
            </article>

            <article>
                <h3 class="text-center fw-bold">Recursive Grammars</h3>
                <article>
                    <p>A <strong>recursive grammar</strong> is a grammar where <strong>a non-terminal calls itself</strong> directly or indirectly in its production rules.</p>
                    <p>It's like a function calling itself to repeat a pattern.</p>
                </article>

                <article>
                    <h4>Why recursion?</h4>
                    <p>Recursion in grammar helps us <strong>represent repetition</strong> – like a list, nested expressions, or loops.</p>
                </article>

                <article>
                    <h4>Types of Recursion:</h4>

                    <h5>1. <strong>Left Recursion</strong> ❌ (bad for LL(1))</h5>
                    <pre><code class="">
A → A α | β
</code></pre>
                    <p>Here, <code>A</code> appears on the <strong>leftmost side</strong> → leads to infinite loop in <strong>Top-Down Parsers</strong></p>
                    <p><strong>Example:</strong></p>
                    <pre><code class="">
E → E + T | T
</code></pre>

                    <h5>2. <strong>Right Recursion</strong> ✅ (safe for LL(1))</h5>
                    <pre><code class="">
A → β A | ε
</code></pre>
                    <p>Or,</p>
                    <pre><code class="">
A → a A | a
</code></pre>
                    <p>Here, recursion happens on the <strong>right side</strong>. Works well with LL(1).</p>
                    <p><strong>Example:</strong></p>
                    <pre><code class="">
L → id , L | id
</code></pre>

                    <h5>3. <strong>Indirect Recursion</strong></h5>
                    <pre><code class="">
A → B α  
B → A β
</code></pre>
                    <p>Still recursive, but <strong>through another non-terminal</strong>.</p>
                </article>

                <article>
                    <h4>How to Handle Recursive Grammars?</h4>
                    <div class="table-responsive">
                        <table class="table table-bordered table-striped">
                            <thead>
                                <tr>
                                    <th>Type</th>
                                    <th>Action Needed</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Left Recursion</td>
                                    <td>Remove it</td>
                                </tr>
                                <tr>
                                    <td>Right Recursion</td>
                                    <td>Keep it, LL(1) friendly</td>
                                </tr>
                                <tr>
                                    <td>Indirect</td>
                                    <td>Rewrite to remove left recursion</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </article>

                <article>
                    <h4>Remove Left Recursion</h4>
                    <p>Given:</p>
                    <pre><code class="">
A → A α | β
</code></pre>
                    <p>Convert to:</p>
                    <pre><code class="">
A  → β A'
A' → α A' | ε
</code></pre>

                    <p><strong>Example:</strong></p>
                    <pre><code class="">
Expr → Expr + Term | Term  
→ becomes:  
Expr → Term Expr'  
Expr' → + Term Expr' | ε
</code></pre>
                </article>

                <article>
                    <h4>Summary:</h4>
                    <ul>
                        <li><strong>Recursive Grammar</strong> = Grammar that repeats patterns using itself</li>
                        <li><strong>Left Recursion</strong> = bad for LL(1) → needs fixing</li>
                        <li><strong>Right Recursion</strong> = good for LL(1)</li>
                        <li>Needed for things like lists, loops, expressions</li>
                    </ul>
                    <p>Think of it like a <strong>mirror reflecting itself</strong> – grammar using its own name to define a repeating structure.</p>
                </article>
            </article>

            <article>
                <h3 class="text-center fw-bold">Left Recursive Grammar</h3>
                <article>
                    <p>A <strong>Left Recursive Grammar</strong> is when a <strong>non-terminal calls itself on the leftmost side</strong> of its production.</p>
                </article>

                <article>
                    <h4>Rule:</h4>
                    <p>A grammar is <strong>left recursive</strong> if:</p>
                    <pre><code class="">
A → A α
</code></pre>
                    <p>Here, <code>A</code> appears again at the start of the right-hand side.</p>
                </article>

                <article>
                    <h4>Why it's a problem?</h4>
                    <p>Top-Down Parsers like <strong>LL(1)</strong> use recursion.<br>
                        So left recursion causes <strong>infinite loops</strong>.</p>

                    <p><strong>Example:</strong></p>
                    <pre><code class="">
E → E + T | T
</code></pre>
                    <p>Trying to parse <code>E</code> → again <code>E</code> → again <code>E</code> → 💥 infinite recursion!</p>
                </article>

                <article>
                    <h4>How to Fix It?</h4>
                    <p>We <strong>remove left recursion</strong> using this method:</p>

                    <p><strong>Given:</strong></p>
                    <pre><code class="">
A → A α | β
</code></pre>

                    <p><strong>Convert to:</strong></p>
                    <pre><code class="">
A  → β A'
A' → α A' | ε
</code></pre>
                </article>

                <article>
                    <h4>Example:</h4>

                    <p><strong>Original (Left Recursive):</strong></p>
                    <pre><code class="">
E → E + T | T
</code></pre>

                    <p><strong>Fixed (No Left Recursion):</strong></p>
                    <pre><code class="">
E  → T E'
E' → + T E' | ε
</code></pre>

                    <p>Now it's <strong>LL(1)-friendly</strong> ✅</p>
                </article>

                <article>
                    <h4>Indirect Left Recursion:</h4>
                    <p>Sometimes recursion goes through other non-terminals:</p>
                    <pre><code class="">
A → B α  
B → A β
</code></pre>
                    <p>Still left recursive, must be detected and removed.</p>
                </article>

                <article>
                    <h4>Summary:</h4>
                    <ul>
                        <li><strong>Left Recursive:</strong> <code>A → A α</code></li>
                        <li>Causes <strong>infinite loop</strong> in top-down parsers</li>
                        <li>Must be removed for <strong>LL(1)</strong></li>
                        <li>Replace with <strong>right recursion</strong> using helper non-terminal (<code>A'</code>)</li>
                    </ul>
                    <p>Think of it like <strong>a person stuck in a loop talking to themselves</strong> – we break the loop by changing the sentence structure.</p>
                </article>
            </article>

            <article>
                <article>
                    <h3 class="text-center fw-bold">Right Recursive Grammar</h3>
                    <p>A <strong>Right Recursive Grammar</strong> is when a <strong>non-terminal calls itself on the rightmost side</strong> of its production.</p>
                </article>

                <article>
                    <h4>Rule:</h4>
                    <p>A grammar is <strong>right recursive</strong> if:</p>
                    <pre><code class="">
A → α A
</code></pre>
                    <p>Here, the non-terminal <code>A</code> comes <strong>at the end</strong> of the right-hand side.</p>
                </article>

                <article>
                    <h4>Why it's GOOD?</h4>
                    <ul>
                        <li><strong>Works perfectly</strong> with <strong>Top-Down Parsers</strong> (like LL(1))</li>
                        <li><strong>No infinite loop</strong></li>
                        <li>Safe and easy to implement</li>
                    </ul>
                </article>

                <article>
                    <h4>Example:</h4>
                    <pre><code class="">
L → id , L | id
</code></pre>
                    <p>This generates:</p>
                    <pre><code class="">
id
id , id
id , id , id
</code></pre>
                    <p>It's right-recursive because <code>L</code> calls itself at the end → <code>id , L</code></p>
                </article>

                <article>
                    <h4>How it Parses?</h4>
                    <p>For input: <code>id , id , id</code></p>
                    <p>It builds tree <strong>from left to right</strong>, like a queue.</p>
                </article>

                <article>
                    <h4>Limitation (for Bottom-Up):</h4>
                    <ul>
                        <li>In <strong>Bottom-Up Parsers</strong>, right recursion can cause deep stacks.</li>
                        <li>For very long expressions, it might be inefficient.</li>
                    </ul>
                </article>

                <article>
                    <h4>Summary:</h4>
                    <ul>
                        <li><strong>Right Recursive</strong>: <code>A → α A</code></li>
                        <li><strong>Safe</strong> for LL(1)</li>
                        <li>Best for <strong>lists, sequences</strong> like: <code>id, id, id</code></li>
                        <li>Preferred in <strong>top-down parsing</strong></li>
                    </ul>
                    <p>Think of it like a <strong>train adding coaches one by one at the end</strong> – smooth, expandable, and predictable.</p>
                </article>
            </article>

            <article>
                <h3 class="text-center fw-bold">Non-Determinism in Grammar</h3>
                <article>
                    <p><strong>Non-Determinism</strong> means the parser <strong>can't decide which rule to apply</strong> just by looking at the next input symbol.</p>
                </article>

                <article>
                    <h4>What It Is:</h4>
                    <p>A grammar is <strong>non-deterministic</strong> if for a non-terminal <code>A</code>:</p>
                    <pre><code class="">
A → α | β
</code></pre>
                    <p>and</p>
                    <pre><code class="">
FIRST(α) ∩ FIRST(β) ≠ ∅
</code></pre>
                    <p>→ So the parser <strong>gets confused</strong> which rule to choose with one lookahead.</p>
                </article>

                <article>
                    <h4>Example:</h4>
                    <pre><code class="">
S → i E t S | i E t S e S | a
</code></pre>
                    <p>Start with <code>i</code> → Which rule?<br>Both start with <code>i E t S</code>
                        → <strong>Parser is confused</strong>: should I use rule 1 or rule 2?</p>
                    <p>This is <strong>non-determinism</strong>.</p>
                </article>

                <article>
                    <h4>Why It's a Problem:</h4>
                    <ul>
                        <li><strong>LL(1) parser</strong> needs <strong>exact one rule per input symbol</strong></li>
                        <li>Non-deterministic grammar needs <strong>backtracking</strong> or <strong>more lookahead</strong></li>
                    </ul>
                </article>

                <article>
                    <h4>How to Fix It?</h4>
                    <p>→ <strong>Left Factoring</strong>!</p>
                    <p><strong>Example:</strong></p>
                    <pre><code class="">
S → i E t S | i E t S e S
</code></pre>

                    <p><strong>Becomes:</strong></p>
                    <pre><code class="">
S → i E t S S'
S' → e S | ε
</code></pre>

                    <p>Now:</p>
                    <ul>
                        <li>On input <code>i</code> → only 1 choice</li>
                        <li>After <code>t S</code>, parser waits for <code>e</code> or end</li>
                    </ul>

                    <p>✅ Now it's <strong>deterministic</strong></p>
                </article>

                <article>
                    <h4>Summary:</h4>
                    <ul>
                        <li><strong>Non-Determinism</strong> = Parser <strong>can't decide</strong> next rule with 1 lookahead</li>
                        <li>Happens when <strong>multiple rules start similarly</strong></li>
                        <li>Fix using <strong>Left Factoring</strong></li>
                        <li><strong>LL(1)</strong> <em>requires deterministic grammar</em></li>
                    </ul>
                    <p>Think of it like <strong>a fork in the road</strong> where signs are missing — parser doesn't know which path to take unless you clarify.</p>
                </article>
            </article>

            <article>
                <h3 class="text-center fw-bold">Determinism in Grammar</h3>
                <article>
                    <p><strong>Determinism</strong> means the parser can <strong>always decide</strong> what to do next using <strong>only 1 lookahead symbol</strong> — no guessing, no confusion.</p>
                </article>

                <article>
                    <h4>What It Is:</h4>
                    <p>A grammar is <strong>deterministic</strong> if:</p>
                    <ul>
                        <li>For any non-terminal <code>A</code> with rules <code>A → α | β</code>,</li>
                        <li><code>FIRST(α) ∩ FIRST(β) = ∅</code></li>
                    </ul>
                    <p>Also, if <code>ε ∈ FIRST(α)</code>, then:</p>
                    <p><code>FIRST(β) ∩ FOLLOW(A) = ∅</code></p>
                </article>

                <article>
                    <h4>Example (Deterministic):</h4>
                    <pre><code class="">
S → a A | b B  
A → x  
B → y
</code></pre>
                    <p>
                    <ul>
                        <li><code>a</code> leads to <code>A</code></li>
                        <li><code>b</code> leads to <code>B</code></li>
                        <li>→ No confusion → <strong>Deterministic ✅</strong></li>
                    </ul>
                    </p>
                </article>

                <article>
                    <h4>Counter Example (Non-Deterministic):</h4>
                    <pre><code class="">
S → a A | a B
</code></pre>
                    <p>Both rules start with <code>a</code> → Parser can't decide
                        → <strong>Non-Deterministic ❌</strong></p>
                </article>

                <article>
                    <h4>How to Ensure Determinism:</h4>
                    <ul>
                        <li><strong>Remove left recursion</strong></li>
                        <li><strong>Left factor the grammar</strong></li>
                        <li>Use <strong>FIRST and FOLLOW sets</strong> to check</li>
                    </ul>
                </article>

                <article>
                    <h4>Summary:</h4>
                    <ul>
                        <li><strong>Determinism</strong> = Parser knows exactly what to do next</li>
                        <li>No backtracking, no multiple choices</li>
                        <li><strong>LL(1)</strong> parsers need deterministic grammars</li>
                        <li>Ensures <strong>fast and correct parsing</strong></li>
                    </ul>
                    <p>Think of it like a <strong>GPS with only one correct route</strong> — no confusion, just follow the sign.</p>
                </article>
            </article>

            <article>
                <h3 class="text-center fw-bold">Left Factoring</h3>
                <article>
                    <p><strong>Left Factoring</strong> is a technique to <strong>remove confusion</strong> when two or more productions <strong>start the same</strong> — making the grammar <strong>deterministic</strong> and LL(1)-friendly.</p>
                </article>

                <article>
                    <h4>Why do it?</h4>
                    <p>When a parser sees:</p>
                    <pre><code class="">
A → α β1 | α β2
</code></pre>
                    <p>It gets confused after reading <code>α</code>.
                        <strong>Which rule to pick?</strong> → Parser <strong>can't decide</strong>
                    </p>
                    <p>❌ <strong>Non-Deterministic</strong></p>
                </article>

                <article>
                    <h4>Fix using Left Factoring:</h4>
                    <p>Take common part <code>α</code> out:</p>
                    <pre><code class="">
A → α A'
A' → β1 | β2
</code></pre>
                    <p>Now parser sees <code>α</code>, picks <code>A → α A'</code> Then decides between <code>β1</code> and <code>β2</code> later ✅ <strong>Deterministic</strong></p>
                </article>

                <article>
                    <h4>Example:</h4>
                    <p><strong>Original (Non-LL(1)):</strong></p>
                    <pre><code class="">
S → if E then S else S | if E then S
</code></pre>
                    <p>Parser sees <code>if</code> — gets confused</p>

                    <p><strong>Left Factored:</strong></p>
                    <pre><code class="">
S  → if E then S S'
S' → else S | ε
</code></pre>
                    <p>Now only one rule for <code>if</code>, rest handled later ✅</p>
                </article>

                <article>
                    <h4>Another Example:</h4>
                    <pre><code class="">
A → int id ; | int id = num ;
</code></pre>
                    <p>Both start with <code>int id</code></p>

                    <p><strong>Left Factored:</strong></p>
                    <pre><code class="">
A  → int id A'
A' → ; | = num ;
</code></pre>
                    <p>✅ LL(1)-friendly</p>
                </article>

                <article>
                    <h4>Summary:</h4>
                    <ul>
                        <li><strong>Left Factoring</strong> removes common prefixes</li>
                        <li>Helps parser <strong>choose only 1 rule</strong> with 1 token</li>
                        <li>Makes grammar <strong>deterministic</strong></li>
                        <li>Essential for <strong>LL(1) Parsing</strong></li>
                    </ul>
                    <p>Think of it like <strong>grouping common words</strong> in two sentences to remove repetition and confusion.</p>
                </article>
            </article>

            <article>
                <h3 class="text-center fw-bold">Parser</h3>
                <article>
                    <h4>Definition:</h4>
                    <p>A <strong>Parser</strong> is a program that takes a sequence of tokens (from a lexer) and <strong>checks if they follow the rules</strong> of a programming language and <strong>builds a structure</strong> (like a tree) from it.</p>
                </article>

                <article>
                    <h4>Simple Explanation</h4>
                    <p>Imagine you're checking if a sentence in English makes sense.</p>
                    <ul>
                        <li>✅ "I eat apples." – Correct.</li>
                        <li>❌ "Eat I apples." – Wrong grammar.</li>
                    </ul>
                    <p>Similarly, in programming:</p>
                    <ul>
                        <li>✅ <code>if (x &gt; 0) { y = x; }</code> – Correct.</li>
                        <li>❌ <code>if x &gt; 0 { y = x; }</code> – Wrong syntax.</li>
                    </ul>
                    <p>A <strong>Parser</strong> reads this and checks <strong>grammar rules of programming</strong> (defined by a CFG – Context Free Grammar). If the code is correct, it <strong>builds a parse tree</strong> (like a diagram) showing how the sentence follows the rules.</p>
                </article>

                <article>
                    <h4>Parser Works in 2 Phases:</h4>
                    <ul>
                        <li><strong>Syntax Analyzer</strong> – Checks rules.</li>
                        <li><strong>Parse Tree Generator</strong> – Builds tree.</li>
                    </ul>
                </article>

                <article>
                    <h4>Types of Parsers (Easy):</h4>
                    <div class="table-responsive">
                        <table class="table table-bordered table-striped">
                            <thead>
                                <tr>
                                    <th>Type</th>
                                    <th>How it Works</th>
                                    <th>Example</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>Top-Down Parser</strong></td>
                                    <td>Starts from the top rule & goes down.</td>
                                    <td>LL(1)</td>
                                </tr>
                                <tr>
                                    <td><strong>Bottom-Up Parser</strong></td>
                                    <td>Starts from input & goes up to rules.</td>
                                    <td>LR(0), SLR, CLR, LALR</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </article>

                <article>
                    <h4>Real-Life Example:</h4>
                    <p>You type:</p>
                    <pre><code class="language-c">int a = b + 2;</code></pre>
                    <p>1. <strong>Lexer</strong>: Breaks into tokens → <code>int</code>, <code>a</code>, <code>=</code>, <code>b</code>, <code>+</code>, <code>2</code>, <code>;</code><br>
                        2. <strong>Parser</strong>: Says → "Hmm... this matches the rule: <em>declaration → type id = expression;</em>" ✔️</p>

                    <p>If you typed:</p>
                    <pre><code class="language-c">int = b + 2 a;</code></pre>
                    <p>The parser says: ❌ Error! "This does NOT follow the grammar rules."</p>
                </article>

                <article>
                    <h4>Output of Parser:</h4>
                    <p>A <strong>Parse Tree</strong> or <strong>Syntax Tree</strong> like:</p>
                    <pre><code class="">.

        =
      /   \
   a      +
         / \
       b   2
</code></pre>
                    <p>This is then used by the next compiler stages like semantic analysis and code generation.</p>
                </article>

                <article>
                    <h4>Final Words:</h4>
                    <ul>
                        <li>Parser = <strong>Grammar Checker</strong> of code.</li>
                        <li>It reads tokens, follows grammar, and builds a tree.</li>
                        <li>If rules are violated, it throws errors.</li>
                    </ul>
                    <p>You can think of it as the <strong>"English teacher of programming languages."</strong></p>
                </article>
            </article>

            <article>
                <h3 class="text-center fw-bold">Architecture of a Parser</h3>
                <article>

                    <p>Think of a parser like a <strong>traffic inspector</strong>. Tokens (words) from the lexer are like cars coming in — the parser checks if they are in the <strong>right order</strong> and <strong>follow rules</strong>.</p>
                </article>

                <article>
                    <h4>Basic Architecture:</h4>
                    <pre><code class="">
+------------------+
|   Source Code    |
+--------+---------+
         |
         v
+------------------+
|      Lexer       |  → Breaks into tokens
+--------+---------+
         |
         v
+------------------+
|      Parser      |  → Builds structure from tokens
+--------+---------+
         |
+--------+--------+
|   Parse Tree    |
+-----------------+
</code></pre>
                </article>

                <article>
                    <h4>Inside the Parser:</h4>
                    <p>The parser has two main parts:</p>

                    <h5>1. <strong>Grammar Rules (CFG)</strong></h5>
                    <ul>
                        <li>Written by compiler designer.</li>
                        <li>Example: <code>E → E + T | T</code></li>
                    </ul>

                    <h5>2. <strong>Parsing Algorithm</strong></h5>
                    <ul>
                        <li>Takes tokens + grammar, decides:</li>
                        <li>Valid or invalid?</li>
                        <li>If valid → build tree.</li>
                        <li>If invalid → show error.</li>
                    </ul>
                </article>

                <article>
                    <h4>Components of Parser:</h4>
                    <div class="table-responsive">
                        <table class="table table-bordered table-striped">
                            <thead>
                                <tr>
                                    <th>Component</th>
                                    <th>Function</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>Input Buffer</strong></td>
                                    <td>Holds tokens from lexer.</td>
                                </tr>
                                <tr>
                                    <td><strong>Parsing Table</strong></td>
                                    <td>Guides decisions (for LL or LR parsers).</td>
                                </tr>
                                <tr>
                                    <td><strong>Stack</strong></td>
                                    <td>Holds symbols during parsing.</td>
                                </tr>
                                <tr>
                                    <td><strong>Parse Tree Builder</strong></td>
                                    <td>Constructs tree step-by-step.</td>
                                </tr>
                                <tr>
                                    <td><strong>Error Handler</strong></td>
                                    <td>Detects + manages syntax errors.</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </article>

                <article>
                    <h4>Control Flow:</h4>
                    <pre><code class="">
Tokens → [Parser Stack + Parsing Table] → Actions:
     ↳ Match, Expand rule, Shift, Reduce
     ↳ Build Parse Tree
     ↳ Throw Error (if rule mismatch)
</code></pre>
                </article>

                <article>
                    <h4>Example:</h4>
                    <p>Input code:</p>
                    <pre><code class="language-c">x = a + b * c;</code></pre>
                    <p>Steps:</p>
                    <ul>
                        <li>Lexer gives tokens: <code>id = id + id * id ;</code></li>
                        <li>Parser checks if they fit grammar like: <code>E → E + T → T * F ...</code></li>
                        <li>Builds parse tree accordingly.</li>
                    </ul>
                </article>

                <article>
                    <h4>Output:</h4>
                    <ul>
                        <li><strong>Parse Tree</strong> (full structure)</li>
                        <li>Or <strong>Abstract Syntax Tree (AST)</strong> (cleaned-up version)</li>
                        <li>If error → Error Message with line/column info</li>
                    </ul>
                </article>

                <article>
                    <h4>In short:</h4>
                    <p><strong>Parser</strong> = Brain of compiler that:</p>
                    <ul>
                        <li>Takes tokens.</li>
                        <li>Checks grammar rules.</li>
                        <li>Builds structure.</li>
                        <li>Reports error if syntax is broken.</li>
                    </ul>
                </article>
            </article>

            <article>
                <h3 class="text-center fw-bold">Top Down Parser</h3>
                <article>
                    <p>Imagine you're solving a puzzle <strong>starting from the big picture</strong> and filling in the pieces.</p>
                    <p>A <strong>Top-Down Parser</strong> starts from the <strong>start symbol (like "S")</strong> and tries to rewrite it into the <strong>input string</strong> using grammar rules.</p>
                </article>

                <article>
                    <h4>What it does:</h4>
                    <p>It tries to <em>predict</em> the structure of the input from the <strong>top of the parse tree to the bottom</strong>.</p>
                </article>

                <article>
                    <h4>Steps:</h4>
                    <ul>
                        <li>Start with <strong>Start Symbol</strong> (e.g. <code>S</code>)</li>
                        <li>Apply production rules to <strong>expand</strong> it</li>
                        <li>Match input tokens from left to right</li>
                        <li>Build the <strong>parse tree</strong> from <strong>top → down</strong></li>
                    </ul>
                </article>

                <article>
                    <h4>Example:</h4>
                    <p>Grammar:</p>
                    <pre><code class="">
E → T + E | T  
T → id
</code></pre>
                    <p>Input: <code>id + id</code></p>
                    <p>Parser does:</p>
                    <ul>
                        <li>Start with <code>E</code></li>
                        <li><code>E → T + E</code></li>
                        <li><code>T → id</code> ✅</li>
                        <li><code>+</code> ✅</li>
                        <li><code>E → T → id</code> ✅</li>
                    </ul>
                    <p>✔️ Matched!</p>
                </article>

                <article>
                    <h4>Types of Top Down Parsers:</h4>
                    <div class="table-responsive">
                        <table class="table table-bordered table-striped">
                            <thead>
                                <tr>
                                    <th>Type</th>
                                    <th>Key Idea</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>Recursive Descent</strong></td>
                                    <td>One function per rule. Simple, hand-coded.</td>
                                </tr>
                                <tr>
                                    <td><strong>Predictive Parser (LL(1))</strong></td>
                                    <td>Uses table and one symbol lookahead.</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </article>

                <article>
                    <h4>Recursive Descent Parser:</h4>
                    <p>Each rule is a <strong>function</strong>.</p>
                    <p>Example for <code>E → T + E | T</code>:</p>
                    <pre><code class="language-c">
void E() {
  T();
  if (nextToken == '+') {
    match('+');
    E();
  }
}
</code></pre>
                </article>

                <article>
                    <h4>LL(1) Parser:</h4>
                    <ul>
                        <li><strong>L</strong>: Left to right input</li>
                        <li><strong>L</strong>: Leftmost derivation</li>
                        <li><strong>1</strong>: 1 token lookahead</li>
                        <li>Uses <strong>Parsing Table</strong> to decide which rule to apply</li>
                        <li>More efficient, table-driven</li>
                    </ul>
                </article>

                <article>
                    <h4>Problems in Top Down Parsing:</h4>
                    <div class="table-responsive">
                        <table class="table table-bordered table-striped">
                            <thead>
                                <tr>
                                    <th>Problem</th>
                                    <th>Reason</th>
                                    <th>Fix</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>Left Recursion</strong></td>
                                    <td>e.g. A → Aα</td>
                                    <td>Remove or modify</td>
                                </tr>
                                <tr>
                                    <td><strong>Backtracking</strong></td>
                                    <td>Parser guesses wrong rule</td>
                                    <td>Predictive parsing (LL(1)) avoids this</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </article>

                <article>
                    <h4>Final Output:</h4>
                    <p>A <strong>Parse Tree</strong> from start to finish, top to bottom.</p>
                </article>

                <article>
                    <h4>Summary:</h4>
                    <ul>
                        <li><strong>Top Down Parser</strong> starts from start symbol, tries to rewrite it to match input.</li>
                        <li>Builds parse tree from <strong>top to down</strong>.</li>
                        <li>Easier to understand and implement.</li>
                        <li>Can be recursive (simple) or predictive (table-based).</li>
                    </ul>
                </article>
            </article>

            <article>
                <h3 class="text-center fw-bold">Bottom-Up Parser</h3>
                <article>
                    <p>Think of building a LEGO house by starting with <strong>blocks at the bottom</strong>, then joining them up to form bigger parts, finally forming the complete house (start symbol).</p>
                </article>

                <article>
                    <h4>What it does:</h4>
                    <p><strong>Bottom-Up Parser</strong> starts from the <strong>input (leaves)</strong> and tries to reach the <strong>Start Symbol</strong> by <strong>reducing</strong> the string using grammar rules.</p>
                </article>

                <article>
                    <h4>Steps:</h4>
                    <ul>
                        <li>Start with input tokens (e.g. <code>id + id * id</code>)</li>
                        <li>Match small parts → reduce them to grammar variables</li>
                        <li>Keep reducing until we get the <strong>Start Symbol</strong> (like <code>E</code>)</li>
                        <li>This gives a parse tree from <strong>bottom to top</strong></li>
                    </ul>
                </article>

                <article>
                    <h4>Example:</h4>
                    <p>Grammar:</p>
                    <pre><code class="">
E → E + T | T  
T → T * F | F  
F → id
</code></pre>
                    <p>Input: <code>id + id * id</code></p>
                    <p>Bottom-up Parser:</p>
                    <ul>
                        <li><code>id → F</code></li>
                        <li><code>F → T</code></li>
                        <li><code>id → F</code></li>
                        <li><code>F → T</code></li>
                        <li><code>T * T → T</code></li>
                        <li><code>T + T → E</code> ✅</li>
                    </ul>
                </article>

                <article>
                    <h4>Types of Bottom-Up Parsers:</h4>
                    <div class="table-responsive">
                        <table class="table table-bordered table-striped">
                            <thead>
                                <tr>
                                    <th>Parser Type</th>
                                    <th>Meaning</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>LR(0)</strong></td>
                                    <td>Simple, base version</td>
                                </tr>
                                <tr>
                                    <td><strong>SLR(1)</strong></td>
                                    <td>Simple LR, 1 lookahead</td>
                                </tr>
                                <tr>
                                    <td><strong>LALR(1)</strong></td>
                                    <td>Look-Ahead LR</td>
                                </tr>
                                <tr>
                                    <td><strong>CLR(1)</strong></td>
                                    <td>Canonical LR</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <p>These use <strong>parsing tables</strong> and <strong>shift-reduce stack</strong>.</p>
                </article>

                <article>
                    <h4>Actions of Bottom-Up Parser:</h4>
                    <div class="table-responsive">
                        <table class="table table-bordered table-striped">
                            <thead>
                                <tr>
                                    <th>Action</th>
                                    <th>Meaning</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>Shift</strong></td>
                                    <td>Push input symbol to stack</td>
                                </tr>
                                <tr>
                                    <td><strong>Reduce</strong></td>
                                    <td>Replace top of stack using grammar</td>
                                </tr>
                                <tr>
                                    <td><strong>Accept</strong></td>
                                    <td>Input matched correctly</td>
                                </tr>
                                <tr>
                                    <td><strong>Error</strong></td>
                                    <td>Syntax error</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </article>

                <article>
                    <h4>Why Compiler Prefers Bottom-Up Parsers:</h4>
                    <div class="table-responsive">
                        <table class="table table-bordered table-striped">
                            <thead>
                                <tr>
                                    <th>Reason</th>
                                    <th>Explanation</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>✅ <strong>Handles all CFGs</strong></td>
                                    <td>Even complex ones with left recursion</td>
                                </tr>
                                <tr>
                                    <td>✅ <strong>No backtracking</strong></td>
                                    <td>Fully table-driven, fast & efficient</td>
                                </tr>
                                <tr>
                                    <td>✅ <strong>More Powerful</strong></td>
                                    <td>Can parse more types of languages</td>
                                </tr>
                                <tr>
                                    <td>✅ <strong>Used in YACC/Bison</strong></td>
                                    <td>Industry tools like C/C++ compilers use it</td>
                                </tr>
                                <tr>
                                    <td>✅ <strong>Error Detection is Better</strong></td>
                                    <td>Finds syntax errors closer to actual issue</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </article>

                <article>
                    <h4>Summary:</h4>
                    <ul>
                        <li><strong>Bottom-Up Parser</strong> builds tree <strong>from leaves to root</strong></li>
                        <li>Uses <strong>shift & reduce</strong> actions with a <strong>stack</strong></li>
                        <li>Preferred by compilers because:</li>
                        <ul>
                            <li>More powerful</li>
                            <li>Handles complex grammars</li>
                            <li>Faster and accurate</li>
                            <li>Used in real-life tools like YACC, Bison</li>
                        </ul>
                    </ul>
                    <p>Think of it like a machine <strong>assembling code from smallest parts to the full program structure.</strong></p>
                </article>
            </article>

            <article>
                <h3 class="text-center fw-bold">Recursive Descent Parser</h3>
                <article>
                    <p>A <strong>Recursive Descent Parser</strong> is like a team of <strong>functions</strong> where each function handles a <strong>grammar rule</strong> and <strong>calls others recursively</strong> to process input tokens.</p>
                </article>

                <article>
                    <h4>What is it?</h4>
                    <ul>
                        <li>A <strong>Top-Down Parser</strong></li>
                        <li>Manually written</li>
                        <li>Uses <strong>one function per non-terminal</strong></li>
                        <li>Works like: <br> “If I see <code>E</code>, I call function <code>E()</code>. If I see <code>T</code>, I call <code>T()</code>.”</li>
                    </ul>
                </article>

                <article>
                    <h4>Architecture:</h4>
                    <pre><code class="">
+-----------------+
|  Source Program |
+-----------------+
         |
         v
+-----------------+
|     Lexer       | → Gives tokens
+-----------------+
         |
         v
+-----------------+
| Recursive Descent|
|    Parser        |
| (set of funcs)   |
+-----------------+
         |
         v
+-----------------+
|   Parse Tree    |
+-----------------+
</code></pre>
                </article>

                <article>
                    <h4>How it Works:</h4>
                    <p>For grammar like:</p>
                    <pre><code class="">
E → T E'
E' → + T E' | ε
T → F T'
T' → * F T' | ε
F → (E) | id
</code></pre>
                    <p>Functions:</p>
                    <pre><code class="language-c">
void E() {
    T();
    Eprime();
}

void Eprime() {
    if (lookahead == '+') {
        match('+');
        T();
        Eprime();
    }
}

void T() {
    F();
    Tprime();
}

// and so on...
</code></pre>
                    <p>Each function:</p>
                    <ul>
                        <li>Checks the expected token</li>
                        <li>Calls other functions based on grammar</li>
                    </ul>
                </article>

                <article>
                    <h4>Technical Points:</h4>
                    <div class="table-responsive">
                        <table class="table table-bordered table-striped">
                            <thead>
                                <tr>
                                    <th>Feature</th>
                                    <th>Description</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>LL(1) Support</strong></td>
                                    <td>Left to Right, Leftmost derivation, 1 lookahead</td>
                                </tr>
                                <tr>
                                    <td><strong>No Table</strong></td>
                                    <td>Works without parsing table</td>
                                </tr>
                                <tr>
                                    <td><strong>Hand-Coded</strong></td>
                                    <td>You write each function manually</td>
                                </tr>
                                <tr>
                                    <td><strong>Backtracking (optional)</strong></td>
                                    <td>Some versions support guessing rules</td>
                                </tr>
                                <tr>
                                    <td><strong>Simple & Intuitive</strong></td>
                                    <td>Easy to implement and debug</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </article>

                <article>
                    <h4>Drawbacks:</h4>
                    <div class="table-responsive">
                        <table class="table table-bordered table-striped">
                            <thead>
                                <tr>
                                    <th>Issue</th>
                                    <th>Fix</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>Left Recursion</strong></td>
                                    <td>Must be removed manually</td>
                                </tr>
                                <tr>
                                    <td><strong>Not for complex grammar</strong></td>
                                    <td>Better to use LL(1) or LR parsers</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <p>Example of Left Recursion (bad):</p>
                    <pre><code class="">
E → E + T
</code></pre>
                    <p>Fixed to:</p>
                    <pre><code class="">
E → T E'
E' → + T E' | ε
</code></pre>
                </article>

                <article>
                    <h4>Summary:</h4>
                    <ul>
                        <li><strong>Recursive Descent Parser</strong> = <strong>Set of functions</strong> for grammar</li>
                        <li>Works <strong>top-down</strong>, <strong>recursively</strong></li>
                        <li>Great for simple grammars</li>
                        <li>Needs grammar to be <strong>non-left-recursive</strong></li>
                        <li>Used in small compilers, educational tools</li>
                    </ul>
                    <p>Imagine it as a <strong>conversation between functions</strong>, each one asking the next: “Do you match the grammar?”</p>
                </article>
            </article>

            <article>
                <h3 class="text-center fw-bold">LL(1) Parser</h3>
                <article>
                    <p><strong>LL(1) Parser</strong> is a <strong>Top-Down, Table-Driven Parser</strong>.<br>
                        It's smarter than Recursive Descent – instead of guessing, it <strong>looks ahead 1 token</strong> and uses a <strong>table</strong> to decide what to do.</p>
                </article>

                <article>
                    <h4>What “LL(1)” means:</h4>
                    <ul>
                        <li><strong>L</strong> → Left-to-right input</li>
                        <li><strong>L</strong> → Leftmost derivation</li>
                        <li><strong>1</strong> → One lookahead token</li>
                    </ul>
                </article>

                <article>
                    <h4>🏗️ Architecture:</h4>
                    <pre><code class="">
+-------------------+
|   Input Tokens    |
+--------+----------+
         |
         v
+-------------------+     +------------------+
|    Parsing Stack  |<--->|   Parsing Table  |
+--------+----------+     +--------+---------+
         |                         ^
         v                         |
+-------------------+     +--------+---------+
|     LL(1) Parser   |----| Grammar & First/Follow |
+-------------------+     +------------------+
         |
         v
+-------------------+
|    Parse Tree     |
+-------------------+
</code></pre>
                </article>

                <article>
                    <h4>Internal Working:</h4>
                    <ol>
                        <li><strong>Stack</strong> holds symbols to be matched</li>
                        <li><strong>Input</strong> is read left-to-right</li>
                        <li>Parser uses <strong>LL(1) Parsing Table</strong> to decide:
                            <ul>
                                <li>Which rule to apply based on top of stack and current input</li>
                            </ul>
                        </li>
                        <li><strong>Actions</strong>:
                            <ul>
                                <li><strong>Match</strong> (if terminal)</li>
                                <li><strong>Replace</strong> (if non-terminal)</li>
                                <li><strong>Accept</strong> if success</li>
                                <li><strong>Error</strong> if mismatch</li>
                            </ul>
                        </li>
                    </ol>
                </article>

                <article>
                    <h4>Steps Example:</h4>
                    <p>Grammar:</p>
                    <pre><code class="">
E → T E'
E' → + T E' | ε
T → id
</code></pre>

                    <p>Input: <code>id + id</code></p>

                    <p>Parsing Table:</p>
                    <div class="table-responsive">
                        <table class="table table-bordered table-striped">
                            <thead>
                                <tr>
                                    <th></th>
                                    <th>id</th>
                                    <th>+</th>
                                    <th>$</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>E</strong></td>
                                    <td>E→T E'</td>
                                    <td></td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td><strong>E'</strong></td>
                                    <td></td>
                                    <td>E'→+T E'</td>
                                    <td>E'→ε</td>
                                </tr>
                                <tr>
                                    <td><strong>T</strong></td>
                                    <td>T→id</td>
                                    <td></td>
                                    <td></td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <p>Stack: <code>E $</code><br>
                        Input: <code>id + id $</code></p>

                    <ul>
                        <li>Top = E, Input = id → use E → T E'</li>
                        <li>Replace E with T E'</li>
                        <li>Top = T, Input = id → use T → id</li>
                        <li>Match id</li>
                        <li>Top = E', Input = + → use E' → + T E'</li>
                        <li>And so on...</li>
                    </ul>
                </article>

                <article>
                    <h4>Key Requirements:</h4>
                    <div class="table-responsive">
                        <table class="table table-bordered table-striped">
                            <thead>
                                <tr>
                                    <th>Requirement</th>
                                    <th>Meaning</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>No Left Recursion</strong></td>
                                    <td>e.g. <code>E → E + T</code> must be removed</td>
                                </tr>
                                <tr>
                                    <td><strong>Left Factored</strong></td>
                                    <td>e.g. <code>A → ab | ac</code> becomes <code>A → aB, B → b | c</code></td>
                                </tr>
                                <tr>
                                    <td><strong>First & Follow Sets</strong></td>
                                    <td>Needed to build table</td>
                                </tr>
                                <tr>
                                    <td><strong>One Rule per Cell</strong></td>
                                    <td>LL(1) must be non-ambiguous</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </article>

                <article>
                    <h4>Advantages:</h4>
                    <ul>
                        <li>Fast and table-driven</li>
                        <li>No backtracking</li>
                        <li>Clear and predictable</li>
                    </ul>
                </article>

                <article>
                    <h4>Limitations:</h4>
                    <ul>
                        <li>Can't handle all grammars</li>
                        <li>Needs pre-processing (remove left recursion, left factoring)</li>
                        <li>Only 1 lookahead = less powerful than LR parsers</li>
                    </ul>
                </article>

                <article>
                    <h4>Summary:</h4>
                    <ul>
                        <li><strong>LL(1)</strong> Parser = Table + Stack based Top-Down Parser</li>
                        <li>Uses 1 lookahead to choose production rule</li>
                        <li>Requires First & Follow sets to build the parsing table</li>
                        <li>Efficient but needs grammar to be clean and simple</li>
                    </ul>
                    <p><strong>It's like a Google Map with one arrow – choose the path by just 1 lookahead.</strong></p>
                </article>
            </article>

            <article>
                <h3 class="text-center fw-bold">FIRST() in Compiler Design</h3>
                <article>
                    <p><strong>FIRST(X)</strong> tells: <br>
                        <strong>"What terminals can appear first if I start deriving from X?"</strong>
                    </p>
                </article>

                <article>
                    <h4>Why it matters:</h4>
                    <p>When building <strong>LL(1) parsing tables</strong>, we need to know:</p>
                    <ul>
                        <li>If I have <code>A → α</code>, and input symbol is <code>a</code>, should I use this rule?</li>
                        <li>Check if <code>a ∈ FIRST(α)</code></li>
                    </ul>
                </article>

                <article>
                    <h4>Rules to Find FIRST():</h4>
                    <p>Let <code>X</code> be a symbol (Terminal or Non-Terminal)</p>

                    <h5>Case 1: If X is a <strong>terminal</strong></h5>
                    <pre><code class="">
FIRST(X) = { X }
</code></pre>

                    <h5>Case 2: If X is a <strong>non-terminal</strong> and:</h5>
                    <pre><code class="">
X → a...   ⇒ FIRST(X) = { a }
</code></pre>

                    <h5>Case 3: X → Y₁ Y₂ Y₃...</h5>
                    <ul>
                        <li>Add FIRST(Y₁) to FIRST(X)</li>
                        <li>If FIRST(Y₁) has ε (epsilon), → check Y₂, and so on...</li>
                    </ul>

                    <h5>Case 4: X → ε</h5>
                    <pre><code class="">
Then ε ∈ FIRST(X)
</code></pre>
                </article>

                <article>
                    <h4>Example:</h4>
                    <p>Grammar:</p>
                    <pre><code class="">
E  → T E'
E' → + T E' | ε
T  → id
</code></pre>

                    <p>Now calculate:</p>
                    <div class="table-responsive">
                        <table class="table table-bordered table-striped">
                            <thead>
                                <tr>
                                    <th>Non-Terminal</th>
                                    <th>FIRST()</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>E</strong></td>
                                    <td>FIRST(T) = { id }</td>
                                </tr>
                                <tr>
                                    <td><strong>E'</strong></td>
                                    <td>{ +, ε }</td>
                                </tr>
                                <tr>
                                    <td><strong>T</strong></td>
                                    <td>{ id }</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </article>

                <article>
                    <h4>Simple Algorithm:</h4>
                    <pre><code class="language-text">
Repeat until no more changes:
    For every rule A → α:
        Add FIRST(α) to FIRST(A)
        If α is Y₁ Y₂ ... and FIRST(Yᵢ) has ε
            Then check Yᵢ₊₁
</code></pre>
                </article>

                <article>
                    <h4>Final Notes:</h4>
                    <ul>
                        <li><strong>FIRST()</strong> helps us <strong>predict</strong> the next move in LL(1) parser</li>
                        <li>Very useful to <strong>build parsing table</strong></li>
                        <li><code>ε</code> (empty string) is included only if <strong>whole production can become empty</strong></li>
                    </ul>
                </article>

                <article>
                    <h4>Think like this:</h4>
                    <blockquote><strong>FIRST(X)</strong> = "What can I possibly see first if I start writing X on paper?"</blockquote>
                    <p>It helps the parser <strong>look ahead and decide.</strong></p>
                </article>
            </article>

            <article>
                <h3 class="text-center fw-bold">FOLLOW() in Compiler Design</h3>
                <article>
                    <p><strong>FOLLOW(A)</strong> tells: <br>
                        👉 “What terminals can come <strong>right after</strong> <code>A</code> in some derivation?”</p>
                </article>

                <article>
                    <h4>Why it matters:</h4>
                    <p>Used in <strong>LL(1) Parsing Table</strong> to decide:</p>
                    <ul>
                        <li>If a production like <code>A → ε</code> should be used</li>
                        <li>Helps fill entries when <strong>FIRST(α)</strong> has <code>ε</code></li>
                    </ul>
                </article>

                <article>
                    <h4>Rules to Calculate FOLLOW():</h4>
                    <p>Let's say grammar has a <strong>Start Symbol <code>S</code></strong>.</p>

                    <h5>Rule 1:</h5>
                    <pre><code class="">
If A is the start symbol, add $ to FOLLOW(A)
</code></pre>

                    <h5>Rule 2:</h5>
                    <p>For every production <code>A → α B β</code></p>
                    <pre><code class="">
Add FIRST(β) (excluding ε) to FOLLOW(B)
</code></pre>

                    <h5>Rule 3:</h5>
                    <p>If <code>A → α B</code> or <code>A → α B β</code> and FIRST(β) has ε:</p>
                    <pre><code class="">
Add FOLLOW(A) to FOLLOW(B)
</code></pre>
                </article>

                <article>
                    <h4>Example:</h4>
                    <p>Grammar:</p>
                    <pre><code class="">
E  → T E'
E' → + T E' | ε
T  → id
</code></pre>
                    <p>Start symbol = <code>E</code><br>We calculate:</p>

                    <h5>Step 1:</h5>
                    <p><code>FOLLOW(E) = { $ }</code> (Rule 1)</p>

                    <h5>Step 2:</h5>
                    <p><code>E → T E'</code><br>
                        <code>E'</code> follows <code>T</code> → so <code>FOLLOW(T) = FIRST(E')</code> = { +, ε } (but only if <code>E'</code> can be empty, we add <code>FOLLOW(E)</code>)
                    </p>

                    <h5>Step 3:</h5>
                    <p><code>E' → + T E'</code><br>
                        <code>FOLLOW(T)</code> = FIRST(<code>E'</code>) again<br>
                        <code>E' → ε</code> → <code>FOLLOW(E)</code> goes to <code>E'</code> too
                    </p>

                    <div class="table-responsive">
                        <table class="table table-bordered table-striped">
                            <thead>
                                <tr>
                                    <th>Non-Terminal</th>
                                    <th>FOLLOW()</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>E</strong></td>
                                    <td>{ $ }</td>
                                </tr>
                                <tr>
                                    <td><strong>E'</strong></td>
                                    <td>{ $ }</td>
                                </tr>
                                <tr>
                                    <td><strong>T</strong></td>
                                    <td>{ +, $ }</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </article>

                <article>
                    <h4>Simple Algorithm:</h4>
                    <pre><code class="language-text">
1. Start with FOLLOW(S) = { $ }

2. For every production A → α B β:
    a. Add FIRST(β) (excluding ε) to FOLLOW(B)
    b. If FIRST(β) has ε or β is empty:
        Add FOLLOW(A) to FOLLOW(B)

3. Repeat until no change
</code></pre>
                </article>

                <article>
                    <h4>Final Summary:</h4>
                    <ul>
                        <li><strong>FOLLOW(A)</strong> = All terminals that can come <strong>immediately after A</strong></li>
                        <li>Helps in <strong>LL(1) table</strong>, especially when rule derives <code>ε</code></li>
                        <li>Always put <code>$</code> (end of input) in <strong>FOLLOW(start symbol)</strong></li>
                    </ul>
                    <blockquote><strong>FOLLOW(A)</strong> = “What can I expect to see after A, if I'm parsing from left to right?”</blockquote>
                </article>
            </article>            

            <article>
                <h3 class="text-center fw-bold">Parse Table (LL(1))</h3>
                <article>
                    <p>A <strong>Parse Table</strong> tells the LL(1) parser <strong>which rule to apply</strong> based on:</p>
                    <ul>
                        <li>Current <strong>non-terminal (on stack)</strong></li>
                        <li>Current <strong>input token (lookahead)</strong></li>
                    </ul>
                </article>

                <article>
                    <h4>Structure:</h4>
                    <p>It's a <strong>2D Table</strong> like this:</p>
                    <div class="table-responsive">
                        <table class="table table-bordered table-striped">
                            <thead>
                                <tr>
                                    <th></th>
                                    <th>id</th>
                                    <th>+</th>
                                    <th>*</th>
                                    <th>(</th>
                                    <th>)</th>
                                    <th>$</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>E</strong></td>
                                    <td>E→T E'</td>
                                    <td></td>
                                    <td></td>
                                    <td>E→T E'</td>
                                    <td></td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td><strong>E'</strong></td>
                                    <td></td>
                                    <td>E'→+T E'</td>
                                    <td></td>
                                    <td></td>
                                    <td>E'→ε</td>
                                    <td>E'→ε</td>
                                </tr>
                                <tr>
                                    <td><strong>T</strong></td>
                                    <td>T→id</td>
                                    <td></td>
                                    <td></td>
                                    <td>T→(E)</td>
                                    <td></td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td><strong>T'</strong></td>
                                    <td></td>
                                    <td>T'→ε</td>
                                    <td>T'→*F T'</td>
                                    <td></td>
                                    <td>T'→ε</td>
                                    <td>T'→ε</td>
                                </tr>
                                <tr>
                                    <td><strong>F</strong></td>
                                    <td>F→id</td>
                                    <td></td>
                                    <td></td>
                                    <td>F→(E)</td>
                                    <td></td>
                                    <td></td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </article>

                <article>
                    <h4>How to Build Parse Table:</h4>
                    <ol>
                        <li>For each production <code>A → α</code>:
                            <ul>
                                <li>For every terminal <code>a</code> in <strong>FIRST(α)</strong>, add <code>A → α</code> to <code>M[A, a]</code></li>
                                <li>If <code>ε ∈ FIRST(α)</code>, then for every <code>b</code> in <strong>FOLLOW(A)</strong>, add <code>A → α</code> to <code>M[A, b]</code></li>
                            </ul>
                        </li>
                    </ol>
                </article>

                <article>
                    <h4>Example Grammar:</h4>
                    <pre><code class="">
E  → T E'
E' → + T E' | ε
T  → F T'
T' → * F T' | ε
F  → id | ( E )
</code></pre>
                </article>

                <article>
                    <h4>FIRST & FOLLOW:</h4>
                    <div class="table-responsive">
                        <table class="table table-bordered table-striped">
                            <thead>
                                <tr>
                                    <th>Symbol</th>
                                    <th>FIRST</th>
                                    <th>FOLLOW</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>E</strong></td>
                                    <td>{ id, ( }</td>
                                    <td>{ $, ) }</td>
                                </tr>
                                <tr>
                                    <td><strong>E'</strong></td>
                                    <td>{ +, ε }</td>
                                    <td>{ $, ) }</td>
                                </tr>
                                <tr>
                                    <td><strong>T</strong></td>
                                    <td>{ id, ( }</td>
                                    <td>{ +, $, ) }</td>
                                </tr>
                                <tr>
                                    <td><strong>T'</strong></td>
                                    <td>{ *, ε }</td>
                                    <td>{ +, $, ) }</td>
                                </tr>
                                <tr>
                                    <td><strong>F</strong></td>
                                    <td>{ id, ( }</td>
                                    <td>{ *, +, $, ) }</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </article>

                <article>
                    <h4>How Parser Uses It:</h4>
                    <ul>
                        <li>Stack top = <code>A</code>, input = <code>a</code></li>
                        <li>Go to cell <code>M[A, a]</code> → pick the rule → expand stack</li>
                        <li>Repeat until:
                            <ul>
                                <li>Input & stack both become <code>$</code> → <strong>Accepted</strong></li>
                                <li>No entry found → <strong>Error</strong></li>
                            </ul>
                        </li>
                    </ul>
                </article>

                <article>
                    <h4>Summary:</h4>
                    <ul>
                        <li><strong>Parse Table</strong> = <strong>Guide Map</strong> for LL(1) Parser</li>
                        <li>Built using <strong>FIRST & FOLLOW</strong></li>
                        <li>Each cell has <strong>only one rule</strong> (else → not LL(1))</li>
                        <li>Table-driven → Fast, Predictive, No backtracking</li>
                    </ul>
                    <p>Think of it like a <strong>cheat sheet</strong> for the parser to decide its next move confidently.</p>
                </article>
            </article>

            <article>
                <h3 class="text-center fw-bold">Stack Operation of LL(1) Parser</h3>
                <article>
                    <p>The <strong>LL(1) Parser</strong> uses a <strong>stack</strong> to match grammar rules with input tokens using a <strong>parse table</strong>.</p>
                </article>

                <article>
                    <h4>What's in the Stack?</h4>
                    <ul>
                        <li><strong>Non-terminals</strong> to be expanded</li>
                        <li><strong>Terminals</strong> to be matched</li>
                        <li>Ends with <strong>$</strong> (end marker)</li>
                    </ul>
                </article>

                <article>
                    <h4>Parser Steps:</h4>
                    <ol>
                        <li><strong>Initialize</strong> stack: <code>[$, StartSymbol]</code></li>
                        <li>Read <strong>current input token</strong></li>
                        <li>Check <strong>Top of Stack</strong>:
                            <ul>
                                <li>If <strong>terminal</strong> → match with input → pop both</li>
                                <li>If <strong>non-terminal</strong> → use parse table to get rule → replace top</li>
                            </ul>
                        </li>
                        <li>If both stack & input are <code>$</code> → <strong>ACCEPT</strong></li>
                    </ol>
                </article>

                <article>
                    <h4>Example:</h4>
                    <p>Grammar:</p>
                    <pre><code class="">
E  → T E'
E' → + T E' | ε
T  → id
</code></pre>

                    <p>Input: <code>id + id $</code><br>
                        Start Symbol: <code>E</code></p>

                    <h5>Step-by-step Stack:</h5>
                    <div class="table-responsive">
                        <table class="table table-bordered table-striped">
                            <thead>
                                <tr>
                                    <th>Stack</th>
                                    <th>Input</th>
                                    <th>Action</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>$ E</td>
                                    <td>id + id $</td>
                                    <td>E → T E'</td>
                                </tr>
                                <tr>
                                    <td>$ E' T</td>
                                    <td>id + id $</td>
                                    <td>T → id</td>
                                </tr>
                                <tr>
                                    <td>$ E' id</td>
                                    <td>id + id $</td>
                                    <td>match id</td>
                                </tr>
                                <tr>
                                    <td>$ E'</td>
                                    <td>+ id $</td>
                                    <td>E' → + T E'</td>
                                </tr>
                                <tr>
                                    <td>$ E' T +</td>
                                    <td>+ id $</td>
                                    <td>match +</td>
                                </tr>
                                <tr>
                                    <td>$ E' T</td>
                                    <td>id $</td>
                                    <td>T → id</td>
                                </tr>
                                <tr>
                                    <td>$ E' id</td>
                                    <td>id $</td>
                                    <td>match id</td>
                                </tr>
                                <tr>
                                    <td>$ E'</td>
                                    <td>$</td>
                                    <td>E' → ε (empty)</td>
                                </tr>
                                <tr>
                                    <td>$</td>
                                    <td>$</td>
                                    <td>ACCEPT ✅</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </article>

                <article>
                    <h4>Parse Tree:</h4>
                    <p>We use the rules applied to build a <strong>parse tree</strong>.</p>
                    <pre><code class="">.
        E
      /   \
     T     E'
     |    /   \
    id   +     T
              |
             id
</code></pre>
                    <ul>
                        <li>Each <strong>non-terminal expands</strong> into its RHS</li>
                        <li>Each <strong>match</strong> goes to a <strong>leaf node</strong></li>
                    </ul>
                </article>

                <article>
                    <h4>Summary:</h4>
                    <ul>
                        <li><strong>LL(1) Stack</strong> = Holds what's left to match/expand</li>
                        <li>Stack + Input are read together</li>
                        <li><strong>Parse Table</strong> tells which rule to apply</li>
                        <li><strong>Parse Tree</strong> is built from applied rules, top-down</li>
                    </ul>
                    <p>Think of it like a <strong>puzzle solver</strong> using rules from a cheat-sheet (table) to fit input tokens into a grammar structure.</p>
                </article>
            </article>

            <article>
                <h3 class="text-center fw-bold">Rules to Check if a Grammar is LL(1)</h3>
                <article>
                    <p>To confirm a grammar is <strong>LL(1)</strong>, we must ensure the parser can <strong>decide the correct production</strong> with just <strong>1 lookahead</strong>.</p>
                </article>

                <article>
                    <h4>🧪 Rule 1: No Left Recursion</h4>
                    <p>If a grammar has <strong>left recursion</strong>, it's not LL(1).</p>

                    <p>❌ Example (Left Recursive):</p>
                    <pre><code class="">
A → Aα | β
</code></pre>

                    <p>✅ Fix:</p>
                    <pre><code class="">
A  → βA'
A' → αA' | ε
</code></pre>
                </article>

                <article>
                    <h4>Rule 2: Left Factoring</h4>
                    <p>If multiple rules of a non-terminal <strong>start the same</strong>, it's <strong>ambiguous</strong> for LL(1).</p>

                    <p>❌ Example:</p>
                    <pre><code class="">
A → aB | aC
</code></pre>

                    <p>✅ Fix:</p>
                    <pre><code class="">
A → aA'
A' → B | C
</code></pre>
                </article>

                <article>
                    <h4>Rule 3: FIRST Rule (no FIRST/FIRST conflict)</h4>
                    <p>For a non-terminal <code>A</code> with multiple rules:</p>

                    <pre><code class="">
A → α | β
</code></pre>

                    <p>Then:</p>
                    <pre><code class="">
FIRST(α) ∩ FIRST(β) = ∅
</code></pre>

                    <p>→ Means: no common terminal should appear in both FIRST sets.</p>
                </article>

                <article>
                    <h4>Rule 4: FIRST/FOLLOW Rule (if ε is involved)</h4>
                    <p>If:</p>
                    <pre><code class="">
A → α | ε
</code></pre>

                    <p>Then:</p>
                    <pre><code class="">
FIRST(α) ∩ FOLLOW(A) = ∅
</code></pre>

                    <p>→ So parser doesn't get confused between expanding α or taking ε.</p>
                </article>

                <article>
                    <h4>Final Checklist to Confirm LL(1):</h4>
                    <div class="table-responsive">
                        <table class="table table-bordered table-striped">
                            <thead>
                                <tr>
                                    <th>✅ Condition</th>
                                    <th>🔍 Check for...</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>No Left Recursion</td>
                                    <td><code>A → Aα</code> → ❌</td>
                                </tr>
                                <tr>
                                    <td>Grammar is Left Factored</td>
                                    <td><code>A → aB | aC</code> → ❌</td>
                                </tr>
                                <tr>
                                    <td>FIRST of different rules disjoint</td>
                                    <td><code>FIRST(α) ∩ FIRST(β) = ∅</code></td>
                                </tr>
                                <tr>
                                    <td>FIRST(α) ∩ FOLLOW(A) if ε exists</td>
                                    <td>If ε ∈ FIRST(A), then FIRST and FOLLOW disjoint</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </article>

                <article>
                    <h4>Why all this?</h4>
                    <p>LL(1) parser has <strong>only 1 lookahead token</strong>. So if grammar breaks these rules, it <strong>won't know which rule to choose</strong> → parsing conflict.</p>
                </article>

                <article>
                    <h4>Summary:</h4>
                    <p>A grammar is LL(1) <strong>only if</strong>:</p>
                    <ul>
                        <li>No left recursion</li>
                        <li>Left factored</li>
                        <li><code>FIRST</code> sets don't overlap</li>
                        <li><code>FIRST</code> & <code>FOLLOW</code> disjoint if ε involved</li>
                    </ul>
                    <p>If all conditions are satisfied, it's <strong>safe for fast predictive parsing without backtracking</strong>.</p>
                </article>
            </article>            

            <article>
                <h3 class="fw-bold text-center">Proof that Example 4.9 (book) Grammar is LL(1)</h3>
                <article>
                    <p>We will prove step by step with all conditions and draw necessary tables.</p>
                </article>

                <article>
                    <h4>📘 Grammar (Example 4.9):</h4>
                    <pre><code class="">
E  → T E'  
E' → + T E' | ε  
T  → F T'  
T' → * F T' | ε  
F  → ( E ) | id
</code></pre>
                </article>

                <article>
                    <h4>Step 1: No <strong>Left Recursion</strong>?</h4>
                    <p>We check each non-terminal:</p>
                    <ul>
                        <li>E → T E' (no E on RHS start)</li>
                        <li>E' → + T E' | ε (no E' at start)</li>
                        <li>T → F T'</li>
                        <li>T' → * F T' | ε</li>
                        <li>F → ( E ) | id</li>
                    </ul>
                    <p>✅ No left recursion.</p>
                </article>

                <article>
                    <h4>Step 2: Is the grammar <strong>Left Factored</strong>?</h4>
                    <p>We check if any non-terminal has more than one production with <strong>common prefix</strong>.</p>
                    <p>Check E', T', F:</p>
                    <ul>
                        <li>E' → + T E' | ε → no common prefix</li>
                        <li>T' → * F T' | ε → no common prefix</li>
                        <li>F → ( E ) | id → no common prefix</li>
                    </ul>
                    <p>✅ Grammar is <strong>left factored</strong></p>
                </article>

                <article>
                    <h4>Step 3: Compute <strong>FIRST Sets</strong></h4>
                    <div class="table-responsive">
                        <table class="table table-bordered table-striped">
                            <thead>
                                <tr>
                                    <th>Non-Terminal</th>
                                    <th>FIRST</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>E</strong></td>
                                    <td>( , id</td>
                                </tr>
                                <tr>
                                    <td><strong>E'</strong></td>
                                    <td>+ , ε</td>
                                </tr>
                                <tr>
                                    <td><strong>T</strong></td>
                                    <td>( , id</td>
                                </tr>
                                <tr>
                                    <td><strong>T'</strong></td>
                                    <td>* , ε</td>
                                </tr>
                                <tr>
                                    <td><strong>F</strong></td>
                                    <td>( , id</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <p><strong>Why?</strong></p>
                    <ul>
                        <li>F → ( E ) → FIRST = (</li>
                        <li>F → id → FIRST = id</li>
                        <li>⇒ FIRST(F) = ( , id)</li>
                        <li>⇒ FIRST(T) = FIRST(F)</li>
                        <li>⇒ FIRST(E) = FIRST(T)</li>
                    </ul>
                    <p>E' and T' have ε due to their alternate rules.</p>
                </article>

                <article>
                    <h4>Step 4: Compute <strong>FOLLOW Sets</strong></h4>
                    <p>Use rules and propagation.</p>
                    <ul>
                        <li>FOLLOW(E) = { ), $ } (E appears in F → ( E ) and is start symbol)</li>
                        <li>FOLLOW(E') = FOLLOW(E) = { ), $ }</li>
                        <li>FOLLOW(T) = FIRST(E') excluding ε = { + } and FOLLOW(E') = { ), $ } ⇒ FOLLOW(T) = { +, ), $ }</li>
                        <li>FOLLOW(T') = FOLLOW(T) = { +, ), $ }</li>
                        <li>FOLLOW(F) = FIRST(T') excluding ε = { * } and FOLLOW(T') = { +, ), $ } ⇒ FOLLOW(F) = { *, +, ), $ }</li>
                    </ul>
                    <div class="table-responsive">
                        <table class="table table-bordered table-striped">
                            <thead>
                                <tr>
                                    <th>Non-Terminal</th>
                                    <th>FOLLOW</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>E</strong></td>
                                    <td>) , $</td>
                                </tr>
                                <tr>
                                    <td><strong>E'</strong></td>
                                    <td>) , $</td>
                                </tr>
                                <tr>
                                    <td><strong>T</strong></td>
                                    <td>+ , ) , $</td>
                                </tr>
                                <tr>
                                    <td><strong>T'</strong></td>
                                    <td>+ , ) , $</td>
                                </tr>
                                <tr>
                                    <td><strong>F</strong></td>
                                    <td>* , + , ) , $</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </article>

                <article>
                    <h4>Step 5: Check <strong>FIRST Set Overlap</strong></h4>
                    <ul>
                        <li>E → T E'</li>
                        <li>E' → + T E' | ε → FIRST(+ T E') = { + }, FIRST(ε) = ε → ✔ disjoint</li>
                        <li>T' → * F T' | ε → FIRST(* F T') = { * }, FIRST(ε) = ε → ✔ disjoint</li>
                    </ul>
                    <p>✅ FIRST sets <strong>don't overlap</strong></p>
                </article>

                <article>
                    <h4>Step 6: Check <strong>FIRST & FOLLOW disjoint if ε involved</strong></h4>
                    <ul>
                        <li><strong>E' → ε</strong>: FIRST(E') = { +, ε }, FOLLOW(E') = { ), $ }
                            → FIRST ∩ FOLLOW = ∅ → ✔</li>
                        <li><strong>T' → ε</strong>: FIRST(T') = { *, ε }, FOLLOW(T') = { +, ), $ }
                            → FIRST ∩ FOLLOW = ∅ → ✔</li>
                    </ul>
                    <p>✅ FIRST and FOLLOW are disjoint when ε involved.</p>
                </article>

                <article>
                    <h4>Step 7: LL(1) Parsing Table</h4>
                    <div class="table-responsive">
                        <table class="table table-bordered table-striped">
                            <thead>
                                <tr>
                                    <th></th>
                                    <th>id</th>
                                    <th>+</th>
                                    <th>*</th>
                                    <th>(</th>
                                    <th>)</th>
                                    <th>$</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>E</strong></td>
                                    <td>E → T E'</td>
                                    <td></td>
                                    <td></td>
                                    <td>E → T E'</td>
                                    <td></td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td><strong>E'</strong></td>
                                    <td></td>
                                    <td>E' → + T E'</td>
                                    <td></td>
                                    <td></td>
                                    <td>E' → ε</td>
                                    <td>E' → ε</td>
                                </tr>
                                <tr>
                                    <td><strong>T</strong></td>
                                    <td>T → F T'</td>
                                    <td></td>
                                    <td></td>
                                    <td>T → F T'</td>
                                    <td></td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td><strong>T'</strong></td>
                                    <td></td>
                                    <td>T' → ε</td>
                                    <td>T' → * F T'</td>
                                    <td></td>
                                    <td>T' → ε</td>
                                    <td>T' → ε</td>
                                </tr>
                                <tr>
                                    <td><strong>F</strong></td>
                                    <td>F → id</td>
                                    <td></td>
                                    <td></td>
                                    <td>F → ( E )</td>
                                    <td></td>
                                    <td></td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <p>✅ No cell has multiple entries → <strong>no conflict</strong></p>
                </article>

                <article>
                    <h4>FINAL CONCLUSION:</h4>
                    <p>Grammar satisfies all 4 conditions:</p>
                    <ol>
                        <li><strong>No left recursion</strong> ✅</li>
                        <li><strong>Left factored</strong> ✅</li>
                        <li><strong>FIRST sets don't overlap</strong> ✅</li>
                        <li><strong>FIRST and FOLLOW disjoint when ε is in FIRST</strong> ✅</li>
                        <li><strong>No conflicts in parsing table</strong> ✅</li>
                    </ol>
                </article>

                <article>
                    <h4>✅ Therefore, <strong>Example 4.9 is LL(1)</strong> ✔</h4>
                </article>

                <div class="alert alert-warning lead " role="alert">
                    🎯 Input to parse: <code>id + id * id</code>
                </div>

                <article>
                    <h4>Step-by-Step LL(1) Derivation</h4>
                    <p>We derive using <strong>leftmost derivation</strong> with the help of parsing table.</p>
                    <p>We write the <strong>derivation at each step</strong>.</p>
                </article>

                <article>
                    <h5>Step 1:</h5>
                    <pre><code class="">
Start:        E
</code></pre>
                    <p>Use rule: <code>E → T E'</code></p>

                    <h5>Step 2:</h5>
                    <pre><code class="">
→ T E'
</code></pre>
                    <p>Use rule: <code>T → F T'</code></p>

                    <h5>Step 3:</h5>
                    <pre><code class="">
→ F T' E'
</code></pre>
                    <p>Use rule: <code>F → id</code></p>

                    <h5>Step 4:</h5>
                    <pre><code class="">
→ id T' E'
</code></pre>
                    <p>Next input is <code>+</code><br>Use rule: <code>T' → ε</code></p>

                    <h5>Step 5:</h5>
                    <pre><code class="">
→ id E'
</code></pre>
                    <p>Use rule: <code>E' → + T E'</code></p>

                    <h5>Step 6:</h5>
                    <pre><code class="">
→ id + T E'
</code></pre>
                    <p>Use rule: <code>T → F T'</code></p>

                    <h5>Step 7:</h5>
                    <pre><code class="">
→ id + F T' E'
</code></pre>
                    <p>Use rule: <code>F → id</code></p>

                    <h5>Step 8:</h5>
                    <pre><code class="">
→ id + id T' E'
</code></pre>
                    <p>Lookahead is <code>*</code><br>Use rule: <code>T' → * F T'</code></p>

                    <h5>Step 9:</h5>
                    <pre><code class="">
→ id + id * F T' E'
</code></pre>
                    <p>Use rule: <code>F → id</code></p>

                    <h5>Step 10:</h5>
                    <pre><code class="">
→ id + id * id T' E'
</code></pre>
                    <p>Lookahead is <code>$</code> <br>Use: <code>T' → ε</code> and <code>E' → ε</code></p>
                </article>

                <article>
                    <h4>Final Derivation:</h4>
                    <pre><code class="">
→ T E'
→ F T' E'
→ id T' E'
→ id E'
→ id + T E'
→ id + F T' E'
→ id + id T' E'
→ id + id * F T' E'
→ id + id * id T' E'
→ id + id * id E'
→ id + id * id
</code></pre>
                </article>

                <article>
                    <h4>LL(1) derivation successful</h4>
                    <ul>
                        <li>Input parsed: <code>id + id * id</code></li>
                        <li>Order of operations respected (multiplication before addition)</li>
                        <li>Grammar respects <strong>operator precedence</strong> and <strong>associativity</strong></li>
                    </ul>
                    <p>✅ This proves grammar works properly in <strong>LL(1) parsing</strong>.</p>
                </article>

            </article>


        </main>

        <script> copyright("all"); </script>

    </body>

</html>