<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>

        <title>Term 2 Answers - CSU086 - Shoolini U</title>
        <meta name="description" content="Term 2 Answers - CSU086 - Shoolini University" />

        <meta property="og:image" content="/logo.png">
        <meta property="og:type" content="article">

        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@divyamohan1993">
        <meta name="twitter:creator" content="@divyamohan1993">
        <meta name="twitter:image" content="/logo.png">

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />

        <meta name="author" content="Divya Mohan">
        <meta name="robots" content="index, follow">

        <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                renderMathInElement(document.body, {
                    // customised options
                    // • auto-render specific keys, e.g.:
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\(', right: '\\)', display: false },
                        { left: '\\[', right: '\\]', display: true }
                    ],
                    // • rendering keys, e.g.:
                    throwOnError: false
                });
            });
        </script> -->

        <!-- <style>
            main ul {
                list-style-type: none;
                padding: 0;
                margin: 0;
            }

            main ul li {
                margin: 0;
                padding: 0;
            }
        </style> -->




    </head>

    <body>

        <script> header_author("dm"); </script>

        <main>
            <article class="agen-tableofcontents">
                <h2 class="text-center">
                    Term 2 Answers
                </h2>
                <div class="d-none contentdate">2025, May 4</div>
            </article>

            <article>
                <h3>Section 1 (10 × 1 = 10 marks)</h3>
                <p><strong>1.</strong> <strong>Two LR parsers</strong></p>
                <ul>
                    <li>SLR(1)</li>
                    <li>LALR(1)</li>
                    <li><em>also acceptable: Canonical LR(1), LR(0)</em></li>
                </ul>

                <p><strong>2.</strong> <strong>“Symbol table is accessed only during lexical analysis.”</strong> False</p>
                <p>it’s used throughout—during syntax, semantic analysis, code generation, etc.</p>

                <p><strong>3.</strong> <strong>“Type checking is done before parsing.”</strong> False</p>
                <p>type-checking happens during <em>semantic</em> analysis, after parsing.</p>

                <p><strong>4.</strong> <strong>The derivations used by LR parsers</strong></p>
                <p>Rightmost derivations in reverse</p>

                <p><strong>5.</strong> <strong>Output of a lexical analyzer</strong></p>
                <p>A <strong>stream of tokens</strong> (token-name + attribute/value)</p>

                <p><strong>6.</strong> <strong>Recursive descent parsing is an example of</strong></p>
                <p><strong>Top-down</strong> parsers</p>

                <p><strong>7.</strong> <strong>In a compiler, keywords of a language are recognized during</strong></p>
                <p>The <strong>lexical-analysis</strong> phase</p>

                <p><strong>8.</strong> <strong>Grammar <code>S → aAb</code>, <code>A → aA | ε</code> is LL(1).</strong> True</p>

                <p><strong>9.</strong> <strong>Data structure for managing symbol info</strong></p>
                <p>The <strong>symbol table</strong></p>

                <p><strong>10.</strong> <strong>Match</strong></p>
                <ul>
                    <li>(P) Lexical analysis → (iii) Regular expressions</li>
                    <li>(Q) Top-down parsing → (i) Leftmost derivation</li>
                    <li>(R) Semantic analysis → (ii) Type checking</li>
                    <li>(S) Runtime environments → (iv) Activation records</li>
                </ul>
            </article>

            <article>
                <h3>Section 2 (4 × 2 = 8 marks)</h3>

                <h4>1. Why left-recursion is problematic &amp; removal</h4>
                <p><strong>Problem:</strong> A production of the form $$A \to A \alpha \mid \beta$$ causes an LL(1) (or any top-down) parser to recur infinitely whenever it tries to expand <em>A</em>.</p>
                <p><strong>Removal (direct case):</strong> For</p>
                <p>$$A \to A \alpha_1 \mid A \alpha_2 \mid \dots \mid A \alpha_m \mid \beta_1 \mid \beta_2 \mid \dots \mid \beta_n,$$</p>
                <p>—where no $\beta_i$ begins with <em>A</em>— rewrite as:</p>
                <pre><code class="">A  →  β₁ A′ | β₂ A′ | … | βₙ A′  
A′ →  α₁ A′ | α₂ A′ | … | αₘ A′ | ε</code></pre>

                <h4>2. Convert to right-recursive</h4>
                <p><strong>a.</strong></p>
                <pre><code class="">E → E + T | T
T → T * F | F
F → ( E ) | id</code></pre>
                <p><strong>⇒</strong></p>
                <pre><code class="">E  → T E′
E′ → + T E′ | ε

T  → F T′
T′ → \* F T′ | ε

F  → ( E ) | id</code></pre>

                <p><strong>b.</strong> (original)</p>
                <pre><code class="">S → A a B
A → a A | B a
B → A B | b</code></pre>
                <p><strong>After eliminating indirect recursion and then left-recursion:</strong></p>
                <pre><code class="">S  → A a B
A  → a A | B a
B  → a A B B′  | b B′
B′ → a B B′    | ε</code></pre>

                <h4>3. Deterministic vs. Non-deterministic CFGs</h4>
                <p><strong>Non-deterministic CFG (ND-CFG):</strong> Requires an NPDA; at some point more than one production may apply without a single-way lookahead.</p>
                <pre><code class="">Example:
S → a S b | S S | ε
</code></pre>
                <p><strong>Deterministic CFG (D-CFG):</strong> Can be parsed by a DPDA (deterministic) with no backtracking.</p>
                <pre><code class="">Example:
S → ( S ) S | ε
</code></pre>

                <h4>4. Left-factoring</h4>
                <p><strong>c.</strong> Original:</p>
                <pre><code class="">A → a A A b A
  | a A a A b b b
</code></pre>
                <p>Common prefix: <code>a A</code></p>
                <pre><code class="">A → a A R
R → A b A | a A b b b
</code></pre>

                <p><strong>d.</strong> Original:</p>
                <pre><code class="">A → ( A ) A
  | ( A ) A b ( A ) A b
  | e f
</code></pre>
                <p>Factor out common prefix <code>( A ) A</code>:</p>
                <pre><code class="">A → ( A ) A S
  | e f

S → b ( A ) A b
\| ε </code></pre>

            </article>

            <article>
                <h3>Section 3 (1 × 12 = 12 marks)</h3>

                <h4>a. Architecture of an LL(1) parser</h4>
                <pre class="mermaid text-center">
graph 
subgraph "LL(1)" Parser Architecture
    subgraph Input_Buffer ["Input Buffer (Tape)"]
        direction LR
        A(["a"]) --> B(["b"]) --> D(["d"]) --> End(["$"])
    end
    PT["Parse Table"]
    PA["LL(1) Parser Algorithm"]
    ST["Stack ($)"]

    End --> PA
    PA --> ST
    PA <--> PT
end
</pre>

                               <pre class="mermaid text-center">
flowchart LR
    A["Input buffer<br>(id*(id)$)"] -- parse table --> B["Predictive Parser<br/>(stack + table)"]
    B -- stack ops --> A
                               </pre>
                <p><strong>Input buffer:</strong> tokens + end-marker <code>$</code></p>
                <p><strong>Stack:</strong> holds grammar symbols (initially <code>[E,$]</code>)</p>
                <p><strong>Parse table:</strong> indexed by (non-terminal, lookahead) → production</p>
                <p><strong>Controller:</strong> compare stack top vs. input, consult table for non-terminals, match/pop for terminals, pop on ε.</p>

                <h4>b. FIRST and FOLLOW sets</h4>
                <div class="table-responsive">
                    <table class="table table-bordered table-striped">
                        <thead>
                            <tr>
                                <th>NT</th>
                                <th>FIRST(NT)</th>
                                <th>FOLLOW(NT)</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>E</td>
                                <td>{ id, '(' }</td>
                                <td>{ <code>$</code>, ')' }</td>
                            </tr>
                            <tr>
                                <td>E′</td>
                                <td>{ '+', ε }</td>
                                <td>{ <code>$</code>, ')' }</td>
                            </tr>
                            <tr>
                                <td>T</td>
                                <td>{ id, '(' }</td>
                                <td>{ '+', <code>$</code>, ')' }</td>
                            </tr>
                            <tr>
                                <td>T′</td>
                                <td>{ '*', ε }</td>
                                <td>{ '+', <code>$</code>, ')' }</td>
                            </tr>
                            <tr>
                                <td>F</td>
                                <td>{ id, '(' }</td>
                                <td>{ '*', '+', <code>$</code>, ')' }</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h4>c. LL(1) Parsing Table</h4>
                <div class="table-responsive">
                    <table class="table table-bordered table-striped">
                        <thead>
                            <tr>
                                <th></th>
                                <th>id</th>
                                <th>(</th>
                                <th>+</th>
                                <th>*</th>
                                <th>)</th>
                                <th>$</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>E</strong></td>
                                <td>E → T E′</td>
                                <td>E → T E′</td>
                                <td></td>
                                <td></td>
                                <td></td>
                                <td></td>
                            </tr>
                            <tr>
                                <td><strong>E′</strong></td>
                                <td></td>
                                <td></td>
                                <td>E′ → + T E′</td>
                                <td></td>
                                <td>E′ → ε</td>
                                <td>E′ → ε</td>
                            </tr>
                            <tr>
                                <td><strong>T</strong></td>
                                <td>T → F T′</td>
                                <td>T → F T′</td>
                                <td></td>
                                <td></td>
                                <td></td>
                                <td></td>
                            </tr>
                            <tr>
                                <td><strong>T′</strong></td>
                                <td></td>
                                <td></td>
                                <td>T′ → ε</td>
                                <td>T′ → * F T′</td>
                                <td>T′ → ε</td>
                                <td>T′ → ε</td>
                            </tr>
                            <tr>
                                <td><strong>F</strong></td>
                                <td>F → id</td>
                                <td>F → ( E )</td>
                                <td></td>
                                <td></td>
                                <td></td>
                                <td></td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h4>d. Step-by-step parse of <code>id * id</code></h4>
                <div class="table-responsive">
                    <table class="table table-bordered table-striped">
                        <thead>
                            <tr>
                                <th>Step</th>
                                <th>Stack</th>
                                <th>Input</th>
                                <th>Action</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>0</td>
                                <td>[E, $]</td>
                                <td>id * id $</td>
                                <td>—</td>
                            </tr>
                            <tr>
                                <td>1</td>
                                <td>[T, E′, $]</td>
                                <td>id * id $</td>
                                <td>expand E → T E′</td>
                            </tr>
                            <tr>
                                <td>2</td>
                                <td>[F, T′, E′, $]</td>
                                <td>id * id $</td>
                                <td>expand T → F T′</td>
                            </tr>
                            <tr>
                                <td>3</td>
                                <td>[id, T′, E′, $]</td>
                                <td>id * id $</td>
                                <td>match id; pop id, advance</td>
                            </tr>
                            <tr>
                                <td>4</td>
                                <td>[T′, E′, $]</td>
                                <td>* id $</td>
                                <td>expand T′ → * F T′</td>
                            </tr>
                            <tr>
                                <td>5</td>
                                <td>[*, F, T′, E′, $]</td>
                                <td>* id $</td>
                                <td>match *; pop, advance</td>
                            </tr>
                            <tr>
                                <td>6</td>
                                <td>[F, T′, E′, $]</td>
                                <td>id $</td>
                                <td>expand F → id</td>
                            </tr>
                            <tr>
                                <td>7</td>
                                <td>[id, T′, E′, $]</td>
                                <td>id $</td>
                                <td>match id; pop, advance</td>
                            </tr>
                            <tr>
                                <td>8</td>
                                <td>[T′, E′, $]</td>
                                <td>$</td>
                                <td>pop T′ (ε)</td>
                            </tr>
                            <tr>
                                <td>9</td>
                                <td>[E′, $]</td>
                                <td>$</td>
                                <td>pop E′ (ε)</td>
                            </tr>
                            <tr>
                                <td>10</td>
                                <td>[$]</td>
                                <td>$</td>
                                <td>accept</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h4>e. Parse Tree for <code>id * id</code></h4>
                <pre><code class="">.           E
           |
         T  E′
       /  \   \
      F   T′   ε
      |   | 
     id  * F T′
         |  |
         id ε
</code></pre>
<pre class="d-none mermaid text-center">graph TD
E --> T
E --> EPrime

T --> F
T --> TPrime1

F --> id1["id"]

TPrime1 --> \*
TPrime1 --> F2
TPrime1 --> TPrime2

F2 --> id2["id"]

TPrime2 --> eps1["ε"]
EPrime --> eps2["ε"]
</pre>
            </article>



            <pre id="markdown-raws" class="d-none">
## Section 1 (10 × 1 = 10 marks)

1. **Two LR parsers**

   * SLR(1)
   * LALR(1)
     *(also acceptable: Canonical LR(1), LR(0))*

2. **“Symbol table is accessed only during lexical analysis.”**
   False

   > it’s used throughout—during syntax, semantic analysis, code generation, etc.

3. **“Type checking is done before parsing.”**
   False

   > type-checking happens during *semantic* analysis, after parsing.

4. **The derivations used by LR parsers**
   **Rightmost derivations in reverse**

5. **Output of a lexical analyzer**
   A **stream of tokens** (token-name + attribute/value)

6. **Recursive descent parsing is an example of**
   **Top-down** parsers

7. **In a compiler, keywords of a language are recognized during**
   The **lexical-analysis** phase

8. **Grammar** *S → aAb*, *A → aA | ε* is LL(1).
   True

9. **Data structure for managing symbol info**
   The **symbol table**

10. **Match**
    \| (P) Lexical analysis | (iii) Regular expressions
    \| (Q) Top-down parsing  | (i) Leftmost derivation
    \| (R) Semantic analysis | (ii) Type checking
    \| (S) Runtime environments | (iv) Activation records

---

## Section 2 (4 × 2 = 8 marks)

### 1. Why left-recursion is problematic & removal

* **Problem:**
  A production of form

  ```
  A → A α | β
  ```

  causes an LL(1) (or any top-down) parser to recur infinitely whenever it tries to expand *A*.
* **Removal (direct case):**
  For

  ```
  A → A α₁ | A α₂ | … | A αₘ | β₁ | β₂ | … | βₙ
  ```

  ─where no βᵢ begins with *A*─ rewrite as

  ```
  A  →  β₁ A′ | β₂ A′ | … | βₙ A′  
  A′ →  α₁ A′ | α₂ A′ | … | αₘ A′ | ε
  ```

---

### 2. **Convert to right-recursive**

#### a.

```
E → E + T | T
T → T * F | F
F → ( E ) | id
```

**⇒**

```
E  → T E′
E′ → + T E′ | ε

T  → F T′
T′ → * F T′ | ε

F  → ( E ) | id
```

#### b.

Original (as given):

```
S → A a B
A → a A | B a
B → A B | b
```

1. **Eliminate indirect recursion:**

   * Order nonterminals: A then B
   * A has no direct left-recursion
   * In B → A B | b, substitute A’s alternatives:

     ```
     B → (a A | B a) B | b
       = a A B | B a B | b
     ```
2. **Remove direct left-recursion in B** (where `B → B α | β₁ | β₂`):

   ```
   α = a B
   β₁ = a A B
   β₂ = b

   B  →  β₁ B′ | β₂ B′
   B′ →  α B′  | ε

   ⇒
   B  →  a A B B′  |  b B′
   B′ →  a B  B′  |  ε
   ```
3. **Final grammar** is fully right-recursive:

```
S  → A a B
A  → a A  |  B a
B  → a A B B′  |  b B′
B′ → a B  B′  |  ε
```

---

### 3. Deterministic vs. Non-deterministic CFGs

* **Non-deterministic CFG (ND-CFG):**
  Requires an NPDA to recognize; at some point, more than one production may apply without a single-way lookahead.

  * *Example:*

    ```
    S → a S b | S S | ε
    ```

    (ambiguous; NPDA must guess split point)
* **Deterministic CFG (D-CFG):**
  Can be parsed by a DPDA (deterministic) with no backtracking.

  * *Example:*
    Balanced parentheses

    ```
    S → ( S ) S | ε
    ```

    one-state DPDA suffices.

---

### 4. **Left-factoring**

#### c.

Original:

```
A → a A A b A
  | a A a A b b b
```

* Common prefix: `a A`
* Factor out:

  ```
  A → a A R
  R → A b A | a A b b b
  ```

#### d.

Original:

```
A → ( A ) A
  | ( A ) A b ( A ) A b
  | e f
```

* Two productions start with `(A)A`
* Factor:

  ```
  A → ( A ) A S
      | e f

  S → b ( A ) A b
      | ε
  ```

---

## Section 3 (1 × 12 = 12 marks)

**Grammar:**

```
E  →  T E′
E′ → + T E′ | ε
T  →  F T′
T′ → * F T′ | ε
F  →  id  |  ( E )
```

### a. Architecture of an LL(1) parser

```
┌────────────┐   parse table   ┌─────────────────┐
│  Input buf ├─►──────────────►│                 │
│  (id*(id)$)│                 │  Predictive     │
│            │◄─stack ops─────►│    Parser       │
└────────────┘                 │ (stack + table) │
                               └─────────────────┘
```

* **Input buffer:** tokens + end-marker `$`
* **Stack:** holds grammar symbols (initially `[E,$]`)
* **Parse table:** indexed by (non-terminal, lookahead) → production
* **Controller:**

  * Compare stack top vs. input
  * If top is non-terminal, consult table → expand
  * If match terminal, pop & advance input
  * On ε-production, just pop

---

### b. FIRST and FOLLOW sets

| NT | FIRST(NT)   | FOLLOW(NT)             |
| -- | ----------- | ---------------------- |
| E  | { id, '(' } | { `$`, `)` }           |
| E′ | { `+`, ε }  | { `$`, `)` }           |
| T  | { id, '(' } | { `+`, `$`, `)` }      |
| T′ | { `*`, ε }  | { `+`, `$`, `)` }      |
| F  | { id, '(' } | { `*`, `+`, `$`, `)` } |

---

### c. LL(1) Parsing Table

|        | `id`     | `(`       | `+`       | `*`        | `)`  | `$`  |
| ------ | -------- | --------- | --------- | ---------- | ---- | ---- |
| **E**  | E → T E′ | E → T E′  |           |            |      |      |
| **E′** |          |           | E′→+ T E′ |            | E′→ε | E′→ε |
| **T**  | T → F T′ | T → F T′  |           |            |      |      |
| **T′** |          |           | T′→ε      | T′→\* F T′ | T′→ε | T′→ε |
| **F**  | F → id   | F → ( E ) |           |            |      |      |

*(blank = error cell)*

---

### d. Step-by-step parse of `id * id`

Let input = `id * id $`. Stack starts `[E, $]`.

| Step | Stack                | Input       | Action                          |
| ---- | -------------------- | ----------- | ------------------------------- |
| 0    | \[E, \$]             | id \* id \$ | —                               |
| 1    | \[T, E′, \$]         | id \* id \$ | expand E → T E′                 |
| 2    | \[F, T′, E′, \$]     | id \* id \$ | expand T → F T′                 |
| 3    | \[id, T′, E′, \$]    | id \* id \$ | match id; pop id, advance input |
| 4    | \[T′, E′, \$]        | \* id \$    | expand T′→\* F T′               |
| 5    | \[\*, F, T′, E′, \$] | \* id \$    | match \*; pop \*, advance       |
| 6    | \[F, T′, E′, \$]     | id \$       | expand F → id                   |
| 7    | \[id, T′, E′, \$]    | id \$       | match id; pop id, advance       |
| 8    | \[T′, E′, \$]        | \$          | T′→ε; pop T′                    |
| 9    | \[E′, \$]            | \$          | E′→ε; pop E′                    |
| 10   | \[\$]                | \$          | accept                          |

---

### e. Parse Tree for `id * id`

```
           E
           |
         T  E′
       /  \   \
      F   T′   ε
      |   | 
     id  * F T′
         |  |
         id ε
```

---

> **30 / 30**—all parts complete with clear, exam-style steps.
> Ready for Term I whenever you are!

            </pre>
        </main>

        <script> copyright("all"); </script>

    </body>

</html>