<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>

        <title>Term 1 Answers - CSU086 - Shoolini U</title>
        <meta name="description" content="Term 1 Answers - CSU086 - Shoolini University" />

        <meta property="og:image" content="/logo.png">
        <meta property="og:type" content="article">

        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@divyamohan1993">
        <meta name="twitter:creator" content="@divyamohan1993">
        <meta name="twitter:image" content="/logo.png">

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />

        <meta name="author" content="Divya Mohan">
        <meta name="robots" content="index, follow">

        <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                renderMathInElement(document.body, {
                    // customised options
                    // • auto-render specific keys, e.g.:
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\(', right: '\\)', display: false },
                        { left: '\\[', right: '\\]', display: true }
                    ],
                    // • rendering keys, e.g.:
                    throwOnError: false
                });
            });
        </script> -->

        <!-- <style>
            main ul {
                list-style-type: none;
                padding: 0;
                margin: 0;
            }

            main ul li {
                margin: 0;
                padding: 0;
            }
        </style> -->




    </head>

    <body>

        <script> header_author("dm"); </script>

        <main>
            <article class="agen-tableofcontents">
                <h2 class="text-center">
                    Term 1 Answers
                </h2>
                <div class="d-none contentdate">2025, May 4</div>
            </article>
            
<article>
  <h3>1. What is a language-processing system? Explain using a block diagram.</h3>
  <p><strong>Definition:</strong> A language-processing system is a software suite that takes a source program in a high-level language and translates it into another form (often machine code), performing analysis, translation, and optimization along the way.</p>
  <pre class="mermaid text-center">
flowchart LR
    A["Source Code (program.txt)"] --> B[Lexical Analyzer]
    B --> C[Syntax Analyzer]
    C --> D[Semantic Analyzer]
    D --> E[Intermediate Code Generation]
    E --> F[Code Optimizer]
    F --> G[Target Code Generator]
  </pre>
                        <ul>
                            <li><strong>Lexical Analyzer</strong>: groups characters into tokens.</li>
                            <li><strong>Syntax Analyzer (Parser)</strong>: builds parse tree from tokens.</li>
                            <li><strong>Semantic Analyzer</strong>: checks types, scope, and builds annotated tree.</li>
                            <li><strong>Intermediate Code Generator</strong>: produces low-level code (e.g., three-address code).</li>
                            <li><strong>Optimizer</strong>: improves code (e.g., dead-code removal).</li>
                            <li><strong>Code Generator</strong>: emits target machine or assembly code.</li>
                        </ul>
                        </article>

                        <article>
                            <h3>2. What is the role of the lexical analyser? Explain any two.</h3>
                            <p>A <strong>token</strong> is the lexical analyzer’s output: a pair ⟨token-name, attribute⟩. Its key roles are:</p>
                            <ol>
                                <li>
                                    <strong>Tokenization (Scanning):</strong>
                                    <p>Reads input characters, matches them against token patterns (identifiers, keywords, operators, literals).</p>
                                    <p>Packages each lexeme into a token sent to the parser.</p>
                                </li>
                                <li>
                                    <strong>Filtering:</strong>
                                    <p>Removes whitespace and comments so later phases see only meaningful tokens.</p>
                                    <p>Handles simple error checks (e.g., unterminated string literal) and reports them.</p>
                                </li>
                            </ol>
                            <p><em>(Other roles include symbol-table entry for identifiers, buffering input, and simple error recovery at the lexical level.)</em></p>
                        </article>

                        <article>
                            <h3>3. With the help of an example, explain associativity-violation and how it is resolved.</h3>
                            <p><strong>Example:</strong> subtraction is left-associative, so</p>
                            <pre><code>5 – 3 – 1  ≡  (5 – 3) – 1  = 1</code></pre>
                            <p>But an <strong>ambiguous</strong> grammar like</p>
                            <pre><code>E → E – E | id</code></pre>
                            <p>lets you parse it two ways:</p>
                            <ul>
                                <li>
                                    <strong>Left associate:</strong>
                                    <pre><code>.
   E
  / \
 E   E
/ \   |
5  3  1
      </code></pre>
                                    <p>⇒ (5–3)–1 = 1</p>
                                </li>
                                <li>
                                    <strong>Right associate:</strong>
                                    <pre><code>.
   E
  / \
 5   E
    / \
   3   1
      </code></pre>
                                    <p>⇒ 5–(3–1) = 3</p>
                                </li>
                            </ul>
                            <p><strong>Violation:</strong> if the parser picks the wrong tree, you get 3 instead of 1.</p>
                            <p><strong>Resolution:</strong> enforce left-associativity in the grammar:</p>
                            <pre><code>
E → E – T | T
T → id
  </code></pre>
                            <p>Here, <code>E – T</code> forces any chain of “–” to group on the left.</p>
                        </article>

                        <article>
                            <h3>4. Explain panic-mode recovery.</h3>
                            <p>When the parser detects a syntax error, <strong>panic-mode</strong> recovery:</p>
                            <ol>
                                <li>
                                    <p><strong>Discard input tokens</strong> until a designated <em>synchronizing token</em> (e.g., <code>;</code>, <code>}</code>) is found.</p>
                                </li>
                                <li>
                                    <p><strong>Pop stack symbols</strong> until a state is reached where the synchronizing token is valid.</p>
                                </li>
                                <li>
                                    <p><strong>Resume normal parsing</strong> from that point.</p>
                                </li>
                            </ol>
                            <p>This prevents the parser from cascading (“flood”) errors and guarantees termination, though it may skip some valid constructs.</p>
                        </article>

                        <article>
                            <h3>Section 2 (2 × 6 = 12 marks)</h3>
                            <p><em>Answer all questions</em></p>

                            <h4>1. What is a token? How many tokens are present in the following statements?</h4>
                            <p>A <strong>token</strong> is the basic unit returned by the lexical analyzer, typically ⟨token-name, attribute⟩.</p>
                            <div class="table-responsive">
                                <table class="table table-bordered table-striped">
                                    <thead>
                                        <tr>
                                            <th>Statement</th>
                                            <th>Tokens</th>
                                            <th>Count</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td>a. <code>if (x &gt; 10 &amp;&amp; y &lt; 5)</code></td>
                                            <td><code>if</code>, <code>(</code>, <code>x</code>, <code>&gt;</code>, <code>10</code>, <code>&amp;&amp;</code>, <code>y</code>, <code>&lt;</code>, <code>5</code>, <code>)</code></td>
                                            <td>10</td>
                                        </tr>
                                        <tr>
                                            <td>b. <code>printf("Compiler");</code></td>
                                            <td><code>printf</code>, <code>(</code>, <code>"Compiler"</code>, <code>)</code>, <code>;</code></td>
                                            <td>5</td>
                                        </tr>
                                        <tr>
                                            <td>c. <code>void func(int a, float b) { return; }</code></td>
                                            <td><code>void</code>, <code>func</code>, <code>(</code>, <code>int</code>, <code>a</code>, <code>,</code>, <code>float</code>, <code>b</code>, <code>)</code>, <code>{</code>, <code>return</code>, <code>;</code>, <code>}</code></td>
                                            <td>13</td>
                                        </tr>
                                        <tr>
                                            <td>d. <code>while(a != 0 &amp;&amp; b == 5) { a--; }</code></td>
                                            <td><code>while</code>, <code>(</code>, <code>a</code>, <code>!=</code>, <code>0</code>, <code>&amp;&amp;</code>, <code>b</code>, <code>==</code>, <code>5</code>, <code>)</code>, <code>{</code>, <code>a</code>, <code>--</code>, <code>;</code>, <code>}</code></td>
                                            <td>15</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>

                            <h4>2. Using a block diagram explain the structure of the compiler.</h4>
                            <pre class="mermaid text-center">
flowchart LR
    A["Source Code (text)"] --> B[Lexical Analyzer]
    B --> C[Syntax Analyzer]
    C --> D[Semantic Analyzer]
    D --> E[Intermediate Code Generation]
    E --> F[Code Optimization]
    F --> G[Target Code Generation]
    G --> H[Machine Code / Object File]
  </pre>
                            <p><strong>Phase summaries:</strong></p>
                            <ul>
                                <li><strong>Lexical Analysis:</strong> tokens &amp; symbol table.</li>
                                <li><strong>Syntax Analysis:</strong> parse tree, checks grammar.</li>
                                <li><strong>Semantic Analysis:</strong> type checking, scope resolution.</li>
                                <li><strong>Intermediate Code Generation:</strong> three-address code.</li>
                                <li><strong>Optimization:</strong> peephole, loop optimizations.</li>
                                <li><strong>Code Generation:</strong> assembly or machine code.</li>
                                <li><strong>Error Handler &amp; Symbol Table:</strong> services run throughout.</li>
                            </ul>
                        </article>

                        <article>
                            <h3>Section 3 (1 × 10 = 10 marks)</h3>
                            <p><em>Answer all questions</em></p>
                            <p><strong>Grammar:</strong></p>
                            <pre><code>
E → E + E
| ( E * E )
| id
  </code></pre>
                            <p><strong>String:</strong></p>
                            <pre><code>id + ( id * ( id * id ) )</code></pre>

                            <h4>a. Leftmost &amp; rightmost derivations</h4>
                            <p><strong>Leftmost</strong></p>
                            <pre><code>
E
⇒ E + E
⇒ id + E
⇒ id + ( E * E )
⇒ id + ( id * E )
⇒ id + ( id * ( E * E ) )
⇒ id + ( id * ( id * E ) )
⇒ id + ( id * ( id * id ) )
  </code></pre>

                            <p><strong>Rightmost</strong></p>
                            <pre><code>
E
⇒ E + E
⇒ E + ( E * E )
⇒ E + ( E * ( E * E ) )
⇒ E + ( E * ( id * E ) )
⇒ E + ( E * ( id * id ) )
⇒ E + ( id * ( id * id ) )
⇒ id + ( id * ( id * id ) )
  </code></pre>

                            <h4>b. Parse tree</h4>
                            <pre><code>.
            E
          / | \
         /  +  \
        E       E
        |     / | \
       id    (  E  )
              /|\
             E * E  
             |   /|\
            id id id
  </code></pre>

                            <h4>c. Ambiguity</h4>
                            <p>This grammar is <strong>ambiguous</strong>—there exist strings with more than one parse tree. For example, for <code>id + id * id</code> you can interpret <code>+</code> before <code>*</code> or vice versa, yielding two valid trees.</p>
                        </article>
        </main>

        <script> copyright("all"); </script>

    </body>

</html>