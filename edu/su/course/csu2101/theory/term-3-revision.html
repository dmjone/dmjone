<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <!-- Prefetch mermaid files -->

        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>

        <title>Term 3 Revision - CSU2101 | Shoolini University</title>

        <meta name="description" content="Term 3 Revision - CSU2101 | Shoolini University" />

        <meta property="og:image" content="/logo.png">
        <meta property="og:type" content="article">

        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@divyamohan1993">
        <meta name="twitter:creator" content="@divyamohan1993">
        <meta name="twitter:image" content="/logo.png">

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />

        <meta name="author" content="Divya Mohan">
        <meta name="robots" content="index, follow">

        <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                renderMathInElement(document.body, {
                    // customised options
                    // • auto-render specific keys, e.g.:
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\(', right: '\\)', display: false },
                        { left: '\\[', right: '\\]', display: true }
                    ],
                    // • rendering keys, e.g.:
                    throwOnError: false
                });
            });
        </script> -->

        <!-- <style>
            main ul {
                list-style-type: none;
                padding: 0;
                margin: 0;
            }

            main ul li {
                margin: 0;
                padding: 0;
            }
        </style> -->

        <!-- JSON-LD Structured Data for SEO -->
        <script type="application/ld+json">
        {
          "@context": "https://schema.org",
          "@type": "TechArticle",
          "headline": "Term 3 Revision - CSU2101",
          "description": "Term 3 Revision - CSU2101 | Shoolini University",
          "dateModified": "2025-05-11",
          "author": [
            {
              "@type": "Person",
              "name": "Divya Mohan",
              "url": "https://dmj.one/resume/",
              "sameAs": [
                "https://www.credly.com/users/divyamohan1993",
                "https://www.linkedin.com/in/divyamohan1993/",
                "https://hackerrank.com/divyamohan1993",
                "https://www.coursera.org/learner/divyamohan1993"
              ]
            }
          ],
          "publisher": {
            "@type": "EducationalOrganization",
            "name": "dmj.one",
            "url": "https://dmj.one"
          },
          "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https://dmj.one/edu/su/course/csu2101/theory/"
          },
          "keywords": [
            "SQL",
            "SQL Joins",
            "Inner Join",
            "Outer Join",
            "Self Join",
            "Cross Join",
            "Natural Join",
            "Database Queries",
            "Database Management"
          ],
          "articleSection": [
            "Introduction to SQL Joins",
            "Types of Joins",
            "Why do we need Joins?",
            "Inner Join (Equi Join)",
            "Outer Join (Left, Right, Full)",
            "Self Join",
            "Cross Join (Cartesian Join)",
            "Natural Join",
            "Practical Tips & Insights",
            "Common Pitfalls to Avoid",
            "Test Yourself",
            "Bonus Challenge"
          ],
          "isAccessibleForFree": true,
          "inLanguage": "en-US",
          "license": "https://creativecommons.org/licenses/by-sa/4.0/"
        }
        </script>




    </head>

    <body>

        <script> header_author("dm"); </script>

        <main>
            <article class="agen-tableofcontents">
                <h2 class="text-center">
                    Term 3 Revision
                </h2>
                <div class="d-none contentdate">2025, May 11</div>
            </article>

            <article>
                <h3>Database</h3>
                <p>A <strong>database</strong> is an organized collection of related data stored electronically. It enables efficient storage, retrieval, update and management of large volumes of information.</p>
                <h4>Definition &amp; Purpose</h4>
                <ul>
                    <li><strong>Definition:</strong> A database is a structured set of data, usually stored in tables, that models real-world entities and their relationships.</li>
                    <li><strong>Purpose:</strong></li>
                </ul>
                <ol>
                    <li><strong>Centralize data</strong> so multiple users/applications can share it.</li>
                    <li><strong>Ensure consistency</strong> and integrity by enforcing rules.</li>
                    <li><strong>Support efficient queries</strong> and reports.</li>
                    <li><strong>Provide security, backup and recovery.</strong></li>
                </ol>
                <h4>Types of Databases</h4>
                <blockquote>
                    <p><strong>(A)</strong> <em>By Data Model</em></p>
                </blockquote>
                <ol>
                    <li>
                        <p><strong>Flat-file</strong></p>
                        <ul>
                            <li><em>Structure:</em> Single plain text file (e.g. CSV).</li>
                            <li><em>Use-case:</em> Simple lists (e.g. address book).</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Hierarchical</strong></p>
                        <ul>
                            <li><em>Structure:</em> Tree-like parent-child.</li>
                            <li><em>Example:</em> IBM’s IMS storing bill-of-materials.</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Network</strong></p>
                        <ul>
                            <li><em>Structure:</em> Graph of records with many-to-many links.</li>
                            <li><em>Example:</em> CODASYL DBMS.</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Relational</strong></p>
                        <ul>
                            <li><em>Structure:</em> Tables (rows &amp; columns) with keys.</li>
                            <li><em>Example:</em> MySQL, Oracle.</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Object-Oriented</strong></p>
                        <ul>
                            <li><em>Structure:</em> Data as “objects” (attributes + methods).</li>
                            <li><em>Example:</em> db4o for CAD/CAM applications.</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>NoSQL</strong></p>
                        <ul>
                            <li>
                                <p><em>Variants:</em></p>
                                <ul>
                                    <li><em>Key-Value:</em> Redis (sessions).</li>
                                    <li><em>Document:</em> MongoDB (JSON docs).</li>
                                    <li><em>Column-Family:</em> Cassandra (time-series).</li>
                                    <li><em>Graph:</em> Neo4j (social networks).</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ol>
                <blockquote>
                    <p><strong>(B)</strong> <em>By Usage</em></p>
                </blockquote>
                <ul>
                    <li><strong>OLTP (Online Transaction Processing):</strong> Fast, high-volume transactions (e.g. banking).</li>
                    <li><strong>OLAP (Online Analytical Processing):</strong> Complex queries on historical data (e.g. data warehousing).</li>
                </ul>
                <blockquote>
                    <p><strong>(C)</strong> <em>By Architecture</em></p>
                </blockquote>
                <ul>
                    <li><strong>Centralized:</strong> Single server hosts data.</li>
                    <li><strong>Client-Server:</strong> Clients query a server-based DBMS.</li>
                    <li><strong>Distributed:</strong> Data spread over multiple sites (replication/fragmentation).</li>
                    <li><strong>Cloud Database:</strong> Hosted on cloud platforms (scalable).</li>
                    <li><strong>Data Warehouse:</strong> Integrated, subject-oriented store for analysis.</li>
                </ul>
                <h4>3. Key Features</h4>
                <ol>
                    <li>
                        <p><strong>Data Independence</strong></p>
                        <ul>
                            <li><em>Logical:</em> Schema changes don’t affect applications.</li>
                            <li><em>Physical:</em> Storage changes transparent to users.</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>ACID Properties</strong></p>
                        <ul>
                            <li><em>Atomicity:</em> All or nothing for transactions.</li>
                            <li><em>Consistency:</em> Transitions preserve integrity constraints.</li>
                            <li><em>Isolation:</em> Concurrent transactions do not interfere.</li>
                            <li><em>Durability:</em> Committed data survives failures.</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Integrity Constraints</strong></p>
                        <ul>
                            <li><em>Entity:</em> Primary keys non-NULL &amp; unique.</li>
                            <li><em>Referential:</em> Foreign keys match primary keys.</li>
                            <li><em>Domain:</em> Valid data types &amp; ranges.</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Concurrency Control</strong></p>
                        <ul>
                            <li>Locks/Multiversion to allow safe parallel access.</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Security</strong></p>
                        <ul>
                            <li>Authentication, authorization, encryption.</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Backup &amp; Recovery</strong></p>
                        <ul>
                            <li>Regular backups; restore after crash.</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Data Dictionary</strong></p>
                        <ul>
                            <li>Metadata repository describing structure.</li>
                        </ul>
                    </li>
                </ol>
                <hr>
                <h4>4. Advantages</h4>
                <ul>
                    <li><strong>Reduced Redundancy:</strong> Central storage avoids duplicate data.</li>
                    <li><strong>Improved Consistency:</strong> Single source of truth.</li>
                    <li><strong>Data Sharing:</strong> Multiple users/applications can access concurrently.</li>
                    <li><strong>Data Integrity:</strong> Enforced rules prevent invalid data.</li>
                    <li><strong>Enhanced Security:</strong> Fine-grained access control.</li>
                    <li><strong>Efficient Querying:</strong> Indexes and optimizers speed retrieval.</li>
                    <li><strong>Backup &amp; Recovery:</strong> Automated procedures minimize data loss.</li>
                    <li><strong>Scalability:</strong> Distributed/cloud DBs handle growth.</li>
                </ul>
                <h4>5. Disadvantages</h4>
                <ul>
                    <li><strong>High Cost:</strong> Hardware, software licenses, skilled personnel.</li>
                    <li><strong>Complexity:</strong> Requires careful design and administration.</li>
                    <li><strong>Performance Overhead:</strong> ACID and concurrency controls incur costs.</li>
                    <li><strong>Single Point of Failure:</strong> Without replication, server crash halts service.</li>
                    <li><strong>Vendor Lock-In:</strong> Migration between DBMS products can be hard.</li>
                    <li><strong>Maintenance Effort:</strong> Regular tuning, patching, backups.</li>
                </ul>
                <h4>6. Example: Simple Relational Database</h4>
                <p><strong>Scenario:</strong> University stores Students and Courses.</p>
                <table class="table-dark">
                    <thead>
                        <tr>
                            <th>Student(StudentID, Name, Dept)</th>
                            <th>Course(CourseID, Title, Credits)</th>
                            <th>Enroll(StudentID, CourseID, Grade)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>(101, “Divya”, “CSE”)</td>
                            <td>(CS201, “DBMS”, 4)</td>
                            <td>(101, CS201, “A”)</td>
                        </tr>
                        <tr>
                            <td>(102, “Rahul”, “EEE”)</td>
                            <td>(EE301, “Circuits”, 3)</td>
                            <td>(102, EE301, “B”)</td>
                        </tr>
                    </tbody>
                </table>
                <ul>
                    <li>
                        <p><strong>Demonstrates:</strong></p>
                        <ul>
                            <li><strong>Referential Integrity:</strong> <code>Enroll.StudentID → Student.StudentID</code></li>
                            <li><strong>Query Example:</strong></li>
                        </ul>
                    </li>
                </ul>
                <pre><code class="">SELECT S.Name, C.Title, E.Grade
FROM Student S
JOIN Enroll E ON S.StudentID = E.StudentID
JOIN Course C ON E.CourseID = C.CourseID;
</code></pre>
                <ul>
                    <li><strong>ACID in Action:</strong> A student’s enrollment and fee payment (two updates) succeed or both roll back.</li>
                </ul>
                <hr>
            </article>
            <article>
                <h3>SQL: Definition and Purpose</h3>
                <p><strong>Structured Query Language (SQL)</strong> is the standard language for interacting with relational databases. It lets you <strong>define</strong>, <strong>manipulate</strong>, <strong>control</strong>, and <strong>query</strong> data through simple, English-like statements.</p>
                <hr>
                <h4>1. Data Definition Language (DDL)</h4>
                <p><strong>Concept:</strong> DDL commands specify the <strong>structure</strong> of database objects—tables, indexes, schemas—by creating, altering, or dropping them. Changes made by DDL statements are <strong>auto-committed</strong>.
                    <strong>Key Commands:</strong>
                </p>
                <ul>
                    <li><code>CREATE</code> — make a new table or object</li>
                    <li><code>ALTER</code> — change an existing object</li>
                    <li><code>DROP</code> — delete an object</li>
                    <li><code>TRUNCATE</code> — remove all rows from a table</li>
                </ul>
                <p><strong>Example:</strong> Create, modify, and drop a table</p>
                <pre><code class="">-- Create a table for employees
CREATE TABLE Employee (
EmpID    INT      PRIMARY KEY,
Name     VARCHAR(50),
Dept     VARCHAR(30)
);

-- Add a new column for salary
ALTER TABLE Employee
ADD COLUMN Salary DECIMAL(10,2);

-- Remove the table completely
DROP TABLE Employee;
</code></pre>
                <hr>
                <h4>2. Data Manipulation Language (DML)</h4>
                <p><strong>Concept:</strong> DML commands <strong>change</strong> the data within tables but do not alter table structure. These statements can be <strong>rolled back</strong> if within a transaction.
                    <strong>Key Commands:</strong>
                </p>
                <ul>
                    <li><code>INSERT</code> — add new rows</li>
                    <li><code>UPDATE</code> — modify existing rows</li>
                    <li><code>DELETE</code> — remove rows</li>
                </ul>
                <p><strong>Example:</strong> Insert, update, and delete rows</p>
                <pre><code class="">-- Add two new employees
INSERT INTO Employee (EmpID, Name, Dept, Salary)
VALUES
(101, 'Divya Mohan', 'CSE', 75000),
(102, 'Rahul Singh', 'ECE', 68000);

-- Give Rahul a raise
UPDATE Employee
SET Salary = 70000
WHERE EmpID = 102;

-- Remove an employee record
DELETE FROM Employee
WHERE EmpID = 101;
</code></pre>
                <hr>
                <h4>3. Data Query Language (DQL)</h4>
                <p><em>(Often considered part of DML, but focused on data retrieval.)</em>
                    <strong>Concept:</strong> DQL commands <strong>fetch</strong> data from one or more tables. Results are read-only unless wrapped in DML statements.
                    <strong>Key Command:</strong>
                </p>
                <ul>
                    <li><code>SELECT</code> — retrieve rows matching specified criteria</li>
                </ul>
                <p><strong>Example:</strong> Retrieve employee names in CSE department</p>
                <pre><code class="">SELECT EmpID, Name, Salary
FROM Employee
WHERE Dept = 'CSE'
ORDER BY Salary DESC;
</code></pre>
                <hr>
                <h4>4. Transaction Control Language (TCL)</h4>
                <p><strong>Concept:</strong> TCL commands manage <strong>transactions</strong>, grouping multiple DML operations into a single atomic unit.
                    <strong>Key Commands:</strong>
                </p>
                <ul>
                    <li><code>COMMIT</code> — make all changes permanent</li>
                    <li><code>ROLLBACK</code> — undo changes since last commit</li>
                    <li><code>SAVEPOINT</code> — set a point within a transaction to roll back to</li>
                </ul>
                <p><strong>Example:</strong> Use a savepoint and rollback</p>
                <pre><code class="">BEGIN;  -- start transaction

UPDATE Employee
SET Salary = Salary * 1.1
WHERE Dept = 'ECE';

SAVEPOINT before_bonus;

DELETE FROM Employee
WHERE EmpID = 999;  -- oops, wrong record

ROLLBACK TO before_bonus;  -- undo only the delete

COMMIT;  -- finalize the salary update
</code></pre>
                <hr>
                <h4>5. Data Control Language (DCL)</h4>
                <p><strong>Concept:</strong> DCL commands regulate <strong>access</strong> and <strong>permissions</strong> for database users and roles.
                    <strong>Key Commands:</strong>
                </p>
                <ul>
                    <li><code>GRANT</code> — give privileges to users</li>
                    <li><code>REVOKE</code> — remove granted privileges</li>
                </ul>
                <p><strong>Example:</strong> Grant and revoke privileges</p>
                <pre><code class="">-- Allow user 'alice' to read and insert in Employee
GRANT SELECT, INSERT
ON Employee
TO alice;

-- Later, remove insert privilege
REVOKE INSERT
ON Employee
FROM alice;
</code></pre>
                <hr>
            </article>
            <article>
                <h3>1. Queries</h3>
                <p><strong>Concept:</strong>
                    A <strong>query</strong> is an instruction to the database to <strong>retrieve</strong> or <strong>manipulate</strong> data. In SQL, the primary retrieval query is the <strong><code>SELECT</code></strong> statement. Queries can range from simple single-table lookups to complex nested and joined queries.</p>
                <p><strong>Key Types &amp; Examples:</strong></p>
                <ol>
                    <li>
                        <p><strong>Simple Query</strong></p>
                        <ul>
                            <li>Retrieves all columns or specific columns from one table.</li>
                        </ul>
                    </li>
                </ol>
                <pre><code class="">   -- All columns
SELECT * 
FROM Employee;

   -- Specific columns
SELECT EmpID, Name, Dept 
FROM Employee;
</code></pre>
                <ol start="2">
                    <li>
                        <p><strong>Filtered Query</strong></p>
                        <ul>
                            <li>Uses <strong><code>WHERE</code></strong> to restrict rows.</li>
                        </ul>
                    </li>
                </ol>
                <pre><code class="">SELECT EmpID, Name
FROM Employee
WHERE Dept = 'CSE';
</code></pre>
                <ol start="3">
                    <li>
                        <p><strong>Aggregate Query</strong></p>
                        <ul>
                            <li>Summarizes data using functions like <strong><code>COUNT</code></strong>, <strong><code>SUM</code></strong>, <strong><code>AVG</code></strong>, <strong><code>MAX</code></strong>, <strong><code>MIN</code></strong>.</li>
                        </ul>
                    </li>
                </ol>
                <pre><code class="">   -- Total salary by department
SELECT Dept, SUM(Salary) AS TotalSal
FROM Employee
GROUP BY Dept;
</code></pre>
                <ol start="4">
                    <li>
                        <p><strong>Join Query</strong></p>
                        <ul>
                            <li>Combines rows from two or more tables on a related column.</li>
                        </ul>
                    </li>
                </ol>
                <pre><code class="">SELECT S.Name, C.Title, E.Grade
FROM Student S
JOIN Enroll E ON S.StudentID = E.StudentID
JOIN Course C  ON E.CourseID  = C.CourseID;
</code></pre>
                <ol start="5">
                    <li>
                        <p><strong>Subquery (Nested Query)</strong></p>
                        <ul>
                            <li>A query inside another.</li>
                        </ul>
                    </li>
                </ol>
                <pre><code class="">   -- Employees earning above the average salary
SELECT Name, Salary
FROM Employee
WHERE Salary &gt; (
SELECT AVG(Salary)
FROM Employee
);
</code></pre>
                <ol start="6">
                    <li>
                        <p><strong>Correlated Subquery</strong></p>
                        <ul>
                            <li>References outer query row.</li>
                        </ul>
                    </li>
                </ol>
                <pre><code class="">SELECT E1.EmpID, E1.Name, E1.Salary
FROM Employee E1
WHERE E1.Salary &gt; (
SELECT AVG(E2.Salary)
FROM Employee E2
WHERE E2.Dept = E1.Dept
);
</code></pre>
                <hr>
            </article>
            <article>
                <h3>2. Operators</h3>
                <p><strong>Concept:</strong>
                    <strong>Operators</strong> perform computations or comparisons on data. SQL operators fall into several categories:
                </p>
                <ol>
                    <li>
                        <p><strong>Arithmetic Operators</strong></p>
                        <ul>
                            <li><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code></li>
                        </ul>
                    </li>
                </ol>
                <pre><code class="">SELECT EmpID, Salary, Salary * 0.10 AS Bonus
FROM Employee;
</code></pre>
                <ol start="2">
                    <li>
                        <p><strong>Comparison Operators</strong></p>
                        <ul>
                            <li><code>=</code>, <code>&lt;&gt;</code> (not equal), <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></li>
                        </ul>
                    </li>
                </ol>
                <pre><code class="">SELECT Name
FROM Employee
WHERE Salary &gt;= 60000;
</code></pre>
                <ol start="3">
                    <li>
                        <p><strong>Logical Operators</strong></p>
                        <ul>
                            <li><code>AND</code>, <code>OR</code>, <code>NOT</code></li>
                        </ul>
                    </li>
                </ol>
                <pre><code class="">SELECT *
FROM Employee
WHERE Dept = 'CSE'
AND Salary &gt; 70000;
</code></pre>
                <ol start="4">
                    <li>
                        <p><strong>Set Operators &amp; Conditions</strong></p>
                        <ul>
                            <li><code>IN</code>, <code>NOT IN</code>, <code>BETWEEN … AND …</code>, <code>LIKE</code>, <code>IS NULL</code></li>
                        </ul>
                    </li>
                </ol>
                <pre><code class="">   -- IN
SELECT Name
FROM Employee
WHERE Dept IN ('CSE', 'ECE');

   -- BETWEEN
SELECT Name
FROM Employee
WHERE Salary BETWEEN 50000 AND 80000;

   -- LIKE (pattern match)
SELECT Name
FROM Employee
WHERE Name LIKE 'A%';  -- starts with 'A'
</code></pre>
                <ol start="5">
                    <li>
                        <p><strong>String Operators</strong></p>
                        <ul>
                            <li>Concatenation (<code>||</code> or <code>CONCAT</code>)</li>
                        </ul>
                    </li>
                </ol>
                <pre><code class="">SELECT EmpID, Name || ' (' || Dept || ')' AS Info
FROM Employee;
</code></pre>
                <hr>
            </article>
            <article>
                <h3>3. Clauses</h3>
                <p><strong>Concept:</strong>
                    A <strong>clause</strong> is a component of an SQL statement that defines <strong>what</strong>, <strong>where</strong>, <strong>how</strong>, and <strong>in what order</strong> data is processed. In a <code>SELECT</code> query, common clauses include:</p>
                <table class="table-dark">
                    <thead>
                        <tr>
                            <th>Clause</th>
                            <th>Purpose</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong><code>SELECT</code></strong></td>
                            <td>Specify columns or expressions to retrieve</td>
                            <td><code>SELECT Name, Salary</code></td>
                        </tr>
                        <tr>
                            <td><strong><code>FROM</code></strong></td>
                            <td>Identify source table(s)</td>
                            <td><code>FROM Employee</code></td>
                        </tr>
                        <tr>
                            <td><strong><code>WHERE</code></strong></td>
                            <td>Filter rows before grouping or selecting</td>
                            <td><code>WHERE Dept = 'CSE'</code></td>
                        </tr>
                        <tr>
                            <td><strong><code>GROUP BY</code></strong></td>
                            <td>Aggregate rows sharing common values</td>
                            <td><code>GROUP BY Dept</code></td>
                        </tr>
                        <tr>
                            <td><strong><code>HAVING</code></strong></td>
                            <td>Filter groups after aggregation</td>
                            <td><code>HAVING SUM(Salary) &gt; 200000</code></td>
                        </tr>
                        <tr>
                            <td><strong><code>ORDER BY</code></strong></td>
                            <td>Sort result rows</td>
                            <td><code>ORDER BY Salary DESC</code></td>
                        </tr>
                        <tr>
                            <td><strong><code>LIMIT</code></strong></td>
                            <td>Restrict number of rows returned (MySQL/PostgreSQL)</td>
                            <td><code>LIMIT 5</code></td>
                        </tr>
                        <tr>
                            <td><strong><code>DISTINCT</code></strong></td>
                            <td>Remove duplicate rows</td>
                            <td><code>SELECT DISTINCT Dept</code></td>
                        </tr>
                    </tbody>
                </table>
                <p><strong>Full Example Combining Clauses:</strong></p>
                <pre><code class="">SELECT Dept,
COUNT(*) AS NumEmployees,
AVG(Salary) AS AvgSalary
FROM Employee
WHERE Salary &gt; 40000
GROUP BY Dept
HAVING AVG(Salary) &gt; 50000
ORDER BY AvgSalary DESC
LIMIT 3;
</code></pre>
                <blockquote>
                    <p><strong>Explanation:</strong></p>
                    <ol>
                        <li><strong><code>SELECT</code></strong> columns and aggregates.</li>
                        <li><strong><code>FROM</code></strong> source table.</li>
                        <li><strong><code>WHERE</code></strong> filters individual rows.</li>
                        <li><strong><code>GROUP BY</code></strong> groups them by department.</li>
                        <li><strong><code>HAVING</code></strong> filters groups on aggregate.</li>
                        <li><strong><code>ORDER BY</code></strong> sorts results.</li>
                        <li><strong><code>LIMIT</code></strong> shows top 3 departments.</li>
                    </ol>
                </blockquote>
                <hr>
            </article>
            <article>
                <h3>Joins in SQL</h3>
                <p>A <strong>join</strong> combines rows from two or more tables based on a related column, letting you fetch related data in a single query.</p>
                <hr>
                <h4>1. Inner Join (Equi-Join)</h4>
                <p><strong>Concept:</strong> Returns only rows where the join condition matches in both tables.
                    <strong>Syntax:</strong>
                </p>
                <pre><code class="">SELECT columns
FROM A
INNER JOIN B
ON A.key = B.key;
</code></pre>
                <p><strong>Example:</strong>
                    Tables:</p>
                <ul>
                    <li><strong>Student</strong>(StudID, Name, DeptID)</li>
                    <li><strong>Department</strong>(DeptID, DeptName)</li>
                </ul>
                <pre><code class="">SELECT S.StudID, S.Name, D.DeptName
FROM Student S
INNER JOIN Department D
ON S.DeptID = D.DeptID;
</code></pre>
                <hr>
                <h4>2. Left Outer Join</h4>
                <p><strong>Concept:</strong> Returns all rows from the <strong>left</strong> table, plus matching rows from the right. Non-matching right-side columns are NULL.
                    <strong>Syntax:</strong>
                </p>
                <pre><code class="">SELECT columns
FROM A
LEFT JOIN B
ON A.key = B.key;
</code></pre>
                <p><strong>Example:</strong></p>
                <pre><code class="">SELECT S.StudID, S.Name, D.DeptName
FROM Student S
LEFT JOIN Department D
ON S.DeptID = D.DeptID;
</code></pre>
                <ul>
                    <li>Students without a valid DeptID still appear; DeptName will be NULL.</li>
                </ul>
                <hr>
                <h4>3. Right Outer Join</h4>
                <p><strong>Concept:</strong> Returns all rows from the <strong>right</strong> table, plus matching rows from the left. Non-matching left-side columns are NULL.
                    <strong>Syntax:</strong>
                </p>
                <pre><code class="">SELECT columns
FROM A
RIGHT JOIN B
ON A.key = B.key;
</code></pre>
                <p><strong>Example:</strong></p>
                <pre><code class="">SELECT S.StudID, S.Name, D.DeptName
FROM Student S
RIGHT JOIN Department D
ON S.DeptID = D.DeptID;
</code></pre>
                <ul>
                    <li>Departments with no students still appear; StudID and Name will be NULL.</li>
                </ul>
                <hr>
                <h4>4. Full Outer Join</h4>
                <p><strong>Concept:</strong> Returns <strong>all</strong> rows when there is a match in either left or right table. Non-matches fill with NULLs.
                    <strong>Syntax:</strong>
                </p>
                <pre><code class="">SELECT columns
FROM A
FULL OUTER JOIN B
ON A.key = B.key;
</code></pre>
                <p><strong>Example:</strong></p>
                <pre><code class="">SELECT S.StudID, S.Name, D.DeptName
FROM Student S
FULL OUTER JOIN Department D
ON S.DeptID = D.DeptID;
</code></pre>
                <ul>
                    <li>Covers every student and every department, matching where possible.</li>
                </ul>
                <hr>
                <h4>5. Cross Join (Cartesian Product)</h4>
                <p><strong>Concept:</strong> Returns every combination of rows from both tables (no join condition). Use sparingly—result grows multiplicatively.
                    <strong>Syntax:</strong>
                </p>
                <pre><code class="">SELECT columns
FROM A
CROSS JOIN B;
</code></pre>
                <p><strong>Example:</strong></p>
                <pre><code class="">SELECT S.Name, D.DeptName
FROM Student S
CROSS JOIN Department D;
</code></pre>
                <ul>
                    <li>If Student has 5 rows and Department has 3, result has 15 rows.</li>
                </ul>
                <hr>
                <h4>6. Self Join</h4>
                <p><strong>Concept:</strong> A table joined to <strong>itself</strong>. Useful for hierarchical or comparative queries.
                    <strong>Syntax:</strong>
                </p>
                <pre><code class="">SELECT A.cols, B.cols
FROM Table A
JOIN Table B
ON A.key = B.key2;
</code></pre>
                <p><strong>Example:</strong> (Employees with their managers)
                    Table: <strong>Employee</strong>(EmpID, Name, ManagerID)</p>
                <pre><code class="">SELECT E.EmpID,
E.Name      AS Employee,
M.Name      AS Manager
FROM Employee E
LEFT JOIN Employee M
ON E.ManagerID = M.EmpID;
</code></pre>
                <hr>
                <h4>7. Natural Join</h4>
                <p><strong>Concept:</strong> Automatically joins tables by <strong>all columns with the same names</strong>. Equivalent to inner join on every matching column.
                    <strong>Syntax:</strong>
                </p>
                <pre><code class="">SELECT *
FROM A
NATURAL JOIN B;
</code></pre>
                <p><strong>Example:</strong></p>
                <pre><code class="">SELECT StudID, Name, DeptName
FROM Student
NATURAL JOIN Department;
</code></pre>
                <ul>
                    <li>Automatically uses <code>DeptID</code> as the join column.</li>
                </ul>
                <hr>
                <h4>8. Theta Join (Non-Equi Join)</h4>
                <p><strong>Concept:</strong> General join using a comparison operator other than <code>=</code> (e.g., <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&lt;&gt;</code>).
                    <strong>Syntax:</strong>
                </p>
                <pre><code class="">SELECT columns
FROM A, B
WHERE A.col operator B.col;
</code></pre>
                <p><strong>Example:</strong> (Find students and departments where DeptID is less than student’s DeptID)</p>
                <pre><code class="">SELECT S.Name, D.DeptName
FROM Student S, Department D
WHERE S.DeptID &gt; D.DeptID;
</code></pre>
                <hr>
            </article>
            <article>
                <h3>Key Points to Remember</h3>
                <ul>
                    <li><strong>Inner vs. Outer:</strong> Inner hides non-matches; outer shows non-matches with NULLs.</li>
                    <li><strong>Cross Join:</strong> No condition—Cartesian explosion.</li>
                    <li><strong>Self Join:</strong> Alias same table twice for hierarchical data.</li>
                    <li><strong>Natural Join:</strong> Convenient but can be error-prone if extra common columns exist.</li>
                    <li><strong>Theta Join:</strong> Supports non-equality conditions.</li>
                </ul>
                <hr>
                <h4>1. Subqueries (Nested Queries)</h4>
                <p><strong>Concept:</strong>
                    A <strong>subquery</strong> is a complete query placed inside another SQL statement. The database executes the subquery first and then uses its result in the outer query.</p>
                <p><strong>Common Forms:</strong></p>
                <ol>
                    <li><strong>Single‐row</strong>: Returns one value</li>
                    <li><strong>Multi‐row</strong>: Returns a list of values</li>
                    <li><strong>Multi‐column</strong>: Returns multiple columns</li>
                    <li><strong>Scalar</strong>: Used in <code>SELECT</code> or expressions</li>
                </ol>
                <p><strong>Syntax Pattern:</strong></p>
                <pre><code class="">SELECT … 
FROM MainTable
WHERE column operator 
(SELECT … FROM OtherTable WHERE …);
</code></pre>
                <p><strong>Example 1 – Single‐row Subquery</strong>
                    Find all employees in the “CSE” department:</p>
                <pre><code class="">SELECT EmpID, Name, Salary
FROM Employee
WHERE DeptID = (
SELECT DeptID
FROM Department
WHERE DeptName = 'CSE'
);
</code></pre>
                <ul>
                    <li><strong>Inner query</strong>: finds the ID of the CSE department.</li>
                    <li><strong>Outer query</strong>: retrieves employees matching that ID.</li>
                </ul>
                <p><strong>Example 2 – Multi‐row Subquery</strong>
                    List employees earning more than the company average salary:</p>
                <pre><code class="">SELECT Name, Salary
FROM Employee
WHERE Salary &gt; (
SELECT AVG(Salary)
FROM Employee
);
</code></pre>
                <ul>
                    <li><strong>Inner query</strong>: computes average salary.</li>
                    <li><strong>Outer query</strong>: selects employees above that average.</li>
                </ul>
                <hr>
                <h4>2. Correlated Subqueries</h4>
                <p><strong>Concept:</strong>
                    A <strong>correlated subquery</strong> refers to columns from the outer query. It is re-evaluated once for each row of the outer query, making it “correlated.”</p>
                <p><strong>Syntax Pattern:</strong></p>
                <pre><code class="">SELECT … 
FROM A
WHERE A.col operator
(SELECT … 
FROM B
WHERE B.related_col = A.col);
</code></pre>
                <p><strong>Example – Department‐wise Comparison</strong>
                    Show employees whose salary is above the average salary <em>in their own</em> department:</p>
                <pre><code class="">SELECT E.Name, E.DeptID, E.Salary
FROM Employee E
WHERE E.Salary &gt; (
SELECT AVG(E2.Salary)
FROM Employee E2
WHERE E2.DeptID = E.DeptID
);
</code></pre>
                <ul>
                    <li>
                        <p>For <strong>each</strong> row <strong>E</strong> in the outer query:</p>
                        <ul>
                            <li>The inner query computes the average salary of <strong>E</strong>’s department.</li>
                            <li>Then checks if <strong>E</strong>’s salary exceeds that value.</li>
                        </ul>
                    </li>
                </ul>
                <hr>
                <p><strong>Key Differences:</strong></p>
                <ul>
                    <li><strong>Subquery</strong>: Runs once, result independent of outer rows.</li>
                    <li><strong>Correlated</strong>: Runs per outer row, depends on outer values.</li>
                </ul>
                <hr>
            </article>
            <article>
                <h3>Concept of a View</h3>
                <p>A <strong>view</strong> is a <strong>virtual table</strong> defined by a SQL query. It does <strong>not</strong> store data itself but presents rows from one or more base tables. Views simplify complex queries, encapsulate business logic, and can restrict user access to specific columns or rows.</p>
                <hr>
                <h4>Types of Views</h4>
                <table class="table-dark">
                    <thead>
                        <tr>
                            <th>View Type</th>
                            <th>Definition &amp; Characteristics</th>
                            <th>Example Use</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Simple View</strong></td>
                            <td>- Based on a single table- Contains no aggregates, <code>GROUP BY</code>, <code>DISTINCT</code>, or joins- Often updatable</td>
                            <td>Show only CSE students</td>
                        </tr>
                        <tr>
                            <td><strong>Complex View</strong></td>
                            <td>- May use joins, aggregates, <code>GROUP BY</code>, <code>HAVING</code>, <code>DISTINCT</code>, or subqueries- Usually read-only</td>
                            <td>Department salary totals</td>
                        </tr>
                        <tr>
                            <td><strong>Inline View</strong></td>
                            <td>- A subquery in the <code>FROM</code> clause of another query- Temporary, not named in the schema</td>
                            <td>Top 3 salaries per dept</td>
                        </tr>
                        <tr>
                            <td><strong>Materialized View</strong></td>
                            <td>- Stores the result set physically- Must be refreshed manually or on a schedule- Speeds up complex reports</td>
                            <td>Yearly sales summary</td>
                        </tr>
                        <tr>
                            <td><strong>Partitioned View</strong></td>
                            <td>- Combines identical‐structure tables (often on different servers)- Presents them as one table</td>
                            <td>Sales data by region, each region in its own table</td>
                        </tr>
                        <tr>
                            <td><strong>Updatable vs Read-Only</strong></td>
                            <td>- <em>Updatable:</em> Simple views meeting SQL rules (one table, key preserved) can be modified via <code>INSERT</code>/<code>UPDATE</code>/<code>DELETE</code>- <em>Read-Only:</em> Complex or aggregate views cannot be changed directly</td>
                            <td>Allow managers to update salaries through a view</td>
                        </tr>
                    </tbody>
                </table>
                <hr>
                <h4>Examples</h4>
                <h4>a) Simple View</h4>
                <pre><code class="">-- Create: only CSE students
CREATE VIEW CSE_Students AS
SELECT StudID, Name, GPA
FROM Student
WHERE MajorSubject = 'Computer Science';

-- Use:
SELECT * FROM CSE_Students;
</code></pre>
                <h4>b) Complex View</h4>
                <pre><code class="">-- Create: total and average salary by department
CREATE VIEW Dept_Salary_Stats AS
SELECT DeptID,
COUNT(*)    AS EmpCount,
SUM(Salary) AS TotalSal,
AVG(Salary) AS AvgSal
FROM Employee
GROUP BY DeptID;

-- Use:
SELECT DeptID, AvgSal
FROM Dept_Salary_Stats
WHERE AvgSal &gt; 60000;
</code></pre>
                <h4>c) Inline View</h4>
                <pre><code class="">SELECT DeptID, Name, Salary
FROM (
SELECT DeptID, Name, Salary,
ROW_NUMBER() OVER (PARTITION BY DeptID
ORDER BY Salary DESC) AS rn
FROM Employee
) AS TopEarners
WHERE rn &lt;= 3;
</code></pre>
                <h4>d) Materialized View <em>(Oracle / PostgreSQL)</em></h4>
                <pre><code class="">-- Create and populate
CREATE MATERIALIZED VIEW Sales_Yrly AS
SELECT EXTRACT(YEAR FROM SaleDate) AS Yr,
SUM(Amount)                  AS TotalSales
FROM Sales
GROUP BY EXTRACT(YEAR FROM SaleDate);

-- Refresh later
REFRESH MATERIALIZED VIEW Sales_Yrly;

-- Use:
SELECT * FROM Sales_Yrly;
</code></pre>
                <h4>e) Partitioned View <em>(SQL Server)</em></h4>
                <pre><code class="">-- Assume tables Sales_East, Sales_West with same columns
CREATE VIEW All_Sales AS
SELECT * FROM Sales_East
UNION ALL
SELECT * FROM Sales_West;

-- Query:
SELECT Region, SUM(Amount)
FROM All_Sales
GROUP BY Region;
</code></pre>
                <h4>f) Updatable View vs Read-Only</h4>
                <pre><code class="">-- Updatable: one table, all NOT NULL columns included
CREATE VIEW Emp_Basic AS
SELECT EmpID, Name, Salary
FROM Employee;

/* Allowed: */
UPDATE Emp_Basic
SET Salary = Salary * 1.05
WHERE EmpID = 101;

/* Not allowed on complex view: */
UPDATE Dept_Salary_Stats
SET TotalSal = 500000;  -- ERROR: read-only view
</code></pre>
                <hr>
            </article>
            <article>
                <h3>Integrity Rules</h3>
                <p>Integrity rules (constraints) ensure data in a database is <strong>accurate</strong>, <strong>consistent</strong>, and <strong>reliable</strong> by enforcing conditions at the schema level.</p>
                <hr>
                <h4>Entity Integrity</h4>
                <ul>
                    <li><strong>Concept:</strong> Every table must have a primary key (PK) that uniquely identifies each row, and PK columns <strong>cannot be NULL</strong>.</li>
                    <li><strong>SQL Enforcement:</strong> <code>PRIMARY KEY</code> constraint.</li>
                    <li><strong>Example:</strong></li>
                </ul>
                <pre><code class="">CREATE TABLE Student (
StudID      INT     PRIMARY KEY,   -- PK: never NULL, unique
Name        VARCHAR(50),
Major       VARCHAR(30)
);
</code></pre>
                <ul>
                    <li>Here, <code>StudID</code> ensures each student row is unique and never empty.</li>
                </ul>
                <hr>
                <h4>Key Integrity</h4>
                <ul>
                    <li><strong>Concept:</strong> Beyond the PK, any <strong>candidate key</strong> must also be unique. A <strong>unique key</strong> constraint enforces no duplicate values in a column (or set of columns).</li>
                    <li><strong>SQL Enforcement:</strong> <code>UNIQUE</code> constraint.</li>
                    <li><strong>Example:</strong></li>
                </ul>
                <pre><code class="">CREATE TABLE Employee (
EmpID       INT      PRIMARY KEY,
Email       VARCHAR(100) UNIQUE,   -- no two employees share an email
Name        VARCHAR(50)
);
</code></pre>
                <ul>
                    <li><code>Email</code> cannot repeat across different employee rows.</li>
                </ul>
                <hr>
                <h4>Referential Integrity</h4>
                <ul>
                    <li><strong>Concept:</strong> A <strong>foreign key (FK)</strong> in one table must match an existing primary (or unique) key in the referenced table, or be NULL. This prevents “orphan” records.</li>
                    <li><strong>SQL Enforcement:</strong> <code>FOREIGN KEY … REFERENCES … [ON DELETE|UPDATE …]</code></li>
                    <li><strong>Example:</strong></li>
                </ul>
                <pre><code class="">CREATE TABLE Department (
DeptID      INT     PRIMARY KEY,
DeptName    VARCHAR(50)
);

CREATE TABLE Student (
StudID      INT     PRIMARY KEY,
Name        VARCHAR(50),
DeptID      INT,
FOREIGN KEY (DeptID)
REFERENCES Department(DeptID)
ON DELETE SET NULL   -- if a department is removed, set DeptID to NULL
);
</code></pre>
                <ul>
                    <li>Each <code>Student.DeptID</code> must refer to a valid <code>Department.DeptID</code>.</li>
                </ul>
                <hr>
                <h4>Domain Integrity</h4>
                <ul>
                    <li>
                        <p><strong>Concept:</strong> Each column’s values must belong to a defined <strong>domain</strong>: correct data type, format, length, and optional value ranges.</p>
                    </li>
                    <li>
                        <p><strong>SQL Enforcement:</strong></p>
                        <ul>
                            <li><strong>Data types</strong> (e.g., <code>INT</code>, <code>VARCHAR(…)</code>)</li>
                            <li><strong>NOT NULL</strong> (no missing values)</li>
                            <li><strong>DEFAULT</strong> (fallback value)</li>
                            <li><strong>CHECK</strong> (custom rule on values)</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Example:</strong></p>
                    </li>
                </ul>
                <pre><code class="">CREATE TABLE Course (
CourseID    CHAR(6)       NOT NULL,
Title       VARCHAR(100)  NOT NULL,
Credits     INT           DEFAULT 3,
CHECK (Credits BETWEEN 1 AND 5)  -- must be 1–5
);
</code></pre>
                <ul>
                    <li><code>Credits</code> always falls between 1 and 5; <code>CourseID</code> and <code>Title</code> cannot be empty.</li>
                </ul>
                <hr>
                <h4>User-Defined Integrity</h4>
                <ul>
                    <li>
                        <p><strong>Concept:</strong> Business rules specific to the application that aren’t covered by standard constraints. Enforced using <strong>triggers</strong>, <strong>assertions</strong>, or <strong>stored procedures</strong>.</p>
                    </li>
                    <li>
                        <p><strong>SQL Enforcement:</strong></p>
                        <ul>
                            <li><strong>Triggers</strong> (<code>BEFORE</code>/<code>AFTER INSERT/UPDATE/DELETE</code>)</li>
                            <li><strong>Assertions</strong> (<code>CREATE ASSERTION … CHECK (…)</code>) — not universally supported</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Example (Trigger):</strong></p>
                    </li>
                </ul>
                <pre><code class="">  -- Rule: Grade must be A, B, C, D, or F
CREATE TABLE Enroll (
StudID   INT,
CourseID CHAR(6),
Grade    CHAR(1),
PRIMARY KEY (StudID, CourseID)
);

CREATE TRIGGER validate_grade
BEFORE INSERT OR UPDATE ON Enroll
FOR EACH ROW
BEGIN
IF NEW.Grade NOT IN ('A','B','C','D','F') THEN
SIGNAL SQLSTATE '45000'
SET MESSAGE_TEXT = 'Invalid grade value';
END IF;
END;
</code></pre>
                <ul>
                    <li>This trigger stops any insertion or update if <code>Grade</code> is outside the allowed set.</li>
                </ul>
                <hr>
            </article>
            <article>
                <h2>Summary</h2>
                <ul>
                    <li><strong>Entity &amp; Key Integrity</strong> ensure uniqueness and non-null keys.</li>
                    <li><strong>Referential Integrity</strong> maintains valid links between tables.</li>
                    <li><strong>Domain Integrity</strong> restricts columns to correct types and value ranges.</li>
                    <li><strong>User-Defined Integrity</strong> implements custom business rules.</li>
                </ul>
                <hr>
            </article>
            <article>
                <h3>PHP Superglobals (System Variables)</h3>
                <p>PHP provides built-in <strong>superglobal arrays</strong>—always accessible regardless of scope—to retrieve request data, session info, and server/environment details. Key ones include: <code>$_GET</code>, <code>$_POST</code>, <code>$_REQUEST</code>, <code>$_SESSION</code>, and <code>$_SERVER</code>.</p>
                <hr>
                <h4><code>$_GET</code></h4>
                <ul>
                    <li><strong>Concept:</strong> Retrieves data sent via URL query string (<code>?key=value</code>). Used for safe, idempotent requests (e.g., search filters).</li>
                    <li><strong>Syntax:</strong> <code>$_GET['field_name']</code></li>
                </ul>
                <p><strong>Example:</strong></p>
                <pre><code class=>&lt;!-- URL: product.php?id=42&amp;category=books --&gt;
&lt;?php
// product.php
$productId  = $_GET['id'];       // "42"
$category   = $_GET['category']; // "books"

echo "Showing product {$productId} in {$category}";
?&gt;
</code></pre>
                <hr>
                <h4><code>$_POST</code></h4>
                <ul>
                    <li><strong>Concept:</strong> Retrieves data sent via HTTP POST (form submissions). Suitable for sensitive data (passwords) or large payloads.</li>
                    <li><strong>Syntax:</strong> <code>$_POST['field_name']</code></li>
                </ul>
                <p><strong>Example:</strong></p>
                <pre><code class=>&lt;!-- form.html --&gt;
&lt;form action="submit.php" method="post"&gt;
Name: &lt;input name="username"&gt;&lt;br&gt;
Pass: &lt;input name="password" type="password"&gt;&lt;br&gt;
&lt;button type="submit"&gt;Login&lt;/button&gt;
&lt;/form&gt;

&lt;?php
// submit.php
$username = $_POST['username'];
$password = $_POST['password'];

echo "Welcome, {$username}";
?&gt;
</code></pre>
                <hr>
                <h4><code>$_REQUEST</code></h4>
                <ul>
                    <li><strong>Concept:</strong> Merges <code>$_GET</code>, <code>$_POST</code>, and <code>$_COOKIE</code>. Handy when method doesn’t matter, but less secure—may mix sources.</li>
                    <li><strong>Syntax:</strong> <code>$_REQUEST['field_name']</code></li>
                </ul>
                <p><strong>Example:</strong></p>
                <pre><code class="">&lt;!-- URL: search.php?q=php --&gt;
&lt;form action="search.php" method="post"&gt;
&lt;input name="q"&gt;
&lt;button&gt;Go&lt;/button&gt;
&lt;/form&gt;

&lt;?php
// search.php
$query = $_REQUEST['q'];  // from GET or POST
echo "Search for: {$query}";
?&gt;
</code></pre>
                <hr>
                <h4><code>$_SESSION</code></h4>
                <ul>
                    <li><strong>Concept:</strong> Persists data across multiple pages for a user. Requires session start and usually a session cookie.</li>
                    <li><strong>Setup:</strong></li>
                </ul>
                <ol>
                    <li>Call <code>session_start()</code> at the top of each script.</li>
                    <li>Store/retrieve via <code>$_SESSION['key']</code>.</li>
                </ol>
                <p><strong>Example:</strong></p>
                <pre><code class="">&lt;?php
// login.php
session_start();
$_SESSION['user'] = 'DivyaMohan'; 
echo "Logged in as {$_SESSION['user']}";
?&gt;

&lt;?php
// dashboard.php
session_start();
if(isset($_SESSION['user'])) {
echo "Hello, {$_SESSION['user']}";
} else {
echo "Please log in.";
}
?&gt;
</code></pre>
                <hr>
                <h4>5. <code>$_SERVER</code></h4>
                <ul>
                    <li>
                        <p><strong>Concept:</strong> Contains server and execution environment info (headers, paths, script locations). Read-only.</p>
                    </li>
                    <li>
                        <p><strong>Common Keys:</strong></p>
                        <ul>
                            <li><code>$_SERVER['HTTP_HOST']</code> – current host</li>
                            <li><code>$_SERVER['REQUEST_URI']</code> – requested resource path</li>
                            <li><code>$_SERVER['SCRIPT_NAME']</code> – current script</li>
                            <li><code>$_SERVER['QUERY_STRING']</code> – URL query string</li>
                        </ul>
                    </li>
                </ul>
                <p><strong>Example:</strong></p>
                <pre><code class="">&lt;?php
echo "Host: " . $_SERVER['HTTP_HOST'] . "&lt;br&gt;";
echo "URI: "  . $_SERVER['REQUEST_URI'] . "&lt;br&gt;";
echo "Script: " . $_SERVER['SCRIPT_NAME'];
?&gt;
</code></pre>
                <hr>
                <p><strong>Summary:</strong></p>
                <ul>
                    <li><strong><code>$_GET</code></strong>: URL parameters</li>
                    <li><strong><code>$_POST</code></strong>: Form data via POST</li>
                    <li><strong><code>$_REQUEST</code></strong>: Combined GET/POST/COOKIE</li>
                    <li><strong><code>$_SESSION</code></strong>: User-specific persistent data</li>
                    <li><strong><code>$_SERVER</code></strong>: Environment and request metadata</li>
                </ul>
                <hr>
            </article>
            <article>
                <h3>Session in PHP</h3>
                <p>A <strong>session</strong> lets you store user-specific data on the server across multiple page requests. Unlike cookies (which live in the browser), session data is kept on the server and only a small session ID is sent to the client. This makes sessions more secure for sensitive data like login status.</p>
                <hr>
                <h4>How Sessions Work</h4>
                <ol>
                    <li><strong>Start a session</strong> with <code>session_start()</code>—PHP sends a session cookie (e.g. <code>PHPSESSID</code>) to the browser if none exists.</li>
                    <li><strong>Store/retrieve</strong> data in <code>$_SESSION</code> array.</li>
                    <li><strong>End or destroy</strong> the session when done (<code>session_unset()</code> + <code>session_destroy()</code>).</li>
                </ol>
                <hr>
                <h4>Database Connection (MySQLi)</h4>
                <pre><code class="">&lt;?php
// db_connect.php
$host     = 'localhost';
$user     = 'db_user';
$password = 'db_pass';
$database = 'my_app';

$mysqli = new mysqli($host, $user, $password, $database);
if ($mysqli-&gt;connect_error) {
die('DB Connection Error: ' . $mysqli-&gt;connect_error);
}
?&gt;
</code></pre>
                <hr>
                <h4>Creating (Login) Session</h4>
                <p><strong>login.php</strong></p>
                <pre><code class="">&lt;?php
session_start();                  // 1. Start session
require 'db_connect.php';        // 2. Include DB connection

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
$username = $mysqli-&gt;real_escape_string($_POST['username']);
$password = $_POST['password']; // in real apps, hash &amp; verify

// 3. Check credentials
$sql = "SELECT id, username, password_hash 
FROM users 
WHERE username = '$username'
LIMIT 1";
$result = $mysqli-&gt;query($sql);

if ($result &amp;&amp; $user = $result-&gt;fetch_assoc()) {
// 4. Verify password (assuming password_hash used)
if (password_verify($password, $user['password_hash'])) {
// 5. Store user info in session
$_SESSION['user_id']   = $user['id'];
$_SESSION['username']  = $user['username'];
$_SESSION['logged_in'] = true;

header('Location: dashboard.php');
exit;
}
}
$error = 'Invalid username or password';
}
?&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;
&lt;h2&gt;Login&lt;/h2&gt;
&lt;?php if (!empty($error)) echo "&lt;p style='color:red;'&gt;$error&lt;/p&gt;"; ?&gt;
&lt;form method="post"&gt;
Username: &lt;input name="username" required&gt;&lt;br&gt;
Password: &lt;input type="password" name="password" required&gt;&lt;br&gt;
&lt;button type="submit"&gt;Log In&lt;/button&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
                <hr>
                <h4>Executing (Using) the Session</h4>
                <p><strong>dashboard.php</strong></p>
                <pre><code class="">&lt;?php
session_start();                // Resume session
// 1. Protect page—redirect if not logged in
if (empty($_SESSION['logged_in'])) {
header('Location: login.php');
exit;
}

// 2. Use session data
echo "&lt;h1&gt;Welcome, " . htmlspecialchars($_SESSION['username']) . "&lt;/h1&gt;";
echo "&lt;p&gt;Your User ID: " . $_SESSION['user_id'] . "&lt;/p&gt;";
?&gt;
&lt;p&gt;&lt;a href="logout.php"&gt;Log Out&lt;/a&gt;&lt;/p&gt;
</code></pre>
                <hr>
                <h4>Destroying (Logout) the Session</h4>
                <p><strong>logout.php</strong></p>
                <pre><code class="">&lt;?php
session_start();
// 1. Unset all session variables
$_SESSION = [];

// 2. Destroy session cookie on client
if (ini_get("session.use_cookies")) {
setcookie(
session_name(), 
'', 
time() - 3600, 
ini_get("session.cookie_path"),
ini_get("session.cookie_domain"),
ini_get("session.cookie_secure"),
ini_get("session.cookie_httponly")
);
}

// 3. Destroy server‐side session data
session_destroy();

header('Location: login.php');
exit;
?&gt;
</code></pre>
                <hr>
                <h4>Key Points</h4>
                <ul>
                    <li>Always call <code>session_start()</code> before any output.</li>
                    <li><strong>Sanitize</strong> inputs and <strong>hash</strong> passwords (<code>password_hash()</code>, <code>password_verify()</code>).</li>
                    <li><strong>Regenerate</strong> session ID on login (<code>session_regenerate_id(true)</code>) for security.</li>
                    <li>Unset and destroy both session data and the session cookie on logout.</li>
                    <li>Use <code>$_SESSION</code> only after verifying user authentication.</li>
                </ul>
            </article>
            <article>
                <h3>1. Introduction</h3>
                <p>Web applications often need to <strong>collect user input</strong>, <strong>store</strong> it in a <strong>database</strong>, and later <strong>retrieve</strong> it for display. In PHP &amp; MySQL:</p>
                <ul>
                    <li><strong>HTML form</strong> gathers data</li>
                    <li><strong>PHP script</strong> uses <strong>mysqli</strong> to INSERT/SELECT</li>
                    <li><strong>POST</strong> method sends data securely</li>
                </ul>
                <hr>
                <h4>2. Database &amp; Table Creation (5 M)</h4>
                <p><strong>SQL commands</strong> to set up the database and table:</p>
                <pre><code class="language-sql hljs" data-highlighted="yes"><span class="hljs-comment">-- 1. Create database</span>
<span class="hljs-keyword">CREATE</span> DATABASE IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> mydb;

<span class="hljs-comment">-- 2. Use database</span>
USE mydb;

<span class="hljs-comment">-- 3. Create table</span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> student (
roll <span class="hljs-type">INT</span>      <span class="hljs-keyword">PRIMARY</span> KEY,
name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>),
city <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>)
);
</code></pre>
                <ul>
                    <li><strong>roll</strong> is PRIMARY KEY (unique, NOT NULL)</li>
                    <li><strong>name</strong>, <strong>city</strong> hold text up to 50 chars</li>
                </ul>
                <hr>
                <h4>3. HTML Form Page (5 M)</h4>
                <pre><code class="language-html hljs language-xml" data-highlighted="yes"><span class="hljs-comment">&lt;!-- data.html --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"save_data.php"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Roll: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"roll"</span> <span class="hljs-attr">required</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Name: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">required</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>City: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"city"</span> <span class="hljs-attr">required</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>Save<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
</code></pre>
                <ul>
                    <li><strong>method="post"</strong> → data in <code>$_POST</code>, not URL</li>
                    <li><strong>required</strong> → basic browser validation</li>
                </ul>
                <hr>
                <h4>4. PHP Insert Script (5 M)</h4>
                <pre><code class="">&lt;?php
// save_data.php
$conn = new mysqli("localhost","root","","mydb");
if ($conn-&gt;connect_error) die("Connection failed");

$roll = (int)$_POST['roll'];
$name = $conn-&gt;real_escape_string($_POST['name']);
$city = $conn-&gt;real_escape_string($_POST['city']);

$sql = "INSERT INTO student (roll,name,city)
VALUES ($roll,'$name','$city')";

if ($conn-&gt;query($sql)) {
echo "Record saved. &lt;a href='view_data.php'&gt;View all&lt;/a&gt;";
} else {
echo "Error: " . $conn-&gt;error;
}
$conn-&gt;close();
</code></pre>
                <ul>
                    <li><strong>(int)</strong> cast prevents injection via roll</li>
                    <li><strong>real_escape_string</strong> escapes quotes in text</li>
                    <li><strong>error handling</strong> reports failures</li>
                </ul>
                <hr>
                <h4>5. PHP Fetch &amp; Display Script (5 M)</h4>
                <pre><code class="">&lt;?php
// view_data.php
$conn = new mysqli("localhost","root","","mydb");
if ($conn-&gt;connect_error) die("Connection failed");

$result = $conn-&gt;query("SELECT * FROM student");

echo "&lt;table border=1&gt;
&lt;tr&gt;&lt;th&gt;Roll&lt;/th&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;City&lt;/th&gt;&lt;/tr&gt;";
while ($r = $result-&gt;fetch_assoc()) {
echo "&lt;tr&gt;
&lt;td&gt;{$r['roll']}&lt;/td&gt;
&lt;td&gt;{$r['name']}&lt;/td&gt;
&lt;td&gt;{$r['city']}&lt;/td&gt;
&lt;/tr&gt;";
}
echo "&lt;/table&gt;";
$conn-&gt;close();
</code></pre>
                <ul>
                    <li><strong>SELECT *</strong> retrieves all columns</li>
                    <li><strong>fetch_assoc()</strong> returns each row as an associative array</li>
                </ul>
                <hr>
                <h4>6. Flow Diagram &amp; Best Practices (5 M)</h4>
                <pre><code data-highlighted="yes" class="hljs language-css"><span class="hljs-selector-attr">[data.html form]</span> 
↓ POST
<span class="hljs-selector-attr">[save_data.php]</span> ──INSERT──▶ <span class="hljs-selector-attr">[MySQL student table]</span>
↓ link
<span class="hljs-selector-attr">[view_data.php]</span> ──SELECT──▶ <span class="hljs-selector-attr">[HTML table display]</span>
</code></pre>
                <p><strong>Best Practices:</strong></p>
                <ul>
                    <li><strong>Validate</strong> inputs (e.g., <code>required</code>, <code>is_numeric</code>)</li>
                    <li><strong>Sanitize</strong> data (<code>real_escape_string</code>)</li>
                    <li><strong>Error handling</strong> for DB connection &amp; queries</li>
                    <li><strong>Separate</strong> presentation (HTML) from logic (PHP)</li>
                </ul>
                <hr>
            </article>

            <pre id="markdown-raws" class=d-none>
### Database
A **database** is an organized collection of related data stored electronically. It enables efficient storage, retrieval, update and management of large volumes of information.


#### Definition & Purpose

* **Definition:** A database is a structured set of data, usually stored in tables, that models real-world entities and their relationships.
* **Purpose:**

  1. **Centralize data** so multiple users/applications can share it.
  2. **Ensure consistency** and integrity by enforcing rules.
  3. **Support efficient queries** and reports.
  4. **Provide security, backup and recovery.**

#### Types of Databases

> **(A)** *By Data Model*

1. **Flat-file**

   * *Structure:* Single plain text file (e.g. CSV).
   * *Use-case:* Simple lists (e.g. address book).
2. **Hierarchical**

   * *Structure:* Tree-like parent-child.
   * *Example:* IBM’s IMS storing bill-of-materials.
3. **Network**

   * *Structure:* Graph of records with many-to-many links.
   * *Example:* CODASYL DBMS.
4. **Relational**

   * *Structure:* Tables (rows & columns) with keys.
   * *Example:* MySQL, Oracle.
5. **Object-Oriented**

   * *Structure:* Data as “objects” (attributes + methods).
   * *Example:* db4o for CAD/CAM applications.
6. **NoSQL**

   * *Variants:*

     * *Key-Value:* Redis (sessions).
     * *Document:* MongoDB (JSON docs).
     * *Column-Family:* Cassandra (time-series).
     * *Graph:* Neo4j (social networks).

> **(B)** *By Usage*

* **OLTP (Online Transaction Processing):** Fast, high-volume transactions (e.g. banking).
* **OLAP (Online Analytical Processing):** Complex queries on historical data (e.g. data warehousing).

> **(C)** *By Architecture*

* **Centralized:** Single server hosts data.
* **Client-Server:** Clients query a server-based DBMS.
* **Distributed:** Data spread over multiple sites (replication/fragmentation).
* **Cloud Database:** Hosted on cloud platforms (scalable).
* **Data Warehouse:** Integrated, subject-oriented store for analysis.

#### 3. Key Features

1. **Data Independence**

   * *Logical:* Schema changes don’t affect applications.
   * *Physical:* Storage changes transparent to users.
2. **ACID Properties**

   * *Atomicity:* All or nothing for transactions.
   * *Consistency:* Transitions preserve integrity constraints.
   * *Isolation:* Concurrent transactions do not interfere.
   * *Durability:* Committed data survives failures.
3. **Integrity Constraints**

   * *Entity:* Primary keys non-NULL & unique.
   * *Referential:* Foreign keys match primary keys.
   * *Domain:* Valid data types & ranges.
4. **Concurrency Control**

   * Locks/Multiversion to allow safe parallel access.
5. **Security**

   * Authentication, authorization, encryption.
6. **Backup & Recovery**

   * Regular backups; restore after crash.
7. **Data Dictionary**

   * Metadata repository describing structure.

---

#### 4. Advantages

* **Reduced Redundancy:** Central storage avoids duplicate data.
* **Improved Consistency:** Single source of truth.
* **Data Sharing:** Multiple users/applications can access concurrently.
* **Data Integrity:** Enforced rules prevent invalid data.
* **Enhanced Security:** Fine-grained access control.
* **Efficient Querying:** Indexes and optimizers speed retrieval.
* **Backup & Recovery:** Automated procedures minimize data loss.
* **Scalability:** Distributed/cloud DBs handle growth.

#### 5. Disadvantages

* **High Cost:** Hardware, software licenses, skilled personnel.
* **Complexity:** Requires careful design and administration.
* **Performance Overhead:** ACID and concurrency controls incur costs.
* **Single Point of Failure:** Without replication, server crash halts service.
* **Vendor Lock-In:** Migration between DBMS products can be hard.
* **Maintenance Effort:** Regular tuning, patching, backups.


#### 6. Example: Simple Relational Database

**Scenario:** University stores Students and Courses.

| Student(StudentID, Name, Dept) | Course(CourseID, Title, Credits) | Enroll(StudentID, CourseID, Grade) |
| ------------------------------ | -------------------------------- | ---------------------------------- |
| (101, “Divya”, “CSE”)          | (CS201, “DBMS”, 4)               | (101, CS201, “A”)                  |
| (102, “Rahul”, “EEE”)          | (EE301, “Circuits”, 3)           | (102, EE301, “B”)                  |

* **Demonstrates:**

  * **Referential Integrity:** `Enroll.StudentID → Student.StudentID`
  * **Query Example:**

  ```language-auto
  SELECT S.Name, C.Title, E.Grade
    FROM Student S
    JOIN Enroll E ON S.StudentID = E.StudentID
    JOIN Course C ON E.CourseID = C.CourseID;
  ```
* **ACID in Action:** A student’s enrollment and fee payment (two updates) succeed or both roll back.


---

### SQL: Definition and Purpose

**Structured Query Language (SQL)** is the standard language for interacting with relational databases. It lets you **define**, **manipulate**, **control**, and **query** data through simple, English-like statements.

---

#### 1. Data Definition Language (DDL)

**Concept:** DDL commands specify the **structure** of database objects—tables, indexes, schemas—by creating, altering, or dropping them. Changes made by DDL statements are **auto-committed**.
**Key Commands:**

* `CREATE` — make a new table or object
* `ALTER` — change an existing object
* `DROP` — delete an object
* `TRUNCATE` — remove all rows from a table

**Example:** Create, modify, and drop a table

```language-auto
-- Create a table for employees
CREATE TABLE Employee (
  EmpID    INT      PRIMARY KEY,
  Name     VARCHAR(50),
  Dept     VARCHAR(30)
);

-- Add a new column for salary
ALTER TABLE Employee
  ADD COLUMN Salary DECIMAL(10,2);

-- Remove the table completely
DROP TABLE Employee;
```

---

#### 2. Data Manipulation Language (DML)

**Concept:** DML commands **change** the data within tables but do not alter table structure. These statements can be **rolled back** if within a transaction.
**Key Commands:**

* `INSERT` — add new rows
* `UPDATE` — modify existing rows
* `DELETE` — remove rows

**Example:** Insert, update, and delete rows

```language-auto
-- Add two new employees
INSERT INTO Employee (EmpID, Name, Dept, Salary)
VALUES
  (101, 'Divya Mohan', 'CSE', 75000),
  (102, 'Rahul Singh', 'ECE', 68000);

-- Give Rahul a raise
UPDATE Employee
  SET Salary = 70000
  WHERE EmpID = 102;

-- Remove an employee record
DELETE FROM Employee
  WHERE EmpID = 101;
```

---

#### 3. Data Query Language (DQL)

*(Often considered part of DML, but focused on data retrieval.)*
**Concept:** DQL commands **fetch** data from one or more tables. Results are read-only unless wrapped in DML statements.
**Key Command:**

* `SELECT` — retrieve rows matching specified criteria

**Example:** Retrieve employee names in CSE department

```language-auto
SELECT EmpID, Name, Salary
  FROM Employee
  WHERE Dept = 'CSE'
  ORDER BY Salary DESC;
```

---

#### 4. Transaction Control Language (TCL)

**Concept:** TCL commands manage **transactions**, grouping multiple DML operations into a single atomic unit.
**Key Commands:**

* `COMMIT` — make all changes permanent
* `ROLLBACK` — undo changes since last commit
* `SAVEPOINT` — set a point within a transaction to roll back to

**Example:** Use a savepoint and rollback

```language-auto
BEGIN;  -- start transaction

UPDATE Employee
  SET Salary = Salary * 1.1
  WHERE Dept = 'ECE';

SAVEPOINT before_bonus;

DELETE FROM Employee
  WHERE EmpID = 999;  -- oops, wrong record

ROLLBACK TO before_bonus;  -- undo only the delete

COMMIT;  -- finalize the salary update
```

---

#### 5. Data Control Language (DCL)

**Concept:** DCL commands regulate **access** and **permissions** for database users and roles.
**Key Commands:**

* `GRANT` — give privileges to users
* `REVOKE` — remove granted privileges

**Example:** Grant and revoke privileges

```language-auto
-- Allow user 'alice' to read and insert in Employee
GRANT SELECT, INSERT
  ON Employee
  TO alice;

-- Later, remove insert privilege
REVOKE INSERT
  ON Employee
  FROM alice;
```


---

### 1. Queries

**Concept:**
A **query** is an instruction to the database to **retrieve** or **manipulate** data. In SQL, the primary retrieval query is the **`SELECT`** statement. Queries can range from simple single-table lookups to complex nested and joined queries.

**Key Types & Examples:**

1. **Simple Query**

   * Retrieves all columns or specific columns from one table.

   ```language-auto
   -- All columns
   SELECT * 
     FROM Employee;

   -- Specific columns
   SELECT EmpID, Name, Dept 
     FROM Employee;
   ```
2. **Filtered Query**

   * Uses **`WHERE`** to restrict rows.

   ```language-auto
   SELECT EmpID, Name
     FROM Employee
    WHERE Dept = 'CSE';
   ```
3. **Aggregate Query**

   * Summarizes data using functions like **`COUNT`**, **`SUM`**, **`AVG`**, **`MAX`**, **`MIN`**.

   ```language-auto
   -- Total salary by department
   SELECT Dept, SUM(Salary) AS TotalSal
     FROM Employee
    GROUP BY Dept;
   ```
4. **Join Query**

   * Combines rows from two or more tables on a related column.

   ```language-auto
   SELECT S.Name, C.Title, E.Grade
     FROM Student S
     JOIN Enroll E ON S.StudentID = E.StudentID
     JOIN Course C  ON E.CourseID  = C.CourseID;
   ```
5. **Subquery (Nested Query)**

   * A query inside another.

   ```language-auto
   -- Employees earning above the average salary
   SELECT Name, Salary
     FROM Employee
    WHERE Salary > (
      SELECT AVG(Salary)
        FROM Employee
    );
   ```
6. **Correlated Subquery**

   * References outer query row.

   ```language-auto
   SELECT E1.EmpID, E1.Name, E1.Salary
     FROM Employee E1
    WHERE E1.Salary > (
      SELECT AVG(E2.Salary)
        FROM Employee E2
       WHERE E2.Dept = E1.Dept
    );
   ```

---

### 2. Operators

**Concept:**
**Operators** perform computations or comparisons on data. SQL operators fall into several categories:

1. **Arithmetic Operators**

   * `+`, `-`, `*`, `/`, `%`

   ```language-auto
   SELECT EmpID, Salary, Salary * 0.10 AS Bonus
     FROM Employee;
   ```
2. **Comparison Operators**

   * `=`, `&lt;>` (not equal), `&lt;`, `>`, `&lt;=`, `>=`

   ```language-auto
   SELECT Name
     FROM Employee
    WHERE Salary >= 60000;
   ```
3. **Logical Operators**

   * `AND`, `OR`, `NOT`

   ```language-auto
   SELECT *
     FROM Employee
    WHERE Dept = 'CSE'
      AND Salary > 70000;
   ```
4. **Set Operators & Conditions**

   * `IN`, `NOT IN`, `BETWEEN … AND …`, `LIKE`, `IS NULL`

   ```language-auto
   -- IN
   SELECT Name
     FROM Employee
    WHERE Dept IN ('CSE', 'ECE');

   -- BETWEEN
   SELECT Name
     FROM Employee
    WHERE Salary BETWEEN 50000 AND 80000;

   -- LIKE (pattern match)
   SELECT Name
     FROM Employee
    WHERE Name LIKE 'A%';  -- starts with 'A'
   ```
5. **String Operators**

   * Concatenation (`||` or `CONCAT`)

   ```language-auto
   SELECT EmpID, Name || ' (' || Dept || ')' AS Info
     FROM Employee;
   ```

---

### 3. Clauses

**Concept:**
A **clause** is a component of an SQL statement that defines **what**, **where**, **how**, and **in what order** data is processed. In a `SELECT` query, common clauses include:

| Clause         | Purpose                                             | Example                       |
| -------------- | --------------------------------------------------- | ----------------------------- |
| **`SELECT`**   | Specify columns or expressions to retrieve          | `SELECT Name, Salary`         |
| **`FROM`**     | Identify source table(s)                            | `FROM Employee`               |
| **`WHERE`**    | Filter rows before grouping or selecting            | `WHERE Dept = 'CSE'`          |
| **`GROUP BY`** | Aggregate rows sharing common values                | `GROUP BY Dept`               |
| **`HAVING`**   | Filter groups after aggregation                     | `HAVING SUM(Salary) > 200000` |
| **`ORDER BY`** | Sort result rows                                    | `ORDER BY Salary DESC`        |
| **`LIMIT`**    | Restrict number of rows returned (MySQL/PostgreSQL) | `LIMIT 5`                     |
| **`DISTINCT`** | Remove duplicate rows                               | `SELECT DISTINCT Dept`        |

**Full Example Combining Clauses:**

```language-auto
SELECT Dept,
       COUNT(*) AS NumEmployees,
       AVG(Salary) AS AvgSalary
  FROM Employee
 WHERE Salary > 40000
 GROUP BY Dept
 HAVING AVG(Salary) > 50000
 ORDER BY AvgSalary DESC
 LIMIT 3;
```

> **Explanation:**
>
> 1. **`SELECT`** columns and aggregates.
> 2. **`FROM`** source table.
> 3. **`WHERE`** filters individual rows.
> 4. **`GROUP BY`** groups them by department.
> 5. **`HAVING`** filters groups on aggregate.
> 6. **`ORDER BY`** sorts results.
> 7. **`LIMIT`** shows top 3 departments.


---

### Joins in SQL

A **join** combines rows from two or more tables based on a related column, letting you fetch related data in a single query.

---

#### 1. Inner Join (Equi-Join)

**Concept:** Returns only rows where the join condition matches in both tables.
**Syntax:**

```language-auto
SELECT columns
  FROM A
  INNER JOIN B
    ON A.key = B.key;
```

**Example:**
Tables:

* **Student**(StudID, Name, DeptID)
* **Department**(DeptID, DeptName)

```language-auto
SELECT S.StudID, S.Name, D.DeptName
  FROM Student S
  INNER JOIN Department D
    ON S.DeptID = D.DeptID;
```

---

#### 2. Left Outer Join

**Concept:** Returns all rows from the **left** table, plus matching rows from the right. Non-matching right-side columns are NULL.
**Syntax:**

```language-auto
SELECT columns
  FROM A
  LEFT JOIN B
    ON A.key = B.key;
```

**Example:**

```language-auto
SELECT S.StudID, S.Name, D.DeptName
  FROM Student S
  LEFT JOIN Department D
    ON S.DeptID = D.DeptID;
```

* Students without a valid DeptID still appear; DeptName will be NULL.

---

#### 3. Right Outer Join

**Concept:** Returns all rows from the **right** table, plus matching rows from the left. Non-matching left-side columns are NULL.
**Syntax:**

```language-auto
SELECT columns
  FROM A
  RIGHT JOIN B
    ON A.key = B.key;
```

**Example:**

```language-auto
SELECT S.StudID, S.Name, D.DeptName
  FROM Student S
  RIGHT JOIN Department D
    ON S.DeptID = D.DeptID;
```

* Departments with no students still appear; StudID and Name will be NULL.

---

#### 4. Full Outer Join

**Concept:** Returns **all** rows when there is a match in either left or right table. Non-matches fill with NULLs.
**Syntax:**

```language-auto
SELECT columns
  FROM A
  FULL OUTER JOIN B
    ON A.key = B.key;
```

**Example:**

```language-auto
SELECT S.StudID, S.Name, D.DeptName
  FROM Student S
  FULL OUTER JOIN Department D
    ON S.DeptID = D.DeptID;
```

* Covers every student and every department, matching where possible.

---

#### 5. Cross Join (Cartesian Product)

**Concept:** Returns every combination of rows from both tables (no join condition). Use sparingly—result grows multiplicatively.
**Syntax:**

```language-auto
SELECT columns
  FROM A
  CROSS JOIN B;
```

**Example:**

```language-auto
SELECT S.Name, D.DeptName
  FROM Student S
  CROSS JOIN Department D;
```

* If Student has 5 rows and Department has 3, result has 15 rows.

---

#### 6. Self Join

**Concept:** A table joined to **itself**. Useful for hierarchical or comparative queries.
**Syntax:**

```language-auto
SELECT A.cols, B.cols
  FROM Table A
  JOIN Table B
    ON A.key = B.key2;
```

**Example:** (Employees with their managers)
Table: **Employee**(EmpID, Name, ManagerID)

```language-auto
SELECT E.EmpID,
       E.Name      AS Employee,
       M.Name      AS Manager
  FROM Employee E
  LEFT JOIN Employee M
    ON E.ManagerID = M.EmpID;
```

---

#### 7. Natural Join

**Concept:** Automatically joins tables by **all columns with the same names**. Equivalent to inner join on every matching column.
**Syntax:**

```language-auto
SELECT *
  FROM A
  NATURAL JOIN B;
```

**Example:**

```language-auto
SELECT StudID, Name, DeptName
  FROM Student
  NATURAL JOIN Department;
```

* Automatically uses `DeptID` as the join column.

---

#### 8. Theta Join (Non-Equi Join)

**Concept:** General join using a comparison operator other than `=` (e.g., `&lt;`, `>`, `&lt;=`, `>=`, `&lt;>`).
**Syntax:**

```language-auto
SELECT columns
  FROM A, B
 WHERE A.col operator B.col;
```

**Example:** (Find students and departments where DeptID is less than student’s DeptID)

```language-auto
SELECT S.Name, D.DeptName
  FROM Student S, Department D
 WHERE S.DeptID > D.DeptID;
```

---

### Key Points to Remember

* **Inner vs. Outer:** Inner hides non-matches; outer shows non-matches with NULLs.
* **Cross Join:** No condition—Cartesian explosion.
* **Self Join:** Alias same table twice for hierarchical data.
* **Natural Join:** Convenient but can be error-prone if extra common columns exist.
* **Theta Join:** Supports non-equality conditions.



---

#### 1. Subqueries (Nested Queries)

**Concept:**
A **subquery** is a complete query placed inside another SQL statement. The database executes the subquery first and then uses its result in the outer query.

**Common Forms:**

1. **Single‐row**: Returns one value
2. **Multi‐row**: Returns a list of values
3. **Multi‐column**: Returns multiple columns
4. **Scalar**: Used in `SELECT` or expressions

**Syntax Pattern:**

```language-auto
SELECT … 
  FROM MainTable
 WHERE column operator 
       (SELECT … FROM OtherTable WHERE …);
```

**Example 1 – Single‐row Subquery**
Find all employees in the “CSE” department:

```language-auto
SELECT EmpID, Name, Salary
  FROM Employee
 WHERE DeptID = (
       SELECT DeptID
         FROM Department
        WHERE DeptName = 'CSE'
 );
```

* **Inner query**: finds the ID of the CSE department.
* **Outer query**: retrieves employees matching that ID.

**Example 2 – Multi‐row Subquery**
List employees earning more than the company average salary:

```language-auto
SELECT Name, Salary
  FROM Employee
 WHERE Salary > (
       SELECT AVG(Salary)
         FROM Employee
 );
```

* **Inner query**: computes average salary.
* **Outer query**: selects employees above that average.

---

#### 2. Correlated Subqueries

**Concept:**
A **correlated subquery** refers to columns from the outer query. It is re-evaluated once for each row of the outer query, making it “correlated.”

**Syntax Pattern:**

```language-auto
SELECT … 
  FROM A
 WHERE A.col operator
       (SELECT … 
          FROM B
         WHERE B.related_col = A.col);
```

**Example – Department‐wise Comparison**
Show employees whose salary is above the average salary *in their own* department:

```language-auto
SELECT E.Name, E.DeptID, E.Salary
  FROM Employee E
 WHERE E.Salary > (
       SELECT AVG(E2.Salary)
         FROM Employee E2
        WHERE E2.DeptID = E.DeptID
 );
```

* For **each** row **E** in the outer query:

  * The inner query computes the average salary of **E**’s department.
  * Then checks if **E**’s salary exceeds that value.

---

**Key Differences:**

* **Subquery**: Runs once, result independent of outer rows.
* **Correlated**: Runs per outer row, depends on outer values.



---

### Concept of a View

A **view** is a **virtual table** defined by a SQL query. It does **not** store data itself but presents rows from one or more base tables. Views simplify complex queries, encapsulate business logic, and can restrict user access to specific columns or rows.

---

#### Types of Views

| View Type                  | Definition & Characteristics                                                                                                                                                                    | Example Use                                        |
| -------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------- |
| **Simple View**            | - Based on a single table<br>- Contains no aggregates, `GROUP BY`, `DISTINCT`, or joins<br>- Often updatable                                                                                    | Show only CSE students                             |
| **Complex View**           | - May use joins, aggregates, `GROUP BY`, `HAVING`, `DISTINCT`, or subqueries<br>- Usually read-only                                                                                             | Department salary totals                           |
| **Inline View**            | - A subquery in the `FROM` clause of another query<br>- Temporary, not named in the schema                                                                                                      | Top 3 salaries per dept                            |
| **Materialized View**      | - Stores the result set physically<br>- Must be refreshed manually or on a schedule<br>- Speeds up complex reports                                                                              | Yearly sales summary                               |
| **Partitioned View**       | - Combines identical‐structure tables (often on different servers)<br>- Presents them as one table                                                                                              | Sales data by region, each region in its own table |
| **Updatable vs Read-Only** | - *Updatable:* Simple views meeting SQL rules (one table, key preserved) can be modified via `INSERT`/`UPDATE`/`DELETE`<br>- *Read-Only:* Complex or aggregate views cannot be changed directly | Allow managers to update salaries through a view   |

---

#### Examples

#### a) Simple View

```language-auto
-- Create: only CSE students
CREATE VIEW CSE_Students AS
  SELECT StudID, Name, GPA
    FROM Student
   WHERE MajorSubject = 'Computer Science';

-- Use:
SELECT * FROM CSE_Students;
```

#### b) Complex View

```language-auto
-- Create: total and average salary by department
CREATE VIEW Dept_Salary_Stats AS
  SELECT DeptID,
         COUNT(*)    AS EmpCount,
         SUM(Salary) AS TotalSal,
         AVG(Salary) AS AvgSal
    FROM Employee
GROUP BY DeptID;

-- Use:
SELECT DeptID, AvgSal
  FROM Dept_Salary_Stats
 WHERE AvgSal > 60000;
```

#### c) Inline View

```language-auto
SELECT DeptID, Name, Salary
  FROM (
         SELECT DeptID, Name, Salary,
                ROW_NUMBER() OVER (PARTITION BY DeptID
                                   ORDER BY Salary DESC) AS rn
           FROM Employee
       ) AS TopEarners
 WHERE rn &lt;= 3;
```

#### d) Materialized View  *(Oracle / PostgreSQL)*

```language-auto
-- Create and populate
CREATE MATERIALIZED VIEW Sales_Yrly AS
  SELECT EXTRACT(YEAR FROM SaleDate) AS Yr,
         SUM(Amount)                  AS TotalSales
    FROM Sales
GROUP BY EXTRACT(YEAR FROM SaleDate);

-- Refresh later
REFRESH MATERIALIZED VIEW Sales_Yrly;

-- Use:
SELECT * FROM Sales_Yrly;
```

#### e) Partitioned View *(SQL Server)*

```language-auto
-- Assume tables Sales_East, Sales_West with same columns
CREATE VIEW All_Sales AS
  SELECT * FROM Sales_East
  UNION ALL
  SELECT * FROM Sales_West;

-- Query:
SELECT Region, SUM(Amount)
  FROM All_Sales
 GROUP BY Region;
```

#### f) Updatable View vs Read-Only

```language-auto
-- Updatable: one table, all NOT NULL columns included
CREATE VIEW Emp_Basic AS
  SELECT EmpID, Name, Salary
    FROM Employee;

/* Allowed: */
UPDATE Emp_Basic
   SET Salary = Salary * 1.05
 WHERE EmpID = 101;

/* Not allowed on complex view: */
UPDATE Dept_Salary_Stats
   SET TotalSal = 500000;  -- ERROR: read-only view
```


---

### Integrity Rules

Integrity rules (constraints) ensure data in a database is **accurate**, **consistent**, and **reliable** by enforcing conditions at the schema level.

---

#### Entity Integrity

* **Concept:** Every table must have a primary key (PK) that uniquely identifies each row, and PK columns **cannot be NULL**.
* **SQL Enforcement:** `PRIMARY KEY` constraint.
* **Example:**

  ```language-auto
  CREATE TABLE Student (
    StudID      INT     PRIMARY KEY,   -- PK: never NULL, unique
    Name        VARCHAR(50),
    Major       VARCHAR(30)
  );
  ```

  * Here, `StudID` ensures each student row is unique and never empty.

---

#### Key Integrity

* **Concept:** Beyond the PK, any **candidate key** must also be unique. A **unique key** constraint enforces no duplicate values in a column (or set of columns).
* **SQL Enforcement:** `UNIQUE` constraint.
* **Example:**

  ```language-auto
  CREATE TABLE Employee (
    EmpID       INT      PRIMARY KEY,
    Email       VARCHAR(100) UNIQUE,   -- no two employees share an email
    Name        VARCHAR(50)
  );
  ```

  * `Email` cannot repeat across different employee rows.

---

#### Referential Integrity

* **Concept:** A **foreign key (FK)** in one table must match an existing primary (or unique) key in the referenced table, or be NULL. This prevents “orphan” records.
* **SQL Enforcement:** `FOREIGN KEY … REFERENCES … [ON DELETE|UPDATE …]`
* **Example:**

  ```language-auto
  CREATE TABLE Department (
    DeptID      INT     PRIMARY KEY,
    DeptName    VARCHAR(50)
  );

  CREATE TABLE Student (
    StudID      INT     PRIMARY KEY,
    Name        VARCHAR(50),
    DeptID      INT,
    FOREIGN KEY (DeptID)
      REFERENCES Department(DeptID)
      ON DELETE SET NULL   -- if a department is removed, set DeptID to NULL
  );
  ```

  * Each `Student.DeptID` must refer to a valid `Department.DeptID`.

---

#### Domain Integrity

* **Concept:** Each column’s values must belong to a defined **domain**: correct data type, format, length, and optional value ranges.
* **SQL Enforcement:**

  * **Data types** (e.g., `INT`, `VARCHAR(…)`)
  * **NOT NULL** (no missing values)
  * **DEFAULT** (fallback value)
  * **CHECK** (custom rule on values)
* **Example:**

  ```language-auto
  CREATE TABLE Course (
    CourseID    CHAR(6)       NOT NULL,
    Title       VARCHAR(100)  NOT NULL,
    Credits     INT           DEFAULT 3,
    CHECK (Credits BETWEEN 1 AND 5)  -- must be 1–5
  );
  ```

  * `Credits` always falls between 1 and 5; `CourseID` and `Title` cannot be empty.

---

#### User-Defined Integrity

* **Concept:** Business rules specific to the application that aren’t covered by standard constraints. Enforced using **triggers**, **assertions**, or **stored procedures**.
* **SQL Enforcement:**

  * **Triggers** (`BEFORE`/`AFTER INSERT/UPDATE/DELETE`)
  * **Assertions** (`CREATE ASSERTION … CHECK (…)`) — not universally supported
* **Example (Trigger):**

  ```language-auto
  -- Rule: Grade must be A, B, C, D, or F
  CREATE TABLE Enroll (
    StudID   INT,
    CourseID CHAR(6),
    Grade    CHAR(1),
    PRIMARY KEY (StudID, CourseID)
  );

  CREATE TRIGGER validate_grade
    BEFORE INSERT OR UPDATE ON Enroll
    FOR EACH ROW
  BEGIN
    IF NEW.Grade NOT IN ('A','B','C','D','F') THEN
      SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Invalid grade value';
    END IF;
  END;
  ```

  * This trigger stops any insertion or update if `Grade` is outside the allowed set.

---

## Summary

* **Entity & Key Integrity** ensure uniqueness and non-null keys.
* **Referential Integrity** maintains valid links between tables.
* **Domain Integrity** restricts columns to correct types and value ranges.
* **User-Defined Integrity** implements custom business rules.


---

### PHP Superglobals (System Variables)

PHP provides built-in **superglobal arrays**—always accessible regardless of scope—to retrieve request data, session info, and server/environment details. Key ones include: `$_GET`, `$_POST`, `$_REQUEST`, `$_SESSION`, and `$_SERVER`.

---

#### `$_GET`

* **Concept:** Retrieves data sent via URL query string (`?key=value`). Used for safe, idempotent requests (e.g., search filters).
* **Syntax:** `$_GET['field_name']`

**Example:**

```
&lt;!-- URL: product.php?id=42&category=books -->
&lt;?php
// product.php
$productId  = $_GET['id'];       // "42"
$category   = $_GET['category']; // "books"

echo "Showing product {$productId} in {$category}";
?>
```

---

#### `$_POST`

* **Concept:** Retrieves data sent via HTTP POST (form submissions). Suitable for sensitive data (passwords) or large payloads.
* **Syntax:** `$_POST['field_name']`

**Example:**

```
&lt;!-- form.html -->
&lt;form action="submit.php" method="post">
  Name: &lt;input name="username">&lt;br>
  Pass: &lt;input name="password" type="password">&lt;br>
  &lt;button type="submit">Login&lt;/button>
&lt;/form>

&lt;?php
// submit.php
$username = $_POST['username'];
$password = $_POST['password'];

echo "Welcome, {$username}";
?>
```

---

#### `$_REQUEST`

* **Concept:** Merges `$_GET`, `$_POST`, and `$_COOKIE`. Handy when method doesn’t matter, but less secure—may mix sources.
* **Syntax:** `$_REQUEST['field_name']`

**Example:**

```
&lt;!-- URL: search.php?q=php -->
&lt;form action="search.php" method="post">
  &lt;input name="q">
  &lt;button>Go&lt;/button>
&lt;/form>

&lt;?php
// search.php
$query = $_REQUEST['q'];  // from GET or POST
echo "Search for: {$query}";
?>
```

---

#### `$_SESSION`

* **Concept:** Persists data across multiple pages for a user. Requires session start and usually a session cookie.
* **Setup:**

  1. Call `session_start()` at the top of each script.
  2. Store/retrieve via `$_SESSION['key']`.

**Example:**

```
&lt;?php
// login.php
session_start();
$_SESSION['user'] = 'DivyaMohan'; 
echo "Logged in as {$_SESSION['user']}";
?>

&lt;?php
// dashboard.php
session_start();
if(isset($_SESSION['user'])) {
  echo "Hello, {$_SESSION['user']}";
} else {
  echo "Please log in.";
}
?>
```

---

#### 5. `$_SERVER`

* **Concept:** Contains server and execution environment info (headers, paths, script locations). Read-only.
* **Common Keys:**

  * `$_SERVER['HTTP_HOST']` – current host
  * `$_SERVER['REQUEST_URI']` – requested resource path
  * `$_SERVER['SCRIPT_NAME']` – current script
  * `$_SERVER['QUERY_STRING']` – URL query string

**Example:**

```
&lt;?php
echo "Host: " . $_SERVER['HTTP_HOST'] . "&lt;br>";
echo "URI: "  . $_SERVER['REQUEST_URI'] . "&lt;br>";
echo "Script: " . $_SERVER['SCRIPT_NAME'];
?>
```

---

**Summary:**

* **`$_GET`**: URL parameters
* **`$_POST`**: Form data via POST
* **`$_REQUEST`**: Combined GET/POST/COOKIE
* **`$_SESSION`**: User-specific persistent data
* **`$_SERVER`**: Environment and request metadata


---

### Session in PHP

A **session** lets you store user-specific data on the server across multiple page requests. Unlike cookies (which live in the browser), session data is kept on the server and only a small session ID is sent to the client. This makes sessions more secure for sensitive data like login status.

---

#### How Sessions Work

1. **Start a session** with `session_start()`—PHP sends a session cookie (e.g. `PHPSESSID`) to the browser if none exists.
2. **Store/retrieve** data in `$_SESSION` array.
3. **End or destroy** the session when done (`session_unset()` + `session_destroy()`).

---

#### Database Connection (MySQLi)

```
&lt;?php
// db_connect.php
$host     = 'localhost';
$user     = 'db_user';
$password = 'db_pass';
$database = 'my_app';

$mysqli = new mysqli($host, $user, $password, $database);
if ($mysqli->connect_error) {
    die('DB Connection Error: ' . $mysqli->connect_error);
}
?>
```

---

#### Creating (Login) Session

**login.php**

```
&lt;?php
session_start();                  // 1. Start session
require 'db_connect.php';        // 2. Include DB connection

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    $username = $mysqli->real_escape_string($_POST['username']);
    $password = $_POST['password']; // in real apps, hash & verify

    // 3. Check credentials
    $sql = "SELECT id, username, password_hash 
              FROM users 
             WHERE username = '$username'
             LIMIT 1";
    $result = $mysqli->query($sql);

    if ($result && $user = $result->fetch_assoc()) {
        // 4. Verify password (assuming password_hash used)
        if (password_verify($password, $user['password_hash'])) {
            // 5. Store user info in session
            $_SESSION['user_id']   = $user['id'];
            $_SESSION['username']  = $user['username'];
            $_SESSION['logged_in'] = true;

            header('Location: dashboard.php');
            exit;
        }
    }
    $error = 'Invalid username or password';
}
?>
&lt;!DOCTYPE html>
&lt;html>
&lt;body>
  &lt;h2>Login&lt;/h2>
  &lt;?php if (!empty($error)) echo "&lt;p style='color:red;'>$error&lt;/p>"; ?>
  &lt;form method="post">
    Username: &lt;input name="username" required>&lt;br>
    Password: &lt;input type="password" name="password" required>&lt;br>
    &lt;button type="submit">Log In&lt;/button>
  &lt;/form>
&lt;/body>
&lt;/html>
```

---

#### Executing (Using) the Session

**dashboard.php**

```
&lt;?php
session_start();                // Resume session
// 1. Protect page—redirect if not logged in
if (empty($_SESSION['logged_in'])) {
    header('Location: login.php');
    exit;
}

// 2. Use session data
echo "&lt;h1>Welcome, " . htmlspecialchars($_SESSION['username']) . "&lt;/h1>";
echo "&lt;p>Your User ID: " . $_SESSION['user_id'] . "&lt;/p>";
?>
&lt;p>&lt;a href="logout.php">Log Out&lt;/a>&lt;/p>
```

---

#### Destroying (Logout) the Session

**logout.php**

```
&lt;?php
session_start();
// 1. Unset all session variables
$_SESSION = [];

// 2. Destroy session cookie on client
if (ini_get("session.use_cookies")) {
    setcookie(
      session_name(), 
      '', 
      time() - 3600, 
      ini_get("session.cookie_path"),
      ini_get("session.cookie_domain"),
      ini_get("session.cookie_secure"),
      ini_get("session.cookie_httponly")
    );
}

// 3. Destroy server‐side session data
session_destroy();

header('Location: login.php');
exit;
?>
```

---

#### Key Points

* Always call `session_start()` before any output.
* **Sanitize** inputs and **hash** passwords (`password_hash()`, `password_verify()`).
* **Regenerate** session ID on login (`session_regenerate_id(true)`) for security.
* Unset and destroy both session data and the session cookie on logout.
* Use `$_SESSION` only after verifying user authentication.



### 1. Introduction

Web applications often need to **collect user input**, **store** it in a **database**, and later **retrieve** it for display. In PHP & MySQL:

* **HTML form** gathers data
* **PHP script** uses **mysqli** to INSERT/SELECT
* **POST** method sends data securely

---

#### 2. Database & Table Creation (5 M)

**SQL commands** to set up the database and table:

```sql
-- 1. Create database
CREATE DATABASE IF NOT EXISTS mydb;

-- 2. Use database
USE mydb;

-- 3. Create table
CREATE TABLE IF NOT EXISTS student (
  roll INT      PRIMARY KEY,
  name VARCHAR(50),
  city VARCHAR(50)
);
```

* **roll** is PRIMARY KEY (unique, NOT NULL)
* **name**, **city** hold text up to 50 chars

---

#### 3. HTML Form Page (5 M)

```html
&lt;!-- data.html -->
&lt;form action="save_data.php" method="post">
  &lt;label>Roll: &lt;input name="roll" required>&lt;/label>&lt;br>
  &lt;label>Name: &lt;input name="name" required>&lt;/label>&lt;br>
  &lt;label>City: &lt;input name="city" required>&lt;/label>&lt;br>
  &lt;button type="submit">Save&lt;/button>
&lt;/form>
```

* **method="post"** → data in `$_POST`, not URL
* **required** → basic browser validation

---

#### 4. PHP Insert Script (5 M)

```
&lt;?php
// save_data.php
$conn = new mysqli("localhost","root","","mydb");
if ($conn->connect_error) die("Connection failed");

$roll = (int)$_POST['roll'];
$name = $conn->real_escape_string($_POST['name']);
$city = $conn->real_escape_string($_POST['city']);

$sql = "INSERT INTO student (roll,name,city)
        VALUES ($roll,'$name','$city')";

if ($conn->query($sql)) {
    echo "Record saved. &lt;a href='view_data.php'>View all&lt;/a>";
} else {
    echo "Error: " . $conn->error;
}
$conn->close();
```

* **(int)** cast prevents injection via roll
* **real\_escape\_string** escapes quotes in text
* **error handling** reports failures

---

#### 5. PHP Fetch & Display Script (5 M)

```
&lt;?php
// view_data.php
$conn = new mysqli("localhost","root","","mydb");
if ($conn->connect_error) die("Connection failed");

$result = $conn->query("SELECT * FROM student");

echo "&lt;table border=1>
        &lt;tr>&lt;th>Roll&lt;/th>&lt;th>Name&lt;/th>&lt;th>City&lt;/th>&lt;/tr>";
while ($r = $result->fetch_assoc()) {
    echo "&lt;tr>
            &lt;td>{$r['roll']}&lt;/td>
            &lt;td>{$r['name']}&lt;/td>
            &lt;td>{$r['city']}&lt;/td>
          &lt;/tr>";
}
echo "&lt;/table>";
$conn->close();
```

* **SELECT \*** retrieves all columns
* **fetch\_assoc()** returns each row as an associative array

---

#### 6. Flow Diagram & Best Practices (5 M)

```
[data.html form] 
     ↓ POST
[save_data.php] ──INSERT──▶ [MySQL student table]
     ↓ link
[view_data.php] ──SELECT──▶ [HTML table display]
```

**Best Practices:**

* **Validate** inputs (e.g., `required`, `is_numeric`)
* **Sanitize** data (`real_escape_string`)
* **Error handling** for DB connection & queries
* **Separate** presentation (HTML) from logic (PHP)

---



            </pre>




        </main>

        <script> copyright("all"); </script>

    </body>

</html>