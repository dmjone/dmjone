<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>

        <title>Assignment Questions - CSU1288 - Shoolini U</title>
        <meta name="description" content="Assignment Questions - CSU1288 - Shoolini U" />

        <meta property="og:image" content="/logo.png">
        <meta property="og:type" content="article">

        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@divyamohan1993">
        <meta name="twitter:creator" content="@divyamohan1993">
        <meta name="twitter:image" content="/logo.png">

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />

        <meta name="author" content="Divya Mohan">
        <meta name="robots" content="index, follow">



        <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                renderMathInElement(document.body, {
                    // customised options
                    // • auto-render specific keys, e.g.:
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\(', right: '\\)', display: false },
                        { left: '\\[', right: '\\]', display: true }
                    ],
                    // • rendering keys, e.g.:
                    throwOnError: false
                });
            });
        </script> -->

        <!-- <style>
            main ul {
                list-style-type: none;
                padding: 0;
                margin: 0;
            }

            main ul li {
                margin: 0;
                padding: 0;
            }
        </style> -->

        <script type="application/ld+json">
        {
          "@context": "https://schema.org",
          "@type": "TechArticle",
          "headline": "Mapping Intrusion Responses to Security Policies",
          "description": "An in-depth guide on aligning intrusion response mechanisms with organizational security policies. Covers types of policies, response actions, automation strategies, challenges, and best practices for effective cybersecurity management.",
          "dateModified": "2025-05-13",
          "author": [
            {
              "@type": "Person",
              "name": "Divya Mohan",
              "url": "https://dmj.one/resume/",
              "sameAs": [
                "https://www.credly.com/users/divyamohan1993",
                "https://www.linkedin.com/in/divyamohan1993/",
                "https://hackerrank.com/divyamohan1993",
                "https://www.coursera.org/learner/divyamohan1993"
              ]
            }
          ],
          "publisher": {
            "@type": "EducationalOrganization",
            "name": "dmj.one",
            "url": "https://dmj.one"
          },
          "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https://dmj.one/edu/su/course/csu1288/theory/mapping-intrusion-responses-to-security-policies"
          },
          "keywords": [
            "Security Policies",
            "Intrusion Detection",
            "Incident Response",
            "Access Control",
            "Data Protection",
            "Network Security",
            "SOAR",
            "SIEM",
            "Automated Security",
            "Cybersecurity Best Practices"
          ],
          "articleSection": [
            "Security Policies",
            "Intrusion Response",
            "Mapping Responses to Policies",
            "Policy-Specific Response Mapping",
            "Automation Strategies",
            "Challenges in Response Mapping",
            "Best Practices"
          ],
          "isAccessibleForFree": true,
          "inLanguage": "en-US",
          "license": "https://www.gnu.org/licenses/agpl-3.0.en.html"
        }
        </script>



    </head>

    <body>

        <script> header_author("dm"); </script>

        <main>
            <article class="agen-tableofcontents">
                <h2 class="text-center">
                    Assignment questions
                </h2>
                <div class="d-none contentdate">2025, May 13</div>
            </article>

            <!-- <article>
                <h3>Question 1</h3>
                <p><strong>Question</strong>: How Snort is installed and configured. What are rule headers, rule options and Snort modules (preprocessors, plugins, outputs etc)?</p>
                <p><strong>Installation and Configuration of Snort</strong>
                    Snort is an open-source network intrusion detection and prevention system. To install and configure:</p>
                <ol>
                    <li><strong>Prerequisites</strong>: Install libpcap (packet capture), libpcre (regular expressions), zlib (compression) and DAQ (Data Acquisition) library.</li>
                    <li><strong>Download &amp; Compile</strong>:</li>
                </ol>
                <pre><code class="">wget https://www.snort.org/downloads/snort/snort-2.9.20.tar.gz
tar -xzf snort-2.9.20.tar.gz
cd snort-2.9.20
./configure --enable-sourcefire
make &amp;&amp; sudo make install
</code></pre>
                <ol start="3">
                    <li><strong>Directory Setup</strong>:</li>
                </ol>
                <pre><code class="">sudo useradd snort
sudo mkdir -p /etc/snort/rules /var/log/snort /usr/local/lib/snort_dynamicrules
sudo chown -R snort:snort /etc/snort /var/log/snort /usr/local/lib/snort_dynamicrules
</code></pre>
                <ol start="4">
                    <li>
                        <p><strong>Configuration Files</strong>: Copy <code>snort.conf</code>, <code>classification.config</code>, <code>threshold.conf</code> into <code>/etc/snort/</code>. Edit <code>/etc/snort/snort.conf</code> to set:</p>
                        <ul>
                            <li><code>var HOME_NET 192.168.1.0/24</code></li>
                            <li><code>var EXTERNAL_NET !$HOME_NET</code></li>
                            <li><code>include $RULE_PATH/local.rules</code></li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Testing</strong>:</p>
                    </li>
                </ol>
                <pre><code class="">snort -T -c /etc/snort/snort.conf
</code></pre>
                <ol start="6">
                    <li><strong>Running Snort</strong>:</li>
                </ol>
                <pre><code class="">snort -A console -q -c /etc/snort/snort.conf -i eth0
</code></pre>
                <p><em>Example:</em> On Ubuntu, one may instead use <code>sudo apt-get install snort</code> and then edit <code>/etc/snort/snort.conf</code> before <code>sudo systemctl start snort</code>.</p>
                
                <p><strong>Rule Headers</strong>
                    A Snort rule header defines the basic packet match parameters and action. Its syntax is:</p>
                <pre><code class="">action  protocol  src_IP  src_port  direction  dst_IP  dst_port
</code></pre>
                <ul>
                    <li><strong>action</strong>: what Snort does when matched (e.g. <code>alert</code>, <code>log</code>, <code>pass</code>, <code>drop</code>).</li>
                    <li><strong>protocol</strong>: network layer protocol (<code>tcp</code>, <code>udp</code>, <code>icmp</code>, <code>ip</code>).</li>
                    <li><strong>src_IP/src_port</strong>: source address or network (<code>any</code>, CIDR) and port (<code>any</code>, number, range).</li>
                    <li><strong>direction</strong>: packet flow arrow (<code>-&gt;</code> for uni-directional, <code>&lt;-&gt;</code> for bi-directional).</li>
                    <li><strong>dst_IP/dst_port</strong>: destination address and port.</li>
                </ul>
                <p><em>Example:</em></p>
                <pre><code class="">alert tcp any any -&gt; 192.168.1.0/24 80  
</code></pre>
                <p>This rule “alerts” on any TCP packet from any host/port to the 192.168.1.0/24 network on port 80.</p>
                
                <p><strong>Rule Options</strong>
                    Rule options refine detection and specify alert details. They are enclosed in parentheses and separated by semicolons:</p>
                <pre><code class="">(action …) (option1; option2; …; sid:ID; rev:revision;)
</code></pre>
                <p>Common options:</p>
                <ul>
                    <li><code>msg:"text"</code> – alert message.</li>
                    <li><code>sid:number</code> – unique Snort ID.</li>
                    <li><code>rev:number</code> – revision counter.</li>
                    <li><code>content:"string"</code> – payload pattern to match.</li>
                    <li><code>nocase</code> – case-insensitive content match.</li>
                    <li><code>flow:to_server,established</code> – packet flow direction and TCP state.</li>
                    <li><code>classtype:policy-violation</code> – classification category.</li>
                    <li><code>priority:number</code> – alert priority.</li>
                </ul>
                <p><em>Example:</em></p>
                <pre><code class="">alert tcp any any -&gt; $HOME_NET 80 (msg:"HTTP GET attempt"; flow:to_server,established; content:"GET "; http_uri; sid:1000001; rev:1;)  
</code></pre>
                <p>This alerts when “GET ” appears in the URI of an established TCP session to port 80.</p>
                
                <p><strong>Snort Modules</strong>
                    Snort modules extend sniffing, normalization and output capabilities.</p>
                <ol>
                    <li>
                        <p><strong>Preprocessors</strong></p>
                        <ul>
                            <li>Process packets before detection.</li>
                            <li><strong>frag3_engine</strong>: reassembles IP fragments.</li>
                            <li><strong>stream5_tcp</strong>: reassembles TCP streams.</li>
                            <li><strong>http_inspect</strong>: normalizes HTTP traffic, detects anomalies.</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Dynamic Plugins</strong></p>
                        <ul>
                            <li>Loadable libraries for specialized tasks.</li>
                            <li>e.g. <code>sfportscan</code> for port scan detection, <code>sf_ssh</code> for SSH protocol logging.</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Output Modules</strong></p>
                        <ul>
                            <li>Control how alerts and logs are stored or forwarded.</li>
                            <li><strong>alert_fast</strong>: one-line console alerts.</li>
                            <li><strong>alert_full</strong>: full packet dump.</li>
                            <li><strong>unified2</strong>: binary format for analyzers (e.g. Barnyard2).</li>
                            <li><strong>syslog</strong>: sends alerts to syslog server.</li>
                        </ul>
                    </li>
                </ol>
                <p><em>Configuration Example in snort.conf:</em></p>
                <p>These modules ensure correct packet reassembly, protocol normalization and efficient alert logging.</p>
                <pre><code class="">preprocessor frag3_engine: policy linux detect_anomalies
preprocessor stream5_global: track_tcp yes
output unified2: filename snort.u2, limit 128
</code></pre>
            </article> -->

            <article>
                <h3>Question 1</h3>
                <p><strong>Question</strong>: How Snort is installed and configured. What are rule headers, rule options and Snort modules (preprocessors, plugins, outputs etc)?</p>
            
                <p><strong>Installation &amp; Configuration on Ubuntu</strong></p>
                <ol>
                    <li>
                        <strong>Install Snort</strong>:
                        <pre><code class="">sudo apt update
            sudo apt install snort -y</code></pre>
                    </li>
                    <li>
                        <strong>Set Network Variables</strong>:
                        <pre><code class="">sudo dpkg-reconfigure snort</code></pre>
                        During the prompts, set:
                        <ul>
                            <li><code>HOME_NET</code> (e.g., <code>192.168.1.0/24</code>)</li>
                            <li><code>EXTERNAL_NET</code> (<code>!$HOME_NET</code>)</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Edit Main Config</strong>:
                        <pre><code class="">sudo nano /etc/snort/snort.conf</code></pre>
                        Ensure these lines point to your rules and include local rules:
                        <ul>
                            <li><code>var RULE_PATH /etc/snort/rules</code></li>
                            <li><code>include $RULE_PATH/local.rules</code></li>
                        </ul>
                    </li>
                    <li>
                        <strong>Test Configuration</strong>:
                        <pre><code class="">snort -T -c /etc/snort/snort.conf</code></pre>
                        Fix any errors reported.
                    </li>
                    <li>
                        <strong>Start &amp; Enable</strong>:
                        <pre><code class="">sudo systemctl start snort
            sudo systemctl enable snort</code></pre>
                    </li>
                </ol>
            
                <p><strong>Rule Headers</strong>: define which packets to match and what Snort does.</p>
                <pre><code class="">action protocol src_IP src_port direction dst_IP dst_port</code></pre>
                <ul>
                    <li><code>alert</code>, <code>log</code>, <code>pass</code>, <code>drop</code></li>
                    <li><code>tcp</code>, <code>udp</code>, <code>icmp</code>, <code>ip</code></li>
                    <li><code>any</code> or specific IP/CIDR and port</li>
                    <li><code>-></code> (one-way) or <code><-></code> (two-way)</li>
                </ul>
            
                <p><strong>Rule Options</strong>: refine matching and set alert details. Enclosed in parentheses, separated by semicolons.</p>
                <pre><code class="">(msg:"text"; sid:1000001; rev:1; content:"pattern"; nocase;)</code></pre>
            
                <p><strong>Snort Modules</strong>:</p>
                <ol>
                    <li>
                        <strong>Preprocessors</strong>: prepare traffic for rules.
                        <ul>
                            <li><code>frag3</code> – reassemble IP fragments</li>
                            <li><code>stream5</code> – rebuild TCP streams</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Dynamic Plugins</strong>: loadable libraries for extra checks.
                        <ul>
                            <li><code>sfportscan</code> – detect port scans</li>
                            <li><code>ssh</code> – log SSH sessions</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Output Modules</strong>: define how alerts are logged.
                        <ul>
                            <li><code>alert_fast</code> – simple console alerts</li>
                            <li><code>unified2</code> – binary format for external processors</li>
                        </ul>
                    </li>
                </ol>
            </article>
            <article>
                <h3>Question 2</h3>
                <p><strong>Question</strong>: Summarize how malware differs across Windows, Linux and Android systems. Provide examples of platform-specific malware.</p>
                <h4><strong>Windows Malware</strong></h4>
                <ul>
                    <li>
                        <p><strong>Attack Surface &amp; Distribution</strong>: Predominantly desktop and server environments with high market share. Common delivery via email attachments (e.g. Office macros), drive-by downloads and SMB or RDP exploits.</p>
                    </li>
                    <li>
                        <p><strong>Privilege Model</strong>: Malware often exploits user-level or SYSTEM-level privileges via DLL hijacking, service abuse or fileless techniques (PowerShell, WMI).</p>
                    </li>
                    <li>
                        <p><strong>Typical Types</strong>:</p>
                        <ul>
                            <li><strong>Ransomware</strong> (encrypts files, demands payment) – e.g. <strong>WannaCry</strong> uses the EternalBlue SMB exploit.</li>
                            <li><strong>Banking Trojans</strong> (credential theft) – e.g. <strong>Emotet</strong> spreads via malicious macros and deploys additional payloads.</li>
                            <li><strong>Fileless Malware</strong> (resides in memory) – e.g. <strong>Poweliks</strong> uses registry-based scripts to avoid disk artifacts.</li>
                        </ul>
                    </li>
                </ul>
                <h4><strong>Linux Malware</strong></h4>
                <ul>
                    <li>
                        <p><strong>Attack Surface &amp; Distribution</strong>: Common on servers, IoT devices and cloud instances. Delivered via compromised SSH credentials, malicious packages or container images.</p>
                    </li>
                    <li>
                        <p><strong>Privilege Model</strong>: Focus on gaining root via kernel exploits or misconfigured sudo; persistence through cronjobs or systemd units.</p>
                    </li>
                    <li>
                        <p><strong>Typical Types</strong>:</p>
                        <ul>
                            <li><strong>Cryptominers</strong> (unauthorized resource use) – e.g. <strong>XMRig</strong>‐based scripts injected into <code>/etc/cron.d</code>.</li>
                            <li><strong>Rootkits &amp; Backdoors</strong> – e.g. <strong>Linux.BackDoor.Gates</strong> hides processes and grants remote shell access.</li>
                            <li><strong>Botnets</strong> (DDoS) – e.g. <strong>Mirai</strong> infects IoT devices running Linux to launch volumetric attacks.</li>
                        </ul>
                    </li>
                </ul>
                <h4><strong>Android Malware</strong></h4>
                <ul>
                    <li>
                        <p><strong>Attack Surface &amp; Distribution</strong>: Mobile-specific via Google Play or third-party APK stores; social-engineering prompts for permissions.</p>
                    </li>
                    <li>
                        <p><strong>Privilege Model</strong>: Relies on requesting dangerous permissions (SMS, Accessibility, Overlay) to escalate capabilities within the app sandbox.</p>
                    </li>
                    <li>
                        <p><strong>Typical Types</strong>:</p>
                        <ul>
                            <li><strong>Banking Trojans</strong> – e.g. <strong>Cerberus</strong> overlays fake login screens to capture credentials.</li>
                            <li><strong>Adware &amp; Click Fraud</strong> – e.g. <strong>HummingBad</strong> invisibly generates ad clicks and installs other malware.</li>
                            <li><strong>Spyware &amp; SMS Trojans</strong> – e.g. <strong>Joker</strong> subscribes users to premium services by intercepting SMS.</li>
                        </ul>
                    </li>
                </ul>
                <h4>Key Differences</h4>
                <ol>
                    <li><strong>Target &amp; Prevalence</strong>: Windows remains most targeted due to global desktop use; Linux focuses on servers/IoT; Android targets mobile users.</li>
                    <li><strong>Persistence Mechanisms</strong>: Windows uses registry, scheduled tasks, Windows services; Linux uses cron, systemd; Android uses <code>BOOT_COMPLETED</code> receivers and Accessibility services.</li>
                    <li><strong>Detection &amp; Defense</strong>: Windows employs signature- and behavior-based AV, EDR agents; Linux relies on file integrity checkers (AIDE), anomaly detection; Android uses Play Protect, permission audits.</li>
                </ol>
            </article>
            <article>
                <h3>Question 3</h3>
                <p><strong>Question</strong>: List common signs of intrusion in IT and OT networks. What makes intrusion detection in OT networks more challenging?</p>
                <h4><strong>Common Signs of Intrusion in IT Networks</strong></h4>
                <ol>
                    <li>
                        <p><strong>Unusual Network Traffic</strong></p>
                        <ul>
                            <li>Sudden spikes in outbound connections or data volume</li>
                            <li>Connections to known malicious IPs or geographies</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Authentication Anomalies</strong></p>
                        <ul>
                            <li>Multiple failed login attempts or brute-force patterns</li>
                            <li>Logins at unusual hours or from unexpected locations</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>File and Configuration Changes</strong></p>
                        <ul>
                            <li>Creation or modification of critical system files</li>
                            <li>New user accounts or unexpected privilege escalations</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Alert and Log Indicators</strong></p>
                        <ul>
                            <li>Repeated antivirus/EDR detections or quarantine events</li>
                            <li>Suspicious entries in Windows Event Logs, syslog or SIEM alerts</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Process and Service Irregularities</strong></p>
                        <ul>
                            <li>Unknown or unsigned executables running in memory</li>
                            <li>Unexpected services enabled or listening on unusual ports</li>
                        </ul>
                    </li>
                </ol>
                <p><strong>Common Signs of Intrusion in OT Networks</strong></p>
                <ol>
                    <li>
                        <p><strong>Process Deviations</strong></p>
                        <ul>
                            <li>Sensor readings outside normal operational thresholds</li>
                            <li>Unexpected start/stop or speed changes of motors, pumps or valves</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Control-Logic Tampering</strong></p>
                        <ul>
                            <li>Changes to PLC/RTU ladder logic or function blocks without maintenance records</li>
                            <li>Unauthorized firmware updates on controllers</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Protocol Anomalies</strong></p>
                        <ul>
                            <li>Malformed or out-of-sequence Modbus, DNP3 or OPC traffic</li>
                            <li>Devices responding to commands they should not support</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Asset and Safety Alerts</strong></p>
                        <ul>
                            <li>Activation of safety interlocks or emergency shutdowns without cause</li>
                            <li>Loss of heartbeat or supervision messages from field devices</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Visibility Gaps</strong></p>
                        <ul>
                            <li>Sudden loss of telemetry data or unexplained “dark” segments in network maps</li>
                        </ul>
                    </li>
                </ol>
                <h4><strong>Why OT Intrusion Detection Is More Challenging</strong></h4>
                <ul>
                    <li><strong>Legacy and Proprietary Protocols</strong>: Many OT devices use undocumented, vendor-specific protocols that IDS tools cannot natively parse.</li>
                    <li><strong>High Availability Requirements</strong>: Any active scanning or packet inspection risks disrupting real-time control loops and must be non-intrusive.</li>
                    <li><strong>Minimal Embedded Logging</strong>: OT controllers often store little to no forensic data, making anomaly investigation difficult.</li>
                    <li><strong>Deterministic Operations</strong>: OT systems follow strict, repeatable cycles; distinguishing malicious deviation from rare but legitimate state changes requires deep process knowledge.</li>
                    <li><strong>Low Tolerance for False Positives</strong>: An incorrect alert may halt production, so detection rules must be highly precise and tailored to each site’s unique process.</li>
                    <li><strong>Segmentation Limits</strong>: OT networks may lack full isolation or standardized segmentation, reducing visibility and increasing the attack surface. Continuous monitoring thus demands specialized sensors and expert tuning.</li>
                </ul>
            </article>
            <article>
                <h3>Question 4</h3>
                <p><strong>Question</strong>: Discuss the three main malware analysis techniques: static, dynamic and hybrid. Compare their advantages and limitations. In what scenarios would each technique be most effectively applied?</p>
                <h4>Static Analysis</h4>
                <p><strong>Definition:</strong> Examination of malware without executing it, by inspecting code, binaries and file properties.
                    <strong>Techniques:</strong>
                </p>
                <ul>
                    <li><strong>Signature &amp; Hash Analysis:</strong> Compare file hash or known byte patterns against malware databases.</li>
                    <li><strong>String &amp; Resource Inspection:</strong> Extract readable text, file paths, URLs and embedded resources.</li>
                    <li><strong>Disassembly &amp; Decompilation:</strong> Translate machine code into assembly or higher-level code to inspect logic.</li>
                    <li><strong>Metadata Review:</strong> Examine PE headers (on Windows), import tables and section characteristics.</li>
                </ul>
                <p><strong>Advantages:</strong></p>
                <ul>
                    <li><strong>Safe Environment:</strong> No risk of infection since code never runs.</li>
                    <li><strong>Rapid Triage:</strong> Quick identification via hashes or signatures.</li>
                    <li><strong>Low Resource Needs:</strong> Requires only analysis tools, no sandboxing infrastructure.</li>
                </ul>
                <p><strong>Limitations:</strong></p>
                <ul>
                    <li><strong>Obfuscation &amp; Packing:</strong> Encrypted or packed code hides true behavior.</li>
                    <li><strong>No Runtime Context:</strong> Cannot see actions that occur only during execution (e.g. network calls).</li>
                    <li><strong>False Negatives:</strong> Novel or polymorphic malware may evade signature checks.</li>
                </ul>
                <p><strong>Best Applied When:</strong></p>
                <ul>
                    <li>You need fast, initial verdicts on large sets of samples.</li>
                    <li>Code is simple or unpacked.</li>
                    <li>Infrastructure to run malware safely is unavailable.</li>
                </ul>
                <h4>Dynamic Analysis</h4>
                <p><strong>Definition:</strong> Execution of malware in a controlled environment (sandbox or VM) to observe real-time behavior.
                    <strong>Techniques:</strong>
                </p>
                <ul>
                    <li><strong>Sandbox Execution:</strong> Run malware in isolated VM or container.</li>
                    <li><strong>API &amp; System Call Monitoring:</strong> Trace registry edits, file creation, process launches.</li>
                    <li><strong>Network Traffic Capture:</strong> Record DNS queries, HTTP requests and C2 communication.</li>
                    <li><strong>Behavioural Logging:</strong> Track changes to services, scheduled tasks and in-memory payloads.</li>
                </ul>
                <p><strong>Advantages:</strong></p>
                <ul>
                    <li><strong>Real Behavior Observation:</strong> Captures actions hidden by obfuscation.</li>
                    <li><strong>Contextual Insight:</strong> Reveals file drops, persistence mechanisms, C2 protocols.</li>
                    <li><strong>Automatable Reports:</strong> Many sandboxes generate human-readable summaries.</li>
                </ul>
                <p><strong>Limitations:</strong></p>
                <ul>
                    <li><strong>Resource Intensive:</strong> Requires dedicated VMs, sandboxes and instrumentation tools.</li>
                    <li><strong>Evasion Techniques:</strong> Malware can detect sandbox environments and alter behavior.</li>
                    <li><strong>Risk of Escape:</strong> Misconfigured isolation may allow malware to harm host.</li>
                </ul>
                <p><strong>Best Applied When:</strong></p>
                <ul>
                    <li>Analyzing unknown or packed samples that resist static inspection.</li>
                    <li>Investigating runtime behaviors like network callbacks or code unpacking.</li>
                    <li>Contextualizing alerts from security monitoring tools.</li>
                </ul>
                <h4>Hybrid Analysis</h4>
                <p><strong>Definition:</strong> Combination of static and dynamic techniques to leverage strengths of both.
                    <strong>Techniques:</strong>
                </p>
                <ul>
                    <li><strong>Pre-execution Static Triage:</strong> Use signature scans to decide which samples need sandboxing.</li>
                    <li><strong>Dynamic Guided by Static Findings:</strong> Inject breakpoints or instrumentation at statically identified code regions.</li>
                    <li><strong>Automated Pipelines:</strong> Orchestrate static unpacking followed by dynamic execution.</li>
                </ul>
                <p><strong>Advantages:</strong></p>
                <ul>
                    <li><strong>Comprehensive Coverage:</strong> Static insight guides dynamic focus; dynamic reveals hidden routines.</li>
                    <li><strong>Improved Accuracy:</strong> Reduces false positives and negatives by cross-validating findings.</li>
                    <li><strong>Efficient Resource Use:</strong> Only suspect or high-priority samples undergo full dynamic analysis.</li>
                </ul>
                <p><strong>Limitations:</strong></p>
                <ul>
                    <li><strong>Complex Setup:</strong> Requires integrating multiple toolchains and managing data exchange.</li>
                    <li><strong>Longer Turnaround:</strong> Two-phase analysis can be slower than single technique.</li>
                    <li><strong>Expertise Required:</strong> Analysts must interpret both static dumps and dynamic traces coherently.</li>
                </ul>
                <p><strong>Best Applied When:</strong></p>
                <ul>
                    <li>Investigating high-risk or targeted attacks where accuracy is critical.</li>
                    <li>Handling sophisticated malware using anti-analysis measures.</li>
                    <li>Organizations with mature labs that can support automated analysis pipelines.</li>
                </ul>
            </article>
            <article>
                <h3>Question 5</h3>
                <p><strong>Question</strong>: Explain how machine learning is applied to intrusion detection in both IT and OT networks. Provide examples of simple models (e.g., decision trees, k-NN) and advanced models (e.g., deep learning, ensemble methods) used for detecting malicious activity.</p>
                <h4><strong>Machine Learning in Intrusion Detection</strong></h4>
                <p>All ML‐based intrusion detection systems follow a common pipeline:</p>
                <ol>
                    <li><strong>Data Collection</strong> – capture network flows, logs or sensor readings.</li>
                    <li><strong>Feature Extraction</strong> – derive numerical attributes (e.g. packet size, TCP flags, time intervals, register values).</li>
                    <li><strong>Model Training</strong> – learn normal vs. malicious patterns (supervised or unsupervised).</li>
                    <li><strong>Detection</strong> – classify incoming data or flag anomalies in real time.</li>
                </ol>
                <p><strong>1. IT Network Intrusion Detection</strong></p>
                <ul>
                    <li>
                        <p><strong>Data Sources</strong>: NetFlow/IPFIX, firewall logs, Windows Event Logs, syslog.</p>
                    </li>
                    <li>
                        <p><strong>Objectives</strong>: Classify known attacks (e.g. DoS, port scans) or detect novel threats.</p>
                    </li>
                    <li>
                        <p><strong>Example Workflow</strong>:</p>
                        <ul>
                            <li>Extract 20 flow‐level features (duration, bytes, flags) from each connection.</li>
                            <li>Label flows using IDS alerts or threat intel.</li>
                            <li>Train a classifier to flag malicious connections.</li>
                        </ul>
                    </li>
                </ul>
                <p><strong>2. OT Network Intrusion Detection</strong></p>
                <ul>
                    <li>
                        <p><strong>Data Sources</strong>: PLC register values, HMI commands, Modbus/DNP3 packet fields, sensor telemetry.</p>
                    </li>
                    <li>
                        <p><strong>Objectives</strong>: Detect process anomalies (e.g. false setpoints), unauthorized firmware updates, command injection.</p>
                    </li>
                    <li>
                        <p><strong>Example Workflow</strong>:</p>
                        <ul>
                            <li>Sample process variables and command logs at fixed intervals.</li>
                            <li>Compute time‐series features (Δvalue, rate of change, periodicity).</li>
                            <li>Train an anomaly detector on clean operational data.</li>
                        </ul>
                    </li>
                </ul>
                
                <p><strong>3. Simple Models</strong></p>
                <ul>
                    <li>
                        <p><strong>Decision Tree</strong></p>
                        <ul>
                            <li><strong>Use Case</strong>: Supervised classification of network flows into “benign” or “malicious.”</li>
                            <li><strong>Strengths</strong>: Fast inference; human‐readable rules (e.g. “if TCP_FLAGS = SYN and byte_count &gt; 1000 then alert”).</li>
                            <li><strong>Limitations</strong>: Prone to overfitting; limited for complex feature interactions.</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>k-Nearest Neighbors (k-NN)</strong></p>
                        <ul>
                            <li><strong>Use Case</strong>: Unsupervised anomaly detection in OT sensor space—flag points distant from normal cluster.</li>
                            <li><strong>Strengths</strong>: No training phase; intuitive distance‐based detection.</li>
                            <li><strong>Limitations</strong>: High memory cost; slow at runtime for large datasets.</li>
                        </ul>
                    </li>
                </ul>
                
                <p><strong>4. Advanced Models</strong></p>
                <ul>
                    <li>
                        <p><strong>Deep Learning</strong></p>
                        <ul>
                            <li>
                                <p><strong>Autoencoders</strong></p>
                                <ul>
                                    <li><strong>Use Case</strong>: Train on normal IT traffic; high reconstruction error for malicious patterns (e.g. zero-day exploits).</li>
                                    <li><strong>Strengths</strong>: Learns nonlinear feature relationships; effective for unsupervised detection.</li>
                                    <li><strong>Limitations</strong>: Requires tuning; opaque “black-box” behavior.</li>
                                </ul>
                            </li>
                            <li>
                                <p><strong>LSTM Networks</strong></p>
                                <ul>
                                    <li><strong>Use Case</strong>: Model sequential ICS commands; detect anomalous control‐sequence deviations.</li>
                                    <li><strong>Strengths</strong>: Captures temporal dependencies; robust to noise.</li>
                                    <li><strong>Limitations</strong>: Computationally heavy; needs large training data.</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Ensemble Methods</strong></p>
                        <ul>
                            <li>
                                <p><strong>Random Forest</strong></p>
                                <ul>
                                    <li><strong>Use Case</strong>: Supervised detection of known Windows malware communications in NetFlow logs.</li>
                                    <li><strong>Strengths</strong>: High accuracy; handles mixed feature types; resistant to overfitting.</li>
                                    <li><strong>Limitations</strong>: Less interpretable than single trees; larger model size.</li>
                                </ul>
                            </li>
                            <li>
                                <p><strong>Gradient Boosting (e.g. XGBoost)</strong></p>
                                <ul>
                                    <li><strong>Use Case</strong>: Classify Modbus packets as normal or attack with labeled OT datasets.</li>
                                    <li><strong>Strengths</strong>: State-of-the-art accuracy; handles missing data.</li>
                                    <li><strong>Limitations</strong>: Training can be slow; sensitive to hyperparameters.</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>
                
                <p><strong>5. Technique Selection</strong></p>
                <table class="table table-bordered table-striped">
                    <thead>
                        <tr>
                            <th>Scenario</th>
                            <th>Recommended Technique</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Real-time, explainable IT alerts</td>
                            <td>Decision Tree</td>
                        </tr>
                        <tr>
                            <td>Resource-constrained OT anomaly detection</td>
                            <td>k-NN or simple clustering</td>
                        </tr>
                        <tr>
                            <td>Zero-day threat hunting in enterprise logs</td>
                            <td>Autoencoder</td>
                        </tr>
                        <tr>
                            <td>Sequence-based ICS attack detection</td>
                            <td>LSTM</td>
                        </tr>
                        <tr>
                            <td>Large labeled network datasets</td>
                            <td>Random Forest or XGBoost</td>
                        </tr>
                        <tr>
                            <td>Mixed feature types and high accuracy needs</td>
                            <td>Gradient Boosting ensemble</td>
                        </tr>
                    </tbody>
                </table>
            </article>

        </main>

        <script> copyright("all"); </script>

    </body>

</html>