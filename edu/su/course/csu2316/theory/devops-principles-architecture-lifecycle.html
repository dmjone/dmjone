<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
<!--<![endif]-->

<head>
    <script src="/js/edu_su_common.js"></script>
    <noscript>
        <style>
            html,
            body {
                margin: 0;
                overflow: hidden;
            }
        </style>
        <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
    </noscript>

    <title>DevOps Principles, Architecture & Lifecycle - CSU2316 - Shoolini U</title>
    <meta name="description" content="An in-depth look at DevOps principles, the infinite lifecycle loop, CI/CD pipelines, and the cultural shift required for modern software engineering.">

    <meta property="og:image" content="/logo.png">
    <meta property="og:type" content="article">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@divyamohan1993">
    <meta name="twitter:creator" content="@divyamohan1993">
    <meta name="twitter:image" content="/logo.png">

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />

    <meta name="author" content="Divya Mohan">
    <meta name="robots" content="index, follow">

    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                renderMathInElement(document.body, {
                    // customised options
                    // • auto-render specific keys, e.g.:
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\(', right: '\\)', display: false },
                        { left: '\\[', right: '\\]', display: true }
                    ],
                    // • rendering keys, e.g.:
                    throwOnError: false
                });
            });
        </script> -->

    <!-- <style>
            main ul {
                list-style-type: none;
                padding: 0;
                margin: 0;
            }

            main ul li {
                margin: 0;
                padding: 0;
            }
        </style> -->

    <!-- JSON-LD Structured Data for SEO -->
    <script type="application/ld+json">
        {
          "@context": "https://schema.org",
          "@type": "Course",
          "name": "DevOps Principles, Architecture & Lifecycle",
          "description": "An in-depth look at DevOps principles, the infinite lifecycle loop, CI/CD pipelines, and the cultural shift required for modern software engineering.",
          "url": "https://dmj.one/edu/su/course/csu2316/theory/devops-principles-architecture-lifecycle",
          "dateModified": "2025-12-16",
          "provider": [
            {
              "@type": "EducationalOrganization",
              "name": "dmj.one",
              "url": "https://dmj.one"
            },
            {
              "@type": "EducationalOrganization",
              "name": "Shoolini University",
              "url": "https://shooliniuniversity.com"
            }
          ],
          "offers": {
              "@type": "Offer",
              "category": "Education",
              "price": "0",
              "priceCurrency": "USD",
              "availability": "https://schema.org/InStock",
              "url": "https://dmj.one/edu/su/course/csu2316/theory/devops-principles-architecture-lifecycle"
          },
          "hasCourseInstance": {
              "@type": "CourseInstance",
              "name": "DevOps Principles, Architecture & Lifecycle",
              "description": "An in-depth look at DevOps principles, the infinite lifecycle loop, CI/CD pipelines, and the cultural shift required for modern software engineering.",
              "courseMode": "online",
              "startDate": "2025-12-16",
              "courseWorkload": "PT4H",               
              "instructor": [                
                {
                  "@type": "Person",
                  "name": "Divya Mohan",                                      
                  "url": "https://dmj.one/resume/",
                    "sameAs": [
                        "https://www.credly.com/users/divyamohan1993",
                        "https://www.linkedin.com/in/divyamohan1993/",
                        "https://hackerrank.com/divyamohan1993",
                        "https://www.coursera.org/learner/divyamohan1993"
                    ]
                }
              ],
              "url": "https://dmj.one/edu/su/course/csu2316/"
            }
        }
        </script>


</head>

<body>

    <script> header_author("dm"); </script>

    <main>
        <article class="agen-tableofcontents">
            <h2 class="text-center">
                DevOps Principles, Architecture & Lifecycle
            </h2>
            <div class="d-none contentdate">2025, Dec 16</div>
        </article>
        <div class="text-center mb-4" style="position:relative;width:100%;height:700px;overflow:hidden"><img src="../img/devops_lifecycle.webp" alt="DevOps Lifecycle Loop" style="position:absolute;top:50%;left:50%;width:100%;height:100%;object-fit:cover;transform:translate(-50%,-50%)"></div>

        <article>
            <h3>0. DevOps Principles, Architecture & Lifecycle</h3>
            <p>Modern software is never “finished.” It is continuously changed, scaled, patched, secured, and observed while users are actively using it. DevOps exists because traditional software engineering models failed to handle this reality. Studying DevOps is not about tools; it is about understanding how reliable systems are built, evolved, and kept alive under constant change.</p>
            <p>Every high-traffic application you use—banking apps, streaming platforms, cloud services—runs on DevOps principles. Without DevOps, rapid innovation collapses into outages, delays, and blame games. With DevOps, change becomes routine, safe, and measurable.</p>
        </article>

        <article>
            <h4>0.1 The Engineering Context: From Development to Operations</h4>
            <p>Software engineering historically split into two opposing worlds:</p>
            <ul>
                <li><strong>Development</strong>: rewarded for speed, new features, and experimentation.</li>
                <li><strong>Operations</strong>: rewarded for stability, uptime, and risk avoidance.</li>
            </ul>
            <p>This split created a structural conflict in incentives, not a human problem.</p>
        </article>

        <article>
            <h5>0.1.1 The Problem: The Wall of Confusion</h5>
            <p>The “Wall of Confusion” describes a system where developers push frequent changes while operations teams resist deployments to protect stability.</p>
            <ul>
                <li>Developers say: “It works on my machine.”</li>
                <li>Operations say: “Don’t touch production.”</li>
            </ul>
            <p>Failures here are systemic: manual deployments, undocumented configurations, environment drift, and late discovery of defects.</p>
            <div class="active-recall-custom-block">
                <details class="interactive-active-recall-card-dmj-su">
                    <summary class="alert-heading list-unstyled">
                        <i class="bi bi-mouse-fill"></i> What is the "Wall of Confusion" conflict fundamentally about?
                    </summary>
                    <hr>
                    <p class="mb-0 small"><strong>A:</strong> It's the conflict of incentives: Development wants <strong>speed/change</strong>, while Operations wants <strong>stability/risk avoidance</strong>.</p>
                </details>
            </div>
        </article>

        <article>
            <h5>0.1.2 The Solution: Automation + Collaboration</h5>
            <p>DevOps removes the wall by replacing manual handoffs with automated, repeatable systems.</p>
            <ul>
                <li><strong>Automation</strong>: Machines perform builds, tests, deployments, and recovery.</li>
                <li><strong>Collaboration</strong>: Shared ownership of code, infrastructure, and production behavior.</li>
            </ul>
            <p>The goal is not speed alone, but safe speed.</p>
        </article>

        <article>
            <h5>0.1.3 Core Engineering Goals</h5>
            <ul>
                <li><strong>High Availability</strong>: Systems remain accessible despite failures.</li>
                <li><strong>Scalability</strong>: Systems adapt to load without redesign.</li>
                <li><strong>Collaboration</strong>: One continuous engineering workflow from idea to production.</li>
            </ul>
        </article>

        <article>
            <h4>0.2 The DevOps Lifecycle (The “Infinity Loop”)</h4>
            <p>DevOps is modeled as an infinite loop because software delivery never ends. Each stage feeds data back into planning.</p>
            <pre class="mermaid text-center">
            graph LR
                Plan --> Code
                Code --> Build
                Build --> Test
                Test --> Release
                Release --> Deploy
                Deploy --> Operate
                Operate --> Monitor
                Monitor --> Plan
                style Plan fill:#f96
                style Deploy fill:#69f
            </pre>
        </article>

        <article>
            <h5>0.2.1 Plan & Code</h5>
            <p>Requirements are translated into source code and stored in a Version Control System (VCS).</p>
            <ul>
                <li>Code is the single source of truth.</li>
                <li>Every change is tracked, reviewable, and reversible.</li>
            </ul>
            <p>This establishes traceability between business intent and system behavior.</p>
        </article>

        <article>
            <h5>0.2.2 Build & Test (Continuous Integration)</h5>
            <p>Each code change triggers automated builds and tests.</p>
            <ul>
                <li>Compilation verifies structural correctness.</li>
                <li>Automated tests verify functional correctness.</li>
            </ul>
            <p>CI shifts defect detection from late production failures to early development feedback.</p>
            <div class="active-recall-custom-block">
                <details class="interactive-active-recall-card-dmj-su">
                    <summary class="alert-heading list-unstyled">
                        <i class="bi bi-mouse-fill"></i> How does Continuous Integration (CI) reduce the cost of defects?
                    </summary>
                    <hr>
                    <p class="mb-0 small"><strong>A:</strong> By detecting errors <strong>early (Shift-Left)</strong> in the development phase, where they are cheap to fix, rather than in production.</p>
                </details>
            </div>
        </article>

        <article>
            <h5>0.2.3 Role of Automation</h5>
            <p>Automation enforces consistency.</p>
            <ul>
                <li>Same process every time.</li>
                <li>No human memory dependency.</li>
                <li>Failures are reproducible and diagnosable.</li>
            </ul>
            <p>Quality becomes a property of the pipeline, not the individual.</p>
        </article>

        <article>
            <h5>0.2.4 Release & Deploy (Continuous Delivery / Deployment)</h5>
            <p>Validated artifacts are automatically promoted to environments.</p>
            <ul>
                <li><strong>Continuous Delivery</strong>: Always deployable.</li>
                <li><strong>Continuous Deployment</strong>: Automatically deployed.</li>
            </ul>
            <p>Releases become routine events instead of high-risk operations.</p>
        </article>

        <article>
            <h5>0.2.5 Operate & Monitor</h5>
            <p>Once live, the system must observe itself.</p>
            <ul>
                <li>Health checks detect failures.</li>
                <li>Metrics expose performance and capacity.</li>
                <li>Logs provide forensic evidence.</li>
            </ul>
            <p>Modern systems are designed to self-heal and auto-scale based on observed state.</p>
        </article>

        <article>
            <h4>0.3 DevOps Architecture: The Pipeline</h4>
            <p>The DevOps pipeline is an automated assembly line that converts code into a running system.</p>
        </article>

        <article>
            <h5>0.3.1 Source Code Management (SCM)</h5>
            <p>SCM stores and versions all artifacts: application code, configuration, infrastructure definitions.</p>
            <ul>
                <li>Enables parallel development.</li>
                <li>Provides auditability.</li>
                <li>Supports rollback and experimentation.</li>
            </ul>
        </article>

        <article>
            <h5>0.3.2 Continuous Integration Server</h5>
            <p>The CI server orchestrates automated validation.</p>
            <ul>
                <li>Triggers on code changes.</li>
                <li>Runs builds and tests.</li>
                <li>Produces deployable artifacts.</li>
            </ul>
            <p>This converts human intent into verified machine output.</p>
        </article>

        <article>
            <h5>0.3.3 Artifact Repository</h5>
            <p>Artifacts are immutable outputs of the pipeline.</p>
            <ul>
                <li>Same artifact promoted across environments.</li>
                <li>No rebuilding in production.</li>
            </ul>
            <p>This guarantees environment consistency.</p>
        </article>

        <article>
            <h5>0.3.4 Orchestration Cluster</h5>
            <p>The production environment is managed by orchestration systems.</p>
            <ul>
                <li><strong>Control Plane</strong>: Desired state management and scheduling.</li>
                <li><strong>Worker Nodes</strong>: Execute workloads.</li>
            </ul>
            <p>The cluster continuously reconciles actual state with declared intent.</p>
        </article>

        <article>
            <h4>0.4 Core Conceptual Pillars of DevOps</h4>
        </article>

        <article>
            <h5>0.4.1 Virtualization vs Containerization</h5>
            <p>Virtual machines virtualize hardware. Containers virtualize processes.</p>
            <ul>
                <li>VMs provide strong isolation with higher overhead.</li>
                <li>Containers provide lightweight, fast, portable execution.</li>
            </ul>
            <p>DevOps favors containers for scalability and deployment speed.</p>
            <div class="active-recall-custom-block">
                <details class="interactive-active-recall-card-dmj-su">
                    <summary class="alert-heading list-unstyled">
                        <i class="bi bi-mouse-fill"></i> What is the difference between what VMs and Containers virtualize?
                    </summary>
                    <hr>
                    <p class="mb-0 small"><strong>A:</strong> VMs virtualize the <strong>Hardware</strong> (allowing full OSs), while Containers virtualize the <strong>OS/Process</strong> (sharing the kernel). <a href="containerization">Read more on Containers</a>.</p>
                </details>
            </div>
        </article>

        <article>
            <h5>0.4.2 CI vs CD</h5>
            <p>CI ensures correctness. CD ensures availability.</p>
            <ul>
                <li>CI answers: “Is this change valid?”</li>
                <li>CD answers: “Can this change safely reach users?”</li>
            </ul>
            <p>Together, they form a continuous delivery system.</p>
        </article>

        <article>
            <h5>0.4.3 Declarative Configuration (Infrastructure as Code)</h5>
            <p>Systems are defined by desired state, not manual steps.</p>
            <p>The system continuously evaluates:</p>
            <p>$$Actual\ State \rightarrow Desired\ State$$</p>
            <p>Differences trigger automated reconciliation.</p>
        </article>

        <article>
            <h5>0.4.4 YAML Manifests and Desired State</h5>
            <p>YAML files describe what should exist, not how to create it.</p>
            <ul>
                <li>Version-controlled infrastructure.</li>
                <li>Predictable environments.</li>
                <li>Reproducible recovery.</li>
            </ul>
            <p>Failure becomes a temporary state, not a permanent condition.</p>
        </article>

        <article>
            <h5>0.4.5 Feedback as a First-Class Principle</h5>
            <p>DevOps treats feedback as an engineering input.</p>
            <ul>
                <li>User behavior informs planning.</li>
                <li>Metrics guide scaling decisions.</li>
                <li>Incidents improve system design.</li>
            </ul>
            <p>Learning is continuous and automated.</p>
        </article>

        <article>
            <h4>0.5 DevOps Culture Model (CALMS)</h4>
            <p>DevOps succeeds only when cultural and technical systems evolve together. The CALMS model captures the minimum cultural pillars required.</p>
            <ul>
                <li><strong>C - Culture</strong>: Shared ownership of failures and outcomes.</li>
                <li><strong>A - Automation</strong>: Remove manual, error-prone steps.</li>
                <li><strong>L - Lean</strong>: Small batches, fast feedback, waste elimination.</li>
                <li><strong>M - Measurement</strong>: Decisions driven by system metrics.</li>
                <li><strong>S - Sharing</strong>: Knowledge, tools, and responsibility are shared.</li>
            </ul>
            <p>Without CALMS, tools alone fail to deliver DevOps outcomes.</p>
        </article>

        <article>
            <h4>0.6 DevOps vs SRE (Site Reliability Engineering)</h4>
            <p>SRE is an engineering implementation of DevOps principles with reliability as a measurable objective.</p>
            <ul>
                <li><strong>DevOps</strong>: Cultural + process movement.</li>
                <li><strong>SRE</strong>: Engineering discipline applying software methods to operations.</li>
            </ul>
            <p>SRE introduces formal reliability budgets to balance innovation and stability.</p>
            <div class="active-recall-custom-block">
                <details class="interactive-active-recall-card-dmj-su">
                    <summary class="alert-heading list-unstyled">
                        <i class="bi bi-mouse-fill"></i> What distinguishes SRE from DevOps?
                    </summary>
                    <hr>
                    <p class="mb-0 small"><strong>A:</strong> DevOps is the <strong>philosophy/culture</strong>; SRE is the prescriptive <strong>implementation</strong> that uses engineering code to solve operations problems.</p>
                </details>
            </div>
        </article>

        <article>
            <h5>0.6.1 Service Level Concepts</h5>
            <ul>
                <li><strong>SLI</strong>: Service Level Indicator (measured metric).</li>
                <li><strong>SLO</strong>: Target reliability threshold.</li>
                <li><strong>SLA</strong>: Contractual reliability promise.</li>
            </ul>
            <p>Error budgets quantify how much failure is acceptable before slowing deployments.</p>
        </article>

        <article>
            <h4>0.7 DevSecOps (Security as a Pipeline Concern)</h4>
            <p>Security cannot be a post-deployment audit in fast-moving systems.</p>
            <ul>
                <li>Security checks integrated into CI pipelines.</li>
                <li>Secrets managed by systems, not developers.</li>
                <li>Vulnerabilities detected before production.</li>
            </ul>
            <p>This is known as <strong>shift-left security</strong>.</p>
        </article>

        <article>
            <h4>0.8 Deployment Strategies (Risk Reduction)</h4>
            <p>Modern DevOps minimizes blast radius during releases.</p>
        </article>

        <article>
            <h5>0.8.1 Blue–Green Deployment</h5>
            <p>Two identical environments exist.</p>
            <ul>
                <li>Blue: current production.</li>
                <li>Green: new version.</li>
            </ul>
            <p>Traffic switches instantly, enabling fast rollback.</p>
        </article>

        <article>
            <h5>0.8.2 Canary Deployment</h5>
            <p>New versions are exposed to a small subset of users.</p>
            <ul>
                <li>Metrics validate behavior.</li>
                <li>Gradual traffic increase.</li>
            </ul>
            <p>Failures are contained and observable.</p>
            <div class="container-fluid col-md-8 mt-4 mb-4">
                <figure class="figure w-100 text-center">
                    <img src="../img/deployment_strategies_comparison.webp" class="imgblacktowhite figure-img img-fluid rounded shadow-lg" alt="Blue-Green vs Canary Deployment Strategies">
                    <figcaption class="figure-caption">Visualizing Safe Deployment: Switching traffic instantly (Blue-Green) vs. gradual rollout (Canary).</figcaption>
                </figure>
            </div>
        </article>

        <article>
            <h4>0.9 Observability vs Monitoring</h4>
            <p>Monitoring answers known questions. Observability answers unknown questions.</p>
            <ul>
                <li><strong>Monitoring</strong>: Alerts on predefined thresholds.</li>
                <li><strong>Observability</strong>: Understand internal system state from outputs.</li>
            </ul>
            <p>Observability is built on metrics, logs, and traces as first-class data.</p>
        </article>

        <article>
            <h4>0.10 DevOps Performance Metrics (DORA)</h4>
            <p>DevOps effectiveness is measurable.</p>
            <ul>
                <li><strong>Deployment Frequency</strong></li>
                <li><strong>Lead Time for Changes</strong></li>
                <li><strong>Mean Time to Recovery (MTTR)</strong></li>
                <li><strong>Change Failure Rate</strong></li>
            </ul>
            <p>High-performing teams improve all four simultaneously.</p>
        </article>

        <article>
            <h4>0.11 DevOps System Thinking (Flow over Tasks)</h4>
            <p>DevOps optimizes the entire delivery system, not individual steps.</p>
            <ul>
                <li>Local optimization creates global bottlenecks.</li>
                <li>Fastest team is irrelevant if the pipeline is slow.</li>
            </ul>
            <p>Value is measured by end-to-end lead time from idea to production.</p>
        </article>

        <article>
            <h4>0.12 Immutable Infrastructure Principle</h4>
            <p>Servers are never modified after creation.</p>
            <ul>
                <li>Changes create new instances.</li>
                <li>Old instances are destroyed.</li>
            </ul>
            <p>This eliminates configuration drift and simplifies rollback.</p>
        </article>

        <article>
            <h4>0.13 Pets vs Cattle Model</h4>
            <p>Traditional systems treated servers as pets. DevOps treats them as cattle.</p>
            <ul>
                <li><strong>Pets</strong>: Named, manually cared for, irreplaceable.</li>
                <li><strong>Cattle</strong>: Numbered, automated, disposable.</li>
            </ul>
            <p>Scalability requires disposability.</p>
            <div class="active-recall-custom-block">
                <details class="interactive-active-recall-card-dmj-su">
                    <summary class="alert-heading list-unstyled">
                        <i class="bi bi-mouse-fill"></i> Why must cloud servers be treated as "Cattle" instead of "Pets"?
                    </summary>
                    <hr>
                    <p class="mb-0 small"><strong>A:</strong> Because <strong>Cattle</strong> are disposable and automated. If one fails, it is replaced, not nursed back to health, ensuring <strong>resilience at scale</strong>. <a href="amazon-ec2">See Auto Scaling in EC2</a>.</p>
                </details>
            </div>
        </article>

        <article>
            <h4>0.14 Shift-Left Testing Philosophy</h4>
            <p>Defects are cheapest when found early.</p>
            <ul>
                <li>Unit tests validate logic.</li>
                <li>Integration tests validate interactions.</li>
                <li>Production tests validate assumptions.</li>
            </ul>
            <p>Testing is a continuous activity, not a phase.</p>
        </article>

        <article>
            <h4>0.15 DevOps Toolchain vs DevOps Mindset</h4>
            <p>DevOps is not Jenkins, Docker, or Kubernetes.</p>
            <ul>
                <li>Tools enable DevOps.</li>
                <li>Mindset sustains DevOps.</li>
            </ul>
            <p>Without mindset change, tool adoption increases complexity without reliability.</p>
        </article>



    </main>

    <script> copyright("all"); </script>

</body>

</html>