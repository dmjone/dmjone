<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
<!--<![endif]-->

<head>
    <script src="/js/edu_su_common.js"></script>
    <noscript>
        <style>
            html,
            body {
                margin: 0;
                overflow: hidden;
            }
        </style>
        <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
    </noscript>

    <title>Virtualization - CSU2316 - Shoolini U</title>
    <meta name="description" content="Understanding Virtualization: how it abstracts hardware, enables cloud computing, and differs from containerization.">

    <meta property="og:image" content="/logo.png">
    <meta property="og:type" content="article">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@divyamohan1993">
    <meta name="twitter:creator" content="@divyamohan1993">
    <meta name="twitter:image" content="/logo.png">

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />

    <meta name="author" content="Divya Mohan">
    <meta name="robots" content="index, follow">

    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                renderMathInElement(document.body, {
                    // customised options
                    // • auto-render specific keys, e.g.:
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\(', right: '\\)', display: false },
                        { left: '\\[', right: '\\]', display: true }
                    ],
                    // • rendering keys, e.g.:
                    throwOnError: false
                });
            });
        </script> -->

    <!-- <style>
            main ul {
                list-style-type: none;
                padding: 0;
                margin: 0;
            }

            main ul li {
                margin: 0;
                padding: 0;
            }
        </style> -->

    <!-- JSON-LD Structured Data for SEO -->
    <script type="application/ld+json">
        {
          "@context": "https://schema.org",
          "@type": "Course",
          "name": "Virtualization",
          "description": "Understanding Virtualization: how it abstracts hardware, enables cloud computing, and differs from containerization.",
          "url": "https://dmj.one/edu/su/course/csu2316/theory/topic.html",
          "dateModified": "2025-12-16",
          "provider": [
            {
              "@type": "EducationalOrganization",
              "name": "dmj.one",
              "url": "https://dmj.one"
            },
            {
              "@type": "EducationalOrganization",
              "name": "Shoolini University",
              "url": "https://shooliniuniversity.com"
            }
          ],
          "offers": {
              "@type": "Offer",
              "category": "Education",
              "price": "0",
              "priceCurrency": "USD",
              "availability": "https://schema.org/InStock",
              "url": "https://dmj.one/edu/su/course/csu2316/theory/topic.html"
          },
          "hasCourseInstance": {
              "@type": "CourseInstance",
              "name": "Virtualization",
              "description": "Understanding Virtualization: how it abstracts hardware, enables cloud computing, and differs from containerization.",
              "courseMode": "online",
              "startDate": "2025-12-16",
              "courseWorkload": "PT4H",               
              "instructor": [                
                {
                  "@type": "Person",
                  "name": "Divya Mohan",                                      
                  "url": "https://dmj.one/resume/",
                    "sameAs": [
                        "https://www.credly.com/users/divyamohan1993",
                        "https://www.linkedin.com/in/divyamohan1993/",
                        "https://hackerrank.com/divyamohan1993",
                        "https://www.coursera.org/learner/divyamohan1993"
                    ]
                }
              ],
              "url": "https://dmj.one/edu/su/course/csu2316/"
            }
        }
        </script>


</head>

<body>

    <script> header_author("dm"); </script>

    <main>
        <article class="agen-tableofcontents">
            <h2 class="text-center">
                Virtualization
            </h2>
            <div class="d-none contentdate">2025, Dec 16</div>
        </article>
        <div class="text-center mb-4" style="position:relative;width:100%;height:250px;overflow:hidden"><img src="../img/virtualization_tech.webp" alt="Virtualization Technology" style="position:absolute;top:50%;left:50%;width:100%;height:100%;object-fit:cover;transform:translate(-50%,-50%)"></div>

        <article>
            <h3>5. Virtualization</h3>
            <p>
                Virtualization is the engineering technique of abstracting physical computing resources (CPU, memory, storage, network)
                into logical, software-defined resources so that multiple isolated systems can run simultaneously on the same hardware.
                The core idea is <strong>decoupling software from hardware</strong>.
            </p>
        </article>

        <article>
            <h4>5.1 Why Virtualization Exists (The Real Problem)</h4>
            <p>
                Before virtualization, one physical server typically ran one operating system and one application.
                This caused three fundamental inefficiencies:
            </p>
            <ul>
                <li><strong>Low hardware utilization</strong>: Servers ran at 10–20% CPU usage.</li>
                <li><strong>Tight coupling</strong>: Application failures affected the entire machine.</li>
                <li><strong>Slow provisioning</strong>: New servers took days or weeks.</li>
            </ul>
            <p>
                Virtualization solves this by slicing one physical machine into multiple isolated logical machines,
                each behaving as if it owns the hardware.
            </p>
            <div class="active-recall-custom-block">
                <details class="interactive-active-recall-card-dmj-su">
                    <summary class="alert-heading list-unstyled">
                        <i class="bi bi-mouse-fill"></i> What is the primary resource problem virtualization solves?
                    </summary>
                    <hr>
                    <p class="mb-0 small"><strong>A:</strong> <strong>Low hardware utilization</strong> (often 10-20%). It allows one physical server to do the work of many, maximizing return on investment.</p>
                </details>
            </div>
        </article>

        <article>
            <h4>5.2 Where Virtualization Is Used</h4>
            <ul>
                <li><strong>Data centers</strong>: Server consolidation and cost reduction.</li>
                <li><strong>Cloud computing</strong>: AWS EC2, Azure VMs, Google Compute Engine.</li>
                <li><strong>Testing & QA</strong>: Running multiple OS environments on one laptop.</li>
                <li><strong>Disaster recovery</strong>: VM snapshots and fast restoration.</li>
                <li><strong>Security labs</strong>: Malware analysis and isolated experimentation.</li>
            </ul>
        </article>

        <article>
            <h4>5.3 How Virtualization Works</h4>
            <p>
                A software layer called a <strong>hypervisor</strong> sits between hardware and operating systems.
                It intercepts hardware instructions and allocates resources dynamically.
            </p>
            <p>
                Each virtual machine believes it owns:
            </p>
            <ul>
                <li>Its own CPU</li>
                <li>Its own RAM</li>
                <li>Its own disk</li>
                <li>Its own network interface</li>
            </ul>
            <p>
                In reality, all these are time-shared and multiplexed by the hypervisor.
            </p>
            <div class="active-recall-custom-block">
                <details class="interactive-active-recall-card-dmj-su">
                    <summary class="alert-heading list-unstyled">
                        <i class="bi bi-mouse-fill"></i> Does a Guest VM "know" it is sharing hardware?
                    </summary>
                    <hr>
                    <p class="mb-0 small"><strong>A:</strong> <strong>Generally no</strong>. The hypervisor creates an illusion where the VM believes it has exclusive access to a dedicated CPU, RAM, and Disk.</p>
                </details>
            </div>
        </article>

        <article>
            <h4>5.4 Virtualization Architecture</h4>
            <p>
                Canonical architecture:
            </p>
            <p><strong>Hardware → Hypervisor → Virtual Machines → Guest OS → Applications</strong></p>
            <p>
                The hypervisor performs:
            </p>
            <ul>
                <li><strong>CPU scheduling</strong>: Context switching between VMs</li>
                <li><strong>Memory virtualization</strong>: Guest virtual memory → host physical memory</li>
                <li><strong>I/O virtualization</strong>: Disk and network abstraction</li>
            </ul>
        </article>

        <article>
            <h4>5.5 Key Concepts</h4>
            <ul>
                <li><strong>Isolation</strong>: Failure in one VM does not affect others.</li>
                <li><strong>Encapsulation</strong>: A VM is a set of files (easy backup & migration).</li>
                <li><strong>Hardware independence</strong>: VMs can move across physical hosts.</li>
                <li><strong>Resource pooling</strong>: Hardware resources are centrally managed.</li>
            </ul>
        </article>

        <article>
            <h4>5.6 Types of Virtualization</h4>
            <ul>
                <li><strong>Server Virtualization</strong>: Multiple server OS on one physical server.</li>
                <li><strong>Storage Virtualization</strong>: Abstracting multiple disks into logical volumes.</li>
                <li><strong>Network Virtualization</strong>: Virtual switches, routers, VLANs.</li>
                <li><strong>Desktop Virtualization</strong>: Virtual desktops delivered remotely.</li>
            </ul>
        </article>

        <article>
            <h4>5.7 Virtual Machine (VM)</h4>
            <p>
                A Virtual Machine is a <strong>software-defined computer</strong> that runs a full operating system
                on virtualized hardware.
            </p>
        </article>

        <article>
            <h5>5.7.1 VM Architecture</h5>
            <p>
                <strong>Hardware → Hypervisor → VM → Guest OS → Applications</strong>
            </p>
            <p>
                Each VM includes:
            </p>
            <ul>
                <li>Virtual CPU (vCPU)</li>
                <li>Virtual RAM</li>
                <li>Virtual Disk (VMDK, VHD)</li>
                <li>Virtual NIC</li>
            </ul>
        </article>

        <article>
            <h5>5.7.2 VM Characteristics</h5>
            <ul>
                <li><strong>Heavyweight</strong>: Includes a full guest OS.</li>
                <li><strong>Strong isolation</strong>: Hardware-level separation.</li>
                <li><strong>Slower startup</strong>: OS boot required.</li>
                <li><strong>High resource usage</strong>: OS duplication per VM.</li>
            </ul>
        </article>

        <article>
            <h4>5.8 Hypervisor</h4>
            <p>
                A hypervisor is the control plane of virtualization.
                It creates, runs, monitors, and destroys virtual machines.
            </p>
        </article>

        <article>
            <h5>5.8.1 Type 1 Hypervisor (Bare Metal)</h5>
            <p>
                Runs directly on physical hardware without a host OS.
            </p>
            <ul>
                <li><strong>Examples</strong>: VMware ESXi, Xen, Microsoft Hyper-V (Server)</li>
                <li><strong>Performance</strong>: Near-native</li>
                <li><strong>Use case</strong>: Data centers, cloud platforms</li>
            </ul>
            <p>
                Architecture:
            </p>
            <p><strong>Hardware → Hypervisor → VMs</strong></p>
            <div class="active-recall-custom-block">
                <details class="interactive-active-recall-card-dmj-su">
                    <summary class="alert-heading list-unstyled">
                        <i class="bi bi-mouse-fill"></i> Why are Type 1 (Bare Metal) hypervisors preferred for data centers?
                    </summary>
                    <hr>
                    <p class="mb-0 small"><strong>A:</strong> Because they run <strong>directly on hardware</strong> without a heavy host OS, offering near-native performance and a smaller security attack surface.</p>
                </details>
            </div>
        </article>

        <article>
            <h5>5.8.2 Type 2 Hypervisor (Hosted)</h5>
            <p>
                Runs as an application on top of a host operating system.
            </p>
            <ul>
                <li><strong>Examples</strong>: VirtualBox, VMware Workstation</li>
                <li><strong>Performance</strong>: Lower due to host OS overhead</li>
                <li><strong>Use case</strong>: Development, learning, testing</li>
            </ul>
            <p>
                Architecture:
            </p>
            <p><strong>Hardware → Host OS → Hypervisor → VMs</strong></p>
        </article>

        <article>
            <h4>5.9 Type 1 vs Type 2 (Conceptual Difference)</h4>
            <pre class="mermaid text-center">
            graph TD
                subgraph Type1 [Type 1: Bare Metal]
                HW1[Hardware] --> Hyp1[Hypervisor]
                Hyp1 --> VM1[VM]
                end
                subgraph Type2 [Type 2: Hosted]
                HW2[Hardware] --> OS[Host OS]
                OS --> Hyp2[Hypervisor]
                Hyp2 --> VM2[VM]
                end
                style Type1 fill:#dcedc8
                style Type2 fill:#ffccbc
            </pre>
            <div class="table-responsive">
                <table class="table table-bordered table-striped">
                    <thead>
                        <tr>
                            <th>Aspect</th>
                            <th>Type 1</th>
                            <th>Type 2</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Execution layer</td>
                            <td>Direct on hardware</td>
                            <td>On host OS</td>
                        </tr>
                        <tr>
                            <td>Performance</td>
                            <td>High</td>
                            <td>Moderate</td>
                        </tr>
                        <tr>
                            <td>Security</td>
                            <td>Stronger</td>
                            <td>Depends on host OS</td>
                        </tr>
                        <tr>
                            <td>Typical use</td>
                            <td>Production</td>
                            <td>Development</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </article>

        <article>
            <h4>5.10 Virtualization vs Physical Deployment</h4>
            <p>
                Virtualization transforms hardware from a <strong>scarce, rigid asset</strong>
                into a <strong>flexible, software-controlled resource</strong>.
                This abstraction is the foundational enabler of modern cloud, DevOps,
                and scalable infrastructure.
            </p>
        </article>

        <article>
            <h4>5.11 Full Virtualization vs Para-Virtualization</h4>
            <p>
                This distinction explains <strong>how the guest OS interacts with hardware</strong>, which directly impacts performance.
            </p>
            <ul>
                <li><strong>Full Virtualization</strong>: Guest OS is unaware it is virtualized; hardware is fully emulated.</li>
                <li><strong>Para-Virtualization</strong>: Guest OS is virtualization-aware and cooperates with hypervisor.</li>
            </ul>
            <p>
                Trade-off:
            </p>
            <ul>
                <li>Full virtualization → Better compatibility</li>
                <li>Para-virtualization → Better performance</li>
            </ul>
        </article>

        <article>
            <h4>5.12 Hardware-Assisted Virtualization</h4>
            <p>
                Modern CPUs provide native virtualization support to reduce hypervisor overhead.
            </p>
            <ul>
                <li><strong>Intel VT-x</strong>, <strong>AMD-V</strong>: CPU privilege modes for VMs</li>
                <li><strong>IOMMU</strong>: Safe device passthrough</li>
            </ul>
            <p>
                Without hardware support, virtualization relies on binary translation, which is slower.
            </p>
        </article>

        <article>
            <h4>5.13 VM Lifecycle (Operational Perspective)</h4>
            <p>
                Understanding VM lifecycle is essential for real-world infrastructure management.
            </p>
            <ul>
                <li>Create → Allocate virtual resources</li>
                <li>Boot → Guest OS loads</li>
                <li>Run → Application execution</li>
                <li>Suspend → State saved to disk</li>
                <li>Snapshot → Point-in-time capture</li>
                <li>Destroy → Resource deallocation</li>
            </ul>
        </article>

        <article>
            <h4>5.14 Snapshots and Cloning</h4>
            <p>
                Snapshots capture the <strong>entire VM state</strong> (disk + memory) at a moment in time.
            </p>
            <ul>
                <li>Used for rollback, testing, and backups</li>
                <li>Not a replacement for full backups</li>
            </ul>
            <p>
                Cloning creates independent VM copies from a base image, enabling rapid scaling.
            </p>
        </article>

        <article>
            <h4>5.15 VM Performance Overhead</h4>
            <p>
                Virtualization introduces overhead due to abstraction layers.
            </p>
            <ul>
                <li>CPU trap-and-emulate</li>
                <li>Memory address translation</li>
                <li>I/O virtualization latency</li>
            </ul>
            <p>
                Modern hypervisors + hardware support reduce this overhead to near-native levels.
            </p>
        </article>

        <article>
            <h4>5.16 Virtualization as Foundation for Cloud</h4>
            <p>
                Cloud services are built on large-scale virtualization:
            </p>
            <ul>
                <li>VM = basic cloud compute unit</li>
                <li>Elastic provisioning via VM templates</li>
                <li>Multi-tenancy through isolation</li>
            </ul>
            <p>
                This concept directly connects virtualization → IaaS → DevOps automation.
            </p>
            <div class="active-recall-custom-block">
                <details class="interactive-active-recall-card-dmj-su">
                    <summary class="alert-heading list-unstyled">
                        <i class="bi bi-mouse-fill"></i> What is the relationship between Virtualization and Cloud Computing?
                    </summary>
                    <hr>
                    <p class="mb-0 small"><strong>A:</strong> Virtualization is the <strong>underlying technology</strong> (the "how"), while Cloud is the <strong>service model</strong> (the "consumption"). Cloud is built on top of massive scale virtualization. <a href="amazon-ec2.html">See EC2</a>.</p>
                </details>
            </div>
        </article>

        <article>
            <h4>5.17 Virtualization Security Model</h4>
            <p>
                Virtualization changes the security boundary from <strong>process-level</strong> to <strong>machine-level</strong>.
                Each VM acts as a separate security domain.
            </p>
            <ul>
                <li><strong>Isolation guarantee</strong>: Compromise of one VM should not affect others</li>
                <li><strong>Attack surface</strong>: Hypervisor becomes a high-value target</li>
                <li><strong>VM escape</strong>: Rare but critical vulnerability where guest breaks isolation</li>
            </ul>
            <p>
                Security responsibility shifts to:
            </p>
            <ul>
                <li>Hypervisor hardening</li>
                <li>Minimal VM images</li>
                <li>Strict resource access controls</li>
            </ul>
        </article>

        <article>
            <h4>5.18 VM Images and Templates</h4>
            <p>
                VMs are instantiated from <strong>images</strong>, which are preconfigured OS + baseline software.
            </p>
            <ul>
                <li>Ensures consistency across environments</li>
                <li>Enables rapid provisioning</li>
                <li>Acts as immutable infrastructure units</li>
            </ul>
            <p>
                In DevOps, images are treated as <strong>versioned artifacts</strong>, similar to binaries.
            </p>
        </article>

        <article>
            <h4>5.19 Virtualization vs Containerization</h4>
            <p>
                This boundary defines modern infrastructure choices.
            </p>
            <div class="table-responsive">
                <table class="table table-bordered table-striped">
                    <thead>
                        <tr>
                            <th>Criterion</th>
                            <th>Virtual Machines</th>
                            <th>Containers</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Isolation level</td>
                            <td>Hardware-level</td>
                            <td>OS-level</td>
                        </tr>
                        <tr>
                            <td>Startup time</td>
                            <td>Seconds–minutes</td>
                            <td>Milliseconds–seconds</td>
                        </tr>
                        <tr>
                            <td>OS flexibility</td>
                            <td>Any OS</td>
                            <td>Same kernel</td>
                        </tr>
                        <tr>
                            <td>Use case</td>
                            <td>Strong isolation, legacy systems</td>
                            <td>Microservices, CI/CD</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <p>
                Containers optimize <strong>speed and density</strong>; VMs optimize <strong>isolation and compatibility</strong>.
            </p>
            <div class="active-recall-custom-block">
                <details class="interactive-active-recall-card-dmj-su">
                    <summary class="alert-heading list-unstyled">
                        <i class="bi bi-mouse-fill"></i> If containers are light and fast, why do we still use VMs?
                    </summary>
                    <hr>
                    <p class="mb-0 small"><strong>A:</strong> For <strong>stronger isolation</strong> (security boundaries) and to run <strong>different OS kernels</strong> (e.g., running Windows on a Linux server). <a href="containerization.html">Compare with Containers</a>.</p>
                </details>
            </div>
        </article>

        <article>
            <h4>5.20 Why Virtualization Still Matters (Even with Containers)</h4>
            <p>
                Containers do not replace virtualization — they run <strong>on top of it</strong>.
            </p>
            <ul>
                <li>Cloud nodes are VMs</li>
                <li>Kubernetes workers are VMs</li>
                <li>Security boundaries rely on VM isolation</li>
            </ul>
            <p>
                Virtualization is the <strong>substrate</strong>; containers are the <strong>execution model</strong>.
            </p>
        </article>



    </main>

    <script> copyright("all"); </script>

</body>

</html>