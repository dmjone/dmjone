<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
<!--<![endif]-->

<head>
    <script src="/js/edu_su_common.js"></script>
    <noscript>
        <style>
            html,
            body {
                margin: 0;
                overflow: hidden;
            }
        </style>
        <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
    </noscript>

    <title>Containerization - CSU2316 - Shoolini U</title>
    <meta name="description" content="An in-depth guide to Containerization, explaining how it works, its advantages over virtualization, and its role in modern DevOps and microservices.">

    <meta property="og:image" content="/logo.png">
    <meta property="og:type" content="article">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@divyamohan1993">
    <meta name="twitter:creator" content="@divyamohan1993">
    <meta name="twitter:image" content="/logo.png">

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />

    <meta name="author" content="Divya Mohan">
    <meta name="robots" content="index, follow">

    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                renderMathInElement(document.body, {
                    // customised options
                    // • auto-render specific keys, e.g.:
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\(', right: '\\)', display: false },
                        { left: '\\[', right: '\\]', display: true }
                    ],
                    // • rendering keys, e.g.:
                    throwOnError: false
                });
            });
        </script> -->

    <!-- <style>
            main ul {
                list-style-type: none;
                padding: 0;
                margin: 0;
            }

            main ul li {
                margin: 0;
                padding: 0;
            }
        </style> -->

    <!-- JSON-LD Structured Data for SEO -->
    <script type="application/ld+json">
        {
          "@context": "https://schema.org",
          "@type": "Course",
          "name": "Containerization",
          "description": "An in-depth guide to Containerization, explaining how it works, its advantages over virtualization, and its role in modern DevOps and microservices.",
          "url": "https://dmj.one/edu/su/course/csu2316/theory/containerization",
          "dateModified": "2025-12-16",
          "provider": [
            {
              "@type": "EducationalOrganization",
              "name": "dmj.one",
              "url": "https://dmj.one"
            },
            {
              "@type": "EducationalOrganization",
              "name": "Shoolini University",
              "url": "https://shooliniuniversity.com"
            }
          ],
          "offers": {
              "@type": "Offer",
              "category": "Education",
              "price": "0",
              "priceCurrency": "USD",
              "availability": "https://schema.org/InStock",
              "url": "https://dmj.one/edu/su/course/csu2316/theory/containerization"
          },
          "hasCourseInstance": {
              "@type": "CourseInstance",
              "name": "Containerization",
              "description": "An in-depth guide to Containerization, explaining how it works, its advantages over virtualization, and its role in modern DevOps and microservices.",
              "courseMode": "online",
              "startDate": "2025-12-16",
              "courseWorkload": "PT4H",               
              "instructor": [                
                {
                  "@type": "Person",
                  "name": "Divya Mohan",                                      
                  "url": "https://dmj.one/resume/",
                    "sameAs": [
                        "https://www.credly.com/users/divyamohan1993",
                        "https://www.linkedin.com/in/divyamohan1993/",
                        "https://hackerrank.com/divyamohan1993",
                        "https://www.coursera.org/learner/divyamohan1993"
                    ]
                }
              ],
              "url": "https://dmj.one/edu/su/course/csu2316/"
            }
        }
        </script>


</head>

<body>

    <script> header_author("dm"); </script>

    <main>
        <article class="agen-tableofcontents">
            <h2 class="text-center">
                Containerization
            </h2>
            <div class="d-none contentdate">2025, Dec 16</div>
        </article>
        <div class="text-center mb-4" style="position:relative;width:100%;height:250px;overflow:hidden"><img src="../img/containerization_tech.webp" alt="Containerization Concepts" style="position:absolute;top:50%;left:50%;width:100%;height:100%;object-fit:cover;transform:translate(-50%,-50%)"></div>

        <article>
            <h3>6. Containerization</h3>
            <p>Containerization is an OS-level virtualization technique where an application is packaged together with its runtime, libraries, and dependencies, and executed as an isolated process on a shared operating system kernel.</p>
            <p>Core idea: instead of virtualizing hardware (like VMs), containerization virtualizes the operating system environment.</p>
        </article>

        <article>
            <h4>6.1 Why Containerization is Used</h4>
            <p>Traditional deployment tightly couples applications to specific machines, OS versions, and configurations, causing the classic problem: “it works on my machine.” Containerization eliminates this mismatch.</p>
            <ul>
                <li><strong>Consistency</strong>: Same container image runs identically across laptop, server, cloud.</li>
                <li><strong>Speed</strong>: Containers start in seconds because no guest OS is booted.</li>
                <li><strong>Resource efficiency</strong>: Multiple containers share one kernel, reducing memory and CPU overhead.</li>
                <li><strong>DevOps enablement</strong>: Enables CI/CD, microservices, and immutable infrastructure.</li>
            </ul>
        </article>

        <article>
            <h4>6.2 Where Containerization is Used</h4>
            <p>Containerization is used wherever applications must be portable, scalable, and rapidly deployable.</p>
            <ul>
                <li><strong>Microservices architectures</strong>: Each service runs in its own container.</li>
                <li><strong>Cloud-native applications</strong>: Kubernetes-based platforms.</li>
                <li><strong>CI/CD pipelines</strong>: Build, test, and deploy in isolated environments.</li>
                <li><strong>Edge & hybrid environments</strong>: Same container runs across heterogeneous infrastructure.</li>
            </ul>
        </article>

        <article>
            <h4>6.3 How Containerization Works</h4>
            <p>A container is not a mini virtual machine. It is a controlled process running on the host OS.</p>
            <p>Key OS primitives enable containers:</p>
            <ul>
                <li><strong>Namespaces</strong>: Isolate process ID, network, filesystem, users.</li>
                <li><strong>Control Groups (cgroups)</strong>: Limit and account CPU, memory, I/O.</li>
                <li><strong>Union filesystems</strong>: Layered, copy-on-write file systems for images.</li>
            </ul>
            <p>Result: processes believe they are alone, while actually sharing the same kernel.</p>
            <div class="active-recall-custom-block">
                <details class="interactive-active-recall-card-dmj-su">
                    <summary class="alert-heading list-unstyled">
                        <i class="bi bi-mouse-fill"></i> Do containers use a Hypervisor?
                    </summary>
                    <hr>
                    <p class="mb-0 small"><strong>A:</strong> <strong>No</strong>. They run as isolated processes directly on the Host OS kernel, utilizing native Linux features like <strong>Namespaces</strong> and <strong>Cgroups</strong>.</p>
                </details>
            </div>
        </article>

        <article>
            <h4>6.4 Containers: Definition & Architecture</h4>
            <p>A container is a running instance of a container image, executed by a container runtime using the host OS kernel.</p>
            <p>Architecture flow:</p>
            <p><strong>Hardware → Host OS → Container Engine → Container → Application</strong></p>
            <ul>
                <li><strong>Host OS</strong>: Provides kernel (Linux typically).</li>
                <li><strong>Container Engine</strong>: Manages images, networking, storage (e.g., Docker Engine).</li>
                <li><strong>Container</strong>: Isolated process group.</li>
                <li><strong>Application</strong>: Code + dependencies inside container.</li>
            </ul>
        </article>

        <article>
            <h5>6.4.1 Container Image vs Container</h5>
            <p>An image is a read-only blueprint. A container is a live execution of that blueprint.</p>
            <ul>
                <li><strong>Image</strong>: Static, layered filesystem.</li>
                <li><strong>Container</strong>: Dynamic, running process with writable layer.</li>
            </ul>
        </article>

        <article>
            <h4>6.5 VM vs Container</h4>
            <pre class="mermaid text-center">
            graph TD
                subgraph VM [Virtual Machine]
                H1[Hardware] --> OS1[Host OS]
                OS1 --> Hyp[Hypervisor]
                Hyp --> G1[Guest OS]
                G1 --> B1[Bins/Libs]
                B1 --> A1[App]
                end
                subgraph Cont [Container]
                H2[Hardware] --> OS2[Host OS]
                OS2 --> Eng[Container Engine]
                Eng --> B2[Bins/Libs]
                B2 --> A2[App]
                end
                style VM fill:#f9f9f9,stroke:#333
                style Cont fill:#e6f3ff,stroke:#333
            </pre>
            <div class="table-responsive">
                <table class="table table-bordered table-striped">
                    <thead>
                        <tr>
                            <th>Aspect</th>
                            <th>Virtual Machine</th>
                            <th>Container</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Operating System</td>
                            <td>Each VM has its own OS</td>
                            <td>Shares host OS kernel</td>
                        </tr>
                        <tr>
                            <td>Size</td>
                            <td>GBs</td>
                            <td>MBs</td>
                        </tr>
                        <tr>
                            <td>Boot Time</td>
                            <td>Minutes</td>
                            <td>Seconds</td>
                        </tr>
                        <tr>
                            <td>Isolation</td>
                            <td>Strong (hardware-level)</td>
                            <td>Process-level</td>
                        </tr>
                        <tr>
                            <td>Performance</td>
                            <td>Lower (hypervisor overhead)</td>
                            <td>Near-native</td>
                        </tr>
                        <tr>
                            <td>Use Case</td>
                            <td>Different OS per workload</td>
                            <td>Microservices, CI/CD</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </article>

        <article>
            <h4>6.6 Advantages of Containers</h4>
            <ul>
                <li><strong>Lightweight</strong>: No guest OS overhead.</li>
                <li><strong>Fast startup</strong>: Ideal for auto-scaling.</li>
                <li><strong>High density</strong>: More workloads per host.</li>
                <li><strong>Portability</strong>: Build once, run anywhere.</li>
            </ul>
        </article>

        <article>
            <h4>6.7 Limitations of Containers</h4>
            <ul>
                <li><strong>Weaker isolation</strong>: Kernel is shared; kernel vulnerabilities affect all containers.</li>
                <li><strong>OS dependency</strong>: Linux containers require Linux kernel.</li>
                <li><strong>State management</strong>: Persistent data needs external volumes.</li>
                <li><strong>Security complexity</strong>: Requires careful runtime hardening.</li>
            </ul>
        </article>

        <article>
            <h4>6.8 Container Runtime & Ecosystem</h4>
            <p>Understanding containers is incomplete without knowing what actually runs them and how they are managed at scale.</p>
            <ul>
                <li><strong>Container Runtime</strong>: Low-level software that executes containers using kernel features.</li>
                <li><strong>High-level Runtime</strong>: Developer-facing tools.</li>
            </ul>
            <div class="table-responsive">
                <table class="table table-bordered table-striped">
                    <thead>
                        <tr>
                            <th>Layer</th>
                            <th>Examples</th>
                            <th>Role</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Low-level Runtime</td>
                            <td>runc, crun</td>
                            <td>Creates namespaces, cgroups, starts process</td>
                        </tr>
                        <tr>
                            <td>High-level Runtime</td>
                            <td>Docker, containerd, CRI-O</td>
                            <td>Image management, networking, volumes</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="active-recall-custom-block">
                <details class="interactive-active-recall-card-dmj-su">
                    <summary class="alert-heading list-unstyled">
                        <i class="bi bi-mouse-fill"></i> What is the difference between Docker and a low-level runtime like <code>runc</code>?
                    </summary>
                    <hr>
                    <p class="mb-0 small"><strong>A:</strong> Docker is a <strong>high-level tool</strong> for managing images and networks; <code>runc</code> is the <strong>low-level tool</strong> that actually interacts with the kernel to create the process.</p>
                </details>
            </div>
        </article>

        <article>
            <h4>6.9 Container Orchestration</h4>
            <p>Running containers manually does not scale. Orchestration automates deployment, scaling, and healing.</p>
            <ul>
                <li><strong>Kubernetes</strong>: Industry-standard container orchestrator.</li>
                <li><strong>Core responsibilities</strong>:
                    <ul>
                        <li>Scheduling containers on nodes</li>
                        <li>Auto-scaling based on load</li>
                        <li>Self-healing (restart, reschedule)</li>
                        <li>Service discovery & load balancing</li>
                    </ul>
                </li>
            </ul>
            <p>Mental model: Kubernetes manages containers the way an OS manages processes.</p>
        </article>

        <article>
            <h4>6.10 Containers in DevOps Lifecycle</h4>
            <p>Containers act as the execution unit across the entire DevOps pipeline.</p>
            <ul>
                <li><strong>Build</strong>: Application packaged into immutable image.</li>
                <li><strong>Test</strong>: Same image tested in isolated container.</li>
                <li><strong>Deploy</strong>: Same image promoted to staging/production.</li>
                <li><strong>Operate</strong>: Monitored, scaled, replaced—not modified.</li>
            </ul>
            <p>This enforces <strong>immutability</strong>: never change a running container, replace it.</p>
        </article>

        <article>
            <h4>6.11 Security Boundary Understanding</h4>
            <p>Containers are not security boundaries like VMs.</p>
            <ul>
                <li><strong>Shared kernel risk</strong>: Kernel exploit compromises all containers.</li>
                <li><strong>Mitigations</strong>:
                    <ul>
                        <li>Minimal base images</li>
                        <li>Non-root containers</li>
                        <li>Read-only filesystems</li>
                        <li>Runtime security policies</li>
                    </ul>
                </li>
            </ul>
            <p>Key distinction: containers improve deployment isolation, not absolute security isolation.</p>
            <div class="active-recall-custom-block">
                <details class="interactive-active-recall-card-dmj-su">
                    <summary class="alert-heading list-unstyled">
                        <i class="bi bi-mouse-fill"></i> Why is a shared kernel a security risk for containers?
                    </summary>
                    <hr>
                    <p class="mb-0 small"><strong>A:</strong> If an attacker finds a vulnerability in the <strong>shared Kernel</strong>, they can potentially "escape" the container and compromise the entire host (unlike VM isolation).</p>
                </details>
            </div>
        </article>

        <article>
            <h4>6.12 Container Networking Basics</h4>
            <p>Containers must communicate with each other and the outside world; networking is abstracted but fundamental.</p>
            <ul>
                <li><strong>Bridge Network</strong>: Default local virtual network on a host.</li>
                <li><strong>Port Mapping</strong>: Host port → container port mapping.</li>
                <li><strong>Overlay Network</strong>: Multi-host container communication (used by Kubernetes).</li>
            </ul>
            <p>Mental model: each container has its own virtual network stack, connected via software-defined networking.</p>
        </article>

        <article>
            <h4>6.13 Container Storage & Persistence</h4>
            <p>Containers are ephemeral; data must live outside the container lifecycle.</p>
            <ul>
                <li><strong>Ephemeral layer</strong>: Writable layer deleted when container stops.</li>
                <li><strong>Volumes</strong>: Persistent storage managed by container engine.</li>
                <li><strong>Bind mounts</strong>: Direct host directory mapping.</li>
            </ul>
            <div class="container-fluid col-md-8 mt-4 mb-4">
                <figure class="figure w-100 text-center">
                    <img src="../img/container_storage_types.webp" class="figure-img img-fluid rounded shadow-lg" alt="Docker Storage Options Comparison">
                    <figcaption class="figure-caption">Comparison of Container Storage: Ephemeral vs Volumes vs Bind Mounts.</figcaption>
                </figure>
            </div>
            <p>Rule: containers should be stateless; state belongs to volumes or external services.</p>
            <div class="active-recall-custom-block">
                <details class="interactive-active-recall-card-dmj-su">
                    <summary class="alert-heading list-unstyled">
                        <i class="bi bi-mouse-fill"></i> What happens to data inside a container when it is deleted?
                    </summary>
                    <hr>
                    <p class="mb-0 small"><strong>A:</strong> It is <strong>lost forever</strong> (ephemeral) unless it was explicitly stored in an external <strong>Volume</strong> or Bind Mount.</p>
                </details>
            </div>
        </article>

        <article>
            <h4>6.14 Containers vs Serverless</h4>
            <p>Students often confuse containerization with serverless computing.</p>
            <div class="table-responsive">
                <table class="table table-bordered table-striped">
                    <thead>
                        <tr>
                            <th>Aspect</th>
                            <th>Containers</th>
                            <th>Serverless</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Control</td>
                            <td>Full runtime control</td>
                            <td>No server/runtime control</td>
                        </tr>
                        <tr>
                            <td>Execution</td>
                            <td>Always running</td>
                            <td>Event-driven</td>
                        </tr>
                        <tr>
                            <td>Use Case</td>
                            <td>Long-running services</td>
                            <td>Short-lived functions</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <p>Containers are the foundation; serverless often runs on containers internally.</p>
        </article>

        <article>
            <h4>6.15 When NOT to Use Containers</h4>
            <ul>
                <li>Strong OS-level isolation is mandatory → prefer VMs</li>
                <li>Single-purpose legacy monolith with no scaling need</li>
                <li>Strict kernel compliance requirements</li>
            </ul>
            <p>This clarifies containers as an engineering trade-off, not a universal solution.</p>
        </article>


    </main>

    <script> copyright("all"); </script>

</body>

</html>