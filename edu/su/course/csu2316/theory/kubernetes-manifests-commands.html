<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
<!--<![endif]-->

<head>
    <script src="/js/edu_su_common.js"></script>
    <noscript>
        <style>
            html,
            body {
                margin: 0;
                overflow: hidden;
            }
        </style>
        <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
    </noscript>

    <title>Kubernetes Manifests & Commands - CSU2316 - Shoolini U</title>
    <meta name="description" content="Master Kubernetes Manifest Files and Kubectl commands. Learn to define declarative infrastructure using YAML.">

    <meta property="og:image" content="/logo.png">
    <meta property="og:type" content="article">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@divyamohan1993">
    <meta name="twitter:creator" content="@divyamohan1993">
    <meta name="twitter:image" content="/logo.png">

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />

    <meta name="author" content="Divya Mohan">
    <meta name="robots" content="index, follow">

    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                renderMathInElement(document.body, {
                    // customised options
                    // • auto-render specific keys, e.g.:
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\(', right: '\\)', display: false },
                        { left: '\\[', right: '\\]', display: true }
                    ],
                    // • rendering keys, e.g.:
                    throwOnError: false
                });
            });
        </script> -->

    <!-- <style>
            main ul {
                list-style-type: none;
                padding: 0;
                margin: 0;
            }

            main ul li {
                margin: 0;
                padding: 0;
            }
        </style> -->

    <!-- JSON-LD Structured Data for SEO -->
    <script type="application/ld+json">
        {
          "@context": "https://schema.org",
          "@type": "Course",
          "name": "Kubernetes Manifests & Commands",
          "description": "Master Kubernetes Manifest Files and Kubectl commands. Learn to define declarative infrastructure using YAML.",
          "url": "https://dmj.one/edu/su/course/csu2316/theory/kubernetes-manifests-commands",
          "dateModified": "2025-12-16",
          "provider": [
            {
              "@type": "EducationalOrganization",
              "name": "dmj.one",
              "url": "https://dmj.one"
            },
            {
              "@type": "EducationalOrganization",
              "name": "Shoolini University",
              "url": "https://shooliniuniversity.com"
            }
          ],
          "offers": {
              "@type": "Offer",
              "category": "Education",
              "price": "0",
              "priceCurrency": "USD",
              "availability": "https://schema.org/InStock",
              "url": "https://dmj.one/edu/su/course/csu2316/theory/kubernetes-manifests-commands"
          },
          "hasCourseInstance": {
              "@type": "CourseInstance",
              "name": "Kubernetes Manifests & Commands",
              "description": "Master Kubernetes Manifest Files and Kubectl commands. Learn to define declarative infrastructure using YAML.",
              "courseMode": "online",
              "startDate": "2025-12-16",
              "courseWorkload": "PT4H",               
              "instructor": [                
                {
                  "@type": "Person",
                  "name": "Divya Mohan",                                      
                  "url": "https://dmj.one/resume/",
                    "sameAs": [
                        "https://www.credly.com/users/divyamohan1993",
                        "https://www.linkedin.com/in/divyamohan1993/",
                        "https://hackerrank.com/divyamohan1993",
                        "https://www.coursera.org/learner/divyamohan1993"
                    ]
                }
              ],
              "url": "https://dmj.one/edu/su/course/csu2316/"
            }
        }
        </script>


</head>

<body>

    <script> header_author("dm"); </script>

    <main>
        <article class="agen-tableofcontents">
            <h2 class="text-center">
                Kubernetes Manifests & Commands
            </h2>
            <div class="d-none contentdate">2025, Dec 16</div>
        </article>
        <div class="text-center mb-4" style="position:relative;width:100%;height:250px;overflow:hidden"><img src="../img/kubernetes_manifests.webp" alt="Kubernetes Manifest YAML" style="position:absolute;top:50%;left:50%;width:100%;height:100%;object-fit:cover;transform:translate(-50%,-50%)"></div>

        <article>
            <h3>11. Kubernetes Manifest File</h3>
            <p>A <strong>Manifest File</strong> is a declarative YAML (or JSON) document that defines the <em>desired state</em> of a Kubernetes object. It tells Kubernetes <strong>what should exist</strong>, not <strong>how to create it step by step</strong>.</p>
            <p>Kubernetes continuously works to make the <em>actual cluster state</em> match the <em>desired state</em> written in the manifest.</p>
        </article>

        <article>
            <h4>11.1 Where Manifest Files Are Used</h4>
            <p>Manifest files are used wherever Kubernetes resources must be created, updated, or managed in a <strong>repeatable and version-controlled</strong> way.</p>
            <ul>
                <li><strong>Application deployment</strong>: Pods, Deployments, Services</li>
                <li><strong>Infrastructure configuration</strong>: Namespaces, ConfigMaps, Secrets</li>
                <li><strong>Automation</strong>: CI/CD pipelines applying manifests</li>
                <li><strong>Disaster recovery</strong>: Recreate entire cluster state from YAML</li>
            </ul>
        </article>

        <article>
            <h4>11.2 Why Manifest Files Are Used</h4>
            <p>Imperative commands say <em>“do this now”</em>. Manifests say <em>“this is how it should always be”</em>.</p>
            <ul>
                <li><strong>Declarative control</strong>: Desired state is always enforced</li>
                <li><strong>Idempotent</strong>: Applying same file multiple times is safe</li>
                <li><strong>Version control friendly</strong>: YAML stored in Git</li>
                <li><strong>Auditable & reproducible</strong>: Same file → same infrastructure</li>
            </ul>
            <div class="active-recall-custom-block">
                <details class="interactive-active-recall-card-dmj-su">
                    <summary class="alert-heading list-unstyled">
                        <i class="bi bi-mouse-fill"></i> What is the benefit of defining infrastructure in Manifest files?
                    </summary>
                    <hr>
                    <p class="mb-0 small"><strong>A:</strong> It allows for <strong>Infrastructure as Code (IaC)</strong>. You can version control your infrastructure (Git), audit changes, and ensure reproducibility safely.</p>
                </details>
            </div>
        </article>

        <article>
            <h4>11.3 How a Manifest Works</h4>
            <pre class="mermaid text-center">
            graph TD
                User[User/CI] -->|kubectl apply| API[API Server]
                API -->|Store| Etcd[(etcd)]
                Control[Controller] -->|Watch| API
                Control -->|Diff| State{Desired == Actual?}
                State -->|No| Fix[Take Action]
                Fix --> API
                style API fill:#ffcc80
            </pre>
            <p>The manifest does not create resources directly. It flows through Kubernetes components.</p>
            <ul>
                <li><strong>kubectl apply</strong> sends YAML to API Server</li>
                <li><strong>API Server</strong> validates and stores it in etcd</li>
                <li><strong>Controllers</strong> compare desired vs actual state</li>
                <li><strong>Scheduler</strong> assigns Pods to Nodes</li>
                <li><strong>Kubelet</strong> creates/maintains Pods</li>
            </ul>
            <p>This loop runs continuously, enabling self-healing.</p>
            <div class="active-recall-custom-block">
                <details class="interactive-active-recall-card-dmj-su">
                    <summary class="alert-heading list-unstyled">
                        <i class="bi bi-mouse-fill"></i> Does the <code>kubectl apply</code> command create the Pods directly?
                    </summary>
                    <hr>
                    <p class="mb-0 small"><strong>A:</strong> <strong>No</strong>. It sends the YAML data to the <strong>API Server</strong>. The internal Kubernetes <strong>Controllers</strong> and <strong>Introduction</strong> then handle the actual creation asynchronously.</p>
                </details>
            </div>
        </article>

        <article>
            <h4>11.4 Standard Manifest Structure</h4>
            <p>Every Kubernetes manifest follows the same structural contract.</p>
            <ul>
                <li><strong>apiVersion</strong>: Which API version to use</li>
                <li><strong>kind</strong>: Type of resource</li>
                <li><strong>metadata</strong>: Identity and labels</li>
                <li><strong>spec</strong>: Desired state definition</li>
            </ul>
            <div class="active-recall-custom-block">
                <details class="interactive-active-recall-card-dmj-su">
                    <summary class="alert-heading list-unstyled">
                        <i class="bi bi-mouse-fill"></i> What is the <code>kind</code> field in a K8s manifest?
                    </summary>
                    <hr>
                    <p class="mb-0 small"><strong>A:</strong> It specifies the <strong>type of object</strong> to create, such as <code>Pod</code>, <code>Deployment</code>, <code>Service</code>, or <code>ConfigMap</code>.</p>
                </details>
            </div>
        </article>

        <article>
            <h5>11.4.1 Minimal Manifest Example</h5>
            <pre><code class="language-yaml">
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod
spec:
  containers:
  - name: nginx
    image: nginx:latest
    ports:
    - containerPort: 80
</code></pre>
        </article>

        <article>
            <h4>11.5 Common Types of Manifest Files</h4>
            <ul>
                <li><strong>Pod</strong>: Single runnable unit</li>
                <li><strong>Deployment</strong>: Manages replica Pods and updates</li>
                <li><strong>Service</strong>: Stable network access to Pods</li>
                <li><strong>ConfigMap</strong>: Non-sensitive configuration</li>
                <li><strong>Secret</strong>: Sensitive data (encoded)</li>
                <li><strong>Namespace</strong>: Logical isolation</li>
            </ul>
        </article>

        <article>
            <h4>11.6 Kubectl Commands for Manifests</h4>
            <ul>
                <li><strong>kubectl apply -f file.yaml</strong>: Create or update resource declaratively</li>
                <li><strong>kubectl delete -f file.yaml</strong>: Remove resource defined in manifest</li>
                <li><strong>kubectl create -f file.yaml</strong>: Create resource (imperative style)</li>
                <li><strong>kubectl edit resource/name</strong>: Live edit resource spec</li>
            </ul>
        </article>

        <article>
            <h4>11.7 Scaling & Rollout Commands</h4>
            <ul>
                <li><strong>kubectl scale deployment app --replicas=5</strong>: Change replica count</li>
                <li><strong>kubectl rollout status deployment app</strong>: Check rollout progress</li>
                <li><strong>kubectl rollout history deployment app</strong>: View revisions</li>
                <li><strong>kubectl rollout undo deployment app</strong>: Roll back to previous version</li>
            </ul>
        </article>

        <article>
            <h4>11.8 Observability & Debugging Commands</h4>
            <ul>
                <li><strong>kubectl get pods</strong>: List resources</li>
                <li><strong>kubectl get pods -o wide</strong>: Include node & IP details</li>
                <li><strong>kubectl describe pod name</strong>: Detailed runtime info</li>
                <li><strong>kubectl logs pod-name</strong>: View container logs</li>
                <li><strong>kubectl exec -it pod-name -- bash</strong>: Enter container shell</li>
            </ul>
        </article>

        <article>
            <h4>11.9 Top 10 Daily-Use Kubectl Commands</h4>
            <div class="table-responsive">
                <table class="table table-bordered table-striped">
                    <thead>
                        <tr>
                            <th>Command</th>
                            <th>What It Does</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>kubectl apply -f</td>
                            <td>Apply desired state from manifest</td>
                        </tr>
                        <tr>
                            <td>kubectl get all</td>
                            <td>Quick cluster resource overview</td>
                        </tr>
                        <tr>
                            <td>kubectl get pods -o wide</td>
                            <td>Pod placement and networking</td>
                        </tr>
                        <tr>
                            <td>kubectl describe</td>
                            <td>Deep inspection of resource state</td>
                        </tr>
                        <tr>
                            <td>kubectl logs</td>
                            <td>Debug application behavior</td>
                        </tr>
                        <tr>
                            <td>kubectl exec</td>
                            <td>Runtime container access</td>
                        </tr>
                        <tr>
                            <td>kubectl scale</td>
                            <td>Manual replica adjustment</td>
                        </tr>
                        <tr>
                            <td>kubectl rollout status</td>
                            <td>Track deployment progress</td>
                        </tr>
                        <tr>
                            <td>kubectl rollout undo</td>
                            <td>Recover from bad deployment</td>
                        </tr>
                        <tr>
                            <td>kubectl delete</td>
                            <td>Remove resources cleanly</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="active-recall-custom-block">
                <details class="interactive-active-recall-card-dmj-su">
                    <summary class="alert-heading list-unstyled">
                        <i class="bi bi-mouse-fill"></i> What is the difference between <code>kubectl apply</code> and <code>kubectl create</code>?
                    </summary>
                    <hr>
                    <p class="mb-0 small"><strong>A:</strong> <code>apply</code> is <strong>declarative</strong> (updates existing resources if they change). <code>create</code> is <strong>imperative</strong> (errors out if the resource already exists).</p>
                </details>
            </div>
        </article>

        <article>
            <h4>11.10 Imperative vs Declarative</h4>
            <p>Kubernetes supports two interaction models. Understanding this distinction is mandatory for real-world DevOps.</p>
            <ul>
                <li><strong>Imperative</strong>: You tell Kubernetes <em>what action to perform now</em></li>
                <li><strong>Declarative</strong>: You tell Kubernetes <em>what final state should exist</em></li>
            </ul>
            <div class="table-responsive">
                <table class="table table-bordered table-striped">
                    <thead>
                        <tr>
                            <th>Aspect</th>
                            <th>Imperative</th>
                            <th>Declarative (Manifest)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Command</td>
                            <td>kubectl run</td>
                            <td>kubectl apply -f</td>
                        </tr>
                        <tr>
                            <td>State tracking</td>
                            <td>Manual</td>
                            <td>Automatic</td>
                        </tr>
                        <tr>
                            <td>Rollback</td>
                            <td>Difficult</td>
                            <td>Built-in</td>
                        </tr>
                        <tr>
                            <td>CI/CD suitability</td>
                            <td>Poor</td>
                            <td>Excellent</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="active-recall-custom-block">
                <details class="interactive-active-recall-card-dmj-su">
                    <summary class="alert-heading list-unstyled">
                        <i class="bi bi-mouse-fill"></i> Why is declarative (Manifest) better for CI/CD than imperative commands?
                    </summary>
                    <hr>
                    <p class="mb-0 small"><strong>A:</strong> Because it is <strong>idempotent</strong>. You can run <code>kubectl apply -f</code> 100 times safely. Imperative scripts break if run twice (e.g., trying to create a resource that exists).</p>
                </details>
            </div>
        </article>

        <article>
            <h4>11.11 Labels & Selectors</h4>
            <p>Labels are <strong>key-value metadata</strong> used to logically group resources. Selectors use labels to connect components.</p>
            <ul>
                <li>Deployments select Pods</li>
                <li>Services select Pods</li>
                <li>NetworkPolicies select traffic targets</li>
            </ul>
            <pre><code class="language-yaml">
metadata:
  labels:
    app: web
    env: prod
</code></pre>
            <p>Without labels, Kubernetes objects cannot scale, route traffic, or self-heal effectively.</p>
        </article>

        <article>
            <h4>11.12 Namespaces in Manifests</h4>
            <p>Namespaces logically isolate resources within the same cluster.</p>
            <ul>
                <li><strong>default</strong>: Normal workloads</li>
                <li><strong>kube-system</strong>: Core Kubernetes components</li>
                <li><strong>dev / test / prod</strong>: Environment separation</li>
            </ul>
            <pre><code class="language-yaml">
metadata:
  name: backend
  namespace: prod
</code></pre>
            <p>Namespaces are mandatory for multi-team and enterprise clusters.</p>
        </article>

        <article>
            <h4>11.13 Validation & Dry Run</h4>
            <p>Kubernetes allows validating manifests without applying them.</p>
            <ul>
                <li><strong>--dry-run=client</strong>: Local syntax validation</li>
                <li><strong>--dry-run=server</strong>: API-level validation</li>
            </ul>
            <pre><code class="language-bash">
kubectl apply -f app.yaml --dry-run=client
kubectl apply -f app.yaml --dry-run=server
</code></pre>
            <p>This prevents broken deployments in production.</p>
        </article>

        <article>
            <h4>11.14 Version Control Best Practices for Manifests</h4>
            <p>Manifests are <strong>infrastructure source code</strong>.</p>
            <ul>
                <li>One resource per file</li>
                <li>Environment-wise folders (dev/test/prod)</li>
                <li>No secrets in plain YAML</li>
                <li>Git commit history = infrastructure audit log</li>
            </ul>
        </article>

        <article>
            <h4>11.15 Common Manifest Mistakes</h4>
            <ul>
                <li>Wrong <strong>apiVersion</strong></li>
                <li>Mismatch between labels and selectors</li>
                <li>Missing container ports in Services</li>
                <li>Using imperative commands in CI/CD</li>
                <li>Editing live resources instead of updating YAML</li>
            </ul>
        </article>

        <article>
            <h4>11.16 Simple Manifest Workflow</h4>
            <p>Here is the absolute simplest way to see Kubernetes Manifests in action. We will create a generic Nginx Pod.</p>

            <p><strong>1. Create the File</strong></p>
            <p>Create a file named <code>simple-pod.yaml</code> on your machine.</p>

            <p><strong>2. Add the Content</strong></p>
            <pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: my-first-pod
  labels:
    app: demo
spec:
  containers:
  - name: web-server
    image: nginx:alpine
    ports:
    - containerPort: 80</code></pre>

            <p><strong>3. Apply It</strong></p>
            <p>Run this command to send the manifest to the cluster:</p>
            <pre><code class="language-bash">kubectl apply -f simple-pod.yaml</code></pre>

            <p><strong>4. How it Works</strong></p>
            <ul>
                <li><strong>apiVersion: v1</strong> → The version of the Kubernetes API to use.</li>
                <li><strong>kind: Pod</strong> → The type of resource to create.</li>
                <li><strong>metadata</strong> → Names the resource <code>my-first-pod</code>.</li>
                <li><strong>spec</strong> → The "specs" or desired state (run <code>nginx:alpine</code>).</li>
                <li><strong>apply</strong> → The command that makes the magic happen.</li>
            </ul>
        </article>



    </main>

    <script> copyright("all"); </script>

</body>

</html>