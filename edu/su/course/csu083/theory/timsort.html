<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>



        <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                renderMathInElement(document.body, {
                    // customised options
                    // • auto-render specific keys, e.g.:
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\(', right: '\\)', display: false },
                        { left: '\\[', right: '\\]', display: true }
                    ],
                    // • rendering keys, e.g.:
                    throwOnError: false
                });
            });
        </script> -->

        <!-- <style>
            main ul {
                list-style-type: none;
                padding: 0;
                margin: 0;
            }

            main ul li {
                margin: 0;
                padding: 0;
            }
        </style> -->



    </head>

    <body>

        <script> header_author("dm"); </script>

        <main>
            <article class="agen-tableofcontents">
                <h2 class="text-center">
                    Timsort
                </h2>
                <div class="d-none contentdate">2025, January 6</div>
            </article>

            <article>
                <h3>1. Prerequisites</h3>
                <p>To understand Timsort, you should be familiar with the following concepts:</p>
                <ul>
                    <li><strong>Sorting Algorithms</strong>: Understanding of basic sorting methods like Merge Sort, Insertion Sort, and Quick Sort.</li>
                    <li><strong>Time Complexity</strong>: Knowledge of Big-O notation to analyze algorithm efficiency.</li>
                    <li><strong>Stable Sorting</strong>: Sorting where equal elements retain their relative order.</li>
                    <li><strong>Divide and Conquer</strong>: Breaking problems into smaller subproblems, solving them, and combining results.</li>
                    <li><strong>Hybrid Sorting</strong>: Combining different sorting strategies for optimal performance.</li>
                </ul>
            </article>

            <article>
                <h3>2. What is Timsort?</h3>
                <p>Timsort is a hybrid sorting algorithm that combines the advantages of Merge Sort and Insertion Sort. It is designed for real-world data and is used in Python’s built-in <code>sorted()</code> and Java’s <code>Arrays.sort()</code> for non-primitive types.</p>
                <p>Key properties of Timsort:</p>
                <ul>
                    <li><strong>Hybrid Approach</strong>: Uses Merge Sort for larger subarrays and Insertion Sort for small ones.</li>
                    <li><strong>Stable Sorting</strong>: Maintains relative order of equal elements.</li>
                    <li><strong>Adaptive</strong>: Performs efficiently on partially sorted data.</li>
                    <li><strong>Run Detection</strong>: Detects already sorted sequences (runs) to minimize operations.</li>
                    <li><strong>Galloping Mode</strong>: Optimizes merging when runs have large size differences.</li>
                </ul>
            </article>

            <article>
                <h3>3. Why Does Timsort Exist?</h3>
                <p>Sorting algorithms must efficiently handle real-world data, which often contains existing order. Timsort was created to optimize sorting for such cases.</p>
                <p>Use cases include:</p>
                <ul>
                    <li><strong>Standard Libraries</strong>: Python’s <code>sorted()</code> and Java’s <code>Arrays.sort()</code> for object sorting.</li>
                    <li><strong>Large Datasets</strong>: Works well for massive lists in databases or scientific computing.</li>
                    <li><strong>Partially Sorted Data</strong>: Performs better than traditional sorts when the input has structure.</li>
                    <li><strong>Stable Sorting Needs</strong>: Suitable for applications where order preservation is critical, such as event scheduling.</li>
                </ul>
            </article>

            <article>
                <h3>4. When Should You Use Timsort?</h3>
                <p>Timsort excels in the following situations:</p>
                <ul>
                    <li><strong>Sorting Lists with Existing Order</strong>: If the data is already sorted or nearly sorted, Timsort performs better than Quick Sort.</li>
                    <li><strong>Stable Sorting is Required</strong>: When elements with equal values must retain their relative positions.</li>
                    <li><strong>Sorting Large Arrays</strong>: Efficiently handles large datasets while maintaining speed and stability.</li>
                    <li><strong>General-Purpose Sorting</strong>: Default sorting algorithm in Python and Java due to its reliability.</li>
                </ul>
            </article>

            <article>
                <h3>5. How Does It Compare to Alternatives?</h3>
                <h4>5.1 Strengths</h4>
                <ul>
                    <li><strong>Efficient on Real-World Data</strong>: Exploits existing order to reduce sorting time.</li>
                    <li><strong>Stable</strong>: Ensures equal elements retain their order.</li>
                    <li><strong>Optimized Merging</strong>: Uses galloping mode for fast merging.</li>
                    <li><strong>Handles Large Data Well</strong>: Comparable to Merge Sort in efficiency.</li>
                </ul>

                <h4>5.2 Weaknesses</h4>
                <ul>
                    <li><strong>Higher Overhead</strong>: More complex than Quick Sort, leading to higher constant factors.</li>
                    <li><strong>Memory Usage</strong>: Requires additional space for merging (O(n) extra space).</li>
                    <li><strong>Not Always the Fastest</strong>: Quick Sort can outperform it on entirely random data due to lower overhead.</li>
                </ul>

                <h4>5.3 Comparison Table</h4>
                <table class="table table-responsive">
                    <tr>
                        <th>Algorithm</th>
                        <th>Time Complexity (Avg)</th>
                        <th>Space Complexity</th>
                        <th>Stable</th>
                        <th>Best Use Case</th>
                    </tr>
                    <tr>
                        <td><strong>Timsort</strong></td>
                        <td>O(n log n)</td>
                        <td>O(n)</td>
                        <td>Yes</td>
                        <td>General-purpose, partially sorted data</td>
                    </tr>
                    <tr>
                        <td>Quick Sort</td>
                        <td>O(n log n)</td>
                        <td>O(log n)</td>
                        <td>No</td>
                        <td>Random data, in-place sorting</td>
                    </tr>
                    <tr>
                        <td>Merge Sort</td>
                        <td>O(n log n)</td>
                        <td>O(n)</td>
                        <td>Yes</td>
                        <td>Stable sorting of large datasets</td>
                    </tr>
                    <tr>
                        <td>Insertion Sort</td>
                        <td>O(n²)</td>
                        <td>O(1)</td>
                        <td>Yes</td>
                        <td>Small or nearly sorted arrays</td>
                    </tr>
                </table>
            </article>


            <article>
                <h3>6. Basic Implementation</h3>
                <p>The following is a basic implementation of Timsort in Python, as Python’s built-in <code>sorted()</code> function uses Timsort internally.</p>

                <pre><code class="language-python"> 
# Python implementation of Timsort

MIN_RUN = 32

def insertion_sort(arr, left, right):
    for i in range(left + 1, right + 1):
        key = arr[i]
        j = i - 1
        while j >= left and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key

def merge(arr, left, mid, right):
    left_part = arr[left:mid + 1]
    right_part = arr[mid + 1:right + 1]
    
    i, j, k = 0, 0, left

    while i < len(left_part) and j < len(right_part):
        if left_part[i] <= right_part[j]:
            arr[k] = left_part[i]
            i += 1
        else:
            arr[k] = right_part[j]
            j += 1
        k += 1

    while i < len(left_part):
        arr[k] = left_part[i]
        i += 1
        k += 1

    while j < len(right_part):
        arr[k] = right_part[j]
        j += 1
        k += 1

def tim_sort(arr):
    n = len(arr)

    # Step 1: Sort small runs using Insertion Sort
    for start in range(0, n, MIN_RUN):
        end = min(start + MIN_RUN - 1, n - 1)
        insertion_sort(arr, start, end)

    # Step 2: Merge sorted runs
    size = MIN_RUN
    while size < n:
        for left in range(0, n, 2 * size):
            mid = min(n - 1, left + size - 1)
            right = min(n - 1, left + 2 * size - 1)
            if mid < right:
                merge(arr, left, mid, right)
        size *= 2

# Example usage
arr = [5, 21, 7, 23, 19, 4, 1, 8]
tim_sort(arr)
print(arr)  # Output: [1, 4, 5, 7, 8, 19, 21, 23]
</code></pre>
            </article>

            <article>
                <h3>7. Dry Run of Timsort</h3>
                <p>We will dry run Timsort on a small input array: <code>[5, 21, 7, 23, 19, 4, 1, 8]</code></p>

                <h4>Step 1: Identify Runs and Sort with Insertion Sort</h4>
                <ul>
                    <li>Divide the array into runs of <code>MIN_RUN = 32</code>. Since our array is small, we apply Insertion Sort directly.</li>
                    <li>Insertion Sort is applied, leading to a sorted array:</li>
                    <li><code>[1, 4, 5, 7, 8, 19, 21, 23]</code></li>
                </ul>

                <h4>Step 2: Merging Sorted Runs</h4>
                <ul>
                    <li>Since the array is now fully sorted, merging is trivial.</li>
                    <li>The final output remains <code>[1, 4, 5, 7, 8, 19, 21, 23]</code></li>
                </ul>

                <h4>Variable Tracking</h4>
                <table class="table table-responsive">
                    <tr>
                        <th>Iteration</th>
                        <th>Array State</th>
                        <th>Key Operations</th>
                    </tr>
                    <tr>
                        <td>Initial</td>
                        <td>[5, 21, 7, 23, 19, 4, 1, 8]</td>
                        <td>Original Array</td>
                    </tr>
                    <tr>
                        <td>Insertion Sort</td>
                        <td>[1, 4, 5, 7, 8, 19, 21, 23]</td>
                        <td>Small segments sorted</td>
                    </tr>
                    <tr>
                        <td>Merge Phase</td>
                        <td>[1, 4, 5, 7, 8, 19, 21, 23]</td>
                        <td>Runs merged</td>
                    </tr>
                    <tr>
                        <td>Final Output</td>
                        <td>[1, 4, 5, 7, 8, 19, 21, 23]</td>
                        <td>Sorted array</td>
                    </tr>
                </table>

                <p>The algorithm efficiently sorts the array by leveraging Insertion Sort on small runs and merging sorted segments.</p>
            </article>

            <article>
                <h3>8. Time & Space Complexity Analysis</h3>

                <h4>8.1 Worst-Case Time Complexity</h4>
                <p>In the worst case, Timsort behaves like Merge Sort, as it must split and merge all elements without leveraging runs.</p>
                <p>Since merging two sorted halves takes \( O(n) \) time and occurs over \( O(\log n) \) levels, the worst-case complexity is:</p>
                <p>$$ O(n \log n) $$</p>

                <h4>8.2 Best-Case Time Complexity</h4>
                <p>If the input array is already sorted, Timsort recognizes runs and only applies Insertion Sort, which runs in:</p>
                <p>$$ O(n) $$</p>
                <p>This is better than Quick Sort’s best case (\( O(n \log n) \)).</p>

                <h4>8.3 Average-Case Time Complexity</h4>
                <p>For random data, Timsort operates similarly to Merge Sort, making it:</p>
                <p>$$ O(n \log n) $$</p>

                <h4>8.4 Summary Table</h4>
                <table class="table table-responsive">
                    <tr>
                        <th>Case</th>
                        <th>Complexity</th>
                        <th>Reason</th>
                    </tr>
                    <tr>
                        <td>Best Case</td>
                        <td>O(n)</td>
                        <td>Already sorted input, uses Insertion Sort</td>
                    </tr>
                    <tr>
                        <td>Average Case</td>
                        <td>O(n log n)</td>
                        <td>Hybrid of Merge Sort and Insertion Sort</td>
                    </tr>
                    <tr>
                        <td>Worst Case</td>
                        <td>O(n log n)</td>
                        <td>No pre-existing order, full merging required</td>
                    </tr>
                </table>

            </article>

            <article>
                <h3>9. Space Complexity Analysis</h3>

                <h4>9.1 Auxiliary Space Usage</h4>
                <ul>
                    <li><strong>Insertion Sort</strong> runs in-place with \( O(1) \) space.</li>
                    <li><strong>Merging</strong> requires temporary arrays, leading to \( O(n) \) extra space.</li>
                    <li><strong>Total Space Complexity</strong>:
                        <p>$$ O(n) $$</p>
                    </li>
                </ul>

                <h4>9.2 Space Usage vs. Input Size</h4>
                <ul>
                    <li>For small inputs, Timsort primarily uses Insertion Sort, keeping space low.</li>
                    <li>For large inputs, additional memory is needed for merging runs.</li>
                    <li>More memory is consumed if runs are small and numerous.</li>
                </ul>

            </article>

            <article>
                <h3>10. Trade-offs in Timsort</h3>

                <h4>10.1 Advantages</h4>
                <ul>
                    <li><strong>Stability</strong>: Maintains the relative order of equal elements.</li>
                    <li><strong>Optimized for Real-World Data</strong>: Adaptive behavior speeds up sorting.</li>
                    <li><strong>Best-Case Efficiency</strong>: Can sort nearly sorted data in \( O(n) \).</li>
                </ul>

                <h4>10.2 Disadvantages</h4>
                <ul>
                    <li><strong>Memory Usage</strong>: Uses \( O(n) \) space, unlike in-place Quick Sort.</li>
                    <li><strong>Higher Constant Overhead</strong>: More complex than Quick Sort, affecting small arrays.</li>
                    <li><strong>Slower on Random Data</strong>: Merge operations can introduce overhead.</li>
                </ul>

                <h4>10.3 When to Choose Timsort?</h4>
                <ul>
                    <li>When sorting large lists that may have existing order.</li>
                    <li>When a stable sorting algorithm is required.</li>
                    <li>When working in Python or Java, where it is the default sort.</li>
                </ul>

            </article>

            <article>
                <h3>11. Optimizations & Variants</h3>

                <h4>11.1 Common Optimizations</h4>
                <p>Timsort includes several optimizations that improve its efficiency:</p>

                <ul>
                    <li><strong>Run Detection</strong>: Pre-existing sorted segments (runs) are identified, reducing sorting effort.</li>
                    <li><strong>Dynamic Run Merging</strong>: Ensures balanced merging to maintain efficiency.</li>
                    <li><strong>Galloping Mode</strong>: Speeds up merging when one run is much larger than the other.</li>
                    <li><strong>Threshold-Based Sorting</strong>: Uses Insertion Sort for small subarrays (typically &lt;32 elements) since it's more efficient on small inputs.</li>
                </ul>

                <h4>11.2 Variants of Timsort</h4>
                <p>There are variations of Timsort adapted for different needs:</p>

                <ul>
                    <li><strong>Classic Timsort</strong>: Used in Python and Java, optimized for general-purpose sorting.</li>
                    <li><strong>Modified Timsort</strong>: Some implementations adjust the <code>MIN_RUN</code> size for better efficiency.</li>
                    <li><strong>Parallel Timsort</strong>: Uses multi-threading for large datasets, improving performance in multi-core systems.</li>
                    <li><strong>Memory-Efficient Timsort</strong>: Reduces auxiliary space usage by adjusting merging behavior.</li>
                </ul>

            </article>

            <article>
                <h3>12. Iterative vs. Recursive Implementations</h3>

                <h4>12.1 Iterative Timsort</h4>
                <p>Most Timsort implementations (including Python’s) use an <strong>iterative approach</strong>:</p>

                <ul>
                    <li>Sorting small segments using Insertion Sort.</li>
                    <li>Progressively merging runs using a stack.</li>
                    <li>Minimizing recursion overhead, leading to better space efficiency.</li>
                </ul>

                <h4>12.2 Recursive Timsort</h4>
                <p>Although possible, a <strong>recursive approach</strong> is rarely used in Timsort:</p>

                <ul>
                    <li>It increases function call overhead due to recursion.</li>
                    <li>Recursion depth can be high for large datasets, leading to stack overflow issues.</li>
                    <li>Space usage increases due to recursive function calls.</li>
                </ul>

                <h4>12.3 Efficiency Comparison</h4>

                <table class="table table-responsive">
                    <tr>
                        <th>Aspect</th>
                        <th>Iterative Timsort</th>
                        <th>Recursive Timsort</th>
                    </tr>
                    <tr>
                        <td>Memory Usage</td>
                        <td>O(n) (stack optimized)</td>
                        <td>O(n log n) (recursive calls)</td>
                    </tr>
                    <tr>
                        <td>Speed</td>
                        <td>Faster due to reduced function call overhead</td>
                        <td>Slower due to recursion overhead</td>
                    </tr>
                    <tr>
                        <td>Stability</td>
                        <td>Stable</td>
                        <td>Stable</td>
                    </tr>
                    <tr>
                        <td>Practicality</td>
                        <td>Used in real-world applications</td>
                        <td>Rarely used due to inefficiency</td>
                    </tr>
                </table>

                <h4>12.4 Conclusion</h4>
                <p><strong>Iterative Timsort</strong> is superior because it avoids recursion overhead, uses stack-based merging, and is more memory-efficient. This is why it is the preferred implementation in Python and Java.</p>

            </article>

            <article>
                <h3>13. Edge Cases & Failure Handling</h3>

                <h4>13.1 Common Edge Cases</h4>
                <p>While Timsort is efficient, certain inputs can challenge its behavior:</p>

                <ul>
                    <li><strong>Already Sorted Arrays</strong>: Best-case scenario, Timsort runs in \(O(n)\).</li>
                    <li><strong>Reverse Sorted Arrays</strong>: Requires full sorting, leading to \(O(n \log n)\) complexity.</li>
                    <li><strong>Arrays with Many Duplicates</strong>: Timsort handles this well due to its stability.</li>
                    <li><strong>Small Arrays</strong>: Uses Insertion Sort, which can be inefficient if not optimized.</li>
                    <li><strong>Large Arrays with Random Data</strong>: Performance is close to Merge Sort, requiring extra memory.</li>
                    <li><strong>Mix of Sorted and Unsorted Segments</strong>: Timsort performs better than Quick Sort in these cases.</li>
                </ul>

                <h4>13.2 Failure Handling</h4>
                <p>Potential failure points in Timsort implementations:</p>

                <ul>
                    <li><strong>Incorrect Run Detection</strong>: Poorly chosen runs can reduce efficiency.</li>
                    <li><strong>Memory Exhaustion</strong>: Large auxiliary arrays during merging can cause memory overflows.</li>
                    <li><strong>Incorrect Merging Strategy</strong>: Improper merging order can break stability.</li>
                    <li><strong>Recursive Depth Issues</strong>: If implemented recursively, stack overflow may occur.</li>
                </ul>

            </article>

            <article>
                <h3>14. Test Cases to Verify Correctness</h3>

                <p>To ensure correctness, various test cases should be written:</p>

                <h4>14.1 Basic Test Cases</h4>
                <pre><code class="language-python">
import random

def test_timsort():
    # Base case: Empty array
    assert sorted([]) == []

    # Single element
    assert sorted([1]) == [1]

    # Small array
    assert sorted([5, 2, 9, 1, 5, 6]) == [1, 2, 5, 5, 6, 9]

    # Already sorted
    assert sorted([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]

    # Reverse sorted
    assert sorted([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]

    # Large array with duplicates
    large_array = [random.randint(0, 100) for _ in range(1000)]
    assert sorted(large_array) == sorted(large_array)

    # Array with negative numbers
    assert sorted([-3, -1, -7, -2, -5]) == [-7, -5, -3, -2, -1]

    print("All test cases passed!")

test_timsort()
</code></pre>

            </article>

            <article>
                <h3>15. Real-World Failure Scenarios</h3>

                <h4>15.1 Memory Overhead in Large Datasets</h4>
                <p>When sorting extremely large datasets, Timsort requires \(O(n)\) auxiliary memory for merging, which can cause:</p>
                <ul>
                    <li>Memory exhaustion leading to process failure.</li>
                    <li>Performance degradation due to excessive memory usage.</li>
                </ul>
                <p><strong>Solution:</strong> Optimize merging strategies or use in-place sorting methods when possible.</p>

                <h4>15.2 Poor Run Selection in Custom Implementations</h4>
                <p>Incorrectly identifying runs can lead to inefficient sorting.</p>
                <p><strong>Solution:</strong> Tune the <code>MIN_RUN</code> parameter based on the dataset.</p>

                <h4>15.3 Stability Issues in Custom Implementations</h4>
                <p>Errors in merging logic can break stability, affecting applications where order preservation is critical.</p>
                <p><strong>Solution:</strong> Ensure elements with equal keys maintain their original order.</p>

                <h4>15.4 Performance Regression in Low-Power Devices</h4>
                <p>Devices with limited memory struggle with Timsort’s space requirements.</p>
                <p><strong>Solution:</strong> Use memory-efficient sorting algorithms like Heap Sort for constrained environments.</p>

            </article>

            <article>
                <h3>16. Real-World Applications & Industry Use Cases</h3>

                <p>Timsort is widely used in industry due to its stability, efficiency, and adaptability to real-world data.</p>

                <h4>16.1 Programming Languages & Libraries</h4>
                <ul>
                    <li><strong>Python:</strong> The built-in <code>sorted()</code> function and <code>list.sort()</code> use Timsort.</li>
                    <li><strong>Java:</strong> Used in <code>Arrays.sort()</code> for non-primitive types.</li>
                    <li><strong>Android:</strong> Used in sorting utilities for better performance on mobile devices.</li>
                    <li><strong>.NET Framework:</strong> Some implementations use Timsort for object sorting.</li>
                </ul>

                <h4>16.2 Use Cases in Industry</h4>
                <ul>
                    <li><strong>Databases:</strong> Optimized sorting for indexes and query optimization.</li>
                    <li><strong>Web Applications:</strong> Sorting UI elements in e-commerce and social media feeds.</li>
                    <li><strong>Finance & Trading:</strong> Used in stock market applications where stable sorting is required.</li>
                    <li><strong>Data Science:</strong> Used in NumPy and Pandas for sorting structured data.</li>
                </ul>

            </article>

            <article>
                <h3>17. Open-Source Implementations</h3>

                <h4>17.1 Python's Implementation</h4>
                <p>The official CPython implementation of Timsort is found in:</p>
                <pre><code class="language-bash">
https://github.com/python/cpython/blob/main/Objects/listsort.txt
</code></pre>

                <h4>17.2 Java's Implementation</h4>
                <p>The Java implementation in the OpenJDK is located here:</p>
                <pre><code class="language-bash">
https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/TimSort.java
</code></pre>

                <h4>17.3 Custom Implementations</h4>
                <ul>
                    <li><a href="https://github.com/timsort/timsort">Timsort C++ Implementation</a></li>
                    <li><a href="https://github.com/paulodowd/Timsort">Timsort in JavaScript</a></li>
                </ul>

            </article>

            <article>
                <h3>18. Practical Project: Using Timsort in a Script</h3>

                <p>Let’s write a Python script that sorts stock market data using Timsort.</p>

                <h4>18.1 Problem Statement</h4>
                <p>We have a dataset of stock prices and want to sort them by price efficiently.</p>

                <h4>18.2 Implementation</h4>
                <pre><code class="language-python">
import random
import time

# Generate stock market data (Stock Name, Price)
stocks = [("AAPL", random.uniform(100, 500)) for _ in range(1000)]
stocks += [("GOOG", random.uniform(1000, 3000)) for _ in range(1000)]
stocks += [("TSLA", random.uniform(600, 1200)) for _ in range(1000)]

# Sorting using Python's built-in Timsort
start_time = time.time()
stocks_sorted = sorted(stocks, key=lambda x: x[1])
end_time = time.time()

# Print top 5 cheapest stocks
print("Top 5 cheapest stocks:")
for stock in stocks_sorted[:5]:
    print(stock)

# Print sorting time
print(f"Sorting time: {end_time - start_time:.5f} seconds")
</code></pre>

                <h4>18.3 Explanation</h4>
                <ul>
                    <li>Generates random stock price data.</li>
                    <li>Sorts it using Timsort (Python’s <code>sorted()</code> function).</li>
                    <li>Prints the top 5 cheapest stocks.</li>
                    <li>Displays sorting execution time.</li>
                </ul>

                <h4>18.4 Possible Enhancements</h4>
                <ul>
                    <li>Integrate with a real stock API.</li>
                    <li>Use a database for larger datasets.</li>
                    <li>Implement Timsort manually for educational purposes.</li>
                </ul>

            </article>

            <article>
                <h3>19. Competitive Programming & System Design Integration</h3>

                <h4>19.1 Timsort in Competitive Programming</h4>
                <p>Timsort is commonly used in competitive programming due to its built-in optimization in Python and Java. It helps solve sorting-based problems efficiently.</p>

                <h4>19.2 When to Use Timsort in Competitive Programming</h4>
                <ul>
                    <li><strong>When stability matters</strong>: Problems where relative order of equal elements must be preserved.</li>
                    <li><strong>Partially sorted input</strong>: Timsort adapts well to nearly sorted data.</li>
                    <li><strong>When built-in sorting is allowed</strong>: In Python, <code>sorted()</code> and <code>list.sort()</code> use Timsort.</li>
                </ul>

                <h4>19.3 Competitive Coding Example</h4>
                <pre><code class="language-python">
# Sorting an array of tuples (name, score) using Timsort
students = [("Alice", 92), ("Bob", 85), ("Charlie", 85), ("David", 95)]

# Sort by score (ascending), preserving order for equal scores
sorted_students = sorted(students, key=lambda x: x[1])

print(sorted_students)
# Output: [('Bob', 85), ('Charlie', 85), ('Alice', 92), ('David', 95)]
</code></pre>

                <h4>19.4 Timsort in System Design</h4>
                <p>Timsort is integrated into system design when sorting large data efficiently is required.</p>

                <ul>
                    <li><strong>Database Indexing</strong>: Used for sorting records efficiently.</li>
                    <li><strong>Log Processing Systems</strong>: Sorting logs for analysis.</li>
                    <li><strong>Distributed Systems</strong>: Optimizing sorting tasks before merging results from multiple nodes.</li>
                </ul>

            </article>

            <article>
                <h3>20. Assignments</h3>

                <h4>20.1 Solve at Least 10 Problems Using Timsort</h4>
                <p>Practice the following problems on platforms like LeetCode, Codeforces, or Hackerrank using Timsort.</p>

                <ol>
                    <li><strong>Sort an array of integers.</strong> (Easy)</li>
                    <li><strong>Sort an array of tuples based on the second element.</strong> (Easy)</li>
                    <li><strong>Find the k-th smallest element using sorting.</strong> (Medium)</li>
                    <li><strong>Sort an array where each element is at most k places away from its target position.</strong> (Medium)</li>
                    <li><strong>Sort a list of employees by salary, ensuring stability.</strong> (Medium)</li>
                    <li><strong>Merge two sorted lists into one sorted list efficiently.</strong> (Medium)</li>
                    <li><strong>Find the median of a large list using sorting.</strong> (Hard)</li>
                    <li><strong>Sort stock market data with timestamps.</strong> (Hard)</li>
                    <li><strong>Implement a sorting-based approach to solve the "Meeting Rooms II" problem.</strong> (Hard)</li>
                    <li><strong>Optimize a frequency-based sorting problem using stable sorting.</strong> (Hard)</li>
                </ol>

                <h4>20.2 Use Timsort in a System Design Problem</h4>
                <p>Design a system that processes large-scale log files and sorts them efficiently before analysis.</p>

                <h5>Requirements:</h5>
                <ul>
                    <li>Design a module that sorts 100 million log entries.</li>
                    <li>Ensure efficient memory usage.</li>
                    <li>Optimize for time constraints.</li>
                </ul>

                <h4>20.3 Implement Timsort Under Time Constraints</h4>
                <p>Practice writing a full implementation of Timsort from scratch within 30 minutes. Measure execution time and optimize performance.</p>

            </article>            

        </main>

        <script> copyright("all"); </script>

    </body>

</html>