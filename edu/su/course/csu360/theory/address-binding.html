<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>

        <title>Address Binding - CSU360 - Shoolini University</title>

        <meta property="og:image" content="/logo.png">
        <meta property="og:type" content="article">

        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@divyamohan1993">
        <meta name="twitter:creator" content="@divyamohan1993">
        <meta name="twitter:image" content="/logo.png">

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />

        <meta name="author" content="Divya Mohan">
        <meta name="robots" content="index, follow">

        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                renderMathInElement(document.body, {
                    // customised options
                    // • auto-render specific keys, e.g.:
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\(', right: '\\)', display: false },
                        { left: '\\[', right: '\\]', display: true }
                    ],
                    // • rendering keys, e.g.:
                    throwOnError: false
                });
            });
        </script>
    </head>

    <body>

        <script> header_author("dm"); </script>

        <main>

            <article class="agen-tableofcontents">
                <h2 class="text-center">
                    Address Binding
                </h2>
            </article>

            <article id="address-binding-overview">
                <h3>1. Address Binding</h3>
                <p>Address Binding is the process of mapping abstract addresses (logical addresses) to physical addresses in memory. This mechanism is essential in managing memory efficiently in a multitasking environment, allowing programs to be loaded and executed from different memory locations.</p>
            </article>

            <article>
                <h4>1.1 Types of Address Binding</h4>
                <p>There are three primary types of address binding: static, dynamic, and execution-time binding.</p>
                <ul>
                    <li><strong>Static Binding:</strong> Addresses are determined before the program is loaded and do not change at runtime.</li>
                    <li><strong>Dynamic Binding:</strong> Addresses are not determined until a program starts running, allowing better memory utilization.</li>
                    <li><strong>Execution-time Binding:</strong> Binding occurs during the execution of a program, facilitating features like dynamic memory allocation.</li>
                </ul>
                <article>
                    <h5>1.1.1 Static Binding in Detail</h5>
                    <p>Static binding, also known as compile-time binding, happens before a program is executed. The physical memory address is fixed at compile time, and the program must run within this specified memory space. This method is simple but lacks flexibility as it cannot accommodate dynamic memory requests made during runtime.</p>
                    <pre><code class="language-cpp">// Example of Static Binding in C++
int main() {
    static int x = 10;  // Memory address for x is bound at compile time
    return 0;
}
</code></pre>
                </article>

                <article>
                    <h5>1.1.2 Dynamic and Execution-time Binding</h5>
                    <p>Dynamic binding allows a program to be loaded into memory at any available location, with the memory addresses being rebound at the start of execution. This type is more flexible and is used in systems where processes are moved between memory segments.</p>
                    <p>Execution-time binding, on the other hand, occurs when a process is already running. This type of binding is critical for supporting advanced memory management features such as paging and segmentation, which allow for more efficient use of memory.</p>
                    <pre><code class="language-c">// Example of Dynamic Binding in C
#include &lt;stdlib.h&gt;

int main() {
    int* ptr = malloc(sizeof(int));  // Memory address for ptr is bound at runtime
    *ptr = 5;
    free(ptr);
    return 0;
}
</code></pre>
                </article>
            </article>

            <article>
                <h4>1.2 Significance of Address Binding</h4>
                <p>Address binding is crucial for:
                <ul>
                    <li><strong>Memory Efficiency:</strong> It optimizes the use of memory and enhances the system's ability to multitask.</li>
                    <li><strong>System Security:</strong> Proper binding mechanisms help in protecting memory regions and preventing unauthorized access.</li>
                    <li><strong>Program Flexibility:</strong> Enables programs to be executed in different memory environments without modification.</li>
                </ul>
                </p>
            </article>

            <article>
                <h4>1.3 Address Space</h4>
                <p>Address space refers to the range of discrete addresses available for a process to use. Each process typically operates within its own address space, which enhances security and fault isolation.</p>
                <p>The address space includes both logical (virtual) and physical address spaces, where logical addresses are used by the program code and physical addresses refer to the actual memory locations.</p>
            </article>

            <article>
                <h4>1.4 Relocation</h4>
                <p>Relocation is a form of address binding that adjusts the program’s addresses at load time. This adjustment ensures that the program runs correctly regardless of where it's loaded in physical memory.</p>
                <p>Relocation is critical in operating systems that use dynamic loading or linking, allowing programs and libraries to be loaded at different memory locations.</p>
            </article>

            <article>
                <h4>1.5 Memory Management Unit (MMU)</h4>
                <p>The Memory Management Unit (MMU) is a hardware component responsible for handling virtual to physical address translations. This unit plays a crucial role in implementing dynamic and execution-time binding.</p>
                <ul>
                    <li><strong>Translation Lookaside Buffer (TLB):</strong> A cache used by the MMU to improve the speed of virtual address translation.</li>
                    <li><strong>Page Table:</strong> A data structure used by the MMU to store mappings between virtual and physical addresses.</li>
                </ul>
                <p>The MMU enables features like paging and memory protection, which are fundamental for modern multitasking systems.</p>
            </article>

            <article>
                <h4>1.6 Impact of Address Binding on System Performance</h4>
                <p>Address binding techniques directly influence system performance through their impact on memory access speeds and system flexibility. For instance:</p>
                <ul>
                    <li><strong>Static Binding:</strong> Can lead to inefficient memory utilization as the memory allocation does not adapt to the program's runtime needs.</li>
                    <li><strong>Dynamic and Execution-time Binding:</strong> Although more flexible, these methods require additional processing to manage memory which can potentially slow down system performance if not managed efficiently.</li>
                </ul>
                <p>Choosing the appropriate binding method is crucial for balancing between performance optimization and resource utilization.</p>
            </article>

            <article>
                <h4>1.7 Logical vs Physical Memory</h4>
                <p>Understanding the distinction between logical and physical memory is essential for comprehending how address binding functions:</p>
                <ul>
                    <li><strong>Logical Memory:</strong> Refers to the view of memory that the operating system provides to applications. In this space, addresses are referenced as seen by the program.</li>
                    <li><strong>Physical Memory:</strong> Is the actual RAM (Random Access Memory) hardware that stores data and program code. Physical addresses correspond to real memory locations.</li>
                </ul>
                <p>The separation of logical and physical memory supports security and abstraction in modern computing, allowing multiple applications to run concurrently without interfering with each other.</p>
            </article>

            <article>
                <h5>1.7.1 Abstraction of Memory</h5>
                <p>The concept of memory abstraction allows programs to be written without concern for the actual physical memory location. This abstraction is crucial for:
                <ul>
                    <li><strong>Portability:</strong> Enables software to run on various hardware configurations without modification.</li>
                    <li><strong>Security:</strong> Prevents applications from accessing the memory space of others, safeguarding against malicious activities and data corruption.</li>
                </ul>
                </p>
            </article>

            <article id="contiguous-memory-allocation">
                <h3>2. Contiguous Memory Allocation</h3>
                <p>Contiguous memory allocation is a technique where each process is assigned a single contiguous section of memory. This approach simplifies memory management but can lead to issues like fragmentation.</p>
                <article>
                    <h4>2.1 Fixed Partition Scheme</h4>
                    <p>In the fixed partition scheme, memory is divided into a fixed number of partitions of predetermined sizes at system initialization. Each partition can contain exactly one process.</p>
                    <p>Key characteristics:</p>
                    <ul>
                        <li><strong>Static allocation:</strong> The number and size of partitions do not change at runtime.</li>
                        <li><strong>Limited scalability:</strong> The fixed number of partitions can lead to inefficient memory use, especially if process sizes vary significantly.</li>
                        <li><strong>Internal fragmentation:</strong> Unused memory within a partition is wasted if a process does not completely fill the partition.</li>
                    </ul>
                </article>
                <article>
                    <h4>2.2 Variable Partition Scheme</h4>
                    <p>The variable partition scheme allows partitions to be created dynamically, adjusted to the size of the processes as they load or terminate, thereby reducing wasted space.</p>
                    <p>Key features:</p>
                    <ul>
                        <li><strong>Dynamic allocation:</strong> Partitions are created as needed without a preset limit on the number or size of partitions.</li>
                        <li><strong>Reduced fragmentation:</strong> Adapting partition sizes to process requirements minimizes unused space.</li>
                        <li><strong>External fragmentation:</strong> Over time, free memory spaces may be scattered throughout the memory, complicating the allocation of large contiguous blocks.</li>
                    </ul>

                    <h5>2.2.1 Management of Variable Partitions</h5>
                    <p>Management techniques for variable partitions include:</p>
                    <ul>
                        <li><strong>Merging:</strong> Adjacent free partitions are merged into a single larger block to reduce external fragmentation.</li>
                        <li><strong>Compaction:</strong> Occasionally, processes are shifted to one end of the memory to consolidate free memory into a contiguous block, enabling allocation of larger partitions.</li>
                    </ul>

                    <pre><code class="language-cpp">
// Example of a compaction process
void compactMemory() {
    // Assuming processes are stored in an array `processes`
    int freeIndex = 0;  // Start of the free memory block
    for (int i = 0; i &lt; numProcesses; i++) {
        if (processes[i].isActive) {
            moveProcessTo(processes[i], freeIndex);
            freeIndex += processes[i].size;
        }
    }
    // Now all free memory is contiguous after `freeIndex`
}
</code></pre>
                </article>


                <article>
                    <h4>2.3 Partition Allocation Method</h4>
                    <p>Partition allocation methods in memory management refer to strategies used to distribute available memory among processes. The choice of method affects the efficiency of memory use and system performance.</p>
                </article>
                <article>
                    <h4>2.3.1 Overview of Allocation Methods</h4>
                    <p>Memory can be allocated using various strategies, each with its advantages and drawbacks. The most common methods include:</p>
                    <ul>
                        <li><strong>Fixed Partitioning</strong>: Divides memory into fixed-sized partitions, each possibly holding one process.</li>
                        <li><strong>Variable Partitioning</strong>: Partitions are dynamically created to fit the size of the requesting process, which helps in reducing wasted space.</li>
                        <li><strong>Dynamic Partitioning</strong>: Similar to variable partitioning but with the ability to resize active partitions dynamically based on process needs.</li>
                    </ul>
                </article>
                <article>
                    <h4>2.3.2 Dynamic Allocation Methods</h4>
                    <p>Dynamic allocation methods adapt to process needs in real-time, attempting to manage memory more efficiently than static methods:</p>
                    <ul>
                        <li><strong>First-fit</strong>: Allocates the first sufficiently large hole found in the memory.</li>
                        <li><strong>Best-fit</strong>: Searches for the smallest hole that is big enough to accommodate the process, aiming to minimize wasted space.</li>
                        <li><strong>Worst-fit</strong>: Allocates the largest available hole, under the assumption that this will leave a large part of the hole still usable for other processes.</li>
                    </ul>

                    <h5>2.3.2.1 First-Fit Allocation</h5>
                    <p>First-fit is generally faster than other dynamic methods as it requires less memory traversal, but can lead to poor memory utilization over time due to external fragmentation.</p>

                    <h5>2.3.2.2 Best-Fit Allocation</h5>
                    <p>Best-fit is more efficient in memory utilization than first-fit but can be computationally expensive as it requires searching the entire list of free blocks to find the optimal fit.</p>

                    <h5>2.3.2.3 Worst-Fit Allocation</h5>
                    <p>Worst-fit tends to leave larger free segments available, which might be useful for very large process requirements but can also lead to significant fragmentation.</p>

                </article>
                <article>
                    <h4>2.4 Choosing an Allocation Method</h4>
                    <p>The choice of an allocation method depends on various factors, including:</p>
                    <ul>
                        <li><strong>System load</strong>: Under heavy loads, quicker allocation methods like first-fit may be preferred.</li>
                        <li><strong>Process size and duration</strong>: For systems with processes of varying sizes and execution times, best-fit or worst-fit might be more appropriate.</li>
                        <li><strong>Memory size and constraints</strong>: Systems with limited memory might require more efficient allocation methods like best-fit to optimize space usage.</li>
                    </ul>

                    <pre><code class="language-c">
// Pseudo-code for Best-Fit Memory Allocation
int bestFit(int processSize, int memoryBlocks[], int nBlocks) {
    int bestIdx = -1;
    int minSize = INT_MAX;

    for (int i = 0; i &lt; nBlocks; i++) {
        if (memoryBlocks[i] &gt;= processSize && memoryBlocks[i] &lt; minSize) {
            bestIdx = i;
            minSize = memoryBlocks[i];
        }
    }

    if (bestIdx != -1) {
        memoryBlocks[bestIdx] -= processSize;  // Allocate memory
        return bestIdx;  // Return the index of the block where allocated
    }
    return -1;  // No suitable block found
}
</code></pre>
                </article>
            </article>

            <article id="non-contiguous-memory-allocation">
                <h3>3. Non-Contiguous Memory Allocation</h3>
                <p>Non-contiguous memory allocation allows processes to be allocated memory in separate, non-adjacent blocks or segments. This method improves flexibility and maximizes memory utilization by overcoming the limitations associated with contiguous allocation, such as external fragmentation and the need for compaction.</p>
            </article>
            <article>
                <h4>3.1 Benefits of Non-Contiguous Allocation</h4>
                <p>Key benefits include:</p>
                <ul>
                    <li><strong>Efficient Memory Usage:</strong> More efficient use of memory by fitting small jobs into gaps between allocated memory blocks, reducing fragmentation.</li>
                    <li><strong>Flexibility:</strong> Allows processes to grow in memory size without needing relocation or continuous blocks.</li>
                    <li><strong>Scalability:</strong> Suits systems with fluctuating or unpredictable memory requirements, facilitating easier handling of large and complex applications.</li>
                </ul>
            </article>
            <article>

                <h4>3.2 Techniques of Non-Contiguous Memory Allocation</h4>
                <p>Several techniques facilitate non-contiguous memory allocation:</p>
                <ul>
                    <li><strong>Paging:</strong> Divides memory into fixed-size blocks called pages and stores these pages in available frames in the physical memory.</li>
                    <li><strong>Segmentation:</strong> Divides memory into segments based on logical divisions of programs such as functions, data, etc., where each segment can be of a different size.</li>
                </ul>

                <h5>3.2.1 Paging</h5>
                <p>Paging involves mapping virtual addresses to physical addresses through a page table, which keeps track of where each page resides in physical memory. This method allows each page to be located anywhere in physical memory, significantly reducing fragmentation and simplifying memory management.</p>

                <h5>3.2.2 Segmentation</h5>
                <p>Segmentation maps memory by segments which are logical units such as procedures, arrays, or objects. Unlike paging, which uses fixed-size units, segmentation varies in size, providing a more natural approach to process memory needs. Each segment has its own address space, and a segment table is used to track these addresses.</p>
            </article>
            <article>
                <h4>3.3 Implementation Considerations</h4>
                <p>Implementing non-contiguous memory allocation requires consideration of various factors:</p>
                <ul>
                    <li><strong>Memory Overhead:</strong> Managing multiple small blocks or segments can increase the overhead for maintaining tables such as page tables and segment tables.</li>
                    <li><strong>Performance:</strong> The need to frequently access these tables can impact system performance, particularly if table lookups are not optimized.</li>
                    <li><strong>Complexity:</strong> Higher complexity in managing memory allocation and free space as compared to contiguous methods.</li>
                </ul>

                <pre><code class="language-c">
// Example of a page table entry setup in C-like pseudo-code
struct PageTableEntry {
    unsigned int isValid : 1;     // Validity bit to check if the page is in memory
    unsigned int frameNumber : 31; // Frame number in physical memory
};

// Function to access a virtual address
char accessMemory(int virtualAddress, struct PageTableEntry pageTable[], int pageSize) {
    int pageIndex = virtualAddress / pageSize;          // Get the page index
    int offset = virtualAddress % pageSize;             // Offset within the page
    if (pageTable[pageIndex].isValid) {
        // Calculate physical address and access the memory
        int physicalAddress = pageTable[pageIndex].frameNumber * pageSize + offset;
        return readPhysicalMemory(physicalAddress);
    } else {
        // Handle page fault if page is not in memory
        handlePageFault(pageIndex);
    }
    return 0; // Return a default value in case of a page fault
}
</code></pre>
            </article>

        </main>
        <script> copyright("all"); </script>
    </body>

</html>
