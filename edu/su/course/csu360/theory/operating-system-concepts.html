<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>

        <title>Operating Systems: Concepts - CSU360 - Shoolini U</title>
        <meta name="description" content="Dive into the world of operating systems, from core functions and types to advanced process and memory management, networking, and beyond.">

        <meta property="og:image" content="/logo.png">
        <meta property="og:type" content="article">

        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@divyamohan1993">
        <meta name="twitter:creator" content="@divyamohan1993">
        <meta name="twitter:image" content="/logo.png">

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />

        <meta name="author" content="Divya Mohan">
        <meta name="robots" content="index, follow">

        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                renderMathInElement(document.body, {
                    // customised options
                    // • auto-render specific keys, e.g.:
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\(', right: '\\)', display: false },
                        { left: '\\[', right: '\\]', display: true }
                    ],
                    // • rendering keys, e.g.:
                    throwOnError: false
                });
            });
        </script>
    </head>

    <body>

        <script> header_author("dm"); </script>

        <main>

            <article class="agen-tableofcontents">
                <h2 class="text-center">
                    Concepts of Operating System
                </h2>
            </article>

            <article id="what-is-an-operating-system">
                <h3>What is an Operating System?</h3>
                <p>An Operating System (OS) is a collection of software that manages computer hardware resources and provides common services for computer programs. The OS acts as an intermediary between users and the computer hardware. It enables user interaction with the hardware in an efficient and secure manner, managing tasks such as memory allocation, process scheduling, input/output operations, and file management.</p>
            </article>
            <article id="functions-of-an-operating-system">
                <h3>Functions of an Operating System</h3>
                <ul>
                    <li><strong>Process Management</strong>: Manages the execution of processes, including process scheduling, creation, termination, and synchronization.</li>
                    <li><strong>Memory Management</strong>: Allocates and manages the computer's primary memory, addressing, and swapping between main memory and disk during execution.</li>
                    <li><strong>Storage Management</strong>: Oversees data storage and retrieval on storage devices, managing file systems, directories, and permissions.</li>
                    <li><strong>Device Management</strong>: Controls hardware devices through their respective drivers, managing input/output operations and buffering.</li>
                    <li><strong>Security and Access Control</strong>: Protects system resources from unauthorized access while ensuring data integrity and privacy.</li>
                    <li><strong>User Interface</strong>: Provides interfaces for user interaction, such as command-line interfaces (CLI) or graphical user interfaces (GUI).</li>
                </ul>
            </article>
            <article id="types-of-operating-system">
                <h3>Different Types of Operating System</h3>
                <p>Operating systems can be classified based on their design and operational objectives. Each type serves specific applications, ranging from personal use to managing complex distributed systems.</p>

                <article id="batch-systems">
                    <h4>Batch Systems</h4>
                    <p>Batch operating systems are designed to process jobs without human interaction. Jobs are collected into batches of similar needs and executed sequentially. This approach maximizes resource utilization but may increase wait times for individual jobs.</p>
                </article>
                <article id="multi-programmed-systems">
                    <h4>Multi-programmed Systems</h4>
                    <p>Multi-programmed systems enhance computational efficiency by running multiple programs simultaneously. This is achieved by keeping multiple programs in memory at the same time, utilizing CPU idle time caused by waiting for I/O operations to complete.</p>
                </article>
                <article id="time-sharing-systems">
                    <h4>Time Sharing Systems</h4>
                    <p>Time-sharing systems, or multitasking systems, extend the concept of multiprogramming by allocating a small time slice to each process in rotation. They offer interactive use of the system and rapid response times, allowing multiple users to share system resources simultaneously.</p>
                </article>
                <article id="personal-computer-systems">
                    <h4>Personal Computer Systems</h4>
                    <p>Designed for individual users, these systems focus on ease of use, responsiveness, and user interface design. They support a wide range of applications, from document processing to multimedia entertainment.</p>
                </article>
                <article id="parallel-systems">
                    <h4>Parallel Systems</h4>
                    <p>Parallel operating systems manage multiple processors to perform tasks concurrently, significantly increasing computing power and efficiency. These systems are crucial for high-performance computing tasks that require vast amounts of computational resources.</p>
                </article>
                <article id="distributed-systems">
                    <h4>Distributed Systems</h4>
                    <p>Distributed operating systems manage a collection of independent computers and make them appear to the user as a single coherent system. This setup is key for applications that require processing large datasets across multiple locations.</p>
                </article>
                <article id="real-time-systems">
                    <h4>Real Time Systems</h4>
                    <p>Real-time operating systems (RTOS) are designed to process data as it comes in, typically within a strict time constraint. They are used in systems where processing must occur within a defined time frame, such as embedded systems in automotive or medical devices.</p>
                </article>
            </article>

            <article id="basic-concepts-of-operating-systems">
                <h3>Basic Concepts of Operating Systems</h3>
                <p>Operating Systems (OS) serve as the foundational software that manages computer hardware and software resources, offering common services for computer programs. This documentation aims to explain the intricate details of operating systems, focusing on their critical components, functionality, and the role they play in computer operation.</p>


                <article id="post">
                    <h4>POST (Power-On Self Test)</h4>
                    <p>The Power-On Self Test is the initial set of diagnostic tests performed by the computer's firmware, typically the BIOS (Basic Input/Output System), immediately after the computer is powered on. The purpose of POST is to ensure that the computer's hardware components are functioning correctly before loading the operating system. If the tests detect a failure in a critical component, the computer will not proceed to load the OS, and an error message will be displayed or beep codes will be emitted to indicate the problem.</p>
                </article>

                <article id="main-memory">
                    <h4>Main Memory</h4>
                    <p>Main Memory, also known as RAM (Random Access Memory), is the primary storage area that the CPU (Central Processing Unit) uses to store data and programs while they are being executed. RAM is volatile, meaning it loses its contents when the power is turned off. It plays a crucial role in determining the speed and performance of a computer, as it directly affects how quickly the CPU can access instructions and data needed for processing tasks.</p>
                </article>

                <article id="secondary-storage">
                    <h4>Secondary Storage</h4>
                    <p>Secondary Storage refers to non-volatile storage devices like HDDs (Hard Disk Drives), SSDs (Solid State Drives), and USB flash drives. Unlike main memory, secondary storage retains data even when the computer is turned off. It is used to permanently store data and programs that are not currently in use. The transfer of programs and data from secondary storage to main memory is a critical operation for program execution and data processing.</p>
                </article>

                <article id="virtual-memory">
                    <h4>Virtual Memory</h4>
                    <p>Virtual Memory is a memory management capability of an OS that uses hardware and software to allow a computer to compensate for physical memory shortages, by temporarily transferring data from random access memory (RAM) to disk storage. This process creates an illusion for users of a very large (virtual) memory space. Virtual memory allows for the execution of programs that may not completely fit in the main memory, by swapping pieces of data or program code in and out of the main memory as needed.</p>
                </article>

                <article id="transfer-control-bios-os">
                    <h4>Transfer of Control from the Motherboard's BIOS to the Operating System (OS)</h4>
                    <p>After the POST process concludes successfully, the control of the computer is transferred from the motherboard's BIOS to the Operating System. This transition is facilitated through the reading of the OS stored on the secondary storage device into the main memory. The BIOS identifies the bootable device, reads the boot sector, and executes the bootloader, which then loads the OS into memory, initiating the startup or boot process.</p>
                </article>

                <article id="definition-role-os">
                    <h4>Definition and Role of an Operating System</h4>
                    <p>An Operating System (OS) is system software that manages computer hardware, software resources, and provides common services for computer programs. The OS acts as an intermediary between users and the computer hardware, enabling efficient execution of user applications. It manages hardware resources such as the CPU, memory, and I/O devices, and ensures that different programs and users running on the computer do not interfere with each other.</p>
                </article>

                <article id="interface-users-hardware">
                    <h4>Interface between Users and Computer Hardware</h4>
                    <p>The Operating System provides an interface between the users and the computer hardware, facilitating the execution of user commands and the use of hardware resources. User interfaces can be graphical (GUIs), command-line (CLI), or touch-based, depending on the OS. This abstraction allows users to interact with the computer without needing to understand the complex details of hardware operations.</p>
                </article>

                <article id="layers-system-software">
                    <h4>Layers of System Software</h4>
                    <p>System software is organized in layers, enhancing the manageability and modularity of different components. The topmost layer consists of Application Programs, designed to fulfill end-user requirements. Utilities, providing system management and maintenance functions, form the middle layer. The Operating System constitutes the core layer, interfacing directly with computer hardware, managing resources, and providing services needed by other software layers.</p>
                </article>

                <article id="execution-system-with-without-os">
                    <h4>Execution of a System/Machine with and Without an Operating System</h4>
                    <p>With an OS, a computer can multitask, manage resources efficiently, and provide a user-friendly interface, facilitating the execution of complex tasks and applications. Without an OS, a computer would lack these capabilities, significantly limiting its functionality and requiring manual management of every hardware component for every task, a highly impractical scenario for modern computing needs.</p>
                </article>

                <article id="role-utilities-os">
                    <h4>Role of Utilities within an Operating System</h4>
                    <p>Utilities are system software that perform system management, configuration, analysis, and maintenance tasks. They are essential for the optimal performance and operational efficiency of a computer system. Utilities help in managing files, disks, network settings, and perform system diagnostics and repair functions, thereby supporting the overall functionality of the operating system.</p>
                </article>

                <article id="programs-secondary-memory">
                    <h4>Programs in Secondary Memory and Their Transfer to Main Memory</h4>
                    <p>Programs and data are stored in secondary memory due to its non-volatile nature. When a program is executed, the operating system transfers the program's executable code from secondary memory to main memory. This transfer is necessary because the CPU can only execute instructions that are in main memory. The efficient management of this transfer process is crucial for system performance and responsiveness.</p>
                </article>

                <article id="kernel">
                    <h4>Kernel</h4>
                    <p>The kernel is the core component of an operating system, managing the system's resources and the communication between hardware and software components. It operates at the lowest level and performs functions such as memory management, process scheduling, and handling of input/output operations. The kernel enables applications to share hardware resources without interfering with each other, providing a stable and efficient computing environment.</p>
                </article>

                <article id="multitasking">
                    <h4>Multitasking</h4>
                    <p>Multitasking is the capability of an operating system to execute multiple processes simultaneously. This is achieved by managing how processes share the central processing unit (CPU), ensuring that each process gets a chance to execute within a specific time frame, thereby creating the illusion of concurrent execution. Multitasking increases the efficiency of CPU usage by organizing CPU time among multiple processes.</p>
                </article>

                <article id="basis-of-time-division">
                    <h4>Basis of Time Division</h4>
                    <p>Time division is a fundamental principle used in multitasking operating systems to allocate CPU time among multiple processes. The CPU time is divided into discrete intervals known as time slices or quantum. Each process is allowed to execute for a specified quantum before the next process is scheduled to run. This time-sharing mechanism ensures fair CPU allocation, enabling multiple processes to run seemingly in parallel on a single CPU.</p>
                </article>

                <article id="multiprocessor-os">
                    <h4>Multiprocessor OS</h4>
                    <p>Multiprocessor operating systems are designed to manage and utilize multiple CPUs within a single computer system. These systems provide enhanced performance and reliability by distributing the workload across several processors. Multiprocessor OSes are capable of executing multiple processes simultaneously across different CPUs, significantly improving the system's computational speed and efficiency.</p>
                </article>
            </article>




            <article id="network-and-ip-addresses">
                <h3>Network and IP Addresses</h3>
                <p>An Internet Protocol (IP) address is a numerical label assigned to each device connected to a computer network that uses the Internet Protocol for communication. IP addresses serve two main functions: host or network interface identification and location addressing. Understanding IP addresses is crucial for networking, as they ensure that data reaches its correct destination across networks.</p>

                <article>
                    <h4>IP Address Structure</h4>
                    <p>IP addresses are composed of two main parts: the network part and the host part. The network part identifies the specific network on which a device is located, while the host part identifies the specific device on that network. There are two versions of IP addresses commonly in use: IPv4 and IPv6. IPv4 addresses are 32 bits long, divided into four octets, and represented in decimal format. IPv6 addresses are 128 bits long, divided into eight 16-bit blocks, and represented in hexadecimal format to accommodate a vastly larger number of devices.</p>
                </article>

                <article>
                    <h4>Classes</h4>
                    <p>IP addresses are categorized into classes based on the first octet, which helps in identifying the network size. There are five classes in total, A through E, but for most practical purposes, Classes A, B, and C are most relevant.</p>
                    <ul>
                        <li><strong>Class A</strong>: Supports 16 million hosts on each of 128 networks. It's identified by a first octet range of 1-126.</li>
                        <li><strong>Class B</strong>: Supports 65,000 hosts on each of 16,000 networks. Identified by a first octet range of 128-191.</li>
                        <li><strong>Class C</strong>: Supports 254 hosts on each of 2 million networks. Identified by a first octet range of 192-223.</li>
                    </ul>
                </article>

                <article>
                    <h4>Range</h4>
                    <p>Each IP class has a specific range of addresses that it can accommodate, determined by the network's first octet. The range defines the possible network and host combinations.</p>
                    <!-- <ul>
                        <li><strong>Class A</strong>: 10.0.0.0 to 10.255.255.255</li>
                        <li><strong>Class B</strong>: 128.0.0.0 to 172.31.255.255</li>
                        <li><strong>Class C</strong>: 192.0.0.0 to 192.168.255.255</li>
                        10.0.0.0/8 IP addresses: 10.0.0.0 – 10.255.255.255
                        172.16.0.0/12 IP addresses: 172.16.0.0 – 172.31.255.255
                        192.168.0.0/16 IP addresses: 192.168.0.0 – 192.168.255.255

                        
                    </ul>
                     -->
                    <table class="table table-bordered text-center">
                        <thead>
                            <tr>
                                <th scope="col">&nbsp;</th>
                                <th scope="col">Public IP Range</th>
                                <th scope="col">Private IP Range</th>
                                <th scope="col">Subnet Mask</th>
                                <th scope="col"># of Networks</th>
                                <th scope="col"># of Hosts per Network</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <th scope="row">Class A</th>
                                <td>1.0.0.0 to <br>
                                    127.0.0.0</td>
                                <td>10.0.0.0 to <br>
                                    10.255.255.255</td>
                                <td>255.0.0.0&nbsp;</td>
                                <td>126</td>
                                <td>16,777,214</td>
                            </tr>
                            <tr>
                                <th scope="row">Class B</th>
                                <td>128.0.0.0 to <br>
                                    191.255.0.0</td>
                                <td>172.16.0.0 to <br>
                                    172.31.255.255</td>
                                <td>255.255.0.0</td>
                                <td>16,382</td>
                                <td>65,534</td>
                            </tr>
                            <tr>
                                <th scope="row">Class C</th>
                                <td>192.0.0.0 to <br>
                                    223.255.255.0</td>
                                <td>192.168.0.0 to <br>
                                    192.168.255.255</td>
                                <td>255.255.255.0&nbsp;</td>
                                <td>2,097,150</td>
                                <td>254</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>This structure allows for a hierarchical organization of networks, facilitating routing through the internet.</p>
                </article>

                <article>
                    <h4>Subnetting</h4>
                    <p>Subnetting is a method used to divide a single IP network into multiple smaller networks, enhancing the efficiency and security of network management. It involves borrowing bits from the host part of an IP address to create a subnet mask, which delineates the network and host portions of addresses within the subnet.</p>
                </article>

                <article>
                    <h4>Special IP Addresses</h4>
                    <p>There are special IP addresses reserved for specific purposes, such as private networks, multicast, and loopback testing.</p>
                    <ul>
                        <li><strong>Private IP Addresses</strong>: Reserved for internal use within private networks, not routable on the internet. Includes ranges in Class A (10.0.0.0 to 10.255.255.255), Class B (172.16.0.0 to 172.31.255.255), and Class C (192.168.0.0 to 192.168.255.255).</li>
                        <li><strong>Loopback IP</strong>: 127.0.0.1 is used to test network software without physically sending packets out of the host.</li>
                        <li><strong>Multicast</strong>: Addresses in the range 224.0.0.0 to 239.255.255.255 are used for multicast groups.</li>
                    </ul>
                </article>

                <article>
                    <h4>IPv6</h4>
                    <p>IPv6 addresses the limitation of IPv4 address exhaustion with a much larger address space. It introduces new features such as simplified header format, improved security, and better support for mobile devices and expanding networks.</p>
                </article>

                <article>
                    <h4>Dynamic and Static IP Addresses</h4>
                    <p>IP addresses can be static, permanently assigned to a device, or dynamic, temporarily assigned from a pool of addresses by a DHCP server. Static IP addresses are crucial for servers hosting websites, while dynamic IP addresses are cost-effective for general consumer devices.</p>
                </article>

                <article>
                    <h4>IP Addressing and Routing</h4>
                    <p>Routing is the process of forwarding IP packets from one network to another. Routers use routing tables to determine the best path for

                        packet forwarding, based on the destination IP address.</p>
                </article>

                <article>
                    <h4>Network Address Translation (NAT)</h4>
                    <p>NAT is a method used to modify network address information in IP packet headers while in transit across a traffic routing device. It enables multiple devices on a private network to share a single public IP address, conserving global IP addresses and adding a layer of security.</p>
                </article>

            </article>

            <article id="role-of-the-dispatcher">
                <h3>Some common Differences in Operating Systems</h3>

                <h4 class="my-4">Differences between IPv4 and IPv6</h4>
                <table class="table table-bordered table-striped my-4">
                    <thead class="table-dark">
                        <tr>
                            <th>Feature</th>
                            <th>IPv4</th>
                            <th>IPv6</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Address Length</td>
                            <td>32 bits</td>
                            <td>128 bits</td>
                        </tr>
                        <tr>
                            <td>Address Format</td>
                            <td>Dotted decimal</td>
                            <td>Hexadecimal</td>
                        </tr>
                        <tr>
                            <td>Number of Addresses</td>
                            <td>Approximately 4.3 billion</td>
                            <td>Approximately 3.4 x 10<sup>38</sup></td>
                        </tr>
                        <tr>
                            <td>IPSec Support</td>
                            <td>Optional</td>
                            <td>Mandatory</td>
                        </tr>
                        <tr>
                            <td>Fragmentation</td>
                            <td>Performed by sending and forwarding routers</td>
                            <td>Performed by the sender only</td>
                        </tr>
                        <tr>
                            <td>Header Length</td>
                            <td>Variable, minimum 20 bytes</td>
                            <td>Fixed, 40 bytes</td>
                        </tr>
                        <tr>
                            <td>Checksum</td>
                            <td>Has header checksum</td>
                            <td>No header checksum</td>
                        </tr>
                        <tr>
                            <td>Address Configuration</td>
                            <td>Manual or via DHCP</td>
                            <td>Automatic, Stateless address autoconfiguration (SLAAC), or via DHCPv6</td>
                        </tr>
                        <tr>
                            <td>NAT (Network Address Translation)</td>
                            <td>Widely used</td>
                            <td>Not required due to the large address space</td>
                        </tr>
                        <tr>
                            <td>Broadcast</td>
                            <td>Uses broadcast addresses</td>
                            <td>No broadcast addresses. Uses multicast instead</td>
                        </tr>
                        <tr>
                            <td>ARP (Address Resolution Protocol)</td>
                            <td>Uses ARP to map to MAC address</td>
                            <td>Uses NDP (Neighbor Discovery Protocol) instead</td>
                        </tr>
                    </tbody>
                </table>

                <h4 class="my-4">Differences Between Primary, Secondary, and Virtual Memory</h4>
                <table class="table table-striped table-bordered my-4">
                    <thead class="table-dark">
                        <tr>
                            <th scope="col">Feature</th>
                            <th scope="col">Primary Memory</th>
                            <th scope="col">Secondary Memory</th>
                            <th scope="col">Virtual Memory</th>
                        </tr>
                    </thead>
                    <tbody class="table-group-divider">
                        <tr>
                            <td>Type of Storage</td>
                            <td>Temporary storage (volatile)</td>
                            <td>Permanent storage (non-volatile)</td>
                            <td>A combination of RAM and disk space</td>
                        </tr>
                        <tr>
                            <td>Direct CPU Access</td>
                            <td>Yes</td>
                            <td>No</td>
                            <td>No, managed through OS</td>
                        </tr>
                        <tr>
                            <td>Speed</td>
                            <td>Fast</td>
                            <td>Slower than primary memory</td>
                            <td>Slower than primary memory</td>
                        </tr>
                        <tr>
                            <td>Cost per Bit</td>
                            <td>High</td>
                            <td>Low</td>
                            <td>Dependent on the underlying physical and secondary storage costs</td>
                        </tr>
                        <tr>
                            <td>Capacity</td>
                            <td>Limited</td>
                            <td>Large</td>
                            <td>Effectively large, limited by physical storage</td>
                        </tr>
                        <tr>
                            <td>Volatility</td>
                            <td>Volatile</td>
                            <td>Non-volatile</td>
                            <td>Depends on the backing storage</td>
                        </tr>
                        <tr>
                            <td>Purpose</td>
                            <td>To store data and instructions temporarily for quick access by CPU</td>
                            <td>To store data and programs permanently</td>
                            <td>To extend the apparent amount of physical memory</td>
                        </tr>
                        <tr>
                            <td>Technology Used</td>
                            <td>RAM, ROM</td>
                            <td>HDD, SSD, USB drives, CDs</td>
                            <td>Combination of RAM and disk space</td>
                        </tr>
                        <tr>
                            <td>Data Retention</td>
                            <td>Loses data on power off</td>
                            <td>Retains data without power</td>
                            <td>Depends on the physical storage component</td>
                        </tr>
                        <tr>
                            <td>Usage</td>
                            <td>Active processes and operating system components</td>
                            <td>Long-term storage and backup</td>
                            <td>Running large applications on systems with limited physical memory</td>
                        </tr>
                        <tr>
                            <td>Accessibility</td>
                            <td>Directly by the processor</td>
                            <td>Through I/O operations</td>
                            <td>Indirectly, managed by OS</td>
                        </tr>
                    </tbody>
                </table>
            </article>



            <article id="role-of-the-dispatcher">
                <h3>Role of the Dispatcher in the Process State Change</h3>
                <p>The dispatcher is a component of the operating system's scheduler responsible for the actual process of context switching from one process to another. Its primary role is to switch the CPU from the context of a currently running process to the context of the next process to run, based on the scheduling algorithm in use.</p>
                <p>When the scheduler decides to execute a different process (during a state change from Ready to Running), the dispatcher performs the following actions:</p>
                <ul>
                    <li>Saves the state of the currently running process (including its program counter, CPU registers, and other execution contexts) into its Process Control Block (PCB).</li>
                    <li>Loads the state of the next process to run from its PCB into the CPU registers, updating the program counter to resume its execution.</li>
                    <li>Transfers control to the selected process, effectively changing the process state to Running.</li>
                </ul>
                <p>This mechanism is crucial for multitasking, allowing the OS to manage multiple processes efficiently, ensuring that each process gets a fair share of CPU time, and facilitating the seamless execution of numerous tasks.</p>
            </article>

            <article id="introduction-to-process-creation-and-states">
                <h3>Introduction to Process Creation and States</h3>
                <p>Process creation is a fundamental operation in operating systems, marking the inception of a new process. This involves allocating a unique Process ID (PID), allocating memory, and initializing process control structures. Processes transition through various states from creation to termination, influenced by scheduling decisions and system events. These states include New, Ready, Running, and Blocked/Wait, each reflecting the process's current status in the system.</p>

                <article id="process-vs-processing">
                    <h4>Process vs. Processing</h4>
                    <p>A process is an instance of a program in execution, characterized by its code, data, and state. It is an active entity with a program counter indicating the next instruction to execute and a set of associated resources. Processing, on the other hand, refers to the series of actions executed by the CPU to perform a task, such as executing instructions, performing calculations, and managing data transfers.</p>
                    <p>A <strong>process</strong> is a dynamic instance of an executable program, with its current state, data, and executing context, such as the values in its program counter, registers, and memory. It represents a single task or program in execution, encapsulated within its own virtual address space and system resources allocated by the operating system (OS). The OS manages processes through various states of execution, ensuring efficient CPU usage and multitasking capabilities.</p>
                    <p><strong>Processing</strong>, conversely, refers to the action performed by a computer's CPU—the execution of instructions that make up a program or process. Processing involves arithmetic calculations, logical operations, data transfer, and control flow management, executing the sequence of instructions that constitute the software being run. While a process is an entity, processing is an activity, signifying the work the CPU undertakes to perform tasks and execute programs.</p>
                </article>

                <article id="definition-of-a-process">
                    <h4>Definition of a Process</h4>
                    <p>A process is a program in execution, encompassing the program code, its current activities, and the resources assigned to it by the operating system. Each process is uniquely identified and managed by the OS, facilitating multitasking by allowing multiple processes to share CPU and system resources efficiently.</p>
                </article>

                <article>
                    <h4>Process Scheduling</h4>
                    <p>Process scheduling is a fundamental operating system function that manages the execution of processes by determining which process runs at any given time. It optimizes the use of the CPU by allocating resources among various processes, ensuring efficient execution, responsiveness, and system throughput. The scheduling strategy may vary depending on the specific requirements of the operating system and the tasks it supports.</p>
                </article>

                <article id="attributes-of-processes">
                    <h4>Attributes of Processes</h4>
                    <p>Each process in an operating system is characterized by a set of attributes, including:</p>
                    <ul>
                        <li><strong>Process ID (PID)</strong>: A unique identifier assigned by the operating system to distinguish each process.</li>
                        <li><strong>Process State</strong>: The current state of the process (e.g., New, Ready, Running).</li>
                        <li><strong>Process Priority</strong>: Determines the order in which processes are scheduled for execution, affecting the process's access to CPU time.</li>
                        <li><strong>Program Counter (PC)</strong>: Holds the address of the next instruction to be executed for this process.</li>
                        <li><strong>Memory Pointers</strong>: References to the process's code, data, and stack in memory.</li>
                        <li><strong>CPU Registers</strong>: The current working variables of the process.</li>
                        <li><strong>General Purpose Registers</strong>: Store temporary data and are used during instruction execution.</li>
                        <li><strong>Accounting Information</strong>: Usage statistics like CPU time consumed.</li>
                    </ul>
                    <p>These attributes are managed through the Process Control Block (PCB), which serves as the kernel's primary data structure for process management.</p>
                </article>


                <article id="explanation-of-program-counter-pc">
                    <h4>Program Counter (PC)</h4>
                    <p>The Program Counter (PC) is a component of the CPU that stores the memory address of the next instruction to be executed by a process. After each instruction is executed, the PC is updated to point to the next instruction. The PC ensures the sequential execution of a program's instructions, guiding the CPU through a process's code.</p>
                </article>




                <article id="process-control-block-pcb">
                    <h4>Process Control Block (PCB)</h4>
                    <p>The Process Control Block is a data structure maintained by the operating system for every process. The PCB contains essential information about the process, including its process ID, process state, program counter, CPU registers, scheduling information, memory management information, and accounting information. The PCB is crucial for the OS to manage all processes efficiently.</p>
                </article>


                <article id="process-state-diagram">
                    <h3>Process State Diagram</h3>
                    <p>The process state diagram visually represents the transitions between the various states of a process throughout its lifecycle. It illustrates how a process moves from the New state to the Ready state, then to Running, possibly cycling through Waiting (if it needs to wait for resources or events), and finally moving to the Terminated state upon completion.</p>
                    <p>The diagram is crucial for understanding how the OS manages processes, scheduling them for execution, and handling them when they are no longer active.</p>
                    <figure class="text-center">
                        <img src="../img/os-process-state-diagram.png" class="img-fluid mx-auto d-block" alt="Operating System Process States">
                        <figcaption>An illustrative diagram showcasing the various states of an operating system process, including transitions like 'New', 'Ready', 'Running', 'Waiting', and 'Terminated', to explain the lifecycle of a process within an operating system.</figcaption>
                    </figure>
                    <ul>
                        <li>A circular or looped diagram can illustrate the lifecycle of a process, showing arrows from New to Ready (initiated by the long-term scheduler), from Ready to Running (by the short-term scheduler), from Running to Waiting/Blocked (when a process waits for I/O or resources), and from Waiting/Blocked back to Ready (once the wait is over).</li>
                        <li>Additional arrows show processes being terminated from the Running state or being swapped in and out of memory by the medium-term scheduler.</li>
                    </ul>
                </article>


                <article id="process-states-and-lifecycle">
                    <h3>Process States and Lifecycle</h3>
                    <p>The lifecycle of a process in an operating system is marked by its transition through several states from creation to termination. These states are:</p>
                    <ul>
                        <li><strong>New</strong>: The process is being created. This is the initial phase where the OS allocates memory and other resources.</li>
                        <li><strong>Ready</strong>: The process has all necessary resources and is waiting to be assigned to the CPU for execution.</li>
                        <li><strong>Running</strong>: The process is currently being executed on the CPU.</li>
                        <li><strong>Waiting</strong>: The process is not executing because it is waiting for some event or resource to become available.</li>
                        <li><strong>Terminated</strong>: The process has finished execution and is waiting to be removed from the system by the OS, releasing all allocated resources.</li>
                    </ul>
                    <p>These states ensure that the OS efficiently manages CPU time among multiple processes, balancing system load and responding to user and system tasks dynamically.</p>
                </article>

                <article id="process-state-transitions">
                    <h4>Process State Transitions</h4>
                    <p>Processes undergo several state transitions in their lifecycle, managed by the operating system schedulers:</p>
                    <ul>
                        <li><strong>From New to Ready</strong>: Once the long-term scheduler decides to admit a new process into the system, it transitions from the New state to the Ready state, where it waits for the short-term scheduler to allocate the CPU.</li>
                        <li><strong>From Ready to Running</strong>: The short-term scheduler selects a process from the Ready queue and allocates the CPU to it, changing its state to Running.</li>
                        <li><strong>From Running to Waiting/Blocked</strong>: If the process requires an I/O operation or needs to wait for a resource, it transitions from Running to the Waiting/Blocked state, releasing the CPU.</li>
                        <li><strong>From Waiting/Blocked to Ready</strong>: Once the I/O operation is complete or the awaited resource becomes available, the process transitions back to the Ready state, waiting for the CPU to be allocated again.</li>
                    </ul>
                    <p>These transitions are critical for multitasking and efficient CPU utilization, ensuring that processes do not waste valuable CPU time waiting for resources or I/O operations to complete.</p>
                </article>

                <article id="dispatching">
                    <h3>Dispatching</h3>
                    <p>Dispatching is the process by which the CPU scheduler selects a process from the ready queue and assigns the CPU to it. The dispatcher is responsible for the context switch, switching the processor from executing one process to executing another. It involves loading the context (state and data) of the selected process into the CPU registers and updating various management structures within the operating system. Dispatching is a crucial step in process scheduling, enabling multitasking and efficient use of CPU resources.</p>
                </article>

                <article id="scheduler-types">
                    <h4>Scheduler Types</h4>
                    <p>The operating system employs different types of schedulers to manage processes through their lifecycle, each with a specific role:</p>
                    <ul>
                        <li><strong>Long-term Scheduler</strong> (or Job Scheduler): Decides which jobs or processes are admitted to the system for processing. It controls the degree of multiprogramming, i.e., the number of processes in memory. The long-term scheduler determines when to move new processes to the ready state.</li>
                        <li><strong>Short-term Scheduler</strong> (or CPU Scheduler): Selects from among the processes that are ready to execute and allocates the CPU to one of them. It's invoked frequently and must be fast, as it affects the system's responsiveness and performance directly.</li>
                        <li><strong>Medium-term Scheduler</strong> (or Swapper): Temporarily removes processes from active contention for the CPU to control the level of multiprogramming. This scheduler may swap out processes to disk, moving them from the waiting state back to the ready state, or vice versa, to balance the mix of CPU-bound and I/O-bound processes.</li>
                    </ul>
                </article>

                <article id="long-term-scheduler-lts">
                    <h4>Long Term Scheduler (LTS)</h4>
                    <p>The Long Term Scheduler, or Job Scheduler, controls the admission of processes into the system. It decides which processes are introduced into the pool of executable tasks based on policies that might consider the mix of CPU-bound and I/O-bound processes, the priority of tasks, or other criteria. The LTS plays a crucial role in determining the degree of multiprogramming, directly impacting system performance and resource utilization.</p>
                </article>

                <article id="short-term-scheduler-sts">
                    <h4>Short Term Scheduler (STS)</h4>
                    <p>The Short Term Scheduler, or CPU Scheduler, selects from among the processes in the Ready state and allocates the CPU to one of them. This scheduler operates more frequently than the LTS, making rapid decisions to ensure the efficient use of the CPU. The STS can employ various scheduling algorithms to determine the execution order of processes.</p>
                </article>

                <article id="priority-based-process-replacement">
                    <h4>Priority-based Process Replacement</h4>
                    <p>In systems employing priority scheduling, processes may be preempted or replaced based on priority. A running process with a lower priority might be interrupted and moved to the Ready or Waiting state if a higher priority process becomes ready to execute. This mechanism ensures that critical tasks receive the CPU time they require, optimizing the system's responsiveness to priority changes.</p>
                </article>

                <article id="scheduler-queues-and-their-functions">
                    <h4>Scheduler Queues and Their Functions</h4>
                    <p>Processes in an operating system are placed in various queues, each managed by different schedulers and serving unique functions:</p>
                    <ul>
                        <li><strong>Job Queue</strong>: Holds all the processes in the system. The LTS selects processes from this queue to load into the ready queue.</li>
                        <li><strong>Ready Queue</strong>: Contains all processes that are in memory and ready to execute but are waiting for CPU time. The STS selects processes from this queue for execution.</li>
                        <li><strong>Waiting Queue</strong>: Contains processes that are waiting for an event or I/O operation to complete. Once the waiting condition is met, processes are moved back to the ready queue.</li>
                    </ul>
                    <p>These queues are essential for managing process states and transitions, facilitating efficient scheduling and execution.</p>
                </article>

                <article id="time-slice-allocation-for-processes">
                    <h4>Time Slice Allocation for Processes</h4>
                    <p>Time slice allocation, also known as quantum, is a critical aspect of the Round Robin (RR) scheduling algorithm used by the STS. A time slice is a fixed time period allocated to each process in the ready queue before the CPU is switched to another process. The allocation of time slices ensures that each process gets a fair share of CPU time, preventing any single process from monopolizing the CPU. The length of the time slice can significantly affect system performance, with shorter slices leading to higher context switch overhead but more responsive system behavior, and longer slices reducing context switch overhead but potentially leading to less responsive behavior for interactive processes.</p>
                </article>

                <article id="context-switching">
                    <h4>Context Switching</h4>
                    <p>Context switching is the process of saving the state of a currently running process and restoring the state of another process to resume its execution. This operation is fundamental to multitasking, allowing the CPU to switch rapidly between processes and utilize time efficiently. Context switching involves overhead, as the system must save and load register contents, stack pointers, and program counters, but it is essential for achieving concurrent execution of multiple processes.</p>
                </article>

                <article id="scheduling-algorithms">
                    <h4>Scheduling Algorithms</h4>
                    <p>Scheduling algorithms are strategies employed by the STS to determine which process in the Ready queue should be allocated the CPU next. Common algorithms include:</p>
                    <ul>
                        <li><strong>First-Come, First-Served (FCFS)</strong>: Processes are scheduled according to their arrival time.</li>
                        <li><strong>Shortest Job First (SJF)</strong>: Processes with the shortest estimated run time are scheduled first.</li>
                        <li><strong>Round Robin (RR)</strong>: Processes are scheduled in a circular order, using time slices called quanta.</li>
                        <li><strong>Priority Scheduling</strong>: Processes are scheduled based on priority, with higher priority processes being executed first.</li>
                    </ul>
                    <p>Each algorithm has its advantages and trade-offs, affecting factors like throughput, turnaround time, and responsiveness We will learn about them in detail in <a href="scheduling-algorithms">next articles.</a>
                    <p>
                </article>


                <article id="different-types-of-time-related-to-processes">
                    <h3>Different Types of Time Related to Processes</h3>
                    <p>In process scheduling, several time metrics are crucial for analyzing system performance and the efficiency of scheduling algorithms. Understanding these metrics is essential for optimizing process execution and system throughput.</p>
                </article>

                <article>
                    <h4>Arrival Time</h4>
                    <p>Arrival Time refers to the time at which a process enters the system or becomes ready for execution. It's the point when a process is added to the Ready Queue.</p>
                </article>

                <article>
                    <h4>Completion Time</h4>
                    <p>Completion Time is the moment a process completes its execution and exits the system. It marks the end of the process's lifecycle.</p>
                </article>

                <article>
                    <h4>Burst Time</h4>
                    <p>Burst Time, also known as Execution Time, is the total time a process requires the CPU for its execution. It doesn't include waiting or I/O operations time.</p>
                </article>

                <article>
                    <h4>Turnaround Time</h4>
                    <p>Turnaround Time is the total time taken for a process from its arrival to its completion. It includes all bursts of execution, waiting time, and performing I/O operations. Mathematically, it's calculated as: <br>
                        $$\text{Turnaround Time} = \text{Completion Time} - \text{Arrival Time}$$</p>
                </article>

                <article>
                    <h4>Waiting Time</h4>
                    <p>Waiting Time is the total time a process spends in the Ready Queue waiting for CPU time. It's calculated by subtracting the total burst time of the process from its turnaround time. <br>
                        $$\text{Waiting Time} = \text{Turnaround Time} - \text{Total Burst Time}$$</p>
                </article>

                <article>
                    <h4>Response Time</h4>
                    <p>Response Time is the interval from the arrival time of a process to the time of the first response by the CPU. Essentially, it's the duration before a process starts execution. For non-preemptive systems, response time and waiting time are identical.</p>
                </article>

                <article>
                    <h4>Calculations and Examples Related to Process Times</h4>
                    <p>Let's consider a simple system with three processes to demonstrate how these times are calculated:</p>
                    <ul>
                        <li><strong>Process 1</strong>: Arrival Time = 0, Burst Time = 5</li>
                        <li><strong>Process 2</strong>: Arrival Time = 2, Burst Time = 3</li>
                        <li><strong>Process 3</strong>: Arrival Time = 4, Burst Time = 1</li>
                    </ul>
                    <p>Assuming a First-Come, First-Served (FCFS) scheduling algorithm:</p>
                    <ul>
                        <li><strong>Completion Time</strong> for Process 1 is at time 5, Process 2 is at time 8 (5 + 3), and Process 3 is at time 9 (8 + 1).</li>
                        <li><strong>Turnaround Time</strong> for Process 1 is \(5 - 0 = 5\), for Process 2 is \(8 - 2 = 6\), and for Process 3 is \(9 - 4 = 5\).</li>
                        <li><strong>Waiting Time</strong> for Process 1 is \(5 - 5 = 0\), for Process 2 is \(6 - 3 = 3\), and for Process 3 is \(5 - 1 = 4\).</li>
                        <li><strong>Response Time</strong> in a FCFS system is identical to the Waiting Time for each process.</li>
                    </ul>
                </article>

            </article>

        </main>
        <script> copyright("all"); </script>
    </body>

</html>