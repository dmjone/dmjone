<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>

        <title>Concurrent Programming - CSU360 - Shoolini University</title>
        <meta name="description" content="Learn about Concurrent Programming with CSU360 and understand the principles of concurrent programming and how to write concurrent programs.">


        <meta property="og:image" content="/logo.png">
        <meta property="og:type" content="article">

        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@divyamohan1993">
        <meta name="twitter:creator" content="@divyamohan1993">
        <meta name="twitter:image" content="/logo.png">

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />

        <meta name="author" content="Divya Mohan">
        <meta name="robots" content="index, follow">

        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                renderMathInElement(document.body, {
                    // customised options
                    // • auto-render specific keys, e.g.:
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\(', right: '\\)', display: false },
                        { left: '\\[', right: '\\]', display: true }
                    ],
                    // • rendering keys, e.g.:
                    throwOnError: false
                });
            });
        </script>
    </head>

    <body>

        <script> header_author("dm"); </script>

        <main>

            <article class="agen-tableofcontents">
                <h2 class="text-center">
                    Concurrent Programming
                </h2>
            </article>

            <article id="concurrent-programming-introduction">
                <h3>1. Introduction to Concurrent Programming</h3>
                <p>Concurrent programming refers to the development of software in which multiple computations or processes are executed simultaneously. Leveraging the capabilities of modern multi-core processors, this programming paradigm aims to improve the efficiency and performance of applications by handling several tasks at once.</p>
            </article>

            <article>
                <h4>1.1 Basics of Concurrency</h4>
                <p>Concurrency involves multiple sequences of operations running in overlapping periods. It is essential for scenarios requiring simultaneous data processing, user interactions, or real-time computation tasks.</p>
                <p>The primary goal of concurrency is to increase the responsiveness and computational throughput of software systems by utilizing the computing resources optimally.</p>
            </article>

            <article>
                <h4>1.2 Threads and Processes</h4>
                <p>At the core of concurrent programming are the concepts of threads and processes:</p>
                <ul>
                    <li><strong>Process</strong>: A program in execution, which is more than the code itself—it includes current activity represented by program counter, process stack, registers, and allocated memory.</li>
                    <li><strong>Thread</strong>: The smallest sequence of programmed instructions that can be managed independently by a scheduler, which is typically a part of the operating system. Threads within the same process share the process resources but can execute independently.</li>
                </ul>
            </article>

            <article>
                <h4>1.3 Thread Safety and Synchronization</h4>
                <p>Thread safety is crucial in concurrent programming to prevent race conditions where two threads manipulate shared data concurrently. The following synchronization mechanisms are commonly used:</p>
                <ul>
                    <li><strong>Mutexes</strong>: Mutual exclusion object to prevent simultaneous access to a critical section by multiple threads.</li>
                    <li><strong>Semaphores</strong>: A signaling mechanism to control access based on available counts. It helps in managing resource counters.</li>
                    <li><strong>Locks</strong>: Prevents concurrent access to a block of code by ensuring that only one thread can execute the block at any given time.</li>
                </ul>
            </article>

            <article>
                <h4>1.4 Challenges in Concurrent Programming</h4>
                <p>Concurrency introduces several challenges:</p>
                <ul>
                    <li><strong>Deadlocks</strong>: A state where two or more threads are waiting indefinitely for each other to release resources they need.</li>
                    <li><strong>Livelocks</strong>: Threads continuously change their state in response to other threads without making any actual progress.</li>
                    <li><strong>Starvation</strong>: A condition where a thread never gets a chance to execute due to the continuous interference of other higher priority threads.</li>
                </ul>
                <p>Understanding these challenges is vital for developing robust concurrent applications.</p>
            </article>

            <article>
                <h4>1.5 Concurrency Models</h4>
                <p>Various models are employed to handle concurrency in software systems:</p>
                <ul>
                    <li><strong>Parallel Computing</strong>: Divides a problem into many small ones, each of which is solved concurrently.</li>
                    <li><strong>Event-Driven Programming</strong>: Manages and processes events in an asynchronous manner.</li>
                    <li><strong>Actor Model</strong>: Treats "actors" as the universal primitives of concurrent computation. Each actor can process messages sequentially, avoiding the need for explicit locks.</li>
                </ul>
            </article>

            <article>
                <h5>1.5.1 Programming with the Actor Model</h5>
                <p>The Actor Model provides a high level of abstraction suitable for dealing with system-level concurrency and can be implemented using various frameworks, like Akka in Scala and Java.</p>
                <pre><code class="language-scala">// Scala example using Akka
val actor = system.actorOf(Props[HelloActor], "helloactor")
actor ! "hello"
actor ! "buenos dias"
</code></pre>
                <p>This snippet shows basic actor creation and message passing in Akka.</p>
            </article>

            <article id="concurrent-programming-race-conditions">
                <h3>2. Race Conditions in Concurrent Programming</h3>
                <p>Race conditions occur in concurrent systems when the outcome of a process depends on the sequence or timing of uncontrollable events such as thread execution orders. These conditions lead to erratic behavior and unpredictable results. The primary types of race conditions involve conflicts in data access, notably read-read, read-write, write-read, and write-write problems.</p>
            </article>
            
            <article>
                <h4>2.1 Read-Read Problem</h4>
                <p>This type of race condition is generally benign since multiple threads or processes are only reading data, and no modification occurs. However, issues might arise if the data is updated during the sequence of reads, leading to inconsistent reads if not managed properly.</p>
            </article>
            
            <article>
                <h4>2.2 Read-Write Problem</h4>
                <p>The read-write problem arises when at least one thread modifies (writes) data while another thread reads the same data concurrently. This situation can lead to a scenario where the reader accesses data before the write is completed, resulting in dirty reads or inconsistent state visibility.</p>
            </article>
            
            <article>
                <h4>2.3 Write-Read Problem</h4>
                <p>In a write-read race condition, a thread that is writing data could be preempted mid-operation by a thread that begins reading the same data. The reader may then obtain partially updated data, which can lead to erroneous program behavior and corrupt state observations.</p>
            </article>
            
            <article>
                <h4>2.4 Write-Write Problem</h4>
                <p>The write-write race condition occurs when two threads or processes attempt to write to the same data location concurrently. This leads to a conflict, as only one of the writes can prevail, potentially causing data corruption or loss of data integrity, with the last write overwriting all previous writes.</p>
            </article>
                
            <article>
                <h4>2.5 Advanced Synchronization Techniques</h4>
                <p>Advanced synchronization techniques provide robust solutions to manage race conditions more effectively:</p>
                <ul>
                    <li><strong>Barriers</strong>: A synchronization method where each thread must wait at a certain point until all participating threads have reached this barrier.</li>
                    <li><strong>Read-Write Locks</strong>: Specialized locks that allow multiple readers simultaneous access but restrict access to a single writer at a time, thereby increasing efficiency when read operations are more frequent than writes.</li>
                    <li><strong>Condition Variables</strong>: These are used to block a thread until a particular condition is met, facilitating more complex synchronization that cannot be handled with mutexes alone.</li>
                </ul>
            </article>
            <article>
                <h4>2.6 Testing and Debugging Tools</h4>
                <p>Effective tools and practices are essential for identifying and resolving race conditions:</p>
                <ul>
                    <li><strong>Static Code Analysis</strong>: Tools that analyze source code before execution to detect potential race conditions and other concurrency-related issues.</li>
                    <li><strong>Dynamic Analysis Tools</strong>: These tools monitor the program during runtime to detect race conditions and deadlocks, with examples including Valgrind's Helgrind and Intel's Inspector.</li>
                    <li><strong>Unit Testing for Concurrency</strong>: Writing unit tests that specifically target and simulate concurrent executions can help in early detection of synchronization issues.</li>
                </ul>
            </article>
            <article>
                <h4>2.7 Best Practices in Concurrent Programming</h4>
                <p>Adhering to best practices can significantly reduce the incidence of race conditions:</p>
                <ul>
                    <li><strong>Minimize Shared Data</strong>: By limiting the amount of shared data or accessing shared data in immutable ways, you can reduce the need for synchronization.</li>
                    <li><strong>Keep Synchronization Segments Small</strong>: The smaller the critical section (the code that must be executed atomically), the less opportunity there is for creating race conditions.</li>
                    <li><strong>Prefer Higher Level Concurrency Mechanisms</strong>: Using high-level constructs like concurrent collections, and frameworks (e.g., Java's Concurrent API) can abstract away many of the complexities of direct thread management and synchronization.</li>
                </ul>
            </article>
        </main>
        <script> copyright("all"); </script>
    </body>

</html>
