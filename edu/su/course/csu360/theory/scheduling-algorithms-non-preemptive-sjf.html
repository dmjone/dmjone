<!-------------------------- Â© 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>

        <title>Scheduling Algorithms: NP-SJF - CSU360 - Shoolini University</title>
        <meta name="description" content="Unlock the NP-SJF with CSU360, covering introductory topics and its formulas. Perfect for developing concept of First Come First Serve algorithm.">


        <meta property="og:image" content="/logo.png">
        <meta property="og:type" content="article">

        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@divyamohan1993">
        <meta name="twitter:creator" content="@divyamohan1993">
        <meta name="twitter:image" content="/logo.png">

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />

        <meta name="author" content="Divya Mohan">
        <meta name="robots" content="index, follow">
    </head>

    <body>

        <script> header_author("dm"); </script>

        <main>

            <article class="agen-tableofcontents">
                <h2 class="text-center">
                    Scheduling Algorithms: Non-Preemptive Shortest Job First
                </h2>
            </article>

            <article id="non-preemptive-sjf">
                <h3 class="fw-bold">Non-Preemptive Shortest Job First (SJF) Scheduling</h3>
                <p>Non-Preemptive Shortest Job First (SJF) Scheduling is a CPU scheduling algorithm that selects the process with the shortest execution time to execute next. This approach optimizes waiting time and turnaround time but can lead to starvation of longer processes. It is non-preemptive, meaning once a process starts execution, it runs till completion without being interrupted by other processes.</p>

                <h4>Concepts and Operation</h4>
                <p>In Non-Preemptive SJF, the CPU is allocated to the process with the smallest execution time among all the available processes in the ready queue. This decision is made whenever the CPU becomes idle, with no preemption after a process has started running.</p>
                <ul class="list-unstyled">
                    <li><strong>Advantages</strong>: Minimizes average waiting time and turnaround time, leading to efficient processing for short jobs.</li>
                    <li><strong>Disadvantages</strong>: Can cause starvation for longer processes; not ideal for time-sharing environments.</li>
                    <li><strong>Application Scenarios</strong>: Best suited for batch jobs where completion time is prioritized and process interruption is minimal or non-existent.</li>
                </ul>

                <h4>Scheduling Criteria</h4>
                <p>Scheduling criteria include factors like CPU utilization, throughput, turnaround time, waiting time, and response time. In Non-Preemptive SJF, the primary focus is on minimizing the average waiting and turnaround times.</p>
                <ul class="list-unstyled">
                    <li>Turnaround Time = Completion Time - Arrival Time</li>
                    <li>Waiting Time = Turnaround Time - Burst Time, where <em>Burst Time</em> is the time required by a process for its execution.</li>
                </ul>
                <h4>Process Arrival and Selection</h4>
                <p>Processes arrive in the ready queue at different times. The scheduler selects the process with the shortest burst time that is available in the ready queue. This selection process occurs whenever the CPU becomes idle.</p>

                <h4>Implementation Considerations</h4>
                <p>Implementing Non-Preemptive SJF requires maintaining a list of ready processes and sorting them by their burst time. A practical implementation detail involves the decision-making point, which is typically when a process finishes execution or a new process enters the system.</p>

                <h4>Algorithm</h4>
                <p>The core algorithm involves the following steps:</p>
                <ol>
                    <li>Upon process arrival, add it to the ready queue.</li>
                    <li>When the CPU is idle, select the process with the shortest burst time from the ready queue.</li>
                    <li>Execute the selected process until completion.</li>
                    <li>Repeat the process until all processes are executed.</li>
                </ol>

                <h4>Example Scenario</h4>
                <p>Consider four processes with the following burst times: P1(6), P2(8), P3(7), P4(3). Following Non-Preemptive SJF, P4 is selected first due to its shortest burst time, followed by P1, P3, and P2.</p>

                <h4>Mathematical Analysis</h4>
                <p>To analyze the efficiency of Non-Preemptive SJF, we calculate the average waiting time and average turnaround time using the formulas mentioned previously in the <a href="scheduling-algorithms-fcfs">FCFS article</a> The goal is to minimize these metrics for enhanced performance.</p>
            </article>


            <article id="gantt-chart-example">
                <h4 class="fw-bold">Gantt Chart</h4>
                <p>
                    To illustrate the creation of a Gantt chart based on a process table for Non-Preemptive SJF scheduling, let's take the example with a process table and perform Gantt chart representation.
                </p>

                <article>
                    <h4>Given Process Table</h4>
                    <p>
                        Consider the updated process table, where each process has a specified arrival and burst time.
                    </p>
                    <pre><code class="language-markdown">Process Table:
| Process | Arrival Time | Burst Time |
|---------|--------------|------------|
| P1      | 0            | 3          |
| P2      | 2            | 4          |
| P3      | 4            | 2          |
</code></pre>
                </article>

                <article>
                    <h4>Step-by-Step Gantt Chart Construction</h4>
                    <ul class="list-unstyled">
                        <li><strong>Step 1:</strong> At time 0, start with P1, which is the only process available.</li>
                        <li><strong>Step 2:</strong> At time 3, P2 has arrived but not P3. Since we are following SJF, and P2 is the only process available, we proceed with P2.</li>
                        <li><strong>Step 3:</strong> By the time P2 completes at time 7, P3 is available. We then proceed with P3, as it is the only remaining process.</li>
                        <li><strong>Step 4:</strong> Each process's start and end time are marked on the Gantt chart, indicating the execution order and duration.</li>
                    </ul>
                </article>

                <article>
                    <h4>Visual Representation</h4>
                    <pre><code class="language-markdown">Gantt Chart Representation:
Time    0    3    7    9
        |----|----|----|
Process | P1 | P2 | P3 |
</code></pre>
                    <p>
                        This Gantt chart accurately represents the execution order and duration for each process based on the updated process table.
                    </p>
                </article>

                <article>
                    <h4>Gantt Chart Interpretation</h4>
                    <p>
                        This visual representation demonstrates the Non-Preemptive SJF scheduling algorithm's approach to prioritizing processes based on burst time to reduce the average waiting and turnaround times. It illustrates how the process with the shortest burst time is selected next, provided it has arrived, ensuring an efficient execution sequence.
                    </p>
                </article>
            </article>

            <article id="sjf-example">
                <h3 class="fw-bold">Non-Preemptive SJF Scheduling Example</h3>
                <p>Consider a process table with 5 processes to demonstrate Non-Preemptive SJF scheduling, calculate key metrics, and illustrate a Gantt chart.</p>
                <table class="table table-responsive table-striped table-bordered">
                    <tr>
                        <th>Process</th>
                        <th>Arrival Time (AT)</th>
                        <th>Burst Time (BT)</th>
                    </tr>
                    <tr>
                        <td>P1</td>
                        <td>0</td>
                        <td>6</td>
                    </tr>
                    <tr>
                        <td>P2</td>
                        <td>2</td>
                        <td>8</td>
                    </tr>
                    <tr>
                        <td>P3</td>
                        <td>1</td>
                        <td>7</td>
                    </tr>
                    <tr>
                        <td>P4</td>
                        <td>3</td>
                        <td>3</td>
                    </tr>
                    <tr>
                        <td>P5</td>
                        <td>5</td>
                        <td>4</td>
                    </tr>
                </table>
                <article>
                    <h4>Gantt Chart Representation</h4>
                    <p>The Gantt chart for these processes, scheduled according to Non-Preemptive SJF, is as follows:</p>
                    <pre><code class="language-markdown">
Time        0    6    13   16   20   28
            |----|----|----|----|----|
Process     | P1 | P3 | P4 | P5 | P2 |
</code></pre>
                </article>
                <article>
                    <h4 class="mt-4">Calculating Non-Preemptive SJF Metrics</h4>
                    <p>Next, we'll calculate the Completion Time (CT), Turnaround Time (TAT), and Waiting Time (WT) for each process, followed by the average TAT and WT.</p>
                </article>
                <article>
                    <h5 class="mt-4">Completion Time (CT)</h5>
                    <p>To find the CT for each process:</p>
                    <ul class="list-unstyled">
                        <li>\(CT_{P1} = AT_{P1} + BT_{P1} = 0 + 6 = 6\)</li>
                        <li>\(CT_{P3} = CT_{P1} + BT_{P3} = 6 + 7 = 13\)</li>
                        <li>\(CT_{P4} = CT_{P3} + BT_{P4} = 13 + 3 = 16\)</li>
                        <li>\(CT_{P5} = CT_{P4} + BT_{P5} = 16 + 4 = 20\)</li>
                        <li>\(CT_{P2} = CT_{P5} + BT_{P2} = 20 + 8 = 28\)</li>
                    </ul>
                </article>
                <article>
                    <h5 class="mt-4">Turnaround Time (TAT)</h5>
                    <p>To find the TAT for each process (\(TAT = CT - AT\)):</p>
                    <ul class="list-unstyled">
                        <li>\(TAT_{P1} = CT_{P1} - AT_{P1} = 6 - 0 = 6\)</li>
                        <li>\(TAT_{P3} = CT_{P3} - AT_{P3} = 13 - 1 = 12\)</li>
                        <li>\(TAT_{P4} = CT_{P4} - AT_{P4} = 16 - 3 = 13\)</li>
                        <li>\(TAT_{P5} = CT_{P5} - AT_{P5} = 20 - 5 = 15\)</li>
                        <li>\(TAT_{P2} = CT_{P2} - AT_{P2} = 28 - 2 = 26\)</li>
                    </ul>


                </article>
                <article>
                    <h5 class="mt-4">Waiting Time (WT)</h5>
                    <p>To find the WT for each process (\(WT = TAT - BT\)):</p>
                    <ul class="list-unstyled">
                        <li>\(WT_{P1} = TAT_{P1} - BT_{P1} = 6 - 6 = 0\)</li>
                        <li>\(WT_{P3} = TAT_{P3} - BT_{P3} = 12 - 7 = 5\)</li>
                        <li>\(WT_{P4} = TAT_{P4} - BT_{P4} = 13 - 3 = 10\)</li>
                        <li>\(WT_{P5} = TAT_{P5} - BT_{P5} = 15 - 4 = 11\)</li>
                        <li>\(WT_{P2} = TAT_{P2} - BT_{P2} = 26 - 8 = 18\)</li>
                    </ul>
                </article>
                <article>
                    <h5>Average Turnaround Time (TAT<sub>ave</sub>)</h5>
                    <p>$$TAT_{ave} = \frac{\sum{TAT_i}}{n}$$ $$= \frac{6 + 12 + 13 + 15 + 26}{5}$$ $$= \frac{72}{5}$$ $$= 14.4$$</p>
                </article>
                <article>
                    <h5>Average Waiting Time (WT<sub>ave</sub>)</h5>
                    <p>$$WT_{ave} = \frac{\sum{WT_i}}{n}$$ $$= \frac{0 + 5 + 10 + 11 + 18}{5}$$ $$= \frac{44}{5}$$ $$= 8.8$$</p>
                </article>
            </article>

            <article id="sjf-implementation">
                <h3 class="fw-bold">Non-Preemptive SJF Pseudocode Implementation</h3>
                <p>Implementing Non-Preemptive SJF involves selecting the process with the shortest burst time from the queue of processes that have arrived (i.e., their arrival time is less than or equal to the current time). This section outlines a basic implementation of the Non-Preemptive SJF scheduling algorithm.</p>
                <pre><code class="language-python">
# Python pseudo-code for Non-Preemptive SJF scheduling

def sjf_schedule(processes):
    """
    Non-Preemptive SJF scheduling algorithm.
    :param processes: List of tuples containing (process_id, arrival_time, burst_time)
    :return: None
    """
    # Sort processes by their arrival time first, then by burst time
    processes.sort(key=lambda x: (x[1], x[2]))
    
    completed = []
    current_time = 0
    while processes:
        # Filter processes that have arrived
        available_processes = [p for p in processes if p[1] <= current_time]
        if not available_processes:  # If no process is available, jump to the next process arrival time
            current_time = processes[0][1]
            continue
        # Select process with the shortest burst time
        shortest_job = min(available_processes, key=lambda x: x[2])
        processes.remove(shortest_job)
        
        process_id, arrival_time, burst_time = shortest_job
        start_time = current_time
        finish_time = start_time + burst_time
        current_time += burst_time  # Update current time
        tat = finish_time - arrival_time  # Turnaround time
        wt = tat - burst_time  # Waiting time
        completed.append((process_id, arrival_time, burst_time, finish_time, tat, wt))
        
    for process in completed:
        print(f"Process {process[0]}, AT: {process[1]}, BT: {process[2]}, CT: {process[3]}, TAT: {process[4]}, WT: {process[5]}")

</code></pre>
                <p>This example demonstrates the Non-Preemptive SJF algorithm applied to a set of processes, showing the calculation of CT, TAT, and WT for each process based on its arrival and burst times. Note that the list of processes is first sorted by arrival time to simplify the selection of the next available process with the shortest burst time.</p>
            </article>


            <article id="sjf-example">
                <h3 class="fw-bold">Non-Preemptive SJF Scheduling Example in Python</h3>
                <p>Consider the following process table for a Non-Preemptive SJF scheduling scenario:</p>
                <table class="table table-responsive table-striped table-bordered">
                    <tr>
                        <th>Process ID</th>
                        <th>Arrival Time (AT)</th>
                        <th>Burst Time (BT)</th>
                    </tr>
                    <tr>
                        <td>P1</td>
                        <td>0</td>
                        <td>6</td>
                    </tr>
                    <tr>
                        <td>P2</td>
                        <td>2</td>
                        <td>8</td>
                    </tr>
                    <tr>
                        <td>P3</td>
                        <td>1</td>
                        <td>7</td>
                    </tr>
                    <tr>
                        <td>P4</td>
                        <td>3</td>
                        <td>3</td>
                    </tr>
                    <tr>
                        <td>P5</td>
                        <td>5</td>
                        <td>4</td>
                    </tr>
                </table>

                <article>
                    <h4>Creating the Gantt Chart</h4>
                    <p>Based on the calculated metrics, the Gantt chart for the processes P1, P3, P4, P5, and P2 can be visually represented. The chart illustrates the execution sequence and duration of each process, chosen based on the shortest job next rule.</p>
                    <pre><code class="language-markdown">Gantt Chart:
Time        0    6    13   16   20   28
            |----|----|----|----|----|
Process     | P1 | P3 | P4 | P5 | P2 |
</code></pre>
                    <p>This chart indicates that P1 starts execution at time 0 and continues for 6 units of time, followed by P3, P4, P5, and finally P2. The Gantt chart visually represents the scheduling of processes according to Non-Preemptive SJF, highlighting the start and end times of each process based on their burst time.</p>
                </article>

                <article>
                    <h4>Calculating CT, TAT, and WT</h4>
                    <pre><code class="language-python">
# Python code to calculate CT, TAT, WT for the given process table using Non-Preemptive SJF

def calculate_sjf_metrics(processes):
    # Sort processes by arrival time, then by burst time for those arriving at the same time
    processes.sort(key=lambda x: (x[1], x[2]))
    completed = []
    current_time = 0
    metrics = []

    while processes:
        # Filter processes that have arrived by current_time
        available_processes = [p for p in processes if p[1] <= current_time]
        if not available_processes:  # If no process is available, advance time
            current_time = processes[0][1]
            available_processes = [p for p in processes if p[1] <= current_time]

        # Select process with shortest burst time
        process_to_run = min(available_processes, key=lambda x: x[2])
        processes.remove(process_to_run)
        pid, at, bt = process_to_run

        ct = max(at, current_time) + bt
        tat = ct - at
        wt = tat - bt
        metrics.append((pid, ct, tat, wt))
        current_time = ct

    return metrics

# Define the processes
processes = [("P1", 0, 6), ("P2", 2, 8), ("P3", 1, 7), ("P4", 3, 3), ("P5", 5, 4)]

# Calculate metrics
metrics = calculate_sjf_metrics(processes)

# Output the results
for metric in metrics:
    print(f"Process {metric[0]}, CT: {metric[1]}, TAT: {metric[2]}, WT: {metric[3]}")
</code></pre>
                    <p>This code calculates the Completion Time (CT), Turnaround Time (TAT), and Waiting Time (WT) for each process based on the Non-Preemptive SJF scheduling algorithm. The results provide the necessary data to create a Gantt chart and demonstrate the efficiency of SJF in reducing the average waiting time compared to FCFS scheduling.</p>
                </article>

            </article>


            <!-- <article id="detailed-example-calculation">
                <h4>Example 2 with Calculation</h4>
                <p>
                    Let's consider a scenario with a process table containing five processes. This example will include the Gantt chart representation followed by calculations for waiting time and turnaround time for each process.
                </p>

                <article>
                    <h4>Process Table and Gantt Chart</h4>
                    <pre><code class="language-markdown">Process Table:
| Process | Arrival Time | Burst Time |
|---------|--------------|------------|
| P1      | 0            | 2          |
| P2      | 1            | 6          |
| P3      | 2            | 4          |
| P4      | 3            | 9          |
| P5      | 4            | 5          |

Gantt Chart Representation:
Time    0    2    8   12   21   26
        |----|----|----|----|----|
Process | P1 | P3 | P2 | P5 | P4 |
</code></pre>
                    <p>The Gantt chart illustrates the execution sequence based on Non-Preemptive SJF scheduling.</p>
                </article>

                <article>
                    <h4>Calculation of Waiting Time and Turnaround Time</h4>
                    <p>Waiting Time (WT) for each process is calculated as the time from its arrival to its start of execution, minus its burst time. Turnaround Time (TAT) is the total time from arrival to completion of the process.</p>
                    <p>Let's calculate the WT and TAT for each process:</p>
                    <ul>
                        <li><strong>P1 WT:</strong> \(0\) (starts immediately)</li>
                        <li><strong>P1 TAT:</strong> \(WT + Burst Time = 0 + 2 = 2\)</li>
                        <li><strong>P3 WT:</strong> \(Time till start - Arrival Time = 2 - 2 = 0\)</li>
                        <li><strong>P3 TAT:</strong> \(WT + Burst Time = 0 + 4 = 4\)</li>
                        <li><strong>P2 WT:</strong> \(Time till start - Arrival Time = 8 - 1 = 7\)</li>
                        <li><strong>P2 TAT:</strong> \(WT + Burst Time = 7 + 6 = 13\)</li>
                        <li><strong>P5 WT:</strong> \(Time till start - Arrival Time = 12 - 4 = 8\)</li>
                        <li><strong>P5 TAT:</strong> \(WT + Burst Time = 8 + 5 = 13\)</li>
                        <li><strong>P4 WT:</strong> \(Time till start - Arrival Time = 21 - 3 = 18\)</li>
                        <li><strong>P4 TAT:</strong> \(WT + Burst Time = 18 + 9 = 27\)</li>
                    </ul>
                    <p>Average Waiting Time \(= \frac{\sum{WT}}{n} = \frac{0 + 0 + 7 + 8 + 18}{5} = \frac{33}{5} = 6.6\)</p>
                    <p>Average Turnaround Time \(= \frac{\sum{TAT}}{n} = \frac{2 + 4 + 13 + 13 + 27}{5} = \frac{59}{5} = 11.8\)</p>
                    <p>These calculations help in assessing the efficiency of the scheduling algorithm.</p>
                </article>
            </article> -->

        </main>
        <script> copyright("all"); </script>
    </body>

</html>
