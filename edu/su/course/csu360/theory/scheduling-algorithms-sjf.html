<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>

        <title>Scheduling Algorithms: SJF - CSU360 - Shoolini University</title>
        <meta name="description" content="Unlock the SJF with CSU360, covering introductory topics and its formulas. Perfect for developing concept of First Come First Serve algorithm.">


        <meta property="og:image" content="/logo.png">
        <meta property="og:type" content="article">

        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@divyamohan1993">
        <meta name="twitter:creator" content="@divyamohan1993">
        <meta name="twitter:image" content="/logo.png">

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />

        <meta name="author" content="Divya Mohan">
        <meta name="robots" content="index, follow">        
    </head>

    <body>

        <script> header_author("dm"); </script>

        <main>

            <article class="agen-tableofcontents">
                <h2 class="text-center">
                    Scheduling Algorithms: Shortest Job First
                </h2>
            </article>

            <article id="sjf-overview">
                <h3>Introduction to SJF (Shortest Job First)</h3>
                <p>
                    Shortest Job First (SJF) is a CPU scheduling algorithm that selects the process with the shortest execution time to execute next. This approach aims to minimize the average waiting time for all processes in the queue. It operates under the principle that shorter tasks are given precedence over longer ones, thus optimizing the overall time taken to complete all tasks.
                </p>
                <h5>Example of SJF Scheduling</h5>
                <p>
                    Consider four processes with the following burst times: P1=6, P2=8, P3=7, P4=3. Using non-preemptive SJF, the order of execution would be P4, P1, P3, P2. This order ensures that the process with the shortest burst time is executed first, reducing the average waiting time for all processes.
                </p>
            </article>
            
            <article id="sjf-types">
                <h3>Types of SJF Scheduling</h3>
                <p>
                    SJF can be implemented in two main variants: Non-Preemptive and Preemptive.
                </p>
                <article>
                    <h4>Non-Preemptive SJF</h4>
                    <p>
                        In Non-Preemptive SJF, once a process starts execution, it cannot be stopped until it completes. The scheduler selects the shortest job that is ready to execute, but only when the CPU becomes idle.
                    </p>
                </article>
                <article>
                    <h4>Preemptive SJF (Shortest Remaining Time First - SRTF)</h4>
                    <p>
                        Preemptive SJF, also known as Shortest Remaining Time First (SRTF), allows a process to be preempted (interrupted) and moved back to the ready queue if a new process arrives with a shorter execution time than what is currently being executed.
                    </p>
                </article>
            </article>
            
            <article id="sjf-criteria">
                <h3>Criteria for SJF Scheduling</h3>
                <p>
                    The primary metric for SJF scheduling is the "burst time" or "execution time" of a process, which must be known in advance for static analysis. In real-time systems, estimations or historical data are used to predict execution times.
                </p>
            </article>
            
            <article id="sjf-advantages-disadvantages">
                <h3>Advantages and Disadvantages of SJF</h3>                
                    <h4>4.1 Advantages</h4>
                    <ul>
                        <li><strong>Efficiency</strong>: SJF can significantly reduce the average waiting time and turnaround time for a set of processes, leading to increased system throughput.</li>
                        <li><strong>Optimality</strong>: For a given set of processes with known execution times, SJF provides the optimal order for the shortest average waiting time.</li>
                    </ul>
                    <h4>4.2 Disadvantages</h4>
                    <ul>
                        <li><strong>Starvation</strong>: Longer processes may suffer from starvation, where they are perpetually delayed in the queue by shorter processes.</li>
                        <li><strong>Prediction</strong>: Accurately predicting process execution times can be challenging, affecting the algorithm's effectiveness.</li>
                    </ul>                
            </article>
            
            <article id="sjf-implementation">
                <h3>Implementation of SJF</h3>
                <p>
                    Implementing SJF requires a method to track and compare the burst times of processes. A priority queue is often used, where the burst time determines priority.
                </p>
                <article>
                    <h4>Non-Preemptive SJF Implementation</h4>
                    <p>
                        For a non-preemptive version, processes are selected based on the shortest burst time from the ready queue and executed until completion. The process with the shortest burst time is always picked next.
                    </p>
                </article>
                <article>
                    <h4>Preemptive SJF (SRTF) Implementation</h4>
                    <p>
                        In the preemptive version, the scheduler must check if the current executing process has a longer burst time than any process in the ready queue at every process arrival or completion. If so, it preempts the current process in favor of the shorter one.
                    </p>
                </article>
            </article>
        </main>
        <script> copyright("all"); </script>
    </body>

</html>