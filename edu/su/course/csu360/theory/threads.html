<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>

        <title>Threads - CSU360 - Shoolini University</title>
        <meta name="description" content="Learn about threads in CSU360 and understand how threads are used in programming.">

        <meta property="og:image" content="/logo.png">
        <meta property="og:type" content="article">

        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@divyamohan1993">
        <meta name="twitter:creator" content="@divyamohan1993">
        <meta name="twitter:image" content="/logo.png">

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />

        <meta name="author" content="Divya Mohan">
        <meta name="robots" content="index, follow">

        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                renderMathInElement(document.body, {
                    // customised options
                    // • auto-render specific keys, e.g.:
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\(', right: '\\)', display: false },
                        { left: '\\[', right: '\\]', display: true }
                    ],
                    // • rendering keys, e.g.:
                    throwOnError: false
                });
            });
        </script>
    </head>

    <body>

        <script> header_author("dm"); </script>

        <main>

            <article class="agen-tableofcontents">
                <h2 class="text-center">
                    Threads
                </h2>
            </article>

            <article>
                <h3>Definition</h3>
                <p>
                    A thread is a lightweight sub-process, the smallest unit of processing. Threads are independent, concurrent paths of execution within a program. Many threads can run concurrently within a program. Every thread in Java is created and controlled by the java.lang.Thread class. A Java program can have many threads, and these threads can run concurrently, either asynchronously or synchronously.
                </p>
            </article>

            <article id="threads-introduction">
                <h3>1. Introduction to Threads</h3>
                <p>Threads are a fundamental component of modern operating systems that allow multiple sequences of programmed instructions to be executed concurrently within a single process. This model of execution enhances the efficiency and responsiveness of applications by allowing tasks to run in parallel, particularly on systems with multiple processors or cores.</p>
            </article>
            <article id="threads-types">
                <h3>2. Types of Threads</h3>
                <p>There are primarily two types of threads used in operating systems:</p>
                <ul>
                    <li><strong>User Threads</strong>: These are managed at the user level, above the kernel and are not recognized by the operating system. User threads are faster to create and manage since they don't require interaction with the operating system kernel.</li>
                    <li><strong>Kernel Threads</strong>: These threads are managed directly by the operating system kernel. They are slower to create and manage but are more powerful because they can utilize features offered by the underlying operating system.</li>
                </ul>
            </article>
            <article id="threads-multithreading-models">
                <h3>3. Multithreading Models</h3>
                <p>Different operating systems implement threads using various models, each affecting the performance and complexity of thread management:</p>
                <ul>
                    <li><strong>Many-to-One Model</strong>: Many user threads map to one kernel thread. This model can lead to performance bottlenecks if one thread blocks, potentially freezing all other threads in the same process.</li>
                    <li><strong>One-to-One Model</strong>: Each user thread maps to one kernel thread. This model provides better concurrency but can be less efficient if a large number of threads are created due to the overhead of managing kernel threads.</li>
                    <li><strong>Many-to-Many Model</strong>: Many user threads map to many kernel threads. This model balances the benefits and drawbacks of the other two models, allowing the operating system to maintain an optimal number of kernel threads.</li>
                </ul>
            </article>
            <article id="threads-advantages-disadvantages">
                <h3>4. Advantages and Disadvantages of Threads</h3>
                <p>Utilizing threads in programming and system design has both advantages and disadvantages:</p>
                <ul>
                    <li><strong>Advantages</strong>:
                        <ul>
                            <li>Improved Application Responsiveness: Threads allow a program to continue running even if part of it is blocked or performing a lengthy operation.</li>
                            <li>Increased Efficiency: Parallel execution of threads can lead to more efficient use of system resources, particularly on multi-core processors.</li>
                            <li>Improved Scalability: Applications can scale better to take advantage of the increasing number of processors.</li>
                        </ul>
                    </li>
                    <li><strong>Disadvantages</strong>:
                        <ul>
                            <li>Synchronization Challenges: Managing access to shared resources can lead to complex synchronization and potential deadlock scenarios.</li>
                            <li>Overhead: Managing threads incurs computational overhead, particularly with kernel threads, as the system must manage and switch between multiple threads.</li>
                            <li>Complexity in Design: Developing multithreaded applications requires careful design to ensure that interaction between threads does not lead to bugs or performance issues.</li>
                        </ul>
                    </li>
                </ul>
            </article>
            <article id="threads-synchronization">
                <h3>5. Thread Synchronization</h3>
                <p>Thread synchronization is critical in preventing threads from interfering with each other while sharing resources. Common synchronization techniques include:</p>
                <ul>
                    <li><strong>Mutexes</strong>: Mutexes ensure that only one thread accesses a particular resource at a time.</li>
                    <li><strong>Semaphores</strong>: Semaphores control access to resources by maintaining a set of permits.</li>
                    <li><strong>Monitors</strong>: A higher-level synchronization mechanism that combines mutual exclusion with the ability to wait for a specific condition to be met.</li>
                </ul>
            </article>

            <article id="user-vs-kernel-threads">
                <h3>6. User vs. Kernel Threads: Key Differences</h3>
                <ul>
                    <li><strong>Management</strong>: User threads are managed by user-level libraries, while kernel threads are managed directly by the operating system.</li>
                    <li><strong>Speed of Creation</strong>: User threads are generally faster to create and destroy due to not requiring system calls.</li>
                    <li><strong>System Resource Access</strong>: Kernel threads can directly interact with operating system services; user threads cannot.</li>
                    <li><strong>Scheduling</strong>: Kernel threads are scheduled by the OS, providing better control over execution; user threads are managed by a user-level library, limiting control.</li>
                    <li><strong>Overhead</strong>: User threads have less overhead because they do not involve the kernel, whereas kernel threads require more resources to manage.</li>
                    <li><strong>Efficiency in Multiprocessing</strong>: Kernel threads can run on multiple processors simultaneously. User threads typically run on a single processor, unless managed by a specific library.</li>
                    <li><strong>Blocking Behavior</strong>: If a kernel thread blocks, other threads can still run. If a user thread blocks, it can freeze all threads of its process, depending on the threading model.</li>
                    <li><strong>Dependency on OS</strong>: Kernel threads are highly dependent on the operating system's capabilities, while user threads are more portable across different systems due to their management in user space.</li>
                    <li><strong>Complexity</strong>: Implementing user threads is generally simpler and requires less coordination with the operating system.</li>
                    <li><strong>Failure Isolation</strong>: Failure in a kernel thread can compromise the security or stability of the whole system; user thread failures generally affect only the application they belong to.</li>
                </ul>
            </article>
           
        </main>
        <script> copyright("all"); </script>
    </body>

</html>
