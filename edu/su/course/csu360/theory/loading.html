<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>

        <title>Loading - CSU360 - Shoolini University</title>
        <meta name="description" content="Learn how loading is done in CSU360 and how it is used in computer systems.">

        <meta property="og:image" content="/logo.png">
        <meta property="og:type" content="article">

        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@divyamohan1993">
        <meta name="twitter:creator" content="@divyamohan1993">
        <meta name="twitter:image" content="/logo.png">

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />

        <meta name="author" content="Divya Mohan">
        <meta name="robots" content="index, follow">

        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                renderMathInElement(document.body, {
                    // customised options
                    // • auto-render specific keys, e.g.:
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\(', right: '\\)', display: false },
                        { left: '\\[', right: '\\]', display: true }
                    ],
                    // • rendering keys, e.g.:
                    throwOnError: false
                });
            });
        </script>
    </head>

    <body>

        <script> header_author("dm"); </script>

        <main>

            <article class="agen-tableofcontents">
                <h2 class="text-center">
                    Loading
                </h2>
            </article>

            <article id="header-loading">
                <h3>1. Introduction to Loading in Operating Systems</h3>
                <p>Loading is a fundamental process in operating systems that involves reading program data from secondary storage (like a hard disk or SSD) into primary memory (RAM). This process is critical for the execution of programs because a CPU can directly access data only from memory.</p>
            </article>

            <article>
                <h4>1.1 The Role of the Loader</h4>
                <p>The loader is a part of the operating system that is responsible for the loading process. It handles the reading of the executable file from the disk, resolving symbolic references in the file, and allocating space in memory for the program's executable image.</p>
            </article>

            <article>
                <h4>1.2 Steps in the Loading Process</h4>
                <p>The loading process typically involves several key steps:</p>
                <ul>
                    <li><strong>Reading the executable:</strong> The loader reads the executable file's contents from the disk into memory.</li>
                    <li><strong>Address binding:</strong> The loader will convert symbolic addresses into physical addresses.</li>
                    <li><strong>Memory allocation:</strong> The loader allocates space in the RAM for the program.</li>
                    <li><strong>Dependency resolution:</strong> Any external files or libraries that the executable depends on are located and loaded.</li>
                    <li><strong>Relocation:</strong> Adjusts any address-dependent code and data to work with the allocated memory addresses.</li>
                </ul>
            </article>

            <article>
                <h4>1.3 Types of Loading</h4>
                <p>There are typically two types of loading:</p>
                <ul>
                    <li><strong>Static Loading:</strong> The process in which the entire program and all needed resources are brought into memory at the initial load time, before execution starts.</li>
                    <li><strong>Dynamic Loading:</strong> Modules are loaded into memory on demand during execution. This method allows unused code to be left on the disk, improving memory usage.</li>
                </ul>
            </article>

            <article id="header-static-loading">
                <h4>1.3.1 Introduction to Static Loading</h4>
                <p>Static loading is a method where an entire program is loaded into memory from executable files before execution starts. Unlike dynamic loading, static loading does not load functions or modules on demand. This method simplifies program execution but requires more memory and increases startup time.</p>

                <article>
                    <h5>How Static Loading Works</h5>
                    <p>The process of static loading involves the following steps:</p>
                    <ul>
                        <li><strong>Compilation:</strong> Source code is compiled into an executable file by a compiler.</li>
                        <li><strong>Linking:</strong> All necessary modules and libraries are linked together to form a single executable file by the linker.</li>
                        <li><strong>Loading:</strong> The entire executable file is loaded into memory by the loader at program start.</li>
                    </ul>
                    <p>This method ensures that all parts of the program are available in memory before execution commences, eliminating the need for run-time loading of modules.</p>
                </article>

                <article>
                    <h5>Advantages of Static Loading</h5>
                    <p>Static loading offers several benefits:</p>
                    <ul>
                        <li><strong>Simplicity:</strong> The loading process is straightforward, which simplifies both the loader's design and the execution of the program.</li>
                        <li><strong>Predictability:</strong> Memory usage is predictable since all resources are allocated at the start, which can simplify memory management.</li>
                        <li><strong>Performance:</strong> Eliminates the overhead associated with dynamic loading during runtime, potentially improving performance in scenarios where rapid execution is crucial.</li>
                    </ul>
                </article>

                <article>
                    <h5>Disadvantages of Static Loading</h5>
                    <p>Despite its advantages, static loading has several drawbacks:</p>
                    <ul>
                        <li><strong>Increased memory usage:</strong> As the entire program needs to be loaded into memory, it consumes more memory resources, which can be inefficient for large applications.</li>
                        <li><strong>Longer startup time:</strong> Loading the entire program at startup can lead to longer loading times compared to dynamic loading methods.</li>
                        <li><strong>Flexibility:</strong> Static loading offers less flexibility for updates and modifications. Changes often require recompiling and relinking the entire application.</li>
                    </ul>
                </article>

                <article>
                    <h5>Use Cases for Static Loading</h5>
                    <p>Static loading is particularly beneficial in environments where:</p>
                    <ul>
                        <li><strong>Consistency and reliability are critical:</strong> Such as in embedded systems or real-time operating systems where predictability in behavior is essential.</li>
                        <li><strong>Resources are abundant:</strong> In systems where memory is not a constraint, static loading can be employed without significant drawbacks.</li>
                    </ul>
                </article>
            </article>

            <article id="header-dynamic-loading">
                <h4>1.3.2 Introduction to Dynamic Loading</h4>
                <p>Dynamic loading is a process in operating systems where a program loads parts of its code or data into memory on an as-needed basis during execution. This method allows programs to be more memory-efficient and adaptable to varying runtime requirements.</p>

                <article>
                    <h5>How Dynamic Loading Works</h5>
                    <p>The dynamic loading process typically involves the following steps:</p>
                    <ul>
                        <li><strong>Initialization:</strong> The program starts execution with only the main module loaded.</li>
                        <li><strong>Requesting modules:</strong> As the program executes, it identifies modules it needs that are not yet in memory.</li>
                        <li><strong>Loading modules:</strong> The operating system loads the requested modules into memory from disk.</li>
                        <li><strong>Execution:</strong> Once loaded, the program can execute functions or use data from these modules.</li>
                    </ul>
                    <p>This on-demand approach can greatly enhance the flexibility and efficiency of program execution.</p>
                </article>

                <article>
                    <h5>Advantages of Dynamic Loading</h5>
                    <p>Dynamic loading provides several key advantages:</p>
                    <ul>
                        <li><strong>Reduced memory usage:</strong> Only necessary parts of the program are loaded, minimizing memory consumption.</li>
                        <li><strong>Improved startup time:</strong> By loading only the essential parts of the program at startup, the initial load time is decreased.</li>
                        <li><strong>Resource optimization:</strong> Resources are used more efficiently as unused modules are never loaded into memory.</li>
                    </ul>
                </article>

                <article>
                    <h5>Disadvantages of Dynamic Loading</h5>
                    <p>While beneficial, dynamic loading also presents certain challenges:</p>
                    <ul>
                        <li><strong>Complexity:</strong> Managing which parts of a program are loaded and when can complicate both the program design and the operating system's loader.</li>
                        <li><strong>Performance overhead:</strong> There may be a performance cost associated with loading modules on demand, especially if disk access is slow.</li>
                        <li><strong>Dependency management:</strong> Care must be taken to handle dependencies between modules correctly to avoid runtime errors.</li>
                    </ul>
                </article>

                <article>
                    <h5>Implementation Techniques</h5>
                    <p>Dynamic loading can be implemented using various techniques, depending on the programming language and operating system:</p>
                    <ul>
                        <li><strong>Dynamic Link Libraries (DLLs) in Windows:</strong> Programs can call functions from DLLs that are loaded into memory only when needed.</li>
                        <li><strong>Shared Libraries in Unix/Linux (e.g., .so files):</strong> Similar to DLLs, these libraries are loaded dynamically during program execution.</li>
                    </ul>
                    <pre><code class="language-c">// Example of using a dynamic library in C
#include &lt;dlfcn.h&gt;

void* handle = dlopen("libexample.so", RTLD_LAZY);
if (handle) {
    void (*func)() = dlsym(handle, "functionName");
    if (func) {
        func();
    }
    dlclose(handle);
}</code></pre>
                </article>
            </article>


            <article>
                <h4>1.4 Dynamic Link Libraries (DLLs)</h4>
                <p>Dynamic Link Libraries (DLLs) are an example of dynamic loading, where specific code and data needed by a program are loaded into memory only when that particular module is needed. This allows for efficient memory usage and reduces the program's initial load time.</p>


                <article>
                    <h5>1.4.1 Benefits of Using DLLs</h5>
                    <p>DLLs provide several benefits:</p>
                    <ul>
                        <li><strong>Memory savings:</strong> Multiple programs can share the same library code in memory.</li>
                        <li><strong>Modular architecture:</strong> Easier to develop updates and patches.</li>
                        <li><strong>Resource sharing:</strong> Programs can share not only code but also resources such as fonts and icons.</li>
                    </ul>
                </article>

                <article>
                    <h5>1.4.2 How DLLs Work</h5>
                    <p>When a program uses a DLL, the operating system loads the DLL into memory when the program starts up or during runtime when needed. The program can then call the functions and use the resources defined in the DLL as if they were part of the program itself.</p>
                    <pre><code class="language-cpp">LoadLibrary("example.dll"); // Windows API to load a DLL
GetModuleHandle("example.dll"); // Get handle to the loaded library
GetProcAddress(handle, "functionName"); // Access functions within the DLL</code></pre>
                </article>
            </article>
            <article id="header-advanced-loading">
                <h4>1.5 Load-Time vs. Run-Time Dynamic Linking</h4>
                <p>Differentiating between load-time and run-time dynamic linking can provide deeper insights into how operating systems manage libraries and dependencies.</p>

                <article>
                    <h5>1.5.1 Load-Time Dynamic Linking</h5>
                    <p>In load-time dynamic linking, all necessary library routines the application depends on are linked and loaded into memory at the time the application is loaded. This is typically handled by the operating system's loader.</p>
                </article>

                <article>
                    <h5>1.5.2 Run-Time Dynamic Linking</h5>
                    <p>Run-time dynamic linking allows an application to load libraries into memory and link to their components during execution. This method is flexible and allows applications to only use resources when they are needed, potentially reducing memory usage.</p>
                    <pre><code class="language-cpp">// Example of run-time dynamic linking using Windows API
HMODULE libHandle = LoadLibrary("example.dll");
if (libHandle != NULL) {
    typedef void (*ExampleFunction)();
    ExampleFunction func = (ExampleFunction) GetProcAddress(libHandle, "functionName");
    if (func != NULL) {
        func();  // Call the function
    }
    FreeLibrary(libHandle);
}</code></pre>
                </article>
            </article>

            <article>
                <h4>1.6 Memory Management During Loading</h4>
                <p>Exploring how the operating system manages memory during the loading process can clarify how efficient loading contributes to overall system performance.</p>
                <ul>
                    <li><strong>Memory Segmentation:</strong> Dividing memory into segments allows the OS to load parts of the program as needed.</li>
                    <li><strong>Page Replacement Algorithms:</strong> Techniques like least recently used (LRU) or first in, first out (FIFO) help manage memory pages dynamically during program execution.</li>
                </ul>
            </article>

            <article>
                <h4>1.7 Security Considerations in Loading</h4>
                <p>Security is a critical aspect of the loading process, particularly in how executables are loaded and managed in memory.</p>
                <ul>
                    <li><strong>Address Space Layout Randomization (ASLR):</strong> A security mechanism that randomly arranges the address space positions of key data areas to prevent malicious buffer overflow attacks.</li>
                    <li><strong>Executable and Linkable Format (ELF) Security:</strong> Ensuring that the executable formats do not contain vulnerabilities that could be exploited during loading.</li>
                </ul>
            </article>


        </main>
        <script> copyright("all"); </script>
    </body>

</html>
