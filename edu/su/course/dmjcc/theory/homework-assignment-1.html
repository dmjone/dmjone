<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>

        <title>Homework Assignment 1 - DMJCC - dmj.one</title>
        <meta name="description" content="Homework Assignment 1: Real-World Cloud Computing and Distributed Systems Challenge - DMJCC - Provided by dmj.one">

        <meta property="og:image" content="/logo.png">
        <meta property="og:type" content="article">

        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@divyamohan1993">
        <meta name="twitter:creator" content="@divyamohan1993">
        <meta name="twitter:image" content="/logo.png">

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />

        <meta name="author" content="Divya Mohan">
        <meta name="robots" content="index, follow">

        <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                renderMathInElement(document.body, {
                    // customised options
                    // • auto-render specific keys, e.g.:
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\(', right: '\\)', display: false },
                        { left: '\\[', right: '\\]', display: true }
                    ],
                    // • rendering keys, e.g.:
                    throwOnError: false
                });
            });
        </script> -->

        <!-- <style>
            main ul {
                list-style-type: none;
                padding: 0;
                margin: 0;
            }

            main ul li {
                margin: 0;
                padding: 0;
            }
        </style> -->

    </head>

    <body>

        <script> header_author("lakshika"); </script>

        <main>
            <article class="agen-tableofcontents">
                <h2 class="text-center">
                    Homework Assignment 1: Real-World Cloud Computing and Distributed Systems Challenge
                </h2>
                <div class="d-none contentdate">2024, December 24</div>
            </article>

            <article>
                <h3>Homework Assignment: Real-World Cloud Computing and Distributed Systems Challenge</h3>
                <p>This assignment combines practical application, critical thinking, and problem-solving skills. You will create a mini-cloud computing system simulation to understand the concepts of distributed systems, MapReduce, and cloud computing paradigms. Follow the instructions carefully and apply your knowledge creatively.</p>
            </article>

            <article>
                <h4>Scenario: Building a Cloud-Based File Word Counter</h4>
                <p>Imagine you work for a company that handles large-scale text processing for analytics. Your task is to design a distributed system using MapReduce to calculate the word count of uploaded files. The system must simulate a real-world cloud environment.</p>
            </article>

            <article>
                <h4>Objectives</h4>
                <ul>
                    <li>Understand the concept of distributed systems and their applications.</li>
                    <li>Implement a simple MapReduce program to count words in a file.</li>
                    <li>Explore and simulate the characteristics of cloud computing such as scalability and fault tolerance.</li>
                    <li>Demonstrate teamwork and report insights effectively (for team submissions).</li>
                </ul>
            </article>

            <article>
                <h4>Instructions</h4>
                <p>Follow these steps to complete your homework:</p>

                <h5>1. Set Up a Simulated Distributed Environment</h5>
                <ul>
                    <li>Use Python (or Java if comfortable) to simulate a cloud environment.</li>
                    <li>Create multiple "nodes" (simulated as separate scripts or threads).</li>
                    <li>Each node will act as a worker for MapReduce tasks.</li>
                </ul>

                <h5>2. Implement the Map Function</h5>
                <p>The Map function should process lines of a given text file and output key-value pairs of words and their occurrence counts.</p>
                <pre><code class="language-python">
# Example: Python Map Function
def map_function(line):
    words = line.split()
    return [(word, 1) for word in words]
</code></pre>

                <h5>3. Simulate Data Distribution</h5>
                <ul>
                    <li>Split a large text file into smaller chunks to simulate distribution across nodes.</li>
                    <li>Each chunk will be processed by a different node using the Map function.</li>
                </ul>

                <h5>4. Implement the Reduce Function</h5>
                <p>The Reduce function should aggregate the counts of words from all nodes and produce the final word count.</p>
                <pre><code class="language-python">
# Example: Python Reduce Function
from collections import defaultdict

def reduce_function(mapped_data):
    word_count = defaultdict(int)
    for word, count in mapped_data:
        word_count[word] += count
    return word_count
</code></pre>

                <h5>5. Simulate Fault Tolerance</h5>
                <ul>
                    <li>Randomly simulate a failure in one or more nodes during execution.</li>
                    <li>Implement a mechanism to retry failed tasks on another node.</li>
                </ul>

                <h5>6. Visualize the Results</h5>
                <ul>
                    <li>Display the final word count using a bar chart or any suitable visualization.</li>
                    <li>You may use Python libraries such as Matplotlib or Seaborn for this.</li>
                </ul>

                <h5>7. Report and Submit</h5>
                <p>Create a report that includes:</p>
                <ul>
                    <li>A brief introduction to the task and its objectives.</li>
                    <li>The code for your solution with comments explaining each part.</li>
                    <li>Observations about scalability, fault tolerance, and performance.</li>
                    <li>Suggestions for improving the system.</li>
                </ul>
            </article>

            <article>
                <h4>Evaluation Criteria</h4>
                <p>Your assignment will be evaluated based on:</p>
                <ul>
                    <li>Correctness of the MapReduce implementation (30%).</li>
                    <li>Simulation of distributed and fault-tolerant environments (30%).</li>
                    <li>Clarity and structure of the report (20%).</li>
                    <li>Visualization and creativity (20%).</li>
                </ul>
            </article>

            <article>
                <h4>Additional Notes</h4>
                <ul>
                    <li>You may work individually or in pairs.</li>
                    <li>Submission deadline: [Insert Deadline Here].</li>
                    <li>Ensure your code is well-documented and easy to understand.</li>
                    <li>If you face issues, document your challenges and how you attempted to overcome them in your report.</li>
                </ul>
            </article>

            <article>
                <h3>Solution: Cloud-Based File Word Counter Using MapReduce</h3>
                <p><strong>Important:</strong> Please attempt the assignment on your own before referring to this solution. The process of trying, failing, and learning will strengthen your understanding and skills.</p>
            </article>

            <article>
                <h4>Step-by-Step Solution</h4>

                <h5>1. Setting Up the Simulated Distributed Environment</h5>
                <p>We simulate nodes using threads to handle tasks in parallel.</p>
                <pre><code class="language-python">
import threading

# Simulate nodes as worker threads
class Node(threading.Thread):
    def __init__(self, id, task_queue, results):
        threading.Thread.__init__(self)
        self.id = id
        self.task_queue = task_queue
        self.results = results

    def run(self):
        while not self.task_queue.empty():
            try:
                chunk = self.task_queue.get_nowait()
                self.results.append(map_function(chunk))
            except:
                break
</code></pre>

                <h5>2. Implementing the Map Function</h5>
                <p>The Map function processes lines from the text file and returns word-count pairs.</p>
                <pre><code class="language-python">
def map_function(chunk):
    word_counts = []
    for line in chunk:
        words = line.split()
        word_counts.extend([(word, 1) for word in words])
    return word_counts
</code></pre>

                <h5>3. Distributing Data</h5>
                <p>Divide the text file into chunks for processing by nodes.</p>
                <pre><code class="language-python">
from queue import Queue

# Split file into chunks
def split_file(file_path, num_chunks):
    with open(file_path, 'r') as f:
        lines = f.readlines()
    chunk_size = len(lines) // num_chunks
    return [lines[i:i + chunk_size] for i in range(0, len(lines), chunk_size)]

# Initialize task queue
task_queue = Queue()
chunks = split_file('input.txt', 4)
for chunk in chunks:
    task_queue.put(chunk)
</code></pre>

                <h5>4. Implementing the Reduce Function</h5>
                <p>The Reduce function aggregates word counts from all nodes.</p>
                <pre><code class="language-python">
from collections import defaultdict

def reduce_function(mapped_results):
    final_word_count = defaultdict(int)
    for result in mapped_results:
        for word, count in result:
            final_word_count[word] += count
    return final_word_count
</code></pre>

                <h5>5. Simulating Fault Tolerance</h5>
                <p>Randomly simulate node failure and reassign failed tasks to remaining nodes.</p>
                <pre><code class="language-python">
import random

def simulate_failure(node_list):
    # Randomly deactivate one node
    failed_node = random.choice(node_list)
    print(f"Node {failed_node.id} failed!")
    node_list.remove(failed_node)
    return node_list
</code></pre>

                <h5>6. Running the Simulation</h5>
                <p>Execute the MapReduce job with fault tolerance and aggregation.</p>
                <pre><code class="language-python">
if __name__ == "__main__":
    num_nodes = 4
    results = []
    nodes = [Node(i, task_queue, results) for i in range(num_nodes)]

    for node in nodes:
        node.start()

    # Simulate failure
    nodes = simulate_failure(nodes)

    for node in nodes:
        node.join()

    # Aggregate results
    word_count = reduce_function(results)
    print(word_count)
</code></pre>

                <h5>7. Visualizing Results</h5>
                <p>Generate a bar chart of the word counts.</p>
                <pre><code class="language-python">
import matplotlib.pyplot as plt

def visualize_results(word_count):
    words = list(word_count.keys())
    counts = list(word_count.values())

    plt.bar(words, counts)
    plt.xlabel("Words")
    plt.ylabel("Frequency")
    plt.title("Word Count Visualization")
    plt.show()

visualize_results(word_count)
</code></pre>
            </article>

            <article>
                <h4>Encouragement</h4>
                <p>Learning comes from doing! If you attempted the assignment and then reviewed the solution, you’re on the right path. Reflect on the differences between your approach and the solution to deepen your understanding. Keep practicing and building your problem-solving skills!</p>
            </article>
        </main>

        <script> copyright("all"); </script>

    </body>

</html>