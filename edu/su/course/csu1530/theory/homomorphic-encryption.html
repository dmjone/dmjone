<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>

        <title>Homomorphic Encryption - CSU1530 - Shoolini U</title>
        <meta name="description" content="Learn about the concept of Homomorphic Encryption in the context of Biometric Security - CSU1530 - Shoolini University">

        <meta property="og:image" content="/logo.png">
        <meta property="og:type" content="article">

        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@divyamohan1993">
        <meta name="twitter:creator" content="@divyamohan1993">
        <meta name="twitter:image" content="/logo.png">

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />

        <meta name="author" content="Divya Mohan">
        <meta name="robots" content="index, follow">

        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                renderMathInElement(document.body, {
                    // customised options
                    // • auto-render specific keys, e.g.:
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\(', right: '\\)', display: false },
                        { left: '\\[', right: '\\]', display: true }
                    ],
                    // • rendering keys, e.g.:
                    throwOnError: false
                });
            });
        </script>

    </head>

    <body>

        <script> header_author("dm"); </script>

        <main>
            <article class="agen-tableofcontents">
                <h2 class="text-center">
                    Homomorphic Encryption
                </h2>
                <div class="d-none contentdate">2024, October 5</div>
            </article>

            <article>
                <h3>1. Introduction to Homomorphic Encryption</h3>
                <p>Homomorphic Encryption is a cryptographic technique that enables computations on encrypted data without needing to decrypt it first. When the result is decrypted, it matches the outcome as if the operations were performed on the original unencrypted data.</p>
            </article>

            <article>
                <h3>2. Basic Principles</h3>
                <p>The core idea is to allow mathematical operations on ciphertexts that correspond to operations on the plaintexts. This is achieved by constructing encryption schemes where specific algebraic structures are preserved during encryption.</p>
            </article>

            <article>
                <h4>2.1 Mathematical Foundations</h4>
                <p>Homomorphic Encryption relies on mathematical concepts that support operations on encrypted data. Key areas include:</p>
                <ul>
                    <li><strong>Modular Arithmetic</strong>: Operations within a finite set of integers.</li>
                    <li><strong>Lattice-Based Cryptography</strong>: Utilizes geometric arrangements of points in multidimensional space.</li>
                </ul>
            </article>

            <article>
                <h5>2.1.1 Modular Arithmetic</h5>
                <p>In modular arithmetic, numbers wrap around upon reaching a certain value, called the modulus. This property is used in encryption schemes to perform operations on encrypted data without changing the modulus.</p>
                <p>For example, the additive property:</p>
                <p>$$ (a \mod n) + (b \mod n) \equiv (a + b) \mod n $$</p>
                <p>This means that adding the remainders of \( a \) and \( b \) modulo \( n \) yields the same result as adding \( a \) and \( b \) first and then taking the modulo \( n \).</p>
            </article>

            <article>
                <h5>2.1.2 Lattice-Based Cryptography</h5>
                <p>Lattices are regular grids of points in multidimensional space. Cryptographic schemes based on lattices are considered secure against attacks from quantum computers. They provide a foundation for constructing Homomorphic Encryption schemes due to their mathematical properties.</p>
            </article>

            <article>
                <h3>3. Types of Homomorphic Encryption</h3>
                <p>Homomorphic Encryption schemes are categorized based on the types and number of operations they support on ciphertexts. The main categories are:</p>
                <ul>
                    <li><strong>Partially Homomorphic Encryption (PHE)</strong></li>
                    <li><strong>Somewhat Homomorphic Encryption (SHE)</strong></li>
                    <li><strong>Fully Homomorphic Encryption (FHE)</strong></li>
                </ul>
            </article>

            <article>
                <h4>3.1 Partially Homomorphic Encryption (PHE)</h4>
                <p>PHE schemes support an unlimited number of operations of a single type (either addition or multiplication) on encrypted data. Examples include:</p>
                <ul>
                    <li><strong>Additive Homomorphic Encryption</strong>: Allows repeated additions on ciphertexts.</li>
                    <li><strong>Multiplicative Homomorphic Encryption</strong>: Allows repeated multiplications on ciphertexts.</li>
                </ul>
            </article>

            <article>
                <h4>3.2 Somewhat Homomorphic Encryption (SHE)</h4>
                <p>SHE schemes support a limited number of both additions and multiplications on encrypted data. The limitation arises due to the accumulation of noise with each operation, which can eventually prevent correct decryption.</p>
            </article>

            <article>
                <h4>3.3 Fully Homomorphic Encryption (FHE)</h4>
                <p>FHE schemes allow unlimited additions and multiplications on ciphertexts. This enables arbitrary computations on encrypted data, making FHE highly versatile but also more complex and resource-intensive.</p>
            </article>

            <article>
                <h3>4. Applications</h3>
                <p>Homomorphic Encryption has significant implications in fields where data privacy is crucial. Some applications include:</p>
            </article>

            <article>
                <h4>4.1 Secure Cloud Computing</h4>
                <p>Users can outsource computations to cloud services without revealing their data. The cloud performs computations on encrypted data, and only the user can decrypt the results.</p>
                <ul>
                    <li>Protects sensitive information from cloud service providers.</li>
                    <li>Enables confidential data processing in untrusted environments.</li>
                </ul>
            </article>

            <article>
                <h4>4.2 Privacy-Preserving Data Analysis</h4>
                <p>Allows analysis of encrypted datasets, such as medical or financial records, without compromising individual privacy.</p>
                <ul>
                    <li>Enables collaborative research on sensitive data.</li>
                    <li>Facilitates compliance with data protection regulations.</li>
                </ul>
            </article>

            <article>
                <h4>4.3 Secure Voting Systems</h4>
                <p>Homomorphic Encryption can be used to tally encrypted votes, ensuring that individual votes remain confidential while providing an accurate election result.</p>
                <ul>
                    <li>Prevents tampering with individual votes.</li>
                    <li>Maintains transparency and integrity of the voting process.</li>
                </ul>
            </article>

            <article>
                <h3>5. Challenges and Limitations</h3>
                <p>Despite its potential, Homomorphic Encryption faces several challenges that affect its practical deployment.</p>
            </article>

            <article>
                <h4>5.1 Computational Overhead</h4>
                <p>Operations on encrypted data are much slower than on unencrypted data due to the complexity of the mathematical computations involved.</p>
                <ul>
                    <li>Requires significant computational resources.</li>
                    <li>May not be suitable for real-time applications.</li>
                </ul>
            </article>

            <article>
                <h4>5.2 Ciphertext Size</h4>
                <p>Encrypted data can be several times larger than the original plaintext, leading to increased storage and transmission requirements.</p>
                <ul>
                    <li>Affects bandwidth usage in network communications.</li>
                    <li>Increases costs for data storage.</li>
                </ul>
            </article>

            <article>
                <h4>5.3 Noise Management</h4>
                <p>Many Homomorphic Encryption schemes introduce noise into ciphertexts to ensure security. With each operation, the noise level increases, and excessive noise can render the ciphertext undecryptable.</p>
                <ul>
                    <li>Limits the number of operations that can be performed.</li>
                    <li>Requires techniques like bootstrapping to reduce noise.</li>
                </ul>
            </article>

            <article>
                <h3>6. Implementation Methods</h3>
                <p>Several Homomorphic Encryption schemes have been developed, each with specific features and suitable use cases.</p>
            </article>

            <article>
                <h4>6.1 RSA Cryptosystem</h4>
                <p>RSA is an example of a multiplicatively homomorphic scheme. It allows multiplication of ciphertexts to correspond to the multiplication of plaintexts.</p>
                <p>Given plaintext messages \( m_1 \) and \( m_2 \), and public key exponent \( e \), the ciphertexts are:</p>
                <p>$$ c_1 = m_1^e \mod n $$</p>
                <p>$$ c_2 = m_2^e \mod n $$</p>
                <p>The product of the ciphertexts corresponds to the product of the plaintexts:</p>
                <p>$$ c_1 \cdot c_2 \mod n = (m_1 \cdot m_2)^e \mod n $$</p>
                <p>This property can be useful in scenarios where multiplication of encrypted values is required.</p>
            </article>

            <article>
                <h4>6.2 Paillier Cryptosystem</h4>
                <p>Paillier is an additive homomorphic encryption scheme. It allows addition of ciphertexts to correspond to the addition of plaintexts.</p>
                <p>Given plaintext messages \( m_1 \) and \( m_2 \), and random values \( r_1 \) and \( r_2 \), the ciphertexts are:</p>
                <p>$$ c_1 = g^{m_1} r_1^n \mod n^2 $$</p>
                <p>$$ c_2 = g^{m_2} r_2^n \mod n^2 $$</p>
                <p>The product of the ciphertexts corresponds to the sum of the plaintexts:</p>
                <p>$$ c_1 \cdot c_2 \mod n^2 = g^{m_1 + m_2} (r_1 r_2)^n \mod n^2 $$</p>
                <p>This allows for the aggregation of encrypted data without revealing individual values.</p>
            </article>

            <article>
                <h4>6.3 Gentry's Fully Homomorphic Encryption</h4>
                <p>In 2009, Craig Gentry presented the first FHE scheme. It uses ideal lattices and introduces a technique called bootstrapping to manage noise.</p>
                <p><strong>Key Concepts:</strong></p>
                <ul>
                    <li><strong>Bootstrapping</strong>: A process that refreshes the ciphertext by reducing noise, allowing further computations.</li>
                    <li><strong>Ideal Lattices</strong>: Mathematical structures that provide the foundation for the encryption scheme's security.</li>
                </ul>
                <p>Gentry's work paved the way for practical FHE implementations, though they remain computationally intensive.</p>
            </article>

            <article>
                <h3>7. Practical Illustration</h3>
                <p>Understanding Homomorphic Encryption can be enhanced by exploring real-world examples.</p>
            </article>

            <article>
                <h4>7.1 Secure Sum Calculation</h4>
                <p>Suppose two companies want to calculate the total of their confidential sales figures without revealing them to each other.</p>
                <p><strong>Steps:</strong></p>
                <ol>
                    <li>Each company encrypts its sales figure using an additive homomorphic encryption scheme.</li>
                    <li>The encrypted values are sent to a third party or combined directly.</li>
                    <li>The combined ciphertext is decrypted by an authorized party to obtain the total sales figure.</li>
                </ol>
                <p><strong>Benefits:</strong></p>
                <ul>
                    <li>Individual sales figures remain confidential.</li>
                    <li>The total can be calculated accurately.</li>
                </ul>
            </article>

            <article>
                <h4>7.2 Encrypted Data Processing in the Cloud</h4>
                <p>A user wants to perform statistical analysis on their sensitive data using cloud computing resources.</p>
                <p><strong>Process:</strong></p>
                <ol>
                    <li>The user encrypts their data using a Homomorphic Encryption scheme.</li>
                    <li>The encrypted data is uploaded to the cloud service provider.</li>
                    <li>The cloud performs computations on the encrypted data.</li>
                    <li>The results are sent back to the user, who decrypts them to obtain the analysis results.</li>
                </ol>
                <p><strong>Advantages:</strong></p>
                <ul>
                    <li>The cloud never sees the unencrypted data.</li>
                    <li>The user benefits from the computational power of the cloud.</li>
                </ul>
            </article>

            <article>
                <h3>8. Live Example</h3>
                <p>Homomorphic Encryption offers a powerful tool for performing computations on encrypted data, preserving privacy and security. Let's explore some <a href="https://colab.research.google.com/drive/1otsz7RC3RHteORqfG7YPVcIPJn0KKLhp?usp=sharing">live examples</a> to illustrate its application.</p>
                <script src="https://gist.github.com/divyamohan1993/5b3ba6130bc97d626b9df7adc6a863a6.js"></script>
            </article>

            <article>
                <h3>9. Implementation of a Secure Voting System Using Homomorphic Encryption</h3>
                <p>This section outlines the development of a secure electronic voting system utilizing Homomorphic Encryption. The system ensures voter privacy and vote integrity by enabling vote tallying on encrypted ballots without decrypting individual votes.</p>
            </article>

            <article>
                <h4>9.1 Overview of the Voting System</h4>
                <p>The voting system allows voters to encrypt their choices using an additive homomorphic encryption scheme. The encrypted votes are sent to a central authority that aggregates them. The final tally is decrypted to reveal the election outcome without exposing individual votes.</p>
            </article>

            <article>
                <h4>9.2 System Components</h4>
                <p>The main components of the system include:</p>
                <ul>
                    <li><strong>Voters</strong>: Individuals casting encrypted votes.</li>
                    <li><strong>Election Authority</strong>: Generates encryption keys and tallies votes.</li>
                    <li><strong>Ballot Box</strong>: Collects encrypted votes from voters.</li>
                </ul>
            </article>

            <article>
                <h4>9.3 Homomorphic Encryption Scheme Used</h4>
                <p>The Paillier Cryptosystem is employed due to its additive homomorphic properties. It allows the addition of encrypted votes to correspond to the sum of the plaintext votes.</p>
            </article>

            <article>
                <h4>9.4 Implementation Details</h4>
                <p>The implementation involves the following steps:</p>
            </article>

            <article>
                <h5>9.4.1 Key Generation</h5>
                <p>The Election Authority generates a public and private key pair.</p>
                <pre><code class="language-python">from Crypto.Util import number

def generate_keys(key_size):
    # Generate two large primes, p and q
    p = number.getPrime(key_size)
    q = number.getPrime(key_size)
    n = p * q
    g = n + 1
    λ = (p - 1) * (q - 1)
    μ = pow(λ, -1, n)
    public_key = (n, g)
    private_key = (λ, μ)
    return public_key, private_key
</code></pre>
            </article>

            <article>
                <h5>9.4.2 Vote Encryption</h5>
                <p>Each voter encrypts their vote using the public key.</p>
                <pre><code class="language-python">def encrypt_vote(vote, public_key):
    n, g = public_key
    r = number.getRandomRange(1, n)
    c = pow(g, vote, n ** 2) * pow(r, n, n ** 2) % n ** 2
    return c
</code></pre>
                <p>The variable <code>vote</code> represents the voter's choice, typically encoded as an integer.</p>
            </article>

            <article>
                <h5>9.4.3 Vote Collection</h5>
                <p>Encrypted votes are collected in the ballot box.</p>
                <pre><code class="language-python">encrypted_votes = []
encrypted_votes.append(encrypt_vote(vote, public_key))
</code></pre>
            </article>

            <article>
                <h5>9.4.4 Homomorphic Tallying</h5>
                <p>The Election Authority aggregates the encrypted votes by multiplying them.</p>
                <pre><code class="language-python">def aggregate_votes(encrypted_votes, public_key):
    n, _ = public_key
    total = 1
    for c in encrypted_votes:
        total = total * c % n ** 2
    return total
</code></pre>
                <p>The product of the ciphertexts corresponds to the sum of the plaintext votes.</p>
            </article>

            <article>
                <h5>9.4.5 Decryption of Total Votes</h5>
                <p>The Election Authority decrypts the aggregated ciphertext to reveal the total vote count.</p>
                <pre><code class="language-python">def decrypt_total(total_ciphertext, public_key, private_key):
    n, _ = public_key
    λ, μ = private_key
    x = pow(total_ciphertext, λ, n ** 2) - 1
    plaintext = ((x // n) * μ) % n
    return plaintext
</code></pre>
            </article>

            <article>
                <h4>9.5 Full Implementation Code</h4>
                <p>The complete code integrating all components is presented below.</p>
                <pre><code class="language-python">from Crypto.Util import number

def generate_keys(key_size):
    p = number.getPrime(key_size)
    q = number.getPrime(key_size)
    n = p * q
    g = n + 1
    λ = (p - 1) * (q - 1)
    μ = pow(λ, -1, n)
    public_key = (n, g)
    private_key = (λ, μ)
    return public_key, private_key

def encrypt_vote(vote, public_key):
    n, g = public_key
    r = number.getRandomRange(1, n)
    c = pow(g, vote, n ** 2) * pow(r, n, n ** 2) % n ** 2
    return c

def aggregate_votes(encrypted_votes, public_key):
    n, _ = public_key
    total = 1
    for c in encrypted_votes:
        total = total * c % n ** 2
    return total

def decrypt_total(total_ciphertext, public_key, private_key):
    n, _ = public_key
    λ, μ = private_key
    x = pow(total_ciphertext, λ, n ** 2) - 1
    plaintext = ((x // n) * μ) % n
    return plaintext

# Key generation by Election Authority
public_key, private_key = generate_keys(512)

# Votes cast by voters (e.g., 0 for 'No', 1 for 'Yes')
votes = [1, 0, 1, 1, 0]

# Voters encrypt their votes
encrypted_votes = [encrypt_vote(vote, public_key) for vote in votes]

# Encrypted votes are aggregated
total_encrypted = aggregate_votes(encrypted_votes, public_key)

# Decryption of the total votes
total_votes = decrypt_total(total_encrypted, public_key, private_key)
print(f"Total 'Yes' votes: {total_votes}")
</code></pre>
                <p>This code demonstrates a simplified voting system where voters cast a 'Yes' or 'No' vote encoded as 1 or 0. The total number of 'Yes' votes is calculated without revealing individual choices.</p>
            </article>

            <article>
                <h4>9.6 Security Considerations</h4>
                <p>To ensure the system's security and integrity, several factors must be addressed:</p>
                <ul>
                    <li><strong>Voter Authentication</strong>: Verify the identity of voters to prevent fraud.</li>
                    <li><strong>Preventing Multiple Voting</strong>: Implement mechanisms to ensure each voter votes only once.</li>
                    <li><strong>Secure Key Management</strong>: Protect private keys from unauthorized access.</li>
                    <li><strong>Handling Vote Verification</strong>: Allow voters to verify that their vote was counted without revealing their choice.</li>
                </ul>
            </article>

            <article>
                <h4>9.7 Extending the System for Multiple Candidates</h4>
                <p>For elections with multiple candidates, the system can be extended by representing votes as vectors and using more advanced homomorphic schemes.</p>
                <p><strong>Approach:</strong></p>
                <ul>
                    <li>Assign an index to each candidate.</li>
                    <li>Represent each vote as a vector where only the chosen candidate's index is set to 1, and others are 0.</li>
                    <li>Encrypt each component of the vector separately.</li>
                    <li>Aggregate votes component-wise.</li>
                </ul>
                <p>This method allows tallying votes for each candidate without revealing individual selections.</p>
            </article>

            <article>
                <h4>9.8 Practical Challenges</h4>
                <p>Implementing a real-world voting system involves additional complexities:</p>
                <ul>
                    <li><strong>Scalability</strong>: Ensuring the system performs efficiently with a large number of voters.</li>
                    <li><strong>User Experience</strong>: Providing an accessible interface for voters with varying technical expertise.</li>
                    <li><strong>Regulatory Compliance</strong>: Adhering to legal requirements and election regulations.</li>
                    <li><strong>Auditability</strong>: Allowing for independent verification of election results.</li>
                </ul>
            </article>

            <article>
                <h4>9.9 Testing and Validation</h4>
                <p>Thorough testing is essential to validate the system's correctness and security.</p>
                <ul>
                    <li>Unit tests for cryptographic functions.</li>
                    <li>Integration tests for the overall voting process.</li>
                    <li>Security assessments to identify potential vulnerabilities.</li>
                </ul>
            </article>


        </main>

        <script> copyright("all"); </script>

    </body>

</html>