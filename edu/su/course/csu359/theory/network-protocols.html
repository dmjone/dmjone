<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>

        <title>Network Protocols - CSU359 - Shoolini University</title>
        <meta name="description" content="Learn about the different types of network protocols, their functions, and how they are used in data communication and networking.">

        <meta property=" og:image" content="/logo.png">
        <meta property="og:type" content="article">

        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@divyamohan1993">
        <meta name="twitter:creator" content="@divyamohan1993">
        <meta name="twitter:image" content="/logo.png">

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />

        <meta name="author" content="Divya Mohan">
        <meta name="robots" content="index, follow">
    </head>

    <body>

        <script> header_author("dm"); </script>

        <main>

            <article class="agen-tableofcontents">
                <h2 class="text-center">
                    Network Protocols
                </h2>
                <div class="d-none contentdate">2024, September 9</div>
            </article>


            <article>
                <h3>0. Network Protocols</h3>
                <p>Network protocols are formal rules that define how data is transmitted and received across a network. They ensure communication between devices by providing standards for data formats, addressing, transmission methods, and error handling. Protocols operate at different layers of the OSI (Open Systems Interconnection) or TCP/IP models, enabling devices to communicate, share resources, and ensure data integrity and security.</p>
            </article>

            <article>
                <h4>0.1 Types of Network Protocols</h4>
                <p>Network protocols are categorized based on their functions and the layers they operate in. Some common types include:</p>
                <ul>
                    <li><strong>Routing Protocols:</strong> Determine the best path for data to travel across networks.</li>
                    <li><strong>Security Protocols:</strong> Ensure data confidentiality, integrity, and authentication.</li>
                    <li><strong>Data Transfer Protocols:</strong> Manage the transmission of data between devices.</li>
                    <li><strong>Session Control Protocols:</strong> Manage connections and sessions between devices.</li>
                    <li><strong>Address Resolution Protocols:</strong> Map network addresses to physical device addresses.</li>
                </ul>
            </article>

            <article>
                <h4>0.2 Routing Protocols</h4>
                <p>Routing protocols are used to determine the most efficient path for data to travel across interconnected networks. They operate on the Network Layer and are classified into two main types:</p>

                <h5>0.2.1 Distance Vector Protocols</h5>
                <p>These protocols calculate the best path based on the distance (or "cost") to the destination. Each router sends information about the networks it can reach to its immediate neighbors. Examples include:</p>
                <ul>
                    <li><strong>RIP (Routing Information Protocol):</strong> Uses hop count as a metric to determine the shortest path. Limited to 15 hops.</li>
                    <li><strong>EIGRP (Enhanced Interior Gateway Routing Protocol):</strong> An advanced version of a distance vector protocol, which also considers bandwidth and delay in its routing decisions.</li>
                </ul>

                <h5>0.2.2 Link State Protocols</h5>
                <p>Link state protocols build a complete map of the network and calculate the shortest path using algorithms like Dijkstra's Algorithm. Examples include:</p>
                <ul>
                    <li><strong>OSPF (Open Shortest Path First):</strong> A widely used link-state protocol that dynamically adjusts routes based on network changes.</li>
                    <li><strong>IS-IS (Intermediate System to Intermediate System):</strong> Another link-state protocol used in large enterprise networks and ISPs.</li>
                </ul>
            </article>

            <article>
                <h4>0.3 Security Protocols</h4>
                <p>Security protocols are designed to protect the integrity, confidentiality, and authenticity of data transmitted across networks. Key protocols include:</p>

                <h5>0.3.1 IPsec (Internet Protocol Security)</h5>
                <p>IPsec is a suite of protocols used to secure IP communications by authenticating and encrypting each packet. It operates in two modes:</p>
                <ul>
                    <li><strong>Transport Mode:</strong> Only the payload of the IP packet is encrypted.</li>
                    <li><strong>Tunnel Mode:</strong> The entire IP packet, including the header, is encrypted.</li>
                </ul>

                <h5>0.3.2 SSL/TLS (Secure Sockets Layer/Transport Layer Security)</h5>
                <p>SSL and its successor TLS provide encryption and authentication for data transmitted over networks, typically used to secure web traffic (HTTPS) and email (FTPS).</p>

                <h5>0.3.3 Kerberos</h5>
                <p>A network authentication protocol that uses secret-key cryptography to verify the identity of users and devices. Commonly used in enterprise environments.</p>
            </article>

            <article>
                <h4>0.4 Address Resolution Protocols</h4>
                <p>Address resolution protocols map network addresses (IP addresses) to physical hardware addresses (MAC addresses). Examples include:</p>

                <h5>0.4.1 ARP (Address Resolution Protocol)</h5>
                <p>ARP is used to resolve an IP address into a MAC address. When a device wants to communicate with another device on the same local network, it uses ARP to discover the MAC address of the destination.</p>

                <h5>0.4.2 RARP (Reverse Address Resolution Protocol)</h5>
                <p>RARP allows a device to request its own IP address from a server based on its MAC address. This protocol is used by devices that do not have any knowledge of their IP address when booting.</p>
            </article>

            <article>
                <h4>0.5 Session Control Protocols</h4>
                <p>Session control protocols manage the establishment, maintenance, and termination of communication sessions between devices. These protocols ensure data can be sent reliably and in sequence.</p>

                <h5>0.5.1 SIP (Session Initiation Protocol)</h5>
                <p>SIP is used for initiating, maintaining, and terminating real-time sessions that involve video, voice, messaging, and other communications over IP networks. Commonly used in VoIP (Voice over IP) and video conferencing applications.</p>

                <h5>0.5.2 L2TP (Layer 2 Tunneling Protocol)</h5>
                <p>L2TP is used to tunnel data between two network endpoints over the internet. It is often combined with IPsec to provide secure communication channels, especially in VPNs (Virtual Private Networks).</p>
            </article>

            <article>
                <h4>0.6 Network Time Protocol (NTP)</h4>
                <p>NTP is a protocol used to synchronize the clocks of devices across a network. It ensures that all systems have the same time, which is critical for time-sensitive operations like logging events and securing communications.</p>
                <ul>
                    <li><strong>Stratum Levels:</strong> NTP uses a hierarchy of time sources called strata, with stratum 0 being the most accurate (e.g., atomic clocks).</li>
                    <li><strong>Synchronization:</strong> NTP uses algorithms to adjust clocks gradually, ensuring smooth synchronization without causing abrupt changes in system time.</li>
                </ul>
            </article>

            <article>
                <h4>0.7 Dynamic Host Configuration Protocol (DHCP)</h4>
                <p>DHCP is a protocol used to automatically assign IP addresses and other network configuration settings (such as subnet mask, gateway, and DNS servers) to devices on a network. This ensures that devices can communicate without manual configuration.</p>

                <ul>
                    <li><strong>IP Address Leasing:</strong> DHCP assigns an IP address to a device for a specific lease period. After the lease expires, the address can be reassigned to another device.</li>
                    <li><strong>Automatic Configuration:</strong> DHCP simplifies network management by automatically configuring devices with the necessary settings.</li>
                </ul>
            </article>

            <article>
                <h4>0.8 DNS (Domain Name System)</h4>
                <p>DNS is a hierarchical protocol used to translate human-readable domain names (e.g., www.example.com) into IP addresses (e.g., 192.168.1.1). DNS enables users to access websites without remembering numerical IP addresses.</p>

                <h5>0.8.1 DNS Resolution Process</h5>
                <p>When a user types a domain name in a browser, the DNS resolver on the user's device queries DNS servers to find the corresponding IP address. The process involves multiple steps:</p>
                <ul>
                    <li><strong>Query the Root Server:</strong> The resolver asks a root DNS server for the address of a top-level domain (TLD) server (e.g., for .com).</li>
                    <li><strong>Query the TLD Server:</strong> The TLD server responds with the address of the authoritative DNS server for the domain.</li>
                    <li><strong>Query the Authoritative DNS Server:</strong> The authoritative server provides the IP address associated with the domain name.</li>
                </ul>
            </article>

            <article>
                <h3>1. Network Protocols - Transmission Control Protocol/Internet Protocol (TCP/IP)</h3>
                <p>TCP/IP is the foundational suite of communication protocols used in the Internet and similar networks. It defines how data should be packetized, addressed, transmitted, routed, and received. TCP/IP has two primary protocols: Transmission Control Protocol (TCP) and Internet Protocol (IP). Together, they ensure reliable, organized communication across networked systems.</p>
            </article>

            <article>
                <h4>1.1 TCP/IP Model Layers</h4>
                <p>The TCP/IP model is structured in four layers, each responsible for a different aspect of communication:</p>
                <ul>
                    <li><strong>Application Layer:</strong> Interfaces between the user and network services (e.g., HTTP, FTP).</li>
                    <li><strong>Transport Layer:</strong> Handles end-to-end communication and error handling (e.g., TCP, UDP).</li>
                    <li><strong>Internet Layer:</strong> Routes packets across networks using IP addresses (e.g., IP, ICMP).</li>
                    <li><strong>Network Access Layer:</strong> Manages physical transmission of data on the network (e.g., Ethernet, Wi-Fi).</li>
                </ul>
            </article>

            <article>
                <h4>1.2 Transmission Control Protocol (TCP)</h4>
                <p>TCP is a reliable, connection-oriented protocol that ensures data is transmitted accurately and in order. It establishes a connection before data transfer, breaks data into segments, and guarantees delivery using acknowledgment and retransmission techniques.</p>

                <h5>1.2.1 Key Features of TCP</h5>
                <ul>
                    <li><strong>Connection Establishment:</strong> TCP uses a three-way handshake to establish a connection between two devices.</li>
                    <li><strong>Reliable Data Transfer:</strong> TCP ensures data integrity by using sequence numbers and acknowledgments to confirm the receipt of segments.</li>
                    <li><strong>Flow Control:</strong> Uses mechanisms like the sliding window to avoid overwhelming the receiving device.</li>
                    <li><strong>Error Control:</strong> TCP employs checksums to detect errors in data transmission.</li>
                    <li><strong>Congestion Control:</strong> Adjusts the rate of data transmission based on network traffic conditions (e.g., slow start, congestion avoidance).</li>
                </ul>

                <pre><code class="">
# Three-Way Handshake Process
1. SYN: Client sends a SYN (synchronize) packet to initiate the connection.
2. SYN-ACK: Server responds with a SYN-ACK packet to acknowledge the request.
3. ACK: Client sends an ACK (acknowledgment) packet, and the connection is established.
</code></pre>
            </article>

            <article>
                <h4>1.3 Internet Protocol (IP)</h4>
                <p>IP is a connectionless protocol responsible for delivering packets from source to destination based on IP addresses. It works on the Internet Layer and does not guarantee delivery or packet ordering.</p>

                <h5>1.3.1 Types of IP</h5>
                <ul>
                    <li><strong>IPv4:</strong> 32-bit addressing scheme (e.g., 192.168.1.1) with around 4.3 billion possible addresses.</li>
                    <li><strong>IPv6:</strong> 128-bit addressing scheme (e.g., 2001:0db8:85a3:0000:0000:8a2e:0370:7334) designed to overcome IPv4 limitations by offering a larger address space.</li>
                </ul>

                <h5>1.3.2 Packet Structure</h5>
                <p>Each IP packet contains a header and a payload:</p>
                <ul>
                    <li><strong>Header:</strong> Contains routing information like source and destination IP addresses.</li>
                    <li><strong>Payload:</strong> Contains the actual data being transmitted.</li>
                </ul>

                <pre><code class="">
# IPv4 Packet Structure
Version | Header Length | Type of Service | Total Length
Identification | Flags | Fragment Offset
Time to Live (TTL) | Protocol | Header Checksum
Source IP Address
Destination IP Address
Options (optional) | Padding
Data (payload)
</code></pre>
            </article>

            <article>
                <h4>1.4 User Datagram Protocol (UDP)</h4>
                <p>UDP is a simpler, connectionless alternative to TCP. It is faster but offers no guarantee of data delivery, ordering, or error checking. It is used for applications where speed is more important than reliability, like streaming or gaming.</p>

                <h5>1.4.1 Key Features of UDP</h5>
                <ul>
                    <li><strong>No Connection Establishment:</strong> Unlike TCP, UDP does not establish a connection before data transfer.</li>
                    <li><strong>Faster Transmission:</strong> Lacks flow control and error-checking mechanisms, making it faster than TCP.</li>
                    <li><strong>Unreliable Delivery:</strong> Packets may be lost, reordered, or duplicated during transmission.</li>
                </ul>

                <pre><code class="">
# UDP Packet Structure
Source Port | Destination Port
Length | Checksum
Data (payload)
</code></pre>
            </article>

            <article>
                <h4>1.5 IP Addressing and Subnetting</h4>
                <p>IP addressing is crucial for identifying devices in a network. A subnet mask is used to divide IP addresses into network and host portions, enabling efficient network design and management.</p>

                <h5>1.5.1 Subnet Mask</h5>
                <p>A subnet mask helps to determine the network and host parts of an IP address. It is typically written in dotted decimal form (e.g., 255.255.255.0).</p>

                <h5>1.5.2 Subnetting Example</h5>
                <pre><code class="">
IP Address: 192.168.1.10
Subnet Mask: 255.255.255.0

# Network address: 192.168.1.0
# Host range: 192.168.1.1 - 192.168.1.254
# Broadcast address: 192.168.1.255
</code></pre>
            </article>

            <article>
                <h4>1.6 Routing in TCP/IP Networks</h4>
                <p>Routing involves determining the optimal path for data to travel from source to destination across interconnected networks. Routers make decisions based on routing tables and protocols such as RIP, OSPF, and BGP.</p>

                <h5>1.6.1 Routing Table</h5>
                <p>Routers use routing tables to store information about possible network paths. A routing table typically includes:</p>
                <ul>
                    <li><strong>Destination IP:</strong> The IP address of the destination network.</li>
                    <li><strong>Subnet Mask:</strong> Defines the network portion of the destination IP.</li>
                    <li><strong>Next Hop:</strong> The next router in the path to the destination.</li>
                    <li><strong>Metric:</strong> A value indicating the cost of using the route.</li>
                </ul>

                <pre><code class="">
# Sample Routing Table
Destination | Gateway | Genmask       | Flags | Metric | Interface
0.0.0.0     | 192.168.1.1 | 0.0.0.0       | UG    | 100    | eth0
192.168.1.0 | 0.0.0.0     | 255.255.255.0 | U     | 0      | eth0
</code></pre>
            </article>

            <article>
            <h3>2. User Datagram Protocol (UDP)</h3>
            <p>UDP is a core protocol in the Internet Protocol (IP) suite, used to send messages called datagrams between devices on an IP network. It is a connectionless protocol, meaning that it does not establish a connection before data transmission, nor does it ensure reliable delivery or order of the data. UDP is ideal for applications where speed is prioritized over reliability, such as real-time video streaming, online gaming, or voice over IP (VoIP).</p>
            </article>

            <article>
                <h4>2.1 Key Characteristics of UDP</h4>
                <ul>
                    <li><strong>Connectionless Communication:</strong> No connection establishment before sending data. Packets are sent without any guarantees.</li>
                    <li><strong>Unreliable:</strong> No acknowledgment of received packets. Data may be lost, duplicated, or arrive out of order.</li>
                    <li><strong>Low Latency:</strong> UDP offers faster transmission because it skips error checking and connection setup.</li>
                    <li><strong>No Flow Control or Congestion Control:</strong> UDP does not handle congestion on the network, so packet loss can occur during heavy traffic.</li>
                    <li><strong>Lightweight:</strong> The overhead of UDP packets is minimal, as it only includes essential header information.</li>
                </ul>
            </article>

            <article>
                <h4>2.2 UDP Packet Structure</h4>
                <p>Each UDP packet consists of a header and a data section (payload). The UDP header is simpler than the TCP header, containing only 4 fields:</p>
                <ul>
                    <li><strong>Source Port (16 bits):</strong> The port number of the sending application.</li>
                    <li><strong>Destination Port (16 bits):</strong> The port number of the receiving application.</li>
                    <li><strong>Length (16 bits):</strong> Specifies the length of the UDP header and data.</li>
                    <li><strong>Checksum (16 bits):</strong> Used for error checking the header and data, though it is optional.</li>
                </ul>

                <pre><code class="">
# UDP Packet Structure
Source Port | Destination Port
Length      | Checksum
Data (payload)
</code></pre>
            </article>

            <article>
                <h4>2.3 Advantages of Using UDP</h4>
                <ul>
                    <li><strong>Speed:</strong> Since UDP does not require connection setup or acknowledgment, it is faster than TCP.</li>
                    <li><strong>Efficiency:</strong> With minimal overhead, UDP is ideal for applications that require efficient use of bandwidth.</li>
                    <li><strong>Broadcast and Multicast Support:</strong> UDP supports one-to-many communication, which is critical for services like live streaming and multiplayer gaming.</li>
                </ul>
            </article>

            <article>
                <h4>2.4 Use Cases for UDP</h4>
                <p>UDP is commonly used in scenarios where timely delivery of data is more critical than ensuring accuracy. Examples include:</p>
                <ul>
                    <li><strong>Real-time Streaming (e.g., video/audio):</strong> Small delays in video or audio are acceptable as long as the data continues streaming.</li>
                    <li><strong>Online Gaming:</strong> Games prioritize low latency for real-time interactions. Missing packets are often acceptable to keep the game flow uninterrupted.</li>
                    <li><strong>Voice over IP (VoIP):</strong> Timely delivery of voice packets is crucial to maintaining smooth communication, even if some packets are lost.</li>
                </ul>
            </article>

            <article>
                <h4>2.5 Differences Between TCP and UDP</h4>
                <p>TCP and UDP serve different purposes, and understanding their differences helps choose the appropriate protocol for a given application:</p>
                <table class="table table-bordered">
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>TCP</th>
                            <th>UDP</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Connection Type</strong></td>
                            <td>Connection-oriented (requires a connection setup)</td>
                            <td>Connectionless (no connection required)</td>
                        </tr>
                        <tr>
                            <td><strong>Reliability</strong></td>
                            <td>Reliable, with acknowledgment, retransmission, and error checking</td>
                            <td>Unreliable, no acknowledgment, no retransmission</td>
                        </tr>
                        <tr>
                            <td><strong>Ordering</strong></td>
                            <td>Ensures data arrives in order</td>
                            <td>No guarantee of order</td>
                        </tr>
                        <tr>
                            <td><strong>Speed</strong></td>
                            <td>Slower due to overhead</td>
                            <td>Faster with less overhead</td>
                        </tr>
                        <tr>
                            <td><strong>Use Cases</strong></td>
                            <td>File transfer, email, web browsing</td>
                            <td>Video streaming, online gaming, VoIP</td>
                        </tr>
                    </tbody>
                </table>
            </article>

            <article>
                <h4>2.6 Example of UDP in Code</h4>
                <p>Here is a basic example of how UDP can be implemented in Python using socket programming:</p>

                <pre><code class="language-python">
import socket

# UDP Server
server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
server_socket.bind(('localhost', 12345))
print("Server listening...")

while True:
    data, addr = server_socket.recvfrom(1024)
    print(f"Received message: {data.decode()} from {addr}")
    server_socket.sendto(b"Message received", addr)

# UDP Client
client_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
client_socket.sendto(b"Hello UDP Server", ('localhost', 12345))
message, server = client_socket.recvfrom(1024)
print(f"Received reply from server: {message.decode()}")
client_socket.close()
</code></pre>
                <p>This code sets up a basic UDP server and client. The server listens on a port for incoming datagrams, while the client sends a message to the server. Notice that no connection is established, and the data is sent and received without acknowledgment.</p>
            </article>

            <article>
                <h3>3. Hypertext Transfer Protocol (HTTP/HTTPS)</h3>
                <p>HTTP (Hypertext Transfer Protocol) and HTTPS (HTTP Secure) are the primary protocols used for transmitting data over the web. HTTP is a stateless, application-layer protocol designed to facilitate communication between web browsers (clients) and web servers. HTTPS is the secure version of HTTP, which adds encryption to ensure the confidentiality and integrity of data being transmitted.</p>
            </article>

            <article>
                <h4>3.1 Key Characteristics of HTTP</h4>
                <ul>
                    <li><strong>Stateless Protocol:</strong> Each request is independent, and no information about previous requests is retained. Sessions need to be managed using cookies or tokens.</li>
                    <li><strong>Client-Server Model:</strong> HTTP follows a request-response model where the client sends a request, and the server responds with the requested data.</li>
                    <li><strong>Methods:</strong> HTTP uses various methods for interaction:
                        <ul>
                            <li><strong>GET:</strong> Retrieve data from the server.</li>
                            <li><strong>POST:</strong> Send data to the server for processing.</li>
                            <li><strong>PUT:</strong> Update existing data on the server.</li>
                            <li><strong>DELETE:</strong> Remove data from the server.</li>
                        </ul>
                    </li>
                    <li><strong>Unsecured:</strong> In HTTP, data is transmitted in plain text, making it vulnerable to interception.</li>
                </ul>
            </article>

            <article>
                <h4>3.2 Key Characteristics of HTTPS</h4>
                <ul>
                    <li><strong>Secure Communication:</strong> HTTPS uses SSL/TLS encryption to ensure that data is secure during transmission.</li>
                    <li><strong>Authentication:</strong> HTTPS ensures that the server is authenticated using digital certificates (e.g., SSL certificates).</li>
                    <li><strong>Data Integrity:</strong> HTTPS guarantees that data cannot be altered during transmission.</li>
                    <li><strong>Confidentiality:</strong> All data is encrypted, protecting sensitive information such as login credentials and payment details.</li>
                </ul>
            </article>

            <article>
                <h4>3.3 HTTP Request and Response Structure</h4>
                <p>HTTP operates using a request-response structure:</p>

                <h5>3.3.1 HTTP Request</h5>
                <p>An HTTP request consists of:</p>
                <ul>
                    <li><strong>Request Line:</strong> Contains the HTTP method (e.g., GET, POST), the requested URL, and the HTTP version.</li>
                    <li><strong>Headers:</strong> Provide additional information about the request, such as content type, user agent, etc.</li>
                    <li><strong>Body (optional):</strong> Contains data sent to the server (for methods like POST or PUT).</li>
                </ul>

                <pre><code class="">
GET /index.html HTTP/1.1
Host: dmj.one
User-Agent: Mozilla/5.0
</code></pre>

                <h5>3.3.2 HTTP Response</h5>
                <p>An HTTP response consists of:</p>
                <ul>
                    <li><strong>Status Line:</strong> Contains the HTTP version, status code (e.g., 200 OK, 404 Not Found), and a reason phrase.</li>
                    <li><strong>Headers:</strong> Provide additional information such as content type and server details.</li>
                    <li><strong>Body (optional):</strong> The requested data (e.g., an HTML page).</li>
                </ul>

                <pre><code class="language-http">
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 138
Server: Apache/2.4.1

&lt;html>
  &lt;body>
    &lt;h1>Welcome to the Homepage</h1>
  &lt;/body>
&lt;/html>
</code></pre>
            </article>

            <article>
                <h4>3.4 Status Codes in HTTP</h4>
                <p>Status codes are used to indicate the result of an HTTP request. These codes are grouped into five categories:</p>
                <ul>
                    <li><strong>1xx Informational:</strong> The request has been received and is being processed.</li>
                    <li><strong>2xx Success:</strong> The request was successful (e.g., <strong>200 OK</strong>).</li>
                    <li><strong>3xx Redirection:</strong> The client must take additional action to complete the request (e.g., <strong>301 Moved Permanently</strong>).</li>
                    <li><strong>4xx Client Error:</strong> There was an error in the client's request (e.g., <strong>404 Not Found</strong>).</li>
                    <li><strong>5xx Server Error:</strong> The server failed to fulfill a valid request (e.g., <strong>500 Internal Server Error</strong>).</li>
                </ul>
            </article>

            <article>
                <h4>3.5 SSL/TLS in HTTPS</h4>
                <p>HTTPS employs SSL (Secure Sockets Layer) or TLS (Transport Layer Security) to encrypt the connection between the client and server. This encryption ensures that sensitive information, such as passwords or payment details, remains secure during transmission.</p>

                <h5>3.5.1 SSL/TLS Handshake</h5>
                <p>The SSL/TLS handshake is a process that establishes a secure connection between a client and a server:</p>
                <ul>
                    <li><strong>Client Hello:</strong> The client sends a request to the server, indicating supported encryption algorithms.</li>
                    <li><strong>Server Hello:</strong> The server responds with its chosen encryption method and provides its SSL certificate.</li>
                    <li><strong>Key Exchange:</strong> The client and server exchange cryptographic keys to establish a secure session.</li>
                    <li><strong>Data Encryption:</strong> All communication between the client and server is encrypted using the agreed-upon method.</li>
                </ul>

                <pre><code class="">
# Simplified TLS Handshake
1. Client Hello -> Server Hello
2. Server sends certificate
3. Client verifies certificate
4. Key exchange
5. Secure data transmission
</code></pre>
            </article>

            <article>
                <h4>3.6 Advantages of HTTPS Over HTTP</h4>
                <ul>
                    <li><strong>Security:</strong> Data is encrypted and protected from eavesdropping and tampering.</li>
                    <li><strong>Authentication:</strong> HTTPS verifies the identity of the website, ensuring that the user is communicating with the intended server.</li>
                    <li><strong>Trust:</strong> Users are more likely to trust and interact with a secure website, as indicated by the padlock symbol in browsers.</li>
                    <li><strong>SEO Benefits:</strong> Search engines prioritize HTTPS-enabled websites, leading to better rankings.</li>
                </ul>
            </article>

            <article>
                <h4>3.7 Example of HTTP and HTTPS Communication</h4>
                <p>Below is a Python example using the <code>requests</code> library to demonstrate HTTP and HTTPS requests:</p>

                <pre><code class="language-python">
import requests

# HTTP Request (Insecure)
response_http = requests.get('http://dmj.one')
print("HTTP Response:", response_http.status_code)

# HTTPS Request (Secure)
response_https = requests.get('https://dmj.one')
print("HTTPS Response:", response_https.status_code)
</code></pre>
                <p>In this example, the same URL is accessed using both HTTP and HTTPS. The HTTPS request provides an encrypted, secure connection, while the HTTP request does not.</p>
            </article>

            <article>
                <h3>4. Simple Mail Transfer Protocol (SMTP)</h3>
                <p>Simple Mail Transfer Protocol (SMTP) is a protocol used for sending emails across the Internet. It operates on the application layer and facilitates communication between email servers to ensure the reliable transfer of email messages. SMTP is primarily responsible for pushing messages from the sender’s email client to the recipient’s email server.</p>
            </article>

            <article>
                <h4>4.1 Key Characteristics of SMTP</h4>
                <ul>
                    <li><strong>Push Protocol:</strong> SMTP is used to push emails from a sender’s email client to the server and between mail servers.</li>
                    <li><strong>Connection-Oriented:</strong> SMTP requires the client to establish a connection with the server before sending emails.</li>
                    <li><strong>Simple and Text-Based:</strong> SMTP commands and messages are sent as plain text, making it easy to implement and debug.</li>
                    <li><strong>Operates on Port 25:</strong> By default, SMTP uses port 25 for communication, though ports 587 and 465 are also used for encrypted transmission (with TLS/SSL).</li>
                </ul>
            </article>

            <article>
                <h4>4.2 How SMTP Works</h4>
                <p>SMTP operates through a client-server model. The process involves multiple steps to deliver an email successfully:</p>
                <ul>
                    <li><strong>Step 1 - Mail Submission:</strong> The email client (e.g., Outlook, Gmail) sends an email to the outgoing mail server using SMTP.</li>
                    <li><strong>Step 2 - Mail Transfer:</strong> The outgoing mail server checks the recipient's domain and forwards the email to the recipient's mail server using SMTP.</li>
                    <li><strong>Step 3 - Mail Delivery:</strong> The recipient's mail server receives the email and stores it in the inbox, where it can be accessed by the recipient using an email client (through IMAP or POP3).</li>
                </ul>

                <p>The process can be visualized as follows:</p>

                <pre><code class="">
Client --&gt; SMTP --&gt; Sender's Mail Server --&gt; SMTP --&gt; Recipient's Mail Server --&gt; Inbox
</code></pre>
            </article>

            <article>
                <h4>4.3 SMTP Commands</h4>
                <p>SMTP uses a set of standard commands to initiate and manage the email-sending process. Key commands include:</p>
                <ul>
                    <li><strong>HELO/EHLO:</strong> Identifies the sender's domain to the mail server.</li>
                    <li><strong>MAIL FROM:</strong> Specifies the sender's email address.</li>
                    <li><strong>RCPT TO:</strong> Specifies the recipient's email address.</li>
                    <li><strong>DATA:</strong> Sends the body of the email, including the subject, content, and attachments.</li>
                    <li><strong>QUIT:</strong> Terminates the SMTP session.</li>
                </ul>

                <pre><code class="">
HELO example.com
MAIL FROM:&lt;sender@example.com>
RCPT TO:&lt;recipient@example.com>
DATA
Subject: Test Email

This is a test email message.
.
QUIT
</code></pre>
                <p>The "DATA" command is used to send the actual email content, and the email is terminated with a single period (".") on a line by itself.</p>
            </article>

            <article>
                <h4>4.4 SMTP Authentication and Security</h4>
                <p>To ensure that email transmission is secure, SMTP often employs authentication and encryption mechanisms. These include:</p>
                <ul>
                    <li><strong>SMTP Authentication:</strong> Requires the sender to authenticate with the mail server using a username and password before sending emails. This prevents unauthorized users from sending emails through the server.</li>
                    <li><strong>SSL/TLS Encryption:</strong> SMTP can be secured using SSL (on port 465) or TLS (on port 587) to encrypt email communications, ensuring that the data transmitted between email servers is protected from eavesdropping and tampering.</li>
                </ul>

                <pre><code class="">
# Using SSL/TLS for secure email transmission
STARTTLS
</code></pre>
            </article>

            <article>
                <h4>4.5 Common SMTP Response Codes</h4>
                <p>When an SMTP command is issued, the server responds with a numeric status code to indicate the result. Common SMTP response codes include:</p>
                <ul>
                    <li><strong>220:</strong> The server is ready to accept requests.</li>
                    <li><strong>250:</strong> The requested action was completed successfully.</li>
                    <li><strong>354:</strong> The server is ready to receive the email body (in response to the "DATA" command).</li>
                    <li><strong>421:</strong> The service is unavailable, and the connection will be closed.</li>
                    <li><strong>450:</strong> The requested action was not taken due to a temporary failure.</li>
                    <li><strong>550:</strong> The email was not delivered because the recipient's mailbox is unavailable.</li>
                </ul>

                <pre><code class="">
# Sample SMTP response codes during communication
220 smtp.example.com ESMTP Service ready
250 OK
354 Start mail input; end with &lt;CRLF&gt;.&lt;CRLF&gt;
550 Requested action not taken: Mailbox unavailable
</code></pre>
            </article>

            <article>
                <h4>4.6 Example of SMTP in Code</h4>
                <p>Here is an example of how to send an email using Python's <code>smtplib</code> library:</p>

                <pre><code class="language-python">
import smtplib
from email.mime.text import MIMEText

# Email details
sender = "sender@example.com"
recipient = "recipient@example.com"
subject = "Test Email"
body = "This is a test email."

# Create the email message
msg = MIMEText(body)
msg["Subject"] = subject
msg["From"] = sender
msg["To"] = recipient

# SMTP server configuration
smtp_server = "smtp.example.com"
smtp_port = 587
smtp_user = "username"
smtp_password = "password"

# Establish a connection to the SMTP server
with smtplib.SMTP(smtp_server, smtp_port) as server:
    server.starttls()  # Secure the connection
    server.login(smtp_user, smtp_password)  # Log in to the SMTP server
    server.sendmail(sender, recipient, msg.as_string())  # Send the email
    print("Email sent successfully!")
</code></pre>
                <p>In this example, we use the <code>smtplib</code> library to establish a connection with an SMTP server and send an email. The connection is secured using <code>starttls()</code>, and the server requires authentication before sending the email.</p>
            </article>

            <article>
                <h3>5. File Transfer Protocol (FTP)</h3>
                <p>File Transfer Protocol (FTP) is a standard network protocol used for transferring files between a client and a server over a TCP/IP network. FTP is designed to enable users to upload, download, and manage files on remote servers. It operates on a client-server model and can work in either active or passive mode depending on the configuration of the server and firewall settings.</p>
            </article>

            <article>
                <h4>5.1 Key Characteristics of FTP</h4>
                <ul>
                    <li><strong>Client-Server Architecture:</strong> FTP functions with a client that connects to a remote FTP server to upload or download files.</li>
                    <li><strong>Two Channels:</strong> FTP uses two separate channels for communication:
                        <ul>
                            <li><strong>Control Channel:</strong> Manages commands and responses (operates on port 21).</li>
                            <li><strong>Data Channel:</strong> Transfers the actual file data (usually on port 20).</li>
                        </ul>
                    </li>
                    <li><strong>Unsecured by Default:</strong> FTP transmits data, including usernames and passwords, in plain text. Secure alternatives like FTPS or SFTP provide encryption.</li>
                    <li><strong>Modes:</strong> FTP can operate in active or passive mode to handle different firewall and network configurations:
                        <ul>
                            <li><strong>Active Mode:</strong> The client opens a port and listens, while the server connects to the client to transfer data.</li>
                            <li><strong>Passive Mode:</strong> The client initiates both the control and data connections, making it easier to work behind firewalls.</li>
                        </ul>
                    </li>
                </ul>
            </article>

            <article>
                <h4>5.2 FTP Commands</h4>
                <p>FTP uses a range of commands for file management and navigation on the server. Common FTP commands include:</p>
                <ul>
                    <li><strong>USER:</strong> Provides the username for login.</li>
                    <li><strong>PASS:</strong> Provides the password for login.</li>
                    <li><strong>LIST:</strong> Lists the files in the current directory.</li>
                    <li><strong>RETR:</strong> Retrieves (downloads) a file from the server.</li>
                    <li><strong>STOR:</strong> Uploads (stores) a file to the server.</li>
                    <li><strong>CWD:</strong> Changes the working directory.</li>
                    <li><strong>QUIT:</strong> Ends the FTP session.</li>
                </ul>

                <pre><code class="">
USER username
PASS password
LIST
RETR example.txt
STOR upload.txt
QUIT
</code></pre>
            </article>

            <article>
                <h4>5.3 How FTP Works</h4>
                <p>FTP follows a straightforward process for file transfers between a client and a server:</p>
                <ul>
                    <li><strong>Step 1 - Connection Establishment:</strong> The client initiates a connection to the FTP server by opening the control channel on port 21 and providing login credentials.</li>
                    <li><strong>Step 2 - Directory Navigation:</strong> The client can navigate the server's file system using commands such as <code>LIST</code> to view files and <code>CWD</code> to change directories.</li>
                    <li><strong>Step 3 - File Transfer:</strong> The client requests to download or upload files using <code>RETR</code> or <code>STOR</code> commands. This initiates the data transfer over the data channel.</li>
                    <li><strong>Step 4 - Session Termination:</strong> The client sends a <code>QUIT</code> command to end the session, closing both the control and data channels.</li>
                </ul>

                <pre><code class="">
# FTP Process Overview:
Client --> Control Channel (port 21) --> Server
Client --> Data Channel (port 20) --> Server (for file transfer)
</code></pre>
            </article>

            <article>
                <h4>5.4 Active vs. Passive FTP Modes</h4>
                <p>FTP can operate in two modes: active and passive. The difference lies in how the data connection is established:</p>

                <h5>5.4.1 Active Mode</h5>
                <p>In active mode, the client opens a random port and informs the server, which then initiates the data connection from its port 20 to the client’s specified port. This mode may face issues with firewalls since the server initiates the connection to the client.</p>

                <h5>5.4.2 Passive Mode</h5>
                <p>In passive mode, the server opens a random port and informs the client, which then initiates the data connection. This is more firewall-friendly because the client initiates both the control and data connections.</p>

                <pre><code class="">
# Active Mode (client opens port, server connects back)
Client --> Control Channel --> Server (port 21)
Server --> Data Channel --> Client (random port)

# Passive Mode (client connects to server's random port)
Client --> Control Channel --> Server (port 21)
Client --> Data Channel --> Server (random port)
</code></pre>
            </article>

            <article>
                <h4>5.5 Security Concerns with FTP</h4>
                <p>Since FTP transmits data in plain text, including login credentials, it is susceptible to security risks such as eavesdropping, data tampering, and man-in-the-middle attacks. To address these issues, two secure alternatives to FTP are widely used:</p>

                <ul>
                    <li><strong>FTPS (FTP Secure):</strong> FTP with SSL/TLS encryption to secure file transfers.</li>
                    <li><strong>SFTP (SSH File Transfer Protocol):</strong> A completely different protocol that operates over SSH, providing encryption and secure authentication for file transfers.</li>
                </ul>
            </article>

            <article>
                <h4>5.6 Example of FTP in Code</h4>
                <p>Here is a basic example of using Python's <code>ftplib</code> to connect to an FTP server, list files, and download a file:</p>

                <pre><code class="language-python">
import ftplib

# FTP server details
ftp_server = "ftp.example.com"
ftp_user = "username"
ftp_password = "password"

# Establish connection to the FTP server
ftp = ftplib.FTP(ftp_server)
ftp.login(ftp_user, ftp_password)

# List files in the current directory
ftp.retrlines('LIST')

# Download a file from the server
with open('downloaded_file.txt', 'wb') as file:
    ftp.retrbinary('RETR example.txt', file.write)

# Close the connection
ftp.quit()
</code></pre>
                <p>This Python script connects to an FTP server, lists the files in the directory, and downloads a file using the <code>RETR</code> command.</p>
            </article>
        </main>

        <script> copyright("all"); </script>

    </body>

</html>