<!-------------------------- Â© 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>

        <title>Sliding Windows Protocol - CSU359 - Shoolini University</title>
        <meta name="description" content="Learn about the Sliding Windows Protocol, part of the CSU359 course at Shoolini University.">

        <meta property=" og:image" content="/logo.png">
        <meta property="og:type" content="article">

        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@divyamohan1993">
        <meta name="twitter:creator" content="@divyamohan1993">
        <meta name="twitter:image" content="/logo.png">

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />

        <meta name="author" content="Divya Mohan">
        <meta name="robots" content="index, follow">
    </head>

    <body>

        <script> header_author("dm"); </script>

        <main>

            <article class="agen-tableofcontents">
                <h2 class="text-center">
                    Sliding Windows Protocol
                </h2>
                <div class="d-none contentdate">2024, September 9</div>
            </article>

            <article>
                <h3>Sliding Window Protocol</h3>
                <p>The Sliding Window Protocol is a crucial mechanism in computer networks used for flow control and error control. It ensures efficient and reliable data transmission between two devices in a network, particularly in environments with varying delay and throughput. This protocol is widely used in Transport Layer protocols like TCP.</p>

                <article>
                    <h4>1. Overview of Sliding Window Protocol</h4>
                    <p>The Sliding Window Protocol allows multiple frames to be sent before requiring an acknowledgment. This improves the utilization of network resources by keeping the communication channel busy.</p>
                    <ul>
                        <li><strong>Window Size</strong>: The number of frames that can be sent without receiving an acknowledgment.</li>
                        <li><strong>Sender's Window</strong>: Tracks frames sent but not yet acknowledged.</li>
                        <li><strong>Receiver's Window</strong>: Tracks frames received and ready for acknowledgment.</li>
                    </ul>
                </article>

                <article>
                    <h4>2. Key Components</h4>
                    <p>The Sliding Window Protocol operates based on several essential components:</p>
                    <ul>
                        <li><strong>Sequence Numbers</strong>: Used to uniquely identify frames.</li>
                        <li><strong>Acknowledgments (ACKs)</strong>: Sent by the receiver to confirm receipt of frames.</li>
                        <li><strong>Window Size</strong>: Determines how many frames can be sent without acknowledgment.</li>
                    </ul>
                </article>

                <article>
                    <h4>3. Types of Sliding Window Protocols</h4>
                    <p>There are three main types of Sliding Window Protocols, each differing in how they handle acknowledgments and retransmissions:</p>

                    <h5>3.1 Stop-and-Wait Protocol</h5>
                    <p>A basic form of sliding window where the sender transmits one frame and waits for an acknowledgment before sending the next frame.</p>
                    <ul>
                        <li><strong>Advantages</strong>: Simple to implement.</li>
                        <li><strong>Disadvantages</strong>: Inefficient as it underutilizes the communication channel.</li>
                    </ul>

                    <h5>3.2 Go-Back-N Protocol</h5>
                    <p>The sender can transmit up to <em>N</em> frames without waiting for an acknowledgment. If an error occurs, all subsequent frames are retransmitted.</p>
                    <ul>
                        <li><strong>Advantages</strong>: Efficient for networks with low error rates.</li>
                        <li><strong>Disadvantages</strong>: Retransmission of multiple frames in case of a single error.</li>
                    </ul>
                    <pre><code class="language-python">
# Example Go-Back-N Simulation
def go_back_n(frames, window_size):
    ack = 0
    for i in range(len(frames)):
        if i < ack + window_size:
            print(f"Sending frame {frames[i]}")
        else:
            print("Window full. Waiting for acknowledgment.")
        if frames[i] == "error":
            print(f"Error in frame {frames[i]}. Retransmitting from frame {ack}")
            break
        ack += 1
    print(f"All frames acknowledged up to {ack}.")
</code></pre>

                    <h5>3.3 Selective Repeat Protocol</h5>
                    <p>The sender retransmits only the specific frames that encountered errors while the receiver stores out-of-order frames in a buffer.</p>
                    <ul>
                        <li><strong>Advantages</strong>: Efficient as only erroneous frames are retransmitted.</li>
                        <li><strong>Disadvantages</strong>: Requires more complex receiver logic.</li>
                    </ul>
                    <pre><code class="language-python">
# Example Selective Repeat Simulation
def selective_repeat(frames, window_size):
    buffer = {}
    for i in range(len(frames)):
        if i < window_size:
            print(f"Sending frame {frames[i]}")
        if frames[i] == "error":
            print(f"Error in frame {frames[i]}. Requesting retransmission.")
        else:
            buffer[i] = frames[i]
    print("Buffered frames:", buffer)
</code></pre>
                </article>

                <article>
                    <h4>4. Advantages of Sliding Window Protocol</h4>
                    <p>Key benefits include:</p>
                    <ul>
                        <li><strong>Improved Efficiency</strong>: Keeps the channel utilized by sending multiple frames before acknowledgment.</li>
                        <li><strong>Error Handling</strong>: Protocol variants like Selective Repeat minimize retransmission overhead.</li>
                        <li><strong>Flow Control</strong>: Dynamically adjusts to network conditions.</li>
                    </ul>
                </article>

                <article>
                    <h4>5. Real-World Application</h4>
                    <p>The Sliding Window Protocol is extensively used in the Transmission Control Protocol (TCP). TCP implements a dynamic sliding window mechanism to optimize data flow based on network conditions, ensuring reliable transmission in diverse network environments.</p>
                </article>
            </article>

        </main>

        <script> copyright("all"); </script>

    </body>

</html>