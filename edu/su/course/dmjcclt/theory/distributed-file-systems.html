<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>

        <title>Distributed File Systems - DMJCCLT - dmj.one</title>
        <meta name="description" content="Know about Distributed File Systems and their applications in Distributed Systems.">

        <meta property="og:image" content="/logo.png">
        <meta property="og:type" content="article">

        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@divyamohan1993">
        <meta name="twitter:creator" content="@divyamohan1993">
        <meta name="twitter:image" content="/logo.png">

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />

        <meta name="author" content="Divya Mohan">
        <meta name="robots" content="index, follow">

        <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                renderMathInElement(document.body, {
                    // customised options
                    // • auto-render specific keys, e.g.:
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\(', right: '\\)', display: false },
                        { left: '\\[', right: '\\]', display: true }
                    ],
                    // • rendering keys, e.g.:
                    throwOnError: false
                });
            });
        </script> -->

        <!-- <style>
            main ul {
                list-style-type: none;
                padding: 0;
                margin: 0;
            }

            main ul li {
                margin: 0;
                padding: 0;
            }
        </style> -->

    </head>

    <body>

        <script> header_author("dm", "lakshika"); </script>

        <main>
            <article class="agen-tableofcontents">
                <h2 class="text-center">
                    Distributed File Systems
                </h2>
                <div class="d-none contentdate">2024, December 31</div>
            </article>
            <article>
                <h3>Distributed File Systems</h3>
                <p>A Distributed File System (DFS) is a system where files and directories are stored across multiple servers and accessed by clients as if they were local. This setup addresses challenges in scalability, availability, and fault tolerance in distributed environments. Let’s break this down:</p>

                <h4>What is DFS?</h4>
                <p>DFS abstracts the complexity of managing data across multiple machines. It allows users and applications to perform file operations seamlessly without worrying about the physical location of the data.</p>

                <h4>Why use DFS?</h4>
                <ul>
                    <li><strong>Transparency:</strong> Users and applications interact with files without needing to know their physical storage location, replication details, or fault-tolerance mechanisms.</li>
                    <li><strong>Concurrent Client Support:</strong> Enables multiple users or processes to access and modify files simultaneously, ensuring collaborative efficiency.</li>
                    <li><strong>Fault Tolerance:</strong> Through replication, DFS ensures data availability even in the event of server failures, making it reliable for critical applications.</li>
                    <li><strong>Scalability:</strong> Distributed storage allows systems to grow and handle increased workloads without central bottlenecks.</li>
                </ul>

                <h4>How does DFS work?</h4>
                <ul>
                    <li><strong>Data Distribution:</strong> Files are segmented into blocks or handled as complete entities, distributed across servers based on the DFS design.</li>
                    <li><strong>Access Mechanism:</strong> Client-side modules communicate with server-side components, often through Remote Procedure Calls (RPCs), to perform file operations.</li>
                    <li><strong>Consistency Management:</strong> Ensures that all replicas reflect accurate and up-to-date information despite concurrent accesses or network partitions.</li>
                    <li><strong>Security:</strong> Authentication and authorization protocols safeguard data during transfers across the network.</li>
                </ul>

                <p>DFS frameworks like NFS and AFS embody these principles, each with unique optimizations to address specific use cases and performance needs.</p>
            </article>

            <article>
                <h4>1. File System Abstraction</h4>
                <p>The concept of file system abstraction simplifies interaction with stored data by shielding users and processes from the complexities of physical storage. Here's an in-depth look:</p>

                <h5>What is File System Abstraction?</h5>
                <p>It is a layer that allows users to perceive stored data as structured entities, such as files and directories, rather than raw storage blocks. This abstraction presents a user-friendly interface while managing intricate backend details like disk allocation and block organization.</p>

                <h5>Why is File System Abstraction Necessary?</h5>
                <ul>
                    <li><strong>Usability:</strong> Enables users and applications to work with named files and directories rather than locating and managing raw data blocks.</li>
                    <li><strong>Efficiency:</strong> Optimizes storage management by handling allocation, metadata, and access control transparently.</li>
                    <li><strong>Scalability:</strong> Simplifies scaling data storage systems by abstracting away complexities inherent in distributed and replicated storage systems.</li>
                </ul>

                <h5>How does File System Abstraction Work?</h5>
                <ul>
                    <li><strong>Files:</strong>
                        <ul>
                            <li><strong>What:</strong> Files contain user data, such as text, programs, or media.</li>
                            <li><strong>Why:</strong> Organized storage units make it easier to store and retrieve content systematically.</li>
                            <li><strong>How:</strong> Data is divided into fixed-size blocks stored on the disk, referenced by metadata in the file header.</li>
                        </ul>
                    </li>
                    <li><strong>Directories:</strong>
                        <ul>
                            <li><strong>What:</strong> Directories act as containers that hold information about files within them.</li>
                            <li><strong>Why:</strong> They provide a hierarchical structure, making file organization intuitive.</li>
                            <li><strong>How:</strong> Contain pointers to file locations on the disk, along with meta-information like file names and permissions.</li>
                        </ul>
                    </li>
                    <li><strong>Header:</strong>
                        <ul>
                            <li><strong>What:</strong> The header stores metadata, such as timestamps (creation, last accessed, modified), file type, ownership, and access permissions.</li>
                            <li><strong>Why:</strong> Metadata facilitates efficient file operations, access control, and system integrity checks.</li>
                            <li><strong>How:</strong> Managed internally by the file system; users interact with it indirectly through APIs.</li>
                        </ul>
                    </li>
                </ul>

                <p>File system abstraction is essential for user-centric data handling, ensuring intuitive access while maintaining backend efficiency and integrity.</p>
            </article>

            <article>
                <h4>2. NFS (Network File System)</h4>
                <p>NFS, pioneered by Sun Microsystems in the 1980s, is a foundational DFS widely adopted for its seamless integration with UNIX systems. It enables efficient, transparent, and consistent file operations in distributed environments. Below are its critical components and functionalities:</p>

                <h5>What is NFS?</h5>
                <p>NFS allows clients to access files on remote servers as if they were stored locally, maintaining transparency and consistency across a distributed environment.</p>

                <h5>Why is NFS Important?</h5>
                <ul>
                    <li><strong>Transparency:</strong> Provides a unified interface for accessing local and remote files, eliminating the need for application-level adjustments.</li>
                    <li><strong>Performance Optimization:</strong> Client and server-side caching enhance read/write speeds and minimize network latency.</li>
                    <li><strong>Scalability:</strong> Supports multiple clients accessing shared resources simultaneously without significant performance degradation.</li>
                </ul>

                <h5>How Does NFS Work?</h5>
                <p>NFS uses a modular architecture and caching strategies to optimize file operations:</p>

                <h6>Key Features</h6>
                <ul>
                    <li><strong>Transparency:</strong>
                        <ul>
                            <li><strong>What:</strong> Uniform API for local and remote file access.</li>
                            <li><strong>Why:</strong> Simplifies application development and user operations.</li>
                            <li><strong>How:</strong> The Virtual File System (VFS) layer abstracts file location details, routing requests appropriately.</li>
                        </ul>
                    </li>
                    <li><strong>Client and Server Caching:</strong>
                        <ul>
                            <li><strong>Server Caching:</strong> Recently accessed file blocks are stored in server memory to accelerate read operations.</li>
                            <li><strong>Client Caching:</strong> Clients maintain a local cache of recently accessed blocks, validated using timestamps (e.g., last modified time) to ensure consistency.</li>
                        </ul>
                    </li>
                    <li><strong>Delayed Write:</strong>
                        <ul>
                            <li><strong>What:</strong> Temporarily stores write operations in memory before committing them to disk.</li>
                            <li><strong>Why:</strong> Reduces the latency of frequent writes by batching them.</li>
                            <li><strong>How:</strong> Periodically flushes buffered writes to disk, often every 30 seconds in typical UNIX systems.</li>
                        </ul>
                    </li>
                </ul>

                <h6>Architecture</h6>
                <ul>
                    <li><strong>NFS Client System:</strong>
                        <ul>
                            <li><strong>What:</strong> Client-side module that interacts with remote servers using Remote Procedure Calls (RPCs).</li>
                            <li><strong>How:</strong> Relays file operation requests (e.g., read, write) to the NFS Server System.</li>
                        </ul>
                    </li>
                    <li><strong>NFS Server System:</strong>
                        <ul>
                            <li><strong>What:</strong> A combination of flat file service and directory service functionality.</li>
                            <li><strong>How:</strong> Receives RPCs, performs requested operations, and returns results to the client.</li>
                        </ul>
                    </li>
                    <li><strong>Virtual File System (VFS):</strong>
                        <ul>
                            <li><strong>What:</strong> Middleware that maintains file descriptors and maps them to local or remote files.</li>
                            <li><strong>How:</strong> Transparently decides whether file operations should be routed to local file systems or the NFS client system based on file location.</li>
                        </ul>
                    </li>
                </ul>
            </article>

            <article>
                <h4>3. AFS (Andrew File System)</h4>
                <p>AFS, designed at Carnegie Mellon University, focuses on efficiency and simplicity in distributed file operations. Its unique design decisions prioritize whole-file management, making it suitable for environments where most files are small and frequently accessed by individual users.</p>

                <h5>Key Design Principles</h5>
                <ul>
                    <li><strong>Whole File Serving:</strong>
                        <ul>
                            <li><strong>What:</strong> The server transfers the entire file to the client upon access rather than serving it in smaller chunks (blocks).</li>
                            <li><strong>Why:</strong> Reduces frequent client-server communication and improves read performance for small or medium-sized files, which dominate most workloads.</li>
                            <li><strong>How:</strong> The entire file is loaded into the client’s local storage, enabling fast, localized access for subsequent operations.</li>
                        </ul>
                    </li>
                    <li><strong>Whole File Caching:</strong>
                        <ul>
                            <li><strong>What:</strong> The client maintains a cached copy of the entire file locally, even persisting across reboots.</li>
                            <li><strong>Why:</strong> Enhances performance and availability by minimizing repeated server interactions, especially for files accessed frequently.</li>
                            <li><strong>How:</strong> Cached files are stored on the client’s disk, enabling offline or faster access. The system synchronizes changes with the server only when necessary.</li>
                        </ul>
                    </li>
                </ul>

                <h5>Components</h5>
                <ul>
                    <li><strong>Venus (Client):</strong>
                        <ul>
                            <li><strong>What:</strong> The client-side component responsible for handling local file operations and maintaining cached data.</li>
                            <li><strong>Why:</strong> Allows users to perform file operations locally, reducing dependency on server availability and improving responsiveness.</li>
                            <li><strong>How:</strong> Venus interacts optimistically with files, applying local changes and deferring synchronization with the server until the file is closed.</li>
                        </ul>
                    </li>
                    <li><strong>Vice (Server):</strong>
                        <ul>
                            <li><strong>What:</strong> The server-side component that manages file storage, synchronization, and inter-client consistency.</li>
                            <li><strong>Why:</strong> Ensures all clients access a consistent version of the files and coordinates updates from multiple clients.</li>
                            <li><strong>How:</strong> Vice propagates client changes upon file closure and maintains callback promises to inform clients about updates.</li>
                        </ul>
                    </li>
                </ul>

                <h5>Callback Promise</h5>
                <ul>
                    <li><strong>What:</strong> A guarantee provided by the server (Vice) to the client (Venus) that the client’s cached copy of a file will remain valid unless explicitly invalidated.</li>
                    <li><strong>Why:</strong> Ensures consistency across clients by notifying them of modifications to shared files.</li>
                    <li><strong>How:</strong> If another client modifies a file, Vice sends an invalidation message to affected clients, marking their cached copies as invalid. This ensures that subsequent accesses fetch the updated file from the server.</li>
                </ul>

                <p>AFS's design, emphasizing whole-file operations and persistent caching, caters to scenarios with frequent read-heavy workloads, small files, and minimal concurrent write conflicts.</p>
            </article>



        </main>

        <script> copyright("all"); </script>

    </body>

</html>