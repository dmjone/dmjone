<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>

        <title>Homework 3 - DMJCCLT - dmj.one</title>
        <meta name="description" content="Homework 3: Novel Approach to Conflict-Free Distributed Scheduling for Urban Ride-Sharing Platforms - DMJCCLT - Provided by dmj.one">

        <meta property="og:image" content="/logo.png">
        <meta property="og:type" content="article">

        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@divyamohan1993">
        <meta name="twitter:creator" content="@divyamohan1993">
        <meta name="twitter:image" content="/logo.png">

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />

        <meta name="author" content="Divya Mohan">
        <meta name="robots" content="index, follow">

        <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                renderMathInElement(document.body, {
                    // customised options
                    // • auto-render specific keys, e.g.:
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\(', right: '\\)', display: false },
                        { left: '\\[', right: '\\]', display: true }
                    ],
                    // • rendering keys, e.g.:
                    throwOnError: false
                });
            });
        </script> -->

        <!-- <style>
            main ul {
                list-style-type: none;
                padding: 0;
                margin: 0;
            }

            main ul li {
                margin: 0;
                padding: 0;
            }
        </style> -->

    </head>

    <body>

        <script> header_author("dm", "lakshika"); </script>

        <main>
            <article class="agen-tableofcontents">
                <h2 class="text-center">
                    Homework 3: Novel Approach to Conflict-Free Distributed Scheduling for Urban Ride-Sharing Platforms
                </h2>
                <div class="d-none contentdate">2024, December 24</div>
            </article>


            <article>

                <p>Ride-sharing platforms like Uber and Lyft face significant challenges in dynamically scheduling drivers and passengers in real-time across distributed servers. Your task is to design a distributed scheduling system that ensures:</p>
                <ul>
                    <li><strong>Scalability:</strong> The system must support millions of concurrent ride requests and driver availability updates.</li>
                    <li><strong>Consistency:</strong> No two drivers should be allocated the same ride, even under high churn conditions.</li>
                    <li><strong>Fault Tolerance:</strong> The system should handle network partitions gracefully without losing scheduling information.</li>
                </ul>
                <p>The goal is to minimize ride allocation latency while maintaining strict fairness in driver-passenger assignments.</p>
            </article>

            <article>
                <h4>1. Background</h4>
                <p>Use the following distributed systems concepts to guide your solution:</p>
                <ul>
                    <li><strong>CAP Theorem:</strong> Trade-offs between consistency, availability, and partition tolerance.</li>
                    <li><strong>Time Synchronization:</strong> Techniques like Lamport Timestamps and Vector Clocks.</li>
                    <li><strong>Key-Value Stores:</strong> Distributed hash tables (DHTs), Cassandra’s partitioning strategies, and quorum-based operations.</li>
                </ul>
            </article>

            <article>
                <h4>2. Problem Statement</h4>
                <p>Design a ride allocation system using a distributed key-value store (e.g., Cassandra) for ride-sharing in a metropolitan area. Ensure the following:</p>
                <ul>
                    <li><strong>Unique Ride Assignments:</strong> Each ride request must be uniquely assigned to one driver.</li>
                    <li><strong>Real-Time Updates:</strong> Drivers and passengers update their statuses frequently.</li>
                    <li><strong>Eventual Consistency:</strong> Allow for eventual synchronization of data after network partitions resolve.</li>
                    <li><strong>Fair Load Balancing:</strong> Distribute requests across drivers evenly based on geographic proximity.</li>
                </ul>
            </article>

            <article>
                <h4>3. Instructions</h4>
                <p>Follow these steps:</p>
                <ol>
                    <li><strong>Partitioning:</strong> Design a partitioning strategy to assign ride requests and drivers to servers. Use hashing or geographic sharding.</li>
                    <li><strong>Conflict Resolution:</strong> Implement a conflict-free replicated data type (CRDT) to resolve conflicts in driver assignments.</li>
                    <li><strong>Time Order:</strong> Use Vector Clocks to ensure causality in updates when multiple servers update driver statuses concurrently.</li>
                    <li><strong>Replication:</strong> Configure replication strategies to tolerate server failures while ensuring strong eventual consistency.</li>
                    <li><strong>Testing:</strong> Simulate network partitions and churn (e.g., drivers frequently entering/exiting the network) and evaluate system performance.</li>
                </ol>
            </article>

            <article>
                <h4>4. Deliverables</h4>
                <p>Your submission should include:</p>
                <ul>
                    <li><strong>Design Document:</strong> A detailed explanation of your system architecture, including diagrams.</li>
                    <li><strong>Implementation Code:</strong> Use Python with libraries like `boto3` for distributed simulation.</li>
                    <li><strong>Performance Metrics:</strong> Measure latency, throughput, and consistency under simulated conditions.</li>
                    <li><strong>Conflict Resolution Demo:</strong> Demonstrate how your system resolves conflicting ride assignments in a simulated partition scenario.</li>
                </ul>
            </article>

            <article>
                <h4>5. Evaluation Criteria</h4>
                <p>Your solution will be evaluated based on:</p>
                <ul>
                    <li><strong>Novelty:</strong> Use of advanced distributed systems techniques.</li>
                    <li><strong>Scalability:</strong> Ability to handle large-scale data and churn.</li>
                    <li><strong>Efficiency:</strong> Minimal latency for ride allocation.</li>
                    <li><strong>Fault Tolerance:</strong> Recovery from simulated network failures.</li>
                </ul>
            </article>


            <div class="alert alert-warning mb-0 text-justify">
                I strongly encourage you to attempt solving the problem independently first. Think creatively about how distributed systems concepts like the CAP theorem, vector clocks, and CRDTs can address the challenges outlined in the assignment. Real-world scenarios like this are best understood through hands-on problem-solving. Take some time to formulate your ideas and test your understanding!
            </div>

            <article class="mt-0">
                <h4>Proposed Solution: Conflict-Free Distributed Scheduling System</h4>
                <p>Here's a structured approach to solving the problem:</p>
            </article>

            <article>
                <h4>1. Architecture Design</h4>
                <p>The system architecture involves:</p>
                <ul>
                    <li><strong>Distributed Key-Value Store:</strong> Use Cassandra for storing ride requests and driver availability. Data is partitioned using a geohashing scheme to minimize latency by keeping geographically close data together.</li>
                    <li><strong>Replication:</strong> Set a replication factor of 3 for fault tolerance. Consistency levels like QUORUM ensure strong eventual consistency while maintaining availability.</li>
                </ul>
            </article>

            <article>
                <h4>2. Partitioning</h4>
                <p>Partition rides and drivers based on geographic regions:</p>
                <ul>
                    <li>Use a geohashing technique to divide the city into regions. Each region is mapped to a Cassandra partition.</li>
                    <li>Store each ride request with keys formatted as `<RegionID>:<RideID>`, and driver availability as `<RegionID>:<DriverID>`.</li>
                </ul>
            </article>

            <article>
                <h4>3. Conflict-Free Assignments</h4>
                <p>To prevent multiple drivers being assigned to the same ride:</p>
                <ul>
                    <li>Use a <strong>CRDT (Conflict-Free Replicated Data Type):</strong> A grow-only set (G-Set) to track ride-driver assignments.</li>
                    <li>When multiple servers propose assignments for the same ride, CRDT ensures convergence by selecting the first proposal based on timestamps.</li>
                </ul>
            </article>

            <article>
                <h4>4. Causal Ordering</h4>
                <p>Use Vector Clocks to handle concurrency in updates:</p>
                <ul>
                    <li>Each server maintains a vector clock for its region. Updates to driver status or ride requests carry the vector timestamp.</li>
                    <li>Upon receiving an update, servers merge vector clocks to determine causality.</li>
                </ul>
                <pre><code class="language-python">
def merge_vector_clocks(vc1, vc2):
    return {k: max(vc1.get(k, 0), vc2.get(k, 0)) for k in set(vc1) | set(vc2)}
</code></pre>
            </article>

            <article>
                <h4>5. Fault Tolerance and Recovery</h4>
                <p>Implement fault-tolerant features:</p>
                <ul>
                    <li><strong>Hinted Handoff:</strong> Ensure writes succeed even when replicas are unavailable by buffering them at the coordinator node.</li>
                    <li><strong>Read Repair:</strong> During reads, resolve inconsistencies across replicas using the latest vector clock.</li>
                </ul>
            </article>

            <article>
                <h4>6. Load Balancing</h4>
                <p>To balance load among drivers:</p>
                <ul>
                    <li>Use a weighted round-robin algorithm within each region to assign rides to drivers based on their distance and availability.</li>
                </ul>
            </article>

            <article>
                <h4>7. Testing and Simulation</h4>
                <p>Simulate the system with high churn and network partitions:</p>
                <ul>
                    <li>Use Python's `concurrent.futures` to simulate driver updates and ride requests across multiple threads representing servers.</li>
                    <li>Log latency, throughput, and error rates during partition scenarios.</li>
                </ul>
                <pre><code class="language-python">
import concurrent.futures
import time
import random

def simulate_ride_request(region, ride_id):
    time.sleep(random.uniform(0.1, 0.5))
    print(f"Ride {ride_id} requested in region {region}")

with concurrent.futures.ThreadPoolExecutor() as executor:
    regions = ["R1", "R2", "R3"]
    for i in range(10):
        executor.submit(simulate_ride_request, random.choice(regions), i)
</code></pre>
            </article>

            <article>
                <h4>Performance Evaluation</h4>
                <p>Analyze the following metrics:</p>
                <ul>
                    <li>Average latency for ride assignments under normal and partitioned conditions.</li>
                    <li>Consistency check: Validate correctness of ride-driver assignments across replicas after partitions resolve.</li>
                    <li>Load distribution among drivers in each region.</li>
                </ul>
            </article>


        </main>

        <script> copyright("all"); </script>

    </body>

</html>