<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>

        <title>Key Value Stores - DMJCCLT - dmj.one</title>
        <meta name="description" content="Know about Key Value Stores and how they work - DMJCCLT - Provided by dmj.one">

        <meta property="og:image" content="/logo.png">
        <meta property="og:type" content="article">

        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@divyamohan1993">
        <meta name="twitter:creator" content="@divyamohan1993">
        <meta name="twitter:image" content="/logo.png">

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />

        <meta name="author" content="Divya Mohan">
        <meta name="robots" content="index, follow">

        <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                renderMathInElement(document.body, {
                    // customised options
                    // • auto-render specific keys, e.g.:
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\(', right: '\\)', display: false },
                        { left: '\\[', right: '\\]', display: true }
                    ],
                    // • rendering keys, e.g.:
                    throwOnError: false
                });
            });
        </script> -->

        <!-- <style>
            main ul {
                list-style-type: none;
                padding: 0;
                margin: 0;
            }

            main ul li {
                margin: 0;
                padding: 0;
            }
        </style> -->

    </head>

    <body>

        <script> header_author("dm", "lakshika"); </script>

        <main>
            <article class="agen-tableofcontents">
                <h2 class="text-center">
                    Key Value Stores
                </h2>
                <div class="d-none contentdate">2024, December 26</div>
            </article>

            <article>
                <h3>1. Introduction to Key-Value Stores</h3>
                <h4>1.1 What are Key-Value Stores?</h4>
                <p>A key-value store is a type of database system that organizes data as <strong>key-value pairs</strong>. The <strong>key</strong> serves as a unique identifier, while the <strong>value</strong> contains the associated data or information. This structure is akin to a dictionary in programming, where each key maps to a specific value.</p>

                <h4>1.2 How Key-Value Stores Work</h4>
                <p>Data is stored in a simple, flat structure. The operations primarily involve:</p>
                <ul>
                    <li><strong>Insert:</strong> Add a new key-value pair.</li>
                    <li><strong>Lookup:</strong> Retrieve the value associated with a given key.</li>
                    <li><strong>Delete:</strong> Remove a key-value pair by its key.</li>
                </ul>
                <p>These operations are designed for speed and simplicity, making key-value stores ideal for high-performance systems.</p>

                <h4>1.3 Why Key-Value Stores Are Useful</h4>
                <p>Key-value stores excel in scenarios requiring quick, scalable, and flexible data management:</p>
                <ul>
                    <li><strong>Simplicity:</strong> Minimal structure allows for easy implementation and maintenance.</li>
                    <li><strong>Scalability:</strong> Designed to handle massive amounts of data across distributed systems.</li>
                    <li><strong>Performance:</strong> Optimized for fast read and write operations.</li>
                </ul>

                <h4>1.4 Real-World Examples</h4>
                <p>Key-value stores are widely used across various industries:</p>
                <ul>
                    <li><strong>Twitter:</strong> Stores tweets with a <code>tweet_id</code> as the key and the tweet's content, metadata, and timestamp as the value.</li>
                    <li><strong>Amazon:</strong> Uses <code>item_id</code> as the key to store product details like price, availability, and seller information.</li>
                    <li><strong>Banking Systems:</strong> Stores customer account information with the <code>account_number</code> as the key and the associated account details as the value.</li>
                </ul>
            </article>


            <article>
                <h3>2. Key Characteristics of Key-Value Stores</h3>
                <h4>2.1 What Are the Key Characteristics?</h4>
                <p>Key-value stores are defined by their unique approach to storing and managing data. These characteristics distinguish them from traditional databases and make them ideal for specific use cases.</p>

                <h4>2.2 How Each Characteristic Works</h4>
                <ul>
                    <li>
                        <strong>Simple Structure:</strong>
                        <p>The data model is a flat key-value mapping, similar to a dictionary or hash table in programming. Operations like <code>get</code> and <code>put</code> are directly applied to keys for retrieving and updating values.</p>
                    </li>
                    <li>
                        <strong>Distributed Nature:</strong>
                        <p>Data is partitioned and replicated across multiple servers, ensuring scalability and fault tolerance. This allows the system to handle large datasets and remain operational even when some servers fail.</p>
                    </li>
                    <li>
                        <strong>Flexible Data Model:</strong>
                        <p>Key-value stores do not enforce strict schemas. Values can be simple strings or complex JSON objects, making it easy to adapt to varying data formats.</p>
                    </li>
                    <li>
                        <strong>Efficiency:</strong>
                        <p>Optimized for high-speed read and write operations, key-value stores often use in-memory caching and other techniques to minimize latency.</p>
                    </li>
                </ul>

                <h4>2.3 Why These Characteristics Are Important</h4>
                <ul>
                    <li><strong>Simple Structure:</strong> Reduces complexity in data storage and retrieval, making the system easier to develop and maintain.</li>
                    <li><strong>Distributed Nature:</strong> Ensures high availability and scalability, critical for modern applications like social media and e-commerce.</li>
                    <li><strong>Flexible Data Model:</strong> Accommodates dynamic and evolving data requirements without the need for extensive migrations or redesigns.</li>
                    <li><strong>Efficiency:</strong> Supports real-time applications where performance is a critical factor, such as gaming leaderboards or financial transactions.</li>
                </ul>
            </article>

            <article>
                <h3>3. Comparison with Relational Databases</h3>

                <h4>3.1 Relational Database Characteristics</h4>
                <h5>What:</h5>
                <p>Relational databases (RDBMS) are the traditional approach to data storage and management, organized in structured tables with rows and columns.</p>

                <h5>How:</h5>
                <ul>
                    <li>
                        <strong>Structured:</strong> Data is organized into predefined schemas. Each table has a fixed schema, ensuring consistent data organization.
                    </li>
                    <li>
                        <strong>Relationships:</strong> Uses foreign keys to establish relationships between tables. Complex queries are performed through operations like joins.
                    </li>
                    <li>
                        <strong>Query Language:</strong> Relies on SQL (Structured Query Language) to enable advanced querying, filtering, and data manipulation.
                    </li>
                </ul>

                <h5>Why:</h5>
                <p>Relational databases are ideal for structured and highly interrelated data, ensuring data integrity and enabling complex analytical queries. Use cases include banking systems, inventory management, and enterprise applications.</p>

                <h4>3.2 Key-Value Store Characteristics</h4>
                <h5>What:</h5>
                <p>Key-value stores provide a schema-less, lightweight alternative to relational databases, designed for flexibility and speed in data operations.</p>

                <h5>How:</h5>
                <ul>
                    <li>
                        <strong>Unstructured:</strong> No predefined schemas. Data can be of varying formats, stored as key-value pairs without rigid constraints.
                    </li>
                    <li>
                        <strong>Joins and Relationships:</strong> Relationships between data are not explicitly supported, simplifying the system but limiting complex queries.
                    </li>
                    <li>
                        <strong>APIs:</strong> Provides basic operations like <code>get(key)</code> to retrieve a value and <code>put(key, value)</code> to update or insert data.
                    </li>
                </ul>

                <h5>Why:</h5>
                <p>Key-value stores excel in scenarios with dynamic or unstructured data and high-performance requirements. They are ideal for real-time applications like session storage, caching, and analytics.</p>

                <h4>3.3 When to Use Each</h4>
                <ul>
                    <li><strong>Relational Databases:</strong> Use when data integrity, complex relationships, and powerful querying are required.</li>
                    <li><strong>Key-Value Stores:</strong> Use for high scalability, flexibility, and performance in real-time, write-intensive, or read-heavy workloads.</li>
                </ul>
            </article>


            <article>
                <h3>4. Scalability in Key-Value Stores</h3>

                <h4>4.1 Scale-Out Approach</h4>
                <h5>What:</h5>
                <p>The scale-out approach refers to expanding a system's capacity by adding more servers instead of upgrading existing ones. These servers are typically cost-effective, off-the-shelf machines (COTS).</p>

                <h5>How:</h5>
                <p>In a key-value store, when the load increases, new servers are seamlessly added to the system. The database automatically redistributes data among the nodes using consistent hashing or similar techniques to ensure balanced storage and computation.</p>

                <h5>Why:</h5>
                <ul>
                    <li><strong>Cost-Effective:</strong> Scaling out is cheaper than upgrading hardware to high-end machines.</li>
                    <li><strong>Incremental Growth:</strong> Allows gradual expansion, matching system growth with business needs.</li>
                    <li><strong>Reliability:</strong> Reduces single points of failure, as the system relies on multiple servers rather than a few high-end ones.</li>
                </ul>

                <h4>4.2 Replication</h4>
                <h5>What:</h5>
                <p>Replication is the process of creating multiple copies of data across different nodes in the cluster.</p>

                <h5>How:</h5>
                <p>Each piece of data (key-value pair) is stored on multiple servers according to a replication strategy. For example:</p>
                <ul>
                    <li><strong>Simple Strategy:</strong> Replicates data to the next N nodes in the cluster.</li>
                    <li><strong>Network Topology Strategy:</strong> Ensures replicas are spread across different racks or data centers to mitigate localized failures.</li>
                </ul>

                <h5>Why:</h5>
                <ul>
                    <li><strong>High Availability:</strong> Ensures data remains accessible even if some nodes fail.</li>
                    <li><strong>Fault Tolerance:</strong> Protects against hardware and network failures by having multiple copies of data.</li>
                    <li><strong>Load Balancing:</strong> Distributes read and write operations across replicas, reducing bottlenecks.</li>
                </ul>
            </article>

            <article>
                <h3>5. Consistency Models</h3>

                <h4>5.1 CAP Theorem</h4>
                <h5>What:</h5>
                <p>The CAP Theorem states that in a distributed system, it is impossible to simultaneously guarantee the following three properties:</p>
                <ul>
                    <li><strong>Consistency:</strong> All nodes see the same data at the same time.</li>
                    <li><strong>Availability:</strong> The system remains operational and responds to queries, even during failures.</li>
                    <li><strong>Partition Tolerance:</strong> The system continues functioning despite network partitions.</li>
                </ul>

                <h5>How:</h5>
                <p>Distributed systems, such as key-value stores, must make trade-offs based on workload priorities. Key-value stores typically prioritize <strong>availability</strong> and <strong>partition tolerance</strong>, relaxing strict consistency requirements.</p>

                <h5>Why:</h5>
                <ul>
                    <li><strong>Modern Needs:</strong> Applications like e-commerce and social media demand high availability and fault tolerance.</li>
                    <li><strong>Scalability:</strong> Prioritizing availability ensures systems can handle large-scale, globally distributed workloads.</li>
                </ul>

                <h4>5.2 Eventual Consistency</h4>
                <h5>What:</h5>
                <p>Eventual consistency is a relaxed consistency model where, given enough time and the absence of new writes, all replicas of a key converge to the same value.</p>

                <h5>How:</h5>
                <p>When a key-value pair is updated, changes are propagated asynchronously to replicas. Mechanisms like read-repair and background synchronization ensure eventual convergence.</p>

                <h5>Why:</h5>
                <ul>
                    <li><strong>Efficiency:</strong> Reduces the overhead of ensuring immediate consistency across all nodes.</li>
                    <li><strong>High Availability:</strong> Guarantees that the system remains operational even under network partitions.</li>
                    <li><strong>Use Cases:</strong> Ideal for systems where slight inconsistencies are tolerable, such as caching and social media feeds.</li>
                </ul>

                <h4>5.3 Advanced Models</h4>
                <h5>What:</h5>
                <p>Advanced consistency models offer varying levels of guarantees beyond eventual consistency:</p>
                <ul>
                    <li><strong>Linearizability:</strong> Ensures operations appear instantaneous, providing the strongest consistency guarantee.</li>
                    <li><strong>Causal Consistency:</strong> Maintains the causal order of operations, ensuring dependent reads and writes are consistent.</li>
                    <li><strong>CRDTs (Commutative Replicated Data Types):</strong> Specialized data structures that ensure consistency through commutative operations, even with out-of-order updates.</li>
                </ul>

                <h5>How:</h5>
                <p>These models involve specific protocols and structures:</p>
                <ul>
                    <li><strong>Linearizability:</strong> Implements locks or quorum-based writes to maintain global order.</li>
                    <li><strong>Causal Consistency:</strong> Uses vector clocks or dependency tracking to maintain causal relationships.</li>
                    <li><strong>CRDTs:</strong> Define operations (e.g., counters, sets) that can be merged deterministically regardless of the order of execution.</li>
                </ul>

                <h5>Why:</h5>
                <ul>
                    <li><strong>Flexibility:</strong> Provides varying consistency guarantees to suit specific application needs.</li>
                    <li><strong>Conflict Resolution:</strong> Reduces the complexity of handling conflicts in distributed systems.</li>
                    <li><strong>Applications:</strong> Linearizability for critical systems (e.g., banking), causal consistency for collaborative tools, and CRDTs for real-time applications like shared documents.</li>
                </ul>
            </article>
            <article>
                <h3>6. Key-Value Store Implementations</h3>

                <h4>6.1 Cassandra</h4>
                <h5>What:</h5>
                <p>Apache Cassandra is a highly scalable, distributed key-value store designed for high availability and performance. It was originally developed at Facebook and later open-sourced as an Apache project.</p>

                <h5>How:</h5>
                <ul>
                    <li><strong>Replication:</strong> Implements strategies like:
                        <ul>
                            <li><strong>SimpleStrategy:</strong> Replicates data to adjacent nodes in a single data center.</li>
                            <li><strong>NetworkTopologyStrategy:</strong> Ensures replicas are distributed across multiple data centers and racks for fault tolerance.</li>
                        </ul>
                    </li>
                    <li><strong>Partitioning:</strong> Uses consistent hashing to distribute data across nodes, ensuring even load distribution and fast lookups.</li>
                    <li><strong>Consistency Levels:</strong> Offers configurable levels such as:
                        <ul>
                            <li><code>ANY:</code> Fastest; allows the coordinator to cache writes.</li>
                            <li><code>QUORUM:</code> Ensures a majority of replicas acknowledge reads/writes.</li>
                            <li><code>ALL:</code> Strongest consistency but slower; requires all replicas to respond.</li>
                        </ul>
                    </li>
                </ul>

                <h5>Why:</h5>
                <ul>
                    <li><strong>High Availability:</strong> Handles node failures gracefully using replication and hinted handoffs.</li>
                    <li><strong>Scalability:</strong> Easily handles large-scale data and traffic by adding more nodes.</li>
                    <li><strong>Use Cases:</strong> Real-time applications like Netflix (tracking user viewing positions) and Twitter (storing user tweets).</li>
                </ul>

                <h4>6.2 HBase</h4>
                <h5>What:</h5>
                <p>HBase is an open-source implementation of Google's BigTable, designed for large-scale data storage with strong consistency guarantees. It is built on top of the Hadoop Distributed File System (HDFS).</p>

                <h5>How:</h5>
                <ul>
                    <li><strong>Region Splits:</strong> Large tables are split into smaller regions, which are distributed across servers to improve manageability and performance.</li>
                    <li><strong>Write-Ahead Log (WAL):</strong> Ensures durability by logging updates before applying them to memory or disk, enabling recovery after failures.</li>
                    <li><strong>Column-Oriented Storage:</strong> Stores data in column families, optimizing queries targeting specific columns rather than entire rows.</li>
                </ul>

                <h5>Why:</h5>
                <ul>
                    <li><strong>Strong Consistency:</strong> Guarantees consistent reads and writes, suitable for applications with strict data integrity requirements.</li>
                    <li><strong>Efficient Queries:</strong> Optimized for range scans and analytical workloads, such as retrieving data based on timestamps or filters.</li>
                    <li><strong>Use Cases:</strong> Facebook (internal infrastructure), Yahoo!, and other organizations requiring scalable and reliable storage for structured data.</li>
                </ul>
            </article>

            <article>
                <h3>7. Advanced Data Structures</h3>

                <h4>7.1 Bloom Filters</h4>
                <h5>What:</h5>
                <p>A Bloom filter is a space-efficient probabilistic data structure used to test whether an element is a member of a set. It can confirm with certainty if an element is not present, but there is a small probability of false positives when the element is reported as present.</p>

                <h5>How:</h5>
                <p>Bloom filters operate using a large bit array and multiple hash functions:</p>
                <ul>
                    <li><strong>Insertion:</strong> To add a key, it is passed through multiple hash functions. Each hash function produces an index, and the corresponding bits in the array are set to 1.</li>
                    <li><strong>Lookup:</strong> To check if a key exists, it is hashed using the same functions. If all the bits at the calculated indices are set to 1, the key is likely in the set. If any bit is 0, the key is definitely not in the set.</li>
                    <li><strong>Efficiency:</strong> Compact representation allows quick existence checks without needing to store the actual data.</li>
                </ul>

                <h5>Why:</h5>
                <ul>
                    <li><strong>Space Efficiency:</strong> Stores data representation in a much smaller space compared to other structures like hash tables.</li>
                    <li><strong>High Speed:</strong> Optimized for fast lookups and insertions, making it suitable for performance-critical applications.</li>
                    <li><strong>Applications:</strong>
                        <ul>
                            <li><strong>Databases:</strong> Used in key-value stores like Cassandra to quickly check if a key exists in an SSTable, reducing unnecessary disk I/O.</li>
                            <li><strong>Networking:</strong> Helps prevent cache pollution in web proxies by filtering out non-cacheable content.</li>
                            <li><strong>Distributed Systems:</strong> Facilitates fast set membership checks across nodes.</li>
                        </ul>
                    </li>
                </ul>
            </article>

            <article>
                <h3>8. Use Cases</h3>

                <h4>8.1 Session Storage</h4>
                <h5>What:</h5>
                <p>Key-value stores are used to manage user session data, which includes temporary user information, preferences, and state during an interaction with an application.</p>

                <h5>How:</h5>
                <ul>
                    <li><strong>Storage:</strong> Each session is assigned a unique key (e.g., <code>session_id</code>) with the corresponding data stored as the value.</li>
                    <li><strong>Access:</strong> The application retrieves or updates session data using the <code>get</code> and <code>put</code> operations.</li>
                    <li><strong>Expiration:</strong> Session keys are often configured with time-to-live (TTL) values, ensuring they expire when the session ends.</li>
                </ul>

                <h5>Why:</h5>
                <ul>
                    <li><strong>Fast Access:</strong> Enables quick retrieval of user state, essential for real-time user experiences.</li>
                    <li><strong>Scalability:</strong> Handles large volumes of concurrent user sessions in systems like e-commerce platforms (e.g., Amazon).</li>
                </ul>

                <h4>8.2 Metadata Storage</h4>
                <h5>What:</h5>
                <p>Key-value stores are used to store metadata, such as file attributes, user preferences, or media playback details, efficiently.</p>

                <h5>How:</h5>
                <ul>
                    <li><strong>Organization:</strong> Metadata is stored as key-value pairs, where the key identifies the resource (e.g., <code>file_id</code>) and the value contains the associated metadata (e.g., file size, timestamp).</li>
                    <li><strong>Usage:</strong> Applications like video streaming services use metadata to resume playback or recommend content.</li>
                </ul>

                <h5>Why:</h5>
                <ul>
                    <li><strong>Efficiency:</strong> Stores and retrieves metadata rapidly, supporting high-speed operations in applications like Netflix.</li>
                    <li><strong>Compactness:</strong> Metadata is lightweight, making key-value stores an ideal choice for its storage.</li>
                </ul>

                <h4>8.3 Real-Time Analytics</h4>
                <h5>What:</h5>
                <p>Social media platforms and other systems use key-value stores to process and analyze data streams in real-time, enabling dynamic insights.</p>

                <h5>How:</h5>
                <ul>
                    <li><strong>Data Ingestion:</strong> Incoming data, such as user activity or trends, is stored as key-value pairs for immediate analysis.</li>
                    <li><strong>Processing:</strong> Data is queried and processed in real-time to provide actionable insights (e.g., trending hashtags or user engagement statistics).</li>
                </ul>

                <h5>Why:</h5>
                <ul>
                    <li><strong>Low Latency:</strong> Handles high-velocity data with minimal delay, crucial for real-time analytics.</li>
                    <li><strong>Scalability:</strong> Supports the vast data generated by platforms like Twitter.</li>
                </ul>
            </article>




        </main>

        <script> copyright("all"); </script>

    </body>

</html>