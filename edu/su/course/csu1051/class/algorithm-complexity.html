<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
  <!--<![endif]-->

  <head>
    <script src="/js/edu_su_common.js"></script>
    <noscript>
      <style>
        html,
        body {
          margin: 0;
          overflow: hidden;
        }
      </style>
      <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
    </noscript>

    <title>Algorithm Complexity: CSU1051 - Shoolini U</title>
    <meta name="description" content="Dive into the world of algorithm complexity at Shoolini University. Learn to analyze and understand the efficiency of algorithms with dmj.one's educational initiative.">

    <meta property="og:image" content="/logo.png">
    <meta property="og:type" content="article">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@divyamohan1993">
    <meta name="twitter:creator" content="@divyamohan1993">
    <meta name="twitter:image" content="/logo.png">

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
          // customised options
          // • auto-render specific keys, e.g.:
          delimiters: [
            { left: '$$', right: '$$', display: true },
            { left: '$', right: '$', display: false },
            { left: '\\(', right: '\\)', display: false },
            { left: '\\[', right: '\\]', display: true }
          ],
          // • rendering keys, e.g.:
          throwOnError: false
        });
      });
    </script>
  </head>

  <body>

    <script>header_author("dm");</script>

    <main>
      <article>
        <h2 class="text-center">
          Complexity of an Algorithm
        </h2>
      </article>
      <article>
        <h3>1. Introduction</h3>
        <p>In computer science, the complexity of an algorithm refers to the amount of resources, such as time and space, that are required to solve a particular problem. Analyzing the complexity of algorithms helps us to understand their efficiency and to select the most suitable algorithm for a given problem. This article provides an in-depth exploration of algorithm complexity, from basic concepts to more advanced topics, using illustrative examples to demonstrate the analysis process. </p>
      </article>
      <article>
        <h3>2. Types of Algorithm Complexity</h3>
        <p>There are two main types of algorithm complexity: time complexity and space complexity. Time complexity describes the amount of time an algorithm takes to execute as a function of the input size, while space complexity describes the amount of memory an algorithm uses as a function of the input size.</p>
      </article>
      <article>
        <h4>2.1 Time Complexity</h4>
        <p>Time complexity is typically expressed using big O notation, which describes the upper bound of an algorithm's growth rate. The notation $O(f(n))$ indicates that the time complexity of an algorithm is at most a constant multiple of the function $f(n)$, where $n$ is the input size. Common time complexities include $O(1)$ (constant time), $O(\log n)$ (logarithmic time), $O(n)$ (linear time), $O(n \log n)$ (linearithmic time), $O(n^2)$ (quadratic time), and $O(n^3)$ (cubic time). Higher-order polynomial and exponential time complexities are also possible but are generally considered to be inefficient.</p>
      </article>
      <article>
        <h4>2.2 Space Complexity</h4>
        <p>Space complexity, like time complexity, is also expressed using big O notation. The notation $O(g(n))$ indicates that the space complexity of an algorithm is at most a constant multiple of the function $g(n)$, where $n$ is the input size. Common space complexities include $O(1)$ (constant space), $O(\log n)$ (logarithmic space), and $O(n)$ (linear space).</p>
      </article>
      <article>
        <h3>3. Analyzing Algorithm Complexity</h3>
        <p>To analyze the complexity of an algorithm, we must first understand the underlying operations and how they contribute to the overall resource usage. In this section, we will discuss various methods for analyzing time and space complexity, including the use of recurrence relations and the master theorem.</p>
      </article>
      <article>
        <h4>3.1 Recurrence Relations</h4>
        <p>Recurrence relations are mathematical expressions that define a sequence recursively, using previous terms in the sequence to calculate the current term. They can be used to describe the time complexity of recursive algorithms.</p>
        <h5>3.1.1 Example: Fibonacci Numbers</h5>
        <p>The Fibonacci sequence is defined as follows:</p>
        <p>$$F_n = \begin{cases} 0 & \text{if } n = 0\\ 1 & \text{if } n = 1\\ F_{n-1} + F_{n-2} & \text{if } n > 1 \end{cases}$$</p>
        <pre><code class="language-cpp">// Recursive Fibonacci
int fibonacci(int n) {
  if (n == 0) return 0;
  if (n == 1) return 1;
  return fibonacci(n - 1) + fibonacci(n - 2);
}</code></pre>
        <p>This algorithm has a time complexity of $O(2^n)$, as each call to the function branches into two more calls, leading to an exponential growth in the number of calls. This can be visualized as a binary tree, where each node has two children. The height of the tree is $n$, and the total number of nodes is approximately $2^n$. The space complexity of this algorithm is $O(n)$ due to the maximum depth of the recursion.</p>
      </article>
      <article>
        <h4>3.2 The Master Theorem</h4>
        <p>The Master Theorem is a powerful tool for analyzing the time complexity of divide-and-conquer algorithms. It provides a formula for solving recurrence relations of the form:</p>
        <p>$$T(n) = a T\left(\frac{n}{b}\right) + f(n)$$</p>
        <p>where $a \geq 1$, $b > 1$, and $f(n)$ is an asymptotically positive function. The Master Theorem classifies the solution to the recurrence relation into three cases:</p>
        <p>1. If $f(n) = O(n^{\log_b a - \epsilon})$ for some $\epsilon > 0$, then $T(n) = \Theta(n^{\log_b a})$.</p>
        <p>2. If $f(n) = \Theta(n^{\log_b a})$, then $T(n) = \Theta(n^{\log_b a} \log n)$.</p>
        <p>3. If $f(n) = \Omega(n^{\log_b a + \epsilon})$ for some $\epsilon > 0$, and if $af\left(\frac{n}{b}\right) \leq cf(n)$ for some constant $c < 1$ and all sufficiently large $n$, then $T(n)=\Theta(f(n))$.</p>
      </article>
      <article>
        <h5>3.2.1 Example: Merge Sort</h5>
        <p>Merge Sort is a divide-and-conquer algorithm that sorts an array by recursively splitting it into two halves, sorting each half, and merging the sorted halves back together. The time complexity of Merge Sort can be described by the recurrence relation:</p>
        <p>$$T(n) = 2T\left(\frac{n}{2}\right) + O(n)$$</p>
        <pre><code class="language-cpp">void merge(int arr[], int l, int m, int r) {
  // ...
}

void mergeSort(int arr[], int l, int r) {
  if (l < r) {
    int m = l + (r - l) / 2;
    mergeSort(arr, l, m);
    mergeSort(arr, m + 1, r);
    merge(arr, l, m, r);
  }
}</code></pre>
        <p>Applying the Master Theorem, we see that $a = 2$, $b = 2$, and $f(n) = O(n)$. Since $\log_2 2 = 1$, we have $f(n) = \Theta(n^{\log_b a})$, which corresponds to case 2 of the Master Theorem. Therefore, the time complexity of Merge Sort is $T(n) = \Theta(n \log n)$. The space complexity of Merge Sort is $O(n)$, as additional memory is needed to store the temporary arrays during the merge step.</p>
      </article>
      <article>
        <h5>3.2.2 Example: Binary Search</h5>
        <p>Binary Search is an efficient algorithm for finding a target value within a sorted array. It works by repeatedly dividing the array in half until the target value is found or the interval has been reduced to zero. The time complexity of Binary Search can be described by the recurrence relation:</p>

        <p>$$T(n) = T\left(\frac{n}{2}\right) + O(1)$$</p>
        <pre><code class="language-cpp">int binarySearch(int arr[], int l, int r, int x) {
  if (r >= l) {
    int mid = l + (r - l) / 2;
    if (arr[mid] == x)
      return mid;
    if (arr[mid] > x)
      return binarySearch(arr, l, mid - 1, x);
    return binarySearch(arr, mid + 1, r, x);
  }
  return -1;
}</code></pre>
        <p>Applying the Master Theorem, we see that $a = 1$, $b = 2$, and $f(n) = O(1)$. Since $\log_2 1 = 0$, we have $f(n) = O(n^{\log_b a - \epsilon})$ for some $\epsilon > 0$, which corresponds to case 1 of the Master Theorem. Therefore, the time complexity of Binary Search is $T(n) = \Theta(\log n)$. The space complexity of the recursive version of Binary Search is $O(\log n)$ due to the depth of the recursion, but an iterative version of Binary Search can be implemented with a space complexity of $O(1)$.</p>
      </article>
      <article>
        <h3>4. Amortized Analysis</h3>
        <p>Amortized analysis is a method for analyzing the average-case performance of an algorithm over a sequence of operations. It allows us to determine the complexity of an algorithm when the cost of a single operation can vary, but the overall cost can be bounded across multiple operations.</p>
      </article>
      <article>
        <h4>4.1 Aggregate Method</h4>
        <p>The aggregate method involves determining the total cost of a sequence of operations and dividing by the number of operations to find the average cost per operation. This gives an amortized complexity for each operation.</p>
      </article>
      <article>
        <h5>4.1.1 Example: Dynamic Array Insertion</h5>
        <p>A dynamic array is an array that can be resized during runtime. When an element is inserted into a dynamic array that is full, the array is resized by allocating a new block of memory, usually twice the size of the current array, and copying the elements from the old array to the new one. The cost of resizing the array is $O(n)$, but this operation does not occur for every insertion.</p>
        <pre><code class="language-cpp">// Dynamic array insertion
void insert(int x, int arr[], int &size, int &capacity) {
  if (size == capacity) {
    capacity *= 2;
    int *new_arr = new int[capacity];
    for (int i = 0; i < size; i++) {
      new_arr[i] = arr[i];
    }
    delete[] arr;
    arr = new_arr;
  }
  arr[size] = x;
  size++;
}</code></pre>
        <p>Over a sequence of $n$ insertions, the total cost can be bounded by $O(n)$, as each element is copied at most once for each power of two smaller than the final size. Thus, the amortized complexity of each insertion is $O(1)$, even though the worst-case complexity of a single insertion is $O(n)$.</p>
      </article>
      <article>
        <h4>4.2 Accounting Method</h4>
        <p>The accounting method involves assigning a "charge" to each operation, representing the amortized cost. Some operations might be charged more than their actual cost, while others might be charged less. The key is to ensure that the total charge across all operations is at least the total cost, so that the average cost per operation is accurately represented.</p>

      </article>
      <article>
        <h5>4.2.1 Example: Stack with Multipop</h5>
        <p>Consider a stack data structure that supports three operations: push, pop, and multipop (which pops multiple elements from the stack at once). The push and pop operations have a constant cost of $O(1)$. The multipop operation, which pops $k$ elements from the stack, has a cost of $O(k)$, where $k \leq n$ (the number of elements in the stack).</p>
        <pre><code class="language-cpp">// Stack with multipop
void push(int x, std::stack<int> &st) {
  st.push(x);
}

void pop(std::stack<int> &st) {
  if (!st.empty()) {
    st.pop();
  }
}

void multipop(std::stack<int> &st, int k) {
  for (int i = 0; i < k && !st.empty(); i++) {
    st.pop();
  }
}</code></pre>
        <p>We can assign an amortized cost of $1$ to each push operation, and an amortized cost of $0$ to each pop and multipop operation. Each time an element is pushed onto the stack, it "prepays" for the cost of its eventual removal by pop or multipop. Since the total charge is equal to the number of push operations, and each element can be removed at most once, the amortized complexity of each operation is $O(1)$.</p>
      </article>
      <article>
        <h4>4.3 Potential Method</h4>
        <p>The potential method involves defining a potential function $\Phi$ that maps the state of the data structure to a non-negative real number. The amortized cost of an operation is then defined as the actual cost of the operation plus the change in potential. The goal is to choose a potential function that accurately reflects the cost distribution across the sequence of operations.</p>
      </article>
      <article>
        <h5>4.3.1 Example: Dynamic Array Insertion (Revisited)</h5>
        <p>Returning to the dynamic array insertion example, we can define a potential function $\Phi$ that measures the difference between the size $n$ of the array and its capacity $c$:</p>
        <p>$$\Phi(n, c) = 2n - c$$</p>
        <p>The amortized cost of each operation can then be calculated as follows:</p>
        <p>1. For an insertion without resizing, the actual cost is $1$, and the potential function increases by $2$. The amortized cost is $1 + (2 - 0) = 3$.</p>
        <p>2. For an insertion with resizing, the actual cost is $n + 1$, and the potential function decreases by $n$. The amortized cost is $(n + 1) + (0 - n) = 1$.</p>
        <p>Since the amortized cost of each insertion operation is constant, the overall complexity of the dynamic array insertion remains $O(1)$ amortized.</p>
      </article>
      <article>
        <h3>5. Conclusion</h3>
        <p>In this article, we have provided a comprehensive overview of algorithm complexity, including time and space complexity, recurrence relations, the Master Theorem, and amortized analysis. We have illustrated these concepts with detailed examples, analyzing the complexity of algorithms step by step. By understanding the complexities of various algorithms, we can make informed decisions about which algorithm to use for a specific problem and optimize the performance of our programs.</p>
      </article>
    </main>

    <script>copyright("all");</script>
  </body>

</html>
