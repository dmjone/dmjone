<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
  <!--<![endif]-->

  <head>
    <script src="/js/edu_su_common.js"></script>
    <noscript>
      <style>
        html,
        body {
          margin: 0;
          overflow: hidden;
        }
      </style>
      <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
    </noscript>

    <title>Data Structures for Searching & Sorting: CSU1051 - Shoolini U</title>
    <meta name="description" content="Explore the use of various data structures for efficient searching and sorting algorithms at Shoolini University. Learn the benefits and applications of different data structures with dmj.one's educational initiative.">

    <meta property="og:image" content="/logo.png">
    <meta property="og:type" content="article">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@divyamohan1993">
    <meta name="twitter:creator" content="@divyamohan1993">
    <meta name="twitter:image" content="/logo.png">

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
          // customised options
          // • auto-render specific keys, e.g.:
          delimiters: [
            { left: '$$', right: '$$', display: true },
            { left: '$', right: '$', display: false },
            { left: '\\(', right: '\\)', display: false },
            { left: '\\[', right: '\\]', display: true }
          ],
          // • rendering keys, e.g.:
          throwOnError: false
        });
      });
    </script>
  </head>

  <body>

    <script>header_author("dm");</script>

    <main>
      <article>
        <h2 class="text-center">
          Use of Various Data Structure for Searching and Sorting
        </h2>
        <div class="container mt-4 w-100 w-xl-75">
          <div class="accordion" id="toc">
            <div class="accordion-item">
              <h2 class="accordion-header" id="h1">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#c1" aria-controls="c1" aria-expanded="false">
                  <i class="fas fa-book"></i> <strong>&nbsp;Table of Contents</strong>
                </button>
              </h2>
              <div id="c1" class="accordion-collapse collapse" aria-labelledby="h1" data-bs-parent="#toc">
                <div class="accordion-body">
                  <ol class="list-unstyled p-0 m-0">
                    <li class="p-1"><a href="#intro"><i class="fas fa-chevron-circle-right"></i> Introduction</a></li>
                    <li class="p-1"><a href="#implementation"><i class="fas fa-chevron-circle-right"></i> Implementation</a></li>
                    <li class="p-1"><a href="#complexity"><i class="fas fa-chevron-circle-right"></i> Complexity Analysis</a></li>
                    <li class="p-1"><a href="#conclusion"><i class="fas fa-chevron-circle-right"></i> Conclusion</a></li>
                  </ol>
                </div>
              </div>
            </div>
          </div>
        </div>
      </article>

      <article id="introduction-searching-sorting">
        <h3>1. Introduction: The Dance of Searching and Sorting</h3>
        <p>Computer science thrives on the efficient management of data. Key to this efficiency is the selection of appropriate data structures that facilitate rapid searching and sorting. The science of searching and sorting is an area of study that teems with a variety of techniques, each of which is applicable under specific circumstances. The choice of the method often depends on the nature of the data, its volume, and the specific requirements of the task.</p>
      </article>

      <article id="understanding-data-structures">
        <h3>2. Understanding Data Structures: The Foundation</h3>
        <p>A data structure is a way of organizing data in a computer so that it can be used efficiently. It is an arrangement of data in the computer's memory (or sometimes on disk). Data structures provide a means to manage large amounts of data efficiently for uses such as large databases and internet indexing services. They are critical to various areas of computer science, including graphics, artificial intelligence, and operating systems.</p>
      </article>

      <article id="searching-data-structures">
        <h4>2.1 Searching in Data Structures: An Essential Operation</h4>
        <p>Searching is the process of finding a particular element from the data structure where the data is stored. This is one of the most common operations performed on data structures. Depending on the type and structure of the data, different searching algorithms can be utilized for optimal results.</p>
        <article id="linear-binary-search">
          <h5>2.1.1 Linear Search vs Binary Search</h5>
          <p>A simple method of searching a data structure is the linear search, which checks each element in sequence until it finds a match. This method is straightforward but slow for large data sets.</p>
          <p>Binary search, on the other hand, is a more efficient algorithm for ordered data sets. It works by repeatedly dividing in half the part of the list that could contain the item until you've narrowed down the possible locations to just one.</p>
          <pre><code class="language-cpp">
// C++ code for binary search
#include&lt;iostream&gt;
using namespace std;

int binary_search(int array[], int size, int target) {
    int low = 0;
    int high = size - 1;
    
    while(low <= high) {
        int mid = (low + high) / 2;
        if(array[mid] == target) {
            return mid;
        } else if(array[mid] < target) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    return -1; // returns -1 if target element is not found
}
</code></pre>
        </article>

        <article id="sorting-data-structures">
          <h4>2.2 Sorting in Data Structures: Organizing Chaos</h4>
          <p>Sorting is another key operation in data structures, responsible for arranging data in a particular format, often either in ascending or descending order. Numerous sorting algorithms exist, each with their distinct advantages and ideal use cases.</p>
          <article id="bubble-quick-sort">
            <h5>2.2.1 Bubble Sort vs Quick Sort</h5>
            <p>Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. This process continues until no more swaps are needed.</p>
            <p>Quick Sort, on the other hand, is a more complex but efficient sorting algorithm. It works by selecting a 'pivot' element from the array and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. The sub-arrays are then recursively sorted.</p>
            <pre><code class="language-cpp">// C++ code for quick sort
#include&lt;iostream&gt;
using namespace std;

int partition(int array[], int low, int high) {
    int pivot = array[high];
    int i = (low - 1);

    for(int j = low; j <= high - 1; j++) {
        if (array[j] < pivot) {
            i++;
            swap(array[i], array[j]);
        }
    }
    swap(array[i + 1], array[high]);
    return (i + 1);
}

void quickSort(int array[], int low, int high) {
    if (low < high) {
        int pi = partition(array, low, high);
        quickSort(array, low, pi - 1);
        quickSort(array, pi + 1, high);
    }
}
</code></pre>
          </article>

          <article id="complex-data-structures">
            <h3>3. Unraveling Complex Data Structures: Navigating Intricate Paths</h3>
            <p>Complex data structures like trees and graphs open up new avenues for efficient searching and sorting, thereby allowing for the handling of more sophisticated types of data and queries.</p>
            <article id="binary-search-trees">
              <h4>3.1 Binary Search Trees: Hierarchical Order</h4>
              <p>A Binary Search Tree (BST) is a tree data structure in which each node has at most two children, referred to as the left child and the right child. For each node, all elements in the left subtree are less than the node, and all elements in the right subtree are greater. Thus, BST provides an ordered or sorted view of the data. Searching in BST involves traversing down the tree from the root to a leaf node, following a path determined by a series of left-or-right decisions.</p>
            </article>

            <article id="hashing">
              <h4>3.2 Hashing: Fast and Furious Search</h4>
              <p>Hashing is a unique approach to searching. In a hash table, data is stored in an array format, where each data value has its unique index value. The search time for a hashed list is generally $O(1)$, making it a highly efficient searching method.</p>
              <p>$$\text{Search time for hashing} = O(1)$$</p>
            </article>

            <article id="closing-remarks">
              <h3>4. Closing Remarks: The Spectrum of Search and Sort</h3>
              <p>Through this exploration, we've peeked into the dynamic world of searching and sorting in data structures. We've discovered how different data structures play a pivotal role in selecting an efficient searching and sorting algorithm. From linear to binary search, bubble to quick sort, binary search trees to hashing, each method has its place in the broad spectrum of search and sort. Understanding these methods and their efficient utilization forms the backbone of computer science, enabling us to manage and utilize data in the most effective way.</p>
            </article>

            <article id="next-read">
              <h3>5. On the Horizon: Journey into the World of Graph Algorithms</h3>
              <p>Having taken a leap into the intricate dance of searching and sorting, let's tread further. In our subsequent exploration, we'll dive into the fascinating world of Graph Algorithms, exploring concepts such as Depth-First Search, Breadth-First Search, Dijkstra's Algorithm, and many more. These algorithms allow us to navigate through data in more complex, non-linear ways, revealing insights that are often invisible to simpler algorithms. Stay tuned for a deep dive into the dynamic ocean of graph algorithms, and let's continue this journey of discovery together.</p>
            </article>

    </main>

    <script>copyright("all");</script>
  </body>

</html>
