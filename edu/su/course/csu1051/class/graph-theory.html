<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
  <!--<![endif]-->

  <head>
    <script src="/js/edu_su_common.js"></script>
    <noscript>
      <style>
        html,
        body {
          margin: 0;
          overflow: hidden;
        }
      </style>
      <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
    </noscript>

    <title>Graph Theory Exploration: CSU1051 - DSA - Shoolini U</title>
    <meta name="description" content="Embark on an educational adventure with dmj.one as we delve into the captivating realm of Graph Theory. Join CSU1051 course at Shoolini University to unravel the intricacies of graphs and their applications in data structures and algorithms.">

    <meta property="og:image" content="/logo.png">
    <meta property="og:type" content="article">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@divyamohan1993">
    <meta name="twitter:creator" content="@divyamohan1993">
    <meta name="twitter:image" content="/logo.png">

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
          // customised options
          // • auto-render specific keys, e.g.:
          delimiters: [
            { left: '$$', right: '$$', display: true },
            { left: '$', right: '$', display: false },
            { left: '\\(', right: '\\)', display: false },
            { left: '\\[', right: '\\]', display: true }
          ],
          // • rendering keys, e.g.:
          throwOnError: false
        });
      });
    </script>
  </head>

  <body>

    <script>header_author("dm");</script>

    <main>
      <article>
        <h2 class="text-center">
          Graph Theory
        </h2>
        <div class="container mt-4 w-100 w-xl-75">
          <div class="accordion" id="toc">
            <div class="accordion-item">
              <h2 class="accordion-header" id="h1">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#c1" aria-controls="c1" aria-expanded="false">
                  <i class="fas fa-book"></i> <strong>&nbsp;Table of Contents</strong>
                </button>
              </h2>
              <div id="c1" class="accordion-collapse collapse" aria-labelledby="h1" data-bs-parent="#toc">
                <div class="accordion-body">
                  <ol class="list-unstyled p-0 m-0">
                    <li class="p-1"><a href="#intro"><i class="fas fa-chevron-circle-right"></i> Introduction</a></li>
                    <li class="p-1"><a href="#basic-terminologies"><i class="fas fa-chevron-circle-right"></i> Basic Terminologies</a></li>
                    <li class="p-1"><a href="#conclusion"><i class="fas fa-chevron-circle-right"></i> Conclusion</a></li>                    
                  </ol>
                </div>
              </div>
            </div>
          </div>
        </div>
      </article>
      <article id="intro">
        <h3>1. Introduction to Graph Theory</h3>
        <p>Graph Theory is a fundamental area of study in mathematics and computer science, focusing on the analysis of graphs. A graph is a structure comprising nodes (or vertices) connected by edges (or arcs). Graphs are used to model various real-world phenomena, including networks, relationships, and physical structures.</p>
      </article>

      <article id="basic-terminologies">
        <h4>1.1 Basic Terminologies</h4>
        <p>Before delving into the depths of graph theory, it is essential to understand the basic terminologies:</p>
        <ul>
          <li><strong>Vertex:</strong> A node in a graph.</li>
          <li><strong>Edge:</strong> A connection between two vertices.</li>
          <li><strong>Adjacency:</strong> Two vertices are adjacent if they are connected by an edge.</li>
          <li><strong>Path:</strong> A sequence of vertices where each adjacent pair is connected by an edge.</li>
        </ul>
      </article>

      <article id="fundamentals-of-graph-theory">
        <h4>1.1.1 Fundamentals of Graph Theory</h4>
        <p>At the core of Graph Theory lies the graph, a mathematical structure that models pairwise relations between objects. A graph is made up of vertices (or nodes) and edges (or links). There are various types of graphs, such as directed, undirected, weighted, and unweighted graphs.</p>
        <p>$$G = (V, E)$$</p>
        <p>Where $G$ is a graph consisting of a set of vertices $V$ and a set of edges $E$.</p>
      </article>

      <article id="types-of-graphs">
        <h4>1.2 Types of Graphs</h4>
        <p>There are several types of graphs, each with its own set of properties and applications.</p>
        <ul>
          <li><strong>Undirected Graph:</strong> A graph where edges have no direction.</li>
          <li><strong>Directed Graph (Digraph):</strong> A graph where edges have directions.</li>
          <li><strong>Weighted Graph:</strong> A graph where edges have weights or values associated with them.</li>
          <li><strong>Bipartite Graph:</strong> A graph whose vertices can be divided into two disjoint sets such that every edge connects a vertex in one set to a vertex in the other set.</li>
        </ul>
      </article>

      <article id="graph-representations">
        <h4>1.3 Graph Representations</h4>
        <p>Graphs can be represented in various forms such as adjacency matrix, adjacency list, and incidence matrix. Each representation has its own advantages and is used based on the requirements of the problem. There are two common ways to represent a graph in computer memory:</p>
        <ul>
          <li><strong>Adjacency Matrix:</strong> A 2D array of size V x V where V is the number of vertices in the graph. The value matrix[i][j] is 1 if there is an edge from vertex i to vertex j, otherwise 0.
            <p>$Adjacency\ Matrix: G[i][j] = 1$ if there is an edge between vertex i and vertex j, else 0.</p>
          </li>
          <li><strong>Adjacency List:</strong> An array of lists. The size of the array is equal to the number of vertices. An entry array[i] represents the list of vertices adjacent to the ith vertex.
            <p>$Adjacency\ List: G[i]$ is a list of vertices that are adjacent to vertex i.</p>
          </li>
        </ul>
        <pre><code class="language-cpp">class Graph {
    int V;
    list<int> *adj;
public:
    Graph(int V);
    void addEdge(int v, int w);
    void printGraph();
};</code></pre>
      </article>


      <article id="graph-traversal">
        <h4>1.4 Graph Traversal</h4>
        <p>Graph traversal is the process of visiting all the vertices of a graph. There are two standard graph traversal algorithms:</p>
        <ul>
          <li><strong>Depth-First Search (DFS):</strong> DFS is a graph traversal method that explores as far as possible along each branch before backtracking.
            <pre><code class="language-cpp">
void dfs(int v, vector&lt;bool&gt; &visited, vector&lt;vector&lt;int&gt;&gt; &graph) {
    visited[v] = true;
    for (int u : graph[v]) {
        if (!visited[u]) {
            dfs(u, visited, graph);
        }
    }
}
</code></pre>
          </li>
          <li><strong>Breadth-First Search (BFS):</strong> BFS is a graph traversal method that explores all the vertices at the present "depth" before moving on to vertices at the next depth level.
            <pre><code class="language-cpp">void bfs(int v, vector&lt;vector&lt;int&gt;&gt; &graph) {
    queue&lt;int&gt; q;
    vector&lt;bool&gt; visited(graph.size(), false);
    q.push(v);
    visited[v] = true;
    while (!q.empty()) {
        int f = q.front();
        q.pop();
        for (int u : graph[f]) {
            if (!visited[u]) {
                q.push(u);
                visited[u] = true;
            }
        }
    }
}
</code></pre>
          </li>
        </ul>
      </article>

      <article id="dfs-implementation">
        <h5>1.4.1 Depth-First Search Implementation</h5>
        <p>Depth-First Search can be implemented using recursion or with a stack. Below is the C++ code for the recursive implementation of DFS.</p>
        <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;list&gt;
using namespace std;

class Graph {
    int V;
    list&lt;int&gt; *adj;
    void DFSUtil(int v, bool visited[]);
public:
    Graph(int V);
    void addEdge(int v, int w);
    void DFS(int v);
};

Graph::Graph(int V) {
    this->V = V;
    adj = new list&lt;int&gt;[V];
}

void Graph::addEdge(int v, int w) {
    adj[v].push_back(w);
}

void Graph::DFSUtil(int v, bool visited[]) {
    visited[v] = true;
    cout &lt;&lt; v &lt;&lt; " ";

    list&lt;int&gt;::iterator i;
    for (i = adj[v].begin(); i != adj[v].end(); ++i)
        if (!visited[*i])
            DFSUtil(*i, visited);
}

void Graph::DFS(int v) {
    bool *visited = new bool[V];
    for (int i = 0; i &lt; V; i++)
        visited[i] = false;

    DFSUtil(v, visited);
}

int main() {
    Graph g(4);
    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 2);
    g.addEdge(2, 0);
    g.addEdge(2, 3);
    g.addEdge(3, 3);

    cout &lt;&lt; "Depth First Traversal (starting from vertex 2):\n";
    g.DFS(2);

    return 0;
}</code></pre>
      </article>

      <article id="graph-algorithms">
        <h4>1.5 Graph Algorithms</h4>
        <p>There are several algorithms in graph theory that are used to solve various problems like finding the shortest path, detecting cycles, finding maximum flow, etc. Some of the famous algorithms are:</p>
        <ul>
          <li><strong>Dijkstra's Algorithm:</strong> For finding the shortest path from a single source vertex to all other vertices in a weighted graph. <p>In other words, Dijkstra's algorithm is an algorithm for finding the shortest paths between vertices in a graph with non-negative edge weights. It maintains a set of vertices whose final shortest-path weights from the source have already been determined.</p>
            <pre><code class="language-cpp">void dijkstra(vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; &graph, int src) {
  int n = graph.size();
  vector&lt;int&gt; dist(n, INT_MAX);
  priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq;
  pq.push({0, src});
  dist[src] = 0;

  while (!pq.empty()) {
      int u = pq.top().second;
      pq.pop();

      for (auto &edge : graph[u]) {
          int v = edge.first, weight = edge.second;
          if (dist[v] > dist[u] + weight) {
              dist[v] = dist[u] + weight;
              pq.push({dist[v], v});
          }
      }
  }
}
</code></pre>
          </li>
          <li><strong>Bellman-Ford Algorithm:</strong> Also for finding the shortest path, but capable of handling graphs with negative weights.<p>In other words, the Bellman-Ford algorithm deals with graphs in which edge weights can be negative. It is used for finding the shortest path from a single source vertex to all other vertices in a weighted graph.</p>
            <pre><code class="language-cpp">bool bellman_ford(vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; &graph, int src, vector&lt;int&gt; &dist) {
    int n = graph.size();
    dist[src] = 0;
    for (int i = 0; i < n - 1; i++) {
      for (int u = 0; u < n; u++) {
          for (auto &edge : graph[u]) {
              int v = edge.first, weight = edge.second;
              if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) {
                  dist[v] = dist[u] + weight;
              }
          }
      }
  }
  
  // Check for negative weight cycles
  for (int u = 0; u < n; u++) {
      for (auto &edge : graph[u]) {
          int v = edge.first, weight = edge.second;
          if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) {
              return false; // Negative cycle found
          }
      }
  }
  
  return true;
}</code></pre>
          </li>
          <li><strong>Floyd-Warshall Algorithm:</strong> For finding shortest paths between all pairs of vertices in a weighted graph.</li>
          <li><strong>Kruskal's Algorithm:</strong> For finding the Minimum Spanning Tree (MST) of a graph.</li>
          <li><strong>Prim's Algorithm:</strong> Another algorithm for finding the MST of a graph.</li>
        </ul>
      </article>

      <article id="network-flows">
        <h4>1.5.1 Network Flows</h4>
        <p>Network flow is a concept in graph theory, where an amount of some quantity (like water or data) can flow through edges, which have a capacity. The Ford-Fulkerson algorithm and the Push-Relabel algorithm are used to solve network flow problems.</p>
      </article>

      <article id="graph-coloring">
        <h4>1.5.2 Graph Coloring</h4>
        <p>Graph coloring is an assignment of labels, called colors, to the vertices of a graph such that no two adjacent vertices share the same color. This concept is widely used in scheduling and partitioning problems.</p>
      </article>

      <article id="planar-graphs">
        <h4>1.5.3 Planar Graphs</h4>
        <p>Planar graphs are graphs that can be embedded in the plane without any edges crossing. They are fundamental in computational geometry and are used in various applications like circuit design.</p>
      </article>

      <article id="graph-theory-in-networks">
        <h4>1.5.4 Graph Theory in Networks</h4>
        <p>Graph theory plays a crucial role in computer networks. The internet can be represented as a graph, where web pages are vertices and hyperlinks are edges. Algorithms like PageRank use graph theory to rank web pages in search engine results.</p>
      </article>

      <article id="graph-isomorphism">
        <h4>1.5.5 Graph Isomorphism</h4>
        <p>Graph isomorphism is the study of the conditions under which two graphs are considered structurally identical. This area has applications in chemistry, where molecules can be represented as graphs with atoms as vertices and bonds as edges.</p>
      </article>

      <article id="random-graphs">
        <h4>1.5.6 Random Graphs</h4>
        <p>Random graphs are used for probabilistic methods in graph theory. They are particularly useful in the study of network optimization and reliability.</p>
      </article>

      <article id="graph-applications">
        <h4>1.6 Applications of Graph Theory</h4>
        <p>Graph theory is used in various domains such as:</p>
        <ul>
          <li><strong>Computer Networks:</strong> For designing routing algorithms.</li>
          <li><strong>Social Networks:</strong> For representing and analyzing relationships.</li>
          <li><strong>Search Engines:</strong> For ranking web pages and providing search results.</li>
          <li><strong>Recommendation Systems:</strong> For suggesting products or services.</li>
        </ul>
      </article>

      <article id="relation-with-other-concepts">
        <h3>2. Relating Graph Theory to Object-Oriented Programming (OOP)</h3>
        <p>Graph Theory and Object-Oriented Programming (OOP) may seem like two different domains, but they can be intertwined elegantly. In OOP, objects are instances of classes and can be thought of as vertices in a graph. The relationships between these objects, such as inheritance and association, can be considered as edges. This analogy helps in visualizing complex object-oriented systems as graphs, which can be analyzed for design patterns and optimizations.</p>
      </article>

      <article id="conclusion">
        <h3>3. The Hypergraph Frontier</h3>
        <p>Graph Theory is a versatile and fundamental field in mathematics and computer science. It has a wide range of applications, from computer networks to social networks. Understanding the basic concepts, types of graphs, representation methods, traversal techniques, and algorithms is essential for solving complex problems in various domains. The implementation of graph algorithms requires a solid understanding of data structures and programming concepts.</p>
        <p>As we reach the end of this labyrinth, let’s take a moment to gaze at the horizon. Beyondthe realm of simple graphs lies the enigmatic world of hypergraphs, where an edge can connect more than two vertices. Hypergraphs generalize the concept of graphs and open up new dimensions for combinatorial optimization, clustering, and data representation.</p>
        <p>Imagine a world where relationships are not just binary but can be n-ary, where the connections are not just lines but hyperplanes. This is the world of hypergraphs. As we stand on the precipice of this new frontier, we can only wonder what mysteries and applications it holds.</p>
      </article>

      <article id="next-article-teaser">
        <h3>4. Next Stop: The Enigmatic World of Hypergraphs</h3>
        <p>In our next journey, we will dive into the mesmerizing world of hypergraphs. We will explore their properties, applications, and the algorithms that sail through this high-dimensional space. So, fasten your seat belts as we take off into this uncharted territory, where every discovery is a treasure and every concept a new adventure!</p>
      </article>
    </main>

    <script>copyright("all");</script>
  </body>

</html>
