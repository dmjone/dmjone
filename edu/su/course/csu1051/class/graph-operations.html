<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
  <!--<![endif]-->

  <head>
    <script src="/js/edu_su_common.js"></script>
    <noscript>
      <style>
        html,
        body {
          margin: 0;
          overflow: hidden;
        }
      </style>
      <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
    </noscript>

    <title>Graph Operations: CSU1051 - Shoolini U | Navigating and Manipulating Graphs with dmj.one</title>
    <meta name="description" content="Explore various graph operations and algorithms at Shoolini University. Learn how to navigate, manipulate, and analyze graphs with dmj.one's educational initiative.">

    <meta property="og:image" content="/logo.png">
    <meta property="og:type" content="article">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@divyamohan1993">
    <meta name="twitter:creator" content="@divyamohan1993">
    <meta name="twitter:image" content="/logo.png">

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
          // customised options
          // • auto-render specific keys, e.g.:
          delimiters: [
            { left: '$$', right: '$$', display: true },
            { left: '$', right: '$', display: false },
            { left: '\\(', right: '\\)', display: false },
            { left: '\\[', right: '\\]', display: true }
          ],
          // • rendering keys, e.g.:
          throwOnError: false
        });
      });
    </script>
  </head>

  <body>

    <script>header_author("dm");</script>

    <main>
      <article>
        <h2 class="text-center">
          Graph Operations
        </h2>
        <div class="container mt-4 w-100 w-xl-75">
          <div class="accordion" id="toc">
            <div class="accordion-item">
              <h2 class="accordion-header" id="h1">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#c1" aria-controls="c1" aria-expanded="false">
                  <i class="fas fa-book"></i> <strong>&nbsp;Table of Contents</strong>
                </button>
              </h2>
              <div id="c1" class="accordion-collapse collapse" aria-labelledby="h1" data-bs-parent="#toc">
                <div class="accordion-body">
                  <ol class="list-unstyled p-0 m-0">
                    <li class="p-1"><a href="#intro"><i class="fas fa-chevron-circle-right"></i> Introduction</a></li>
                    <li class="p-1"><a href="#graph-operations"><i class="fas fa-chevron-circle-right"></i> Graph Operations</a></li>
                    <li class="p-1"><a href="#conclusion"><i class="fas fa-chevron-circle-right"></i> Conclusion</a></li>
                  </ol>
                </div>
              </div>
            </div>
          </div>
        </div>
      </article>



      <article id="intro">
        <h3>1. Introduction to Operations on Graphs</h3>
        <p>Graph theory, a fundamental part of computer science and mathematics, has seen its applications spread across diverse fields ranging from communications networks, social media, bioinformatics, to transportation systems. The concept of operations on graphs lies at the core of these applications, forming the backbone of the structural and algorithmic properties of graphs.</p>
      </article>

      <article>
        <h3>2. Fundamentals of Graph</h3>
        <p>A graph is a non-linear data structure consisting of nodes (vertices) and edges. The edges may be directed (digraphs) or undirected, and may carry weights. Operations on graphs are manipulations that allow us to extract meaningful conclusions from these structures.</p>
      </article>

      <article id="graph-operations">
        <h3>3. Primary Operations on Graphs</h3>
        <article>
          <h4>3.1 Traversals</h4>
          <p>Graph traversal involves visiting each node in a graph in a systematic way. The two most common traversal methods are Depth First Search (DFS) and Breadth First Search (BFS).</p>

          <article>
            <h5>3.1.1 Depth First Search (DFS)</h5>
            <p>The DFS traversal visits vertices as far ahead as possible along each branch before backtracking. It can be implemented using a stack data structure.</p>
            <pre><code class="language-cpp"> 
void DFS(int v, bool visited[], list&lt;int> adj[]) {
    visited[v] = true;
    cout << v << " ";
    list&lt;int>::iterator i;
    for (i = adj[v].begin(); i != adj[v].end(); ++i)
        if (!visited[*i])
            DFS(*i, visited, adj);
}
</code></pre>
          </article>

          <article>
            <h5>3.1.2 Breadth First Search (BFS)</h5>
            <p>The BFS traversal visits all vertices at the current depth before moving on to vertices at the next depth level. It can be implemented using a queue data structure.</p>
            <pre><code class="language-cpp"> 
void BFS(int v, bool visited[], list&lt;int> adj[]) {
    list&lt;int> queue;
    visited[v] = true;
    queue.push_back(v);
    while(!queue.empty())
    {
        v = queue.front();
        cout << v << " ";
        queue.pop_front();
        for (auto i = adj[v].begin(); i != adj[v].end(); ++i)
        {
            if (!visited[*i])
            {
                queue.push_back(*i);
                visited[*i] = true;
            }
        }
    }
}
</code></pre>
          </article>
        </article>

        <article>
          <h4>3.2 Path Finding</h4>
          <p>Path finding algorithms help determine the shortest path between two vertices in a graph. Some of the notable path finding algorithms are Dijkstra's algorithm and the Bellman-Ford algorithm.</p>

          <article>
            <h5>3.2.1 Dijkstra's Algorithm</h5>
            <p>Dijkstra's algorithm is used for finding the shortest paths from a single source vertex to all other vertices in a graph. The graph can't contain any edges with negative weight.</p>
            <pre><code class="language-cpp"> 
void dijkstra(vector&lt;vector&lt;int>>& adj, int src, int V) {
    priority_queue< pair&lt;int,int>, vector <pair&lt;int,int>>, greater<pair&lt;int,int>> > pq;
    vector&lt;int> dist(V, INT_MAX);
    pq.push(make_pair(0, src));
    dist[src] = 0;
    while (!pq.empty())
    {
        int u = pq.top().second;
        pq.pop();
        for (auto x : adj[u])
        {
            int v = x.first;
            int weight = x.second;
            if (dist[v] > dist[u] + weight)
            {
                dist[v] = dist[u] + weight;
                pq.push(make_pair(dist[v], v));
            }
        }
    }
    printSolution(dist, V);
}
</code></pre>
          </article>

          <article>
            <h5>3.2.2 Bellman-Ford Algorithm</h5>
            <p>Bellman-Ford algorithm is used to find the shortest paths from a single source vertex to all other vertices in a graph. Unlike Dijkstra's algorithm, Bellman-Ford can handle graphs with negative edge weights.</p>
            <pre><code class="language-cpp"> 
void bellmanFord(vector&lt;vector&lt;int>>& adj, int src, int V) {
    vector&lt;int> dist(V, INT_MAX);
    dist[src] = 0;
    for (int i=1; i<=V-1; i++)
    {
        for (auto edge : adj)
        {
            int u = edge[0];
            int v = edge[1];
            int weight = edge[2];
            if (dist[u] != INT_MAX && dist[u] + weight < dist[v])
                dist[v] = dist[u] + weight;
        }
    }
    printSolution(dist, V);
}
</code></pre>
          </article>
        </article>

        <article>
          <h4>3.3 Topological Sorting</h4>
          <p>Topological Sorting is a linear ordering of vertices such that for every directed edge (u, v), vertex u comes before v in the ordering. It can only be performed on directed acyclic graphs (DAGs).</p>
          <pre><code class="language-cpp">
void topologicalSortUtil(int v, bool visited[], stack&lt;int> &Stack, list&lt;int> adj[]) {
    visited[v] = true;
    for (auto i = adj[v].begin(); i != adj[v].end(); ++i)
        if (!visited[*i])
            topologicalSortUtil(*i, visited, Stack, adj);
    Stack.push(v);
}
void topologicalSort(list&lt;int> adj[], int V) {
    stack&lt;int> Stack;
    bool *visited = new bool[V];
    for (int i = 0; i < V; i++)
        visited[i] = false;
    for (int i = 0; i < V; i++)
        if (visited[i] == false)
            topologicalSortUtil(i, visited, Stack, adj);
    while (Stack.empty() == false)
    {
        cout << Stack.top() << " ";
        Stack.pop();
    }
}
</code></pre>
        </article>

        <article>
          <h4>3.4 Minimum Spanning Tree</h4>
          <p>A minimum spanning tree (MST) for a weighted, connected and undirected graph is a spanning tree with weight less than or equal to the weight of every other spanning tree. The weight of a spanning tree is the sum of weights given to each edge of the spanning tree. Notable algorithms for finding the MST are Prim's algorithm and Kruskal's algorithm.</p>

          <article>
            <h5>3.4.1 Prim's Algorithm</h5>
            <p>Prim's algorithm builds the spanning tree by adding the nearest vertex to the built tree. It starts with an arbitrary node, then expands the tree by adding the minimum-weight edge that connects the tree to nodes not yet in the tree.</p>
            <pre><code class="language-cpp"> 
void primMST(vector&lt;vector&lt;int>>& adj, int V) {
    vector

&lt;int> parent(V);
    vector&lt;int> key(V, INT_MAX);
    vector&lt;bool> mstSet(V, false);
    key[0] = 0;
    parent[0] = -1;
    for (int count = 0; count < V-1; count++)
    {
        int u = minKey(key, mstSet, V);
        mstSet[u] = true;
        for (auto v : adj[u])
            if (mstSet[v.first] == false && v.second < key[v.first])
                key[v.first] = v.second, parent[v.first] = u;
    }
    printMST(parent, V, adj);
}
</code></pre>
          </article>

          <article>
            <h5>3.4.2 Kruskal's Algorithm</h5>
            <p>Kruskal's algorithm builds the spanning tree by adding the lowest-cost edge that connects any two trees in the forest. It treats each node as an independent tree and connects one with another only if it has the lowest cost among all available options.</p>
            <pre><code class="language-cpp"> 
void KruskalMST(vector&lt;vector&lt;int>>& adj, int V) {
    sort(adj.begin(), adj.end());
    vector&lt;int> parent(V);
    for (int i = 0; i < V; i++)
        parent[i] = i;
    vector&lt;vector&lt;int>> mst;
    for (auto u : adj)
    {
        int v = u[0], w = u[1], weight = u[2];
        if (find(v, parent) != find(w, parent))
        {
            mst.push_back({v, w, weight});
            union(v, w, parent);
        }
    }
    printMST(mst);
}
</code></pre>
          </article>
        </article>
      </article>

      <article id="conclusion">
        <h3>4. Conclusion</h3>
        <p>From data analytics to network routing, operations on graphs unlock a wealth of possibilities. Grasping these fundamental operations provides a solid foundation for more complex graph-related tasks. Indeed, the sky is the limit when it comes to the innovative applications and further potential for optimization of these operations.</p>
      </article>

      <article id="graph-operations-next-article">
        <h3>5. Onwards to Greener Pastures: Dynamic Graph Algorithms</h3>
        <p>Graphs aren't always static. With constantly changing vertices and edges, dynamic graphs are the real-world standard. Next, we'll delve into the dynamic world of graphs, exploring efficient algorithms and data structures that handle the ever-changing nature of practical applications. Ready for the dynamic ride?</p>
      </article>
    </main>

    <script>copyright("all");</script>
  </body>

</html>
