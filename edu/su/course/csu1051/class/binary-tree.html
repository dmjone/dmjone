<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
  <!--<![endif]-->

  <head>
    <script src="/js/edu_su_common.js"></script>
    <noscript>
      <style>
        html,
        body {
          margin: 0;
          overflow: hidden;
        }
      </style>
      <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
    </noscript>

    <title>Binary Tree & Traversals: CSU1051 - Shoolini U</title>
    <meta name="description" content="Embark on a journey through Binary Trees and their traversals at Shoolini University. Discover different traversal techniques and unlock the secrets of efficient tree navigation with dmj.one's educational initiative.">

    <meta property="og:image" content="/logo.png">
    <meta property="og:type" content="article">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@divyamohan1993">
    <meta name="twitter:creator" content="@divyamohan1993">
    <meta name="twitter:image" content="/logo.png">

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
          // customised options
          // • auto-render specific keys, e.g.:
          delimiters: [
            { left: '$$', right: '$$', display: true },
            { left: '$', right: '$', display: false },
            { left: '\\(', right: '\\)', display: false },
            { left: '\\[', right: '\\]', display: true }
          ],
          // • rendering keys, e.g.:
          throwOnError: false
        });
      });
    </script>
  </head>

  <body>

    <script>header_author("dm");</script>

    <main>
      <article>
        <h2 class="text-center">
          Binary Tree and its Traversal
        </h2>
        <div class="container mt-4 w-100 w-xl-75">
          <div class="accordion" id="toc">
            <div class="accordion-item">
              <h2 class="accordion-header" id="h1">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#c1" aria-controls="c1" aria-expanded="false">
                  <i class="fas fa-book"></i> <strong>&nbsp;Table of Contents</strong>
                </button>
              </h2>
              <div id="c1" class="accordion-collapse collapse" aria-labelledby="h1" data-bs-parent="#toc">
                <div class="accordion-body">
                  <ol class="list-unstyled p-0 m-0">
                    <li class="p-1"><a href="#binary-trees"><i class="fas fa-chevron-circle-right"></i> Introduction</a></li>
                    <li class="p-1"><a href="#binary-tree-traversal"><i class="fas fa-chevron-circle-right"></i> Tree Traversal</a></li>
                    <li class="p-1"><a href="#threaded-binary-trees"><i class="fas fa-chevron-circle-right"></i> Threaded Binary Tree</a></li>
                    <li class="p-1"><a href="#self-adjusting-trees"><i class="fas fa-chevron-circle-right"></i> Self Adjusting Tree</a></li>                    
                  </ol>
                </div>
              </div>
            </div>
          </div>
        </div>
      </article>

      <article id="executive-summary">
        <h3>Executive Summary</h3>
        <p>
          In this comprehensive exploration of binary trees and their traversal, we delve into the intricacies of this core concept in data structures and algorithms. We begin with an exploration of binary trees, their definition, properties, and usage scenarios. Then, we break down the types of tree traversals - pre-order, in-order, and post-order, elaborating on their algorithms and their practical applications. Building upon this, we extend the discussion to more complex themes like thread binary trees and their traversal optimisations. We explore the connections with object-oriented programming principles in C++, digital electronics concepts such as binary encoding, and the stochastic nature of search paths in a binary tree using principles from Random Variables in mathematics. We conclude with a deep dive into self-adjusting trees like splay trees and AVL trees, and their significance in dynamic data access scenarios. In the next article, we will journey into the realms of advanced tree structures such as B-Trees and Red-Black trees, vital in the functioning of modern databases and file systems.
        </p>
      </article>

      <article id="binary-trees">
        <h3>1. Binary Trees: The Building Blocks</h3>
        <p>
          Imagine you are tasked with creating an organisation's hierarchy chart or a genealogical tree. In such scenarios, you need a data structure that can efficiently represent these hierarchical relationships - binary trees offer an ideal solution. In computer science, a binary tree is a tree data structure in which each node has at most two children, referred to as the left child and the right child. This simple yet powerful data structure forms the foundation of various computer science disciplines, including algorithms, digital electronics, and even aspects of mathematical theory.
        </p>

        <h4>1.1 Definition and Properties</h4>
        <p>
          Formally, a binary tree is defined as a finite set of elements, known as nodes, which is either empty or partitioned into three disjoint subsets: a root element and two binary trees called the left and right subtrees. It is worth noting that the subtrees are themselves binary trees and this recursive nature brings about several elegant algorithms for binary tree manipulations.
        </p>

        <p>
          The properties of binary trees offer significant insight into their characteristics and usage. For instance, the number of nodes at a given level 'i' is $2^{i-1}$, with the root considered as level 1. The maximum number of nodes in a binary tree of height 'h' is $2^h - 1$. These properties highlight the exponential nature of the binary tree growth and are central to its logarithmic height, making them suitable for searching operations.
        </p>

        <h4>1.2 Binary Trees and Object-Oriented Principles</h4>
        <p>
          When implementing binary trees in C++, principles of object-oriented programming (OOP) come into play. The concept of classes, inheritance, encapsulation, and polymorphism can be leveraged to create robust and extensible binary tree structures. Each node can be represented as an object of a 'Node' class, encapsulating data and pointers to child nodes within it. Inheritance allows us to extend this basic structure to more specific trees like binary search trees (BST), AVL trees, and so forth, adhering to the OOP principle of code reusability.
        </p>

        <pre><code class="language-cpp">class Node {
public:
    int data;
    Node* left;
    Node* right;

    Node(int val) {
        data = val;
        left = nullptr;
        right = nullptr;
    }
};</code></pre>

        <p>
          Here, we define a basic node structure encapsulating the data and pointers to left and right children. This structure

          can then be used to construct a binary tree.
        </p>
      </article>

      <article id="binary-tree-traversal">
        <h3>2. Binary Tree Traversal: A Journey Through Nodes</h3>
        <p>
          Traversal is a process of visiting each node in the tree exactly once, in a particular order. It forms the backbone of many binary tree operations, from search and update operations to tree structure manipulations. The traversal order varies depending on the requirement. In a binary tree, there are mainly three types of traversals: pre-order, in-order, and post-order.
        </p>

        <h4>2.1 Pre-order Traversal</h4>
        <p>
          In pre-order traversal, the process visits the root node first, then the left subtree, and finally the right subtree. The visit order is 'Root, Left, Right'. This method is typically useful in scenarios like printing a structured document, where parents need to be processed before children.
        </p>

        <pre><code class="language-cpp">
void preorder(Node* root) {
    if(root == nullptr)
        return;
    cout << root->data << " ";
    preorder(root->left);
    preorder(root->right);
}
</code></pre>

        <h4>2.2 In-order Traversal</h4>
        <p>
          In in-order traversal, the left subtree is visited first, then the root node, and finally the right subtree. The visit order is 'Left, Root, Right'. This method is particularly useful in binary search trees, where in-order traversal retrieves data in sorted order.
        </p>

        <pre><code class="language-cpp">
void inorder(Node* root) {
    if(root == nullptr)
        return;
    inorder(root->left);
    cout << root->data << " ";
    inorder(root->right);
}
</code></pre>

        <h4>2.3 Post-order Traversal</h4>
        <p>
          In post-order traversal, the left subtree is visited first, then the right subtree, and finally the root node. The visit order is 'Left, Right, Root'. This method is used in scenarios like evaluating postfix expressions, or deleting a tree, where children need to be processed before parents.
        </p>

        <pre><code class="language-cpp">
void postorder(Node* root) {
    if(root == nullptr)
        return;
    postorder(root->left);
    postorder(root->right);
    cout << root->data << " ";
}
</code></pre>
      </article>

      <article id="threaded-binary-trees">
        <h3>3. Threaded Binary Trees: Harnessing the Power of Null Pointers</h3>
        <p>
          In a standard binary tree, a substantial amount of memory space is left unused in the form of null pointers. Threaded binary trees, a unique spin-off of binary trees, put these idle null pointers to use by creating 'threads' for in-order traversal, thus improving the traversal efficiency. A binary tree is 'threaded' by replacing all null pointers in it with links to in-order successor (for right pointers) or predecessor (for left pointers), hence the term 'threaded'.
        </p>

        <h4>3.1 The Connection with Digital Electronics</h4>
        <p>
          Interestingly, the idea of threading can be related to the concept of data compression in digital electronics. In both cases, the objective is to utilise available resources efficiently. In digital electronics, Huffman coding uses variable-length prefix codes to encode source symbols, reducing the average code length and thereby saving space. Similarly, threaded binary trees optimise the space usage by making efficient use of null pointers, saving both memory and computational overhead.
        </p>

        <h4>3.2 Implementation in C++</h4>
        <p>
          Implementing threaded binary trees involves

          modifying the basic Node structure to include a 'boolean' field that indicates whether the right (or left) pointer points to an in-order successor (or predecessor) or a child. This can be achieved using inheritance in C++ to create a ThreadedNode class.
        </p>

        <pre><code class="language-cpp">
class ThreadedNode : public Node {
public:
    bool rightThread;

    ThreadedNode(int val) : Node(val) {
        rightThread = false;
    }
};
</code></pre>
      </article>

      <article id="binary-tree-traversal-stochastic">
        <h3>4. Binary Tree Traversal: A Stochastic Analysis</h3>
        <p>
          The process of searching for a node in a binary tree can be thought of as a random process where each left or right turn can be considered a random event. This connects binary tree traversal to the concept of Random Variables in mathematics, specifically, Geometric Random Variables, which describe the number of trials needed to get the first success in repeated independent and identically distributed (i.i.d) Bernoulli trials.
        </p>

        <p>
          Consider a binary search tree (BST) and a scenario of searching for a key. Each comparison that leads us left or right can be seen as a Bernoulli trial with two outcomes - either we find the key (success) or we don't (failure). The number of comparisons, hence, is a random variable that follows a geometric distribution. This probabilistic viewpoint can assist in analysing average-case performance of BST operations and designing more efficient tree structures, linking the worlds of data structures and probabilistic analysis.
        </p>
      </article>

      <article id="self-adjusting-trees">
        <h3>5. Self-adjusting Trees: Adapting to the Future</h3>
        <p>
          While binary search trees (BST) provide efficient search operations in their optimal form, the efficiency degrades in the case of skewed trees. To tackle this, we have self-adjusting or self-balancing trees like AVL Trees and Splay Trees that maintain their height within a logarithmic bound of the number of nodes, ensuring optimal search time complexity.
        </p>

        <h4>5.1 AVL Trees</h4>
        <p>
          Named after their inventors Adelson-Velsky and Landis, AVL trees are a type of binary search tree that maintains its height balanced. The balance is ensured by preserving the 'Balance Factor' (the difference in heights of left and right subtrees) of every node in the tree within -1 to 1. Whenever this balance factor goes outside the prescribed range, a re-balancing operation is performed, which could be a single or double rotation, depending on the imbalance type.
        </p>

        <h4>5.2 Splay Trees</h4>
        <p>
          Unlike AVL trees that work towards preserving the balance all the time, Splay trees take a different approach. They are a type of self-adjusting binary search tree that performs a splaying operation to move the recently accessed node to the root of the tree. This 'move-to-root' strategy helps in improving access time for frequently accessed elements, which is particularly useful in cache implementations.
        </p>

        <p>
          As we continue to explore advanced data structures, we observe the elegance and versatility of the simple binary tree, extending into various computer science disciplines and serving as a foundation for many high-level applications. With binary trees, it's all about the journey, not just the destination.
        </p>

        <p>
          As we conclude our deep dive into binary trees and their traversal, we look forward to the next leap into the realms of advanced tree structures like B-Trees and Red-Black trees, central to the functioning of modern databases and file systems. The journey through the binary tree is one filled with discoveries and insights into the fascinating world of data structures, and we're just getting started.
        </p>
      </article>

    </main>

    <script>copyright("all");</script>
  </body>

</html>