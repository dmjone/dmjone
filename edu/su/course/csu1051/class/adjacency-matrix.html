<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
  <!--<![endif]-->

  <head>
    <script src="/js/edu_su_common.js"></script>
    <noscript>
      <style>
        html,
        body {
          margin: 0;
          overflow: hidden;
        }
      </style>
      <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
    </noscript>

    <title>Adjacency Matrix: CSU1051 - Shoolini U | Visualizing Graph Connections with dmj.one</title>
    <meta name="description" content="Understand the concept of Adjacency Matrix in graph theory at Shoolini University. Learn to represent and analyze graph connections using this powerful data structure with dmj.one's educational initiative.">

    <meta property="og:image" content="/logo.png">
    <meta property="og:type" content="article">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@divyamohan1993">
    <meta name="twitter:creator" content="@divyamohan1993">
    <meta name="twitter:image" content="/logo.png">

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
          // customised options
          // • auto-render specific keys, e.g.:
          delimiters: [
            { left: '$$', right: '$$', display: true },
            { left: '$', right: '$', display: false },
            { left: '\\(', right: '\\)', display: false },
            { left: '\\[', right: '\\]', display: true }
          ],
          // • rendering keys, e.g.:
          throwOnError: false
        });
      });
    </script>
  </head>

  <body>

    <script>header_author("dm");</script>

    <main>
      <article>
        <h2 class="text-center">
          Adjacency Matrix
        </h2>
        <div class="container mt-4 w-100 w-xl-75">
          <div class="accordion" id="toc">
            <div class="accordion-item">
              <h2 class="accordion-header" id="h1">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#c1" aria-controls="c1" aria-expanded="false">
                  <i class="fas fa-book"></i> <strong>&nbsp;Table of Contents</strong>
                </button>
              </h2>
              <div id="c1" class="accordion-collapse collapse" aria-labelledby="h1" data-bs-parent="#toc">
                <div class="accordion-body">
                  <ol class="list-unstyled p-0 m-0">
                    <li class="p-1"><a href="#adjacency-matrix-intro"><i class="fas fa-chevron-circle-right"></i> Introduction</a></li>
                    <li class="p-1"><a href="#adjacency-matrix-basic"><i class="fas fa-chevron-circle-right"></i> Adjacency Matrix Basics</a></li>
                    <li class="p-1"><a href="#representation-in-cpp"><i class="fas fa-chevron-circle-right"></i> Representations in C++</a></li>
                    <li class="p-1"><a href="#operations-on-adjacency-matrices"><i class="fas fa-chevron-circle-right"></i> Operations on Adjacency Matrix</a></li>
                    <li class="p-1"><a href="#conclusion"><i class="fas fa-chevron-circle-right"></i> Conclusion</a></li>
                  </ol>
                </div>
              </div>
            </div>
          </div>
        </div>
      </article>



      <article id="adjacency-matrix-intro">
        <h3>1. Introduction to Adjacency Matrices</h3>
        <p>An adjacency matrix is a fundamental concept in computer science, specifically within the domain of data structures and algorithms. It is used to represent graphs as binary or weighted matrices. The nodes of the graph are associated with the rows and columns of the matrix, with matrix elements indicating whether an edge is present between the nodes.</p>

        <p>An adjacency matrix can be used to represent both directed and undirected graphs, simple or multigraphs, and can also be extended to represent weighted graphs. Its uses are widespread, finding applications in various computer science subfields such as network analysis, path finding, and scheduling problems.</p>
      </article>

      <article id="adjacency-matrix-basic">
        <h3>2. The Basic Concept of Adjacency Matrices</h3>
        <p>The adjacency matrix for a graph with 'n' vertices is a square 'n × n' matrix where the entry in the i-th row and j-th column is usually a 0 or 1, depending on whether there is an edge from vertex i to vertex j.</p>

        <p>In the case of an undirected graph, the adjacency matrix is symmetric about the main diagonal, as the presence of an edge from i to j implies the presence of an edge from j to i. However, this is not the case for a directed graph, which results in an asymmetric adjacency matrix.</p>

        <p>In weighted graphs, the weights of the edges can be represented as entries in the adjacency matrix. If there is no edge between two vertices, the entries are usually filled with a specific value to denote "no edge," often zero or infinity.</p>

        <p>An adjacency matrix is a square matrix used to represent a finite graph. The size of the matrix is n x n, where n is the number of vertices in the graph. The element A<sub>ij</sub> is 1 if there is an edge between vertex i and vertex j; otherwise, it is 0. In the case of a weighted graph, the element A<sub>ij</sub> represents the weight of the edge between vertices i and j.</p>
      </article>
      <article id="spectral-graph-theory">
        <h4>2.1 Spectral Graph Theory</h4>
        <p>The relationship between a graph and the eigenvalues and eigenvectors of its adjacency matrix is studied in spectral graph theory. The set of eigenvalues of a graph is known as the spectrum of the graph. The spectrum and the eigenvalues of the adjacency matrix can provide insightful information about the structure of the graph.</p>
      </article>
      <article id="other-matrix-representations">
        <h4>2.2 Other Matrix Representations</h4>
        <p>It is important to distinguish the adjacency matrix from other matrix representations of a graph, such as the incidence matrix and the degree matrix. The incidence matrix has elements that indicate whether vertex-edge pairs are incident or not, while the degree matrix contains information about the degree of each vertex.</p>
      </article>

      <article id="advantages-limitations">
        <h4>2.3 Advantages and Limitations of Adjacency Matrices through Complexity Analysis </h4>
        <p>Adjacency matrices come with their own set of advantages and limitations. They are straightforward to implement and provide a quick way to check if a specific edge is in the graph - this operation can be performed in constant time, i.e., O(1).</p>

        <p>However, for a sparse graph (one with few edges), an adjacency matrix may not be the most space-efficient representation. Each adjacency matrix consumes O(n²) space, regardless of the number of edges in the graph. In such cases, an adjacency list might be a more efficient choice.</p>

        <p>Another drawback is the time complexity for traversing all the edges of a graph, which takes O(n²) time for an adjacency matrix, while an adjacency list can perform this in O(n + m) time, where m is the number of edges.</p>
      </article>

      <article id="representation-in-cpp">
        <h3>3. Representation of Adjacency Matrices in C++</h3>
        <p>Implementing an adjacency matrix in C++ is straightforward. A two-dimensional array can be used to represent the matrix, and standard library functions can manipulate it. Here's a simple implementation:</p>

        <pre><code class="language-cpp">
#include<bits/stdc++.h>
using namespace std;

int main() {
    int vertices, edges, i, j;
    cin >> vertices >> edges;

    // Create a 2D array of size vertices x vertices
    vector<vector<int>> adjMatrix(vertices, vector<int>(vertices, 0));

    for(int e = 0; e < edges; e++) {
        cin >> i >> j;
        adjMatrix[i][j] = 1;
        adjMatrix[j][i] = 1; // Remove this for a directed graph
    }

    return 0;
}
</code></pre>

        <p>In the code above, we first create a square matrix with all elements initialized to zero. Then for each edge in the graph, we set the corresponding element in the adjacency matrix to one.</p>
      </article>
      <article id="example-implementation">
        <h4>3.1. Example Implementation in C++</h4>
        <pre><code class="language-cpp"> 
#include &lt;iostream&gt;
#include &lt;vector&gt;
class Graph {
public:
Graph(int vertices) : adjMatrix(vertices, std::vector<int>(vertices, 0)),numVertices(vertices) {}
  void addEdge(int i, int j) {
    adjMatrix[i][j] = 1;
    adjMatrix[j][i] = 1;
}

void removeEdge(int i, int j) {
    adjMatrix[i][j] = 0;
    adjMatrix[j][i] = 0;
}

void printMatrix() {
    for (int i = 0; i < numVertices; i++) {
        for (int j = 0; j < numVertices; j++) {
            std::cout << adjMatrix[i][j] << " ";
        }
        std::cout << std::endl;
    }
}
private:
std::vector<std::vector<int>> adjMatrix;
int numVertices;
};

int main() {
Graph graph(5);
graph.addEdge(0, 1);
graph.addEdge(0, 4);
graph.addEdge(1, 3);
graph.addEdge(1, 4);
graph.addEdge(3, 4);
graph.printMatrix();

return 0;
}
</code></pre>

      </article>

      <article id="operations-on-adjacency-matrices">
        <h3>4. Operations on Adjacency Matrices</h3>
        <p>Various operations can be performed on adjacency matrices, such as adding a vertex, adding an edge, removing a vertex, removing an edge, and checking if an edge exists between two vertices.</p>
      </article>

      <article id="add-remove-vertex">
        <h4>4.1 Adding and Removing a Vertex</h4>
        <p>To add a vertex, we need to add another row and column to our matrix. In C++, this can be done by resizing our matrix and filling the new entries with zeros:</p>

        <pre><code class="language-cpp">
adjMatrix.resize(vertices + 1);
for(int i = 0; i <= vertices; i++) {
    adjMatrix[i].resize(vertices + 1, 0);
}
</code></pre>

        <p>To remove a vertex, we need to delete the corresponding row and column from our matrix. This can be done by creating a new matrix without the deleted vertex and then assigning it to our original matrix:</p>

        <pre><code class="language-cpp">
vector<vector<int>> newMatrix(vertices - 1, vector<int>(vertices - 1, 0));
for(int i = 0; i < vertices; i++) {
    for(int j = 0; j < vertices; j++) {
        if(i != deletedVertex && j != deletedVertex) {
            newMatrix[i < deletedVertex ? i : i - 1][j < deletedVertex ? j : j - 1] = adjMatrix[i][j];
        }
    }
}
adjMatrix = newMatrix;
</code></pre>
      </article>

      <article id="add-remove-edge">
        <h4>4.2 Adding and Removing an Edge</h4>
        <p>To add an edge, we simply need to update the corresponding entry in our matrix to one:</p>

        <pre><code class="language-cpp">
adjMatrix[i][j] = 1;
</code></pre>

        <p>Similarly, to remove an edge, we update the corresponding entry in our matrix back to zero:</p>

        <pre><code class="language-cpp">
adjMatrix[i][j] = 0;
</code></pre>
      </article>

      <article id="check-edge">
        <h4>4.3 Checking if an Edge Exists</h4>
        <p>To check if an edge exists between two vertices, we simply need to check the value of the corresponding entry in our matrix:</p>

        <pre><code class="language-cpp">
if(adjMatrix[i][j] == 1) {
    cout << "Edge exists.\n";
} else {
    cout << "Edge does not exist.\n";
}
</code></pre>
      </article>

      <article id="advanced-concepts">
        <h3>5. Advanced Concepts and Applications of Adjacency Matrices</h3>
        <p>Adjacency matrices form the foundation for many advanced graph algorithms. They can be used to compute the transitive closure of a graph, determine the presence of a triangle in a graph, or find the shortest path between two vertices using algorithms such as Floyd-Warshall.</p>

        <p>In addition to these, adjacency matrices have found use in social network analysis, image processing, and even in the study of biological networks such as protein-protein interaction networks or metabolic networks.</p>
      </article>

      <article id="conclusion">
        <h3>6. Conclusion</h3>
        <p>Adjacency matrices are powerful tools in the field of data structures and algorithms. They provide an efficient and intuitive way to represent graphs and perform operations on them. Despite their limitations, particularly with sparse graphs, they are instrumental in a wide array of applications.</p>
      </article>

      <article id="next-article-prompt">
        <h3>A Peek into the Next Chapter...</h3>
        <p>Are you ready for the next leap in your journey with graphs? Well, hold on to your curiosity as we unravel the power of adjacency lists in our next chapter "Adjacency Lists: A Gateway to Efficient Graph Traversal". Here, we will take a deep dive into the realm of adjacency lists, their efficient memory usage, and their edge in traversing sparse graphs. So, keep your C++ compilers warmed up and stay tuned!</p>
      </article>
    </main>

    <script>copyright("all");</script>
  </body>

</html>
