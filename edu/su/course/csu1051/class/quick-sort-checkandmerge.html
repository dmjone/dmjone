<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
  <!--<![endif]-->

  <head>
    <script src="/js/edu_su_common.js"></script>
    <noscript>
      <style>
        html,
        body {
          margin: 0;
          overflow: hidden;
        }
      </style>
      <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
    </noscript>

    <title>Quick Sort Algorithm: CSU1051 - Data Structures & Algorithms</title>
    <meta name="description" content="Learn the Quick Sort algorithm for efficient sorting in Data Structures & Algorithms. Join CSU1051 course at Shoolini University to master the implementation and analysis of Quick Sort.">
    
    <meta property="og:image" content="/logo.png">
    <meta property="og:type" content="article">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@divyamohan1993">
    <meta name="twitter:creator" content="@divyamohan1993">
    <meta name="twitter:image" content="/logo.png">

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
          // customised options
          // • auto-render specific keys, e.g.:
          delimiters: [
            { left: '$$', right: '$$', display: true },
            { left: '$', right: '$', display: false },
            { left: '\\(', right: '\\)', display: false },
            { left: '\\[', right: '\\]', display: true }
          ],
          // • rendering keys, e.g.:
          throwOnError: false
        });
      });
    </script>
  </head>

  <body>

    <script>header_author("dm");</script>

    <main>
      <article>
        <h2 class="text-center">
          Quick Sort
        </h2>
        <div class="container mt-4 w-100 w-xl-75">
          <div class="accordion" id="toc">
            <div class="accordion-item">
              <h2 class="accordion-header" id="h1">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#c1" aria-controls="c1" aria-expanded="false">
                  <i class="fas fa-book"></i> <strong>&nbsp;Table of Contents</strong>
                </button>
              </h2>
              <div id="c1" class="accordion-collapse collapse" aria-labelledby="h1" data-bs-parent="#toc">
                <div class="accordion-body">
                  <ol class="list-unstyled p-0 m-0">
                    <li class="p-1"><a href="#left-page"><i class="fas fa-chevron-circle-right"></i> Left Side (Blank Side)</a></li>
                    <li class="p-1"><a href="#right-page"><i class="fas fa-chevron-circle-right"></i> Right Side (Ruled Side)</a></li>
                  </ol>
                </div>
              </div>
            </div>
          </div>
        </div>
      </article>

      <article id="executive-summary">
        <h3>Executive Summary</h3>
        <p>While traversing the landscape of sorting algorithms, the 'Quick Sort' emerges as a pragmatic approach for efficient data arrangement. A signature divide-and-conquer technique, Quick Sort's effectiveness hinges on 'partitioning' and 'pivot selection', defining its best-case, average-case, and worst-case complexities. In this exploration, we dissect Quick Sort in a comprehensive manner – from a basic overview to advanced topics such as Randomized Quick Sort and its recursive implementation, and even delve into its stability and comparisons with other sorting techniques. In addition to theoretical elucidation, practical considerations are discussed, making this article a cornerstone reference for data structure and algorithm enthusiasts. By utilizing a gradual increase in complexity, it serves as an excellent resource for both beginners and advanced researchers.</p>
      </article>

      <article id="introduction">
        <h3>1. Introduction: Embracing Quick Sort</h3>
        <p>Imagine you're working with an extensive database of students' scores and you wish to sort the data in ascending order. The brute-force approach of manually comparing and swapping values can be incredibly time-consuming, especially as the size of the database expands. One solution to efficiently sort this massive data is the Quick Sort algorithm, a well-regarded tool in the domain of data structures and algorithms.</p>

        <p>Quick Sort, as the name suggests, is a sorting algorithm known for its speed and efficiency. It follows a divide-and-conquer strategy, breaking down a large problem into smaller sub-problems until they become simple enough to solve. The simplicity and effectiveness of Quick Sort have led to its widespread use in numerous computer systems.</p>
      </article>
      <article id="algorithmic-overview">
        <h3>2. Algorithmic Overview</h3>
        <p>Quick Sort operates on the principle of partitioning an array around a chosen 'pivot' element. It organizes the data in such a way that all elements less than the pivot come before it, while all elements greater come after it. This operation is performed recursively on the sub-arrays, leading to a fully sorted array. The selection of the pivot element plays a crucial role in the efficiency of Quick Sort.</p>
      </article>

      <article id="working-detail">
        <h4>2.1 Working in Detail</h4>
        <p>The Quick Sort algorithm comprises primarily three steps:</p>
        <ol>
          <li><strong>Partition:</strong> Select a 'pivot' from the array. Rearrange the array elements in such a way that elements less than the pivot are to its left, and elements greater than the pivot are to its right. This is called the 'partition operation'.</li>
          <li><strong>Recursive Sort:</strong> Recursively apply the above process to the sub-array of elements with smaller values and separately to the sub-array of elements with greater values.</li>
          <li><strong>Combine:</strong> Merge the sub-arrays back together. However, in the case of Quick Sort, this step is unnecessary as the array is manipulated in-place.</li>
        </ol>
      </article>

      <article id="partitioning">
        <h3>3. Partitioning</h3>
        <p>The primary task in the Quick Sort algorithm is the partitioning of the array. A well-performing partitioning method ensures that the pivot is placed in the correct position, the elements less than the pivot are to its left, and elements greater are to its right. The algorithm is recursive, and this partitioning process repeats until the array is fully sorted.</p>

        <pre><code class="language-cpp">
int partition(int arr[], int low, int high) {
   int pivot = arr[high];  // select pivot
   int i = (low - 1);  // index of

 smaller element

   for (int j = low; j <= high - 1; j++) {
       // If current element is smaller than or equal to pivot
       if (arr[j] <= pivot) {
           i++;  // increment index of smaller element
           swap(&arr[i], &arr[j]);
       }
   }
   swap(&arr[i + 1], &arr[high]);
   return (i + 1);
}
</code></pre>
      </article>

      <article id="pivot-selection">
        <h3>4. Pivot Selection</h3>
        <p>The choice of the pivot element is crucial in determining the performance of Quick Sort. Different strategies can be employed:</p>
        <ul>
          <li><strong>First element:</strong> The simplest method, although it performs poorly with nearly sorted or reverse-sorted arrays.</li>
          <li><strong>Last element:</strong> Another simple approach but susceptible to the same issues as using the first element.</li>
          <li><strong>Random element:</strong> Selecting a random element mitigates the issues of the previous methods and averages out to a good performance on various inputs.</li>
          <li><strong>Median:</strong> The median of the array is an excellent pivot choice, as it consistently results in balanced splits. However, finding the median is an O(n) operation, which may diminish the overall performance gain.</li>
        </ul>
      </article>

      <article id="complexity-analysis">
        <h3>5. Complexity Analysis</h3>
        <p>The time complexity of Quick Sort depends on how balanced the partitions are, which in turn relies on the pivot selection.</p>

        <h4>5.1 Best-case and Average-case Analysis</h4>
        <p>In the best-case scenario, the pivot always divides the array into two halves leading to a time complexity of O(n log n). On average, Quick Sort has a time complexity of O(n log n), even though this hinges on the assumption of 'average' balance in partitioning.</p>

        <h4>5.2 Worst-case Analysis</h4>
        <p>In the worst-case scenario, the smallest or largest element is always selected as the pivot (an issue when dealing with an already sorted or reverse-sorted array). This imbalance leads to partitions with n-1 elements, resulting in a time complexity of O(n²).</p>
      </article>

      <article id="randomized-quick-sort">
        <h3>6. Randomized Quick Sort</h3>
        <p>To overcome the worst-case scenario of Quick Sort, Randomized Quick Sort is used. Instead of traditionally selecting the pivot, Randomized Quick Sort picks a random element as pivot. This randomization ensures the expected time complexity remains O(n log n) for any input array.</p>

        <pre><code class="language-cpp">
int randomized_partition(int arr[], int low, int high) {
   // Generate a random number in between
   // low .. high
   srand(time(NULL));
   int random = low + rand() % (high - low);

   // Swap arr[random] with arr[high]
   swap(&arr[random], &arr[high]);

   return partition(arr, low, high);
}
</code></pre>
      </article>

      <article id="recursive-implementation">
        <h3>7. Recursive Implementation</h3>
        <p>Quick Sort is typically implemented as a recursive function. After partitioning an array, the function is recursively called for the two sub-arrays around the pivot (excluding the pivot as it is already in its correct place). The recursive calls stop when the size of the sub-array reduces to zero or one (an array of a single element is considered sorted).</p>

        <pre><code class="language-cpp">
void quickSort(int arr[], int low, int high) {


   if (low < high) {
       /* pi is partitioning index, arr[p] is now
       at right place */
       int pi = partition(arr, low, high);

       // Separately sort elements before
       // partition and after partition
       quickSort(arr, low, pi - 1);
       quickSort(arr, pi + 1, high);
   }
}
</code></pre>
      </article>

      <article id="in-place-sorting">
        <h3>8. In-place Sorting</h3>
        <p>Quick Sort is an 'in-place' sorting algorithm. It doesn't require any extra storage other than a small stack space due to recursion. This property makes Quick Sort suitable for environments where auxiliary storage is limited.</p>
      </article>

      <article id="stability">
        <h3>9. Stability</h3>
        <p>Stability is a property where equal elements retain their relative order after sorting. Quick Sort, in its basic form, is not stable due to swapping of nonadjacent elements. However, with advanced modifications (like stable-partition), it can be made stable, but at an added computational cost.</p>
      </article>

      <article id="comparisons-other-sorting-algorithms">
        <h3>10. Comparisons with Other Sorting Algorithms</h3>
        <p>Quick Sort often outperforms other O(n log n) sorting algorithms in practice due to its in-place property and cache efficiency. It is faster than Merge Sort for arrays. However, Merge Sort is preferred for linked lists as Quick Sort requires random access to elements. For smaller arrays, algorithms like Insertion Sort could be faster due to less overhead.</p>
      </article>

      <article id="practical-considerations">
        <h3>11. Practical Considerations</h3>
        <p>While Quick Sort provides excellent average-case performance, certain practices can optimize its efficiency further:</p>
        <ul>
          <li><strong>Hybrid Systems:</strong> Due to the overhead of recursive function calls, it might be efficient to switch to a simpler sorting algorithm like Insertion Sort for small sub-arrays.</li>
          <li><strong>Pivot Selection:</strong> Instead of choosing a random pivot, one could use the 'median of three' method: pick three random elements and use their median as the pivot.</li>
        </ul>
      </article>

      <article id="upcoming">
        <h3>Up Next: Sorting Algorithms' Masterclass</h3>
        <p>As we conclude our in-depth exploration of Quick Sort, let's pivot our curiosity towards other sorting algorithms. In our next article, we will dive into the sea of 'Heap Sort', another ingenious technique of sorting, promising to offer an exciting blend of practicality and theory. From its basic operations to its efficient application, we will unravel every layer, making this journey a delightful learning experience. Stay tuned!</p>
      </article>
    </main>

    <script>copyright("all");</script>
  </body>

</html>
