<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
  <!--<![endif]-->

  <head>
    <script src="/js/edu_su_common.js"></script>
    <noscript>
      <style>
        html,
        body {
          margin: 0;
          overflow: hidden;
        }
      </style>
      <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
    </noscript>

    <title>Operations on Linked Lists: CSU1051 - Data Structures & Algorithms</title>
    <meta name="description" content="Discover the various operations on linked lists, including insertion, deletion, and traversal. Enroll in CSU1051 course at Shoolini University to learn the implementation and analysis of linked list operations in Data Structures & Algorithms.">
    
    <meta property="og:image" content="/logo.png">
    <meta property="og:type" content="article">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@divyamohan1993">
    <meta name="twitter:creator" content="@divyamohan1993">
    <meta name="twitter:image" content="/logo.png">

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
          // customised options
          // • auto-render specific keys, e.g.:
          delimiters: [
            { left: '$$', right: '$$', display: true },
            { left: '$', right: '$', display: false },
            { left: '\\(', right: '\\)', display: false },
            { left: '\\[', right: '\\]', display: true }
          ],
          // • rendering keys, e.g.:
          throwOnError: false
        });
      });
    </script>
  </head>

  <body>

    <script>header_author("dm");</script>

    <main>
      <article>
        <h2 class="text-center">Operations on linked lists - Insertion, Deletion and Traversal</h2>
        <div class="container mt-4 w-100 w-xl-75">
          <div class="accordion" id="toc">
            <div class="accordion-item">
              <h2 class="accordion-header" id="h1">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#c1" aria-controls="c1" aria-expanded="false">
                  <i class="fas fa-book"></i> <strong>&nbsp;Table of Contents</strong>
                </button>
              </h2>
              <div id="c1" class="accordion-collapse collapse" aria-labelledby="h1" data-bs-parent="#toc">
                <div class="accordion-body">
                  <ol class="list-unstyled p-0 m-0">
                    <li class="p-1"><a href="#executive-summary"><i class="fas fa-chevron-circle-right"></i> Executive Summary</a></li>
                    <li class="p-1"><a href="#introduction"><i class="fas fa-chevron-circle-right"></i> Introduction</a></li>
                    <li class="p-1"><a href="#linked-list-types"><i class="fas fa-chevron-circle-right"></i> Linked List Types</a></li>
                    <li class="p-1"><a href="#linked-list-operations"><i class="fas fa-chevron-circle-right"></i> Operations on Linked List</a></li>
                    <li class="p-1"><a href="#conclusion"><i class="fas fa-chevron-circle-right"></i> Conclusion</a></li>
                  </ol>
                </div>
              </div>
            </div>
          </div>
        </div>
      </article>


      <article id="executive-summary">
        <h3>Executive Summary: Navigating Linked Lists</h3>
        <p>As you embark on this in-depth exploration of operations on linked lists, anticipate traversing intricate paths and discovering new ways to handle nodes. Your journey will start at the base camp of understanding linked lists - their structure and practical applications. As the expedition progresses, you will delve into fundamental operations including insertion, deletion, and traversal. This endeavor goes beyond the norm by discussing the intricacies and peculiarities of these operations and exploring corner cases, performance implications, and theoretical complexity. We present concrete, real-world problems with comprehensive solutions using C++ code to illuminate these abstract concepts. Along the way, we'll reveal concepts that you may find thought-provoking. Finally, we tie all these threads together in an engaging, inspiring conclusion that prompts further exploration.</p>
      </article>

      <article id="introduction">
        <h3>1. Introduction: Linked Lists - The Cornerstone of Dynamic Data Structures</h3>
        <p>Imagine you're building a dynamic data structure, needing to accommodate an unpredictable number of elements with frequent additions and deletions. One efficient way to solve this problem is by utilizing a linked list. A linked list is a linear data structure comprising nodes, where each node contains a data element and a reference (or link) to the next node in the sequence. This structure allows for efficient insertions and deletions at any position in the sequence.</p>
        <p>In comparison to arrays, linked lists offer the advantage of efficient insertions and deletions without the need for shifting elements, making them ideal for certain scenarios. However, they lack direct access to individual elements and can consume more memory due to the storage required for links.</p>
      </article>

      <article id="linked-list-types">
        <h3>2. Types of Linked Lists</h3>
        <p>Linked lists can take different forms based on how nodes are linked together:</p>
        <ul>
          <li><b>Singly Linked List:</b> Each node holds data and a link to the next node, forming a linear sequence of nodes.</li>
          <li><b>Doubly Linked List:</b> Nodes hold data and two links, pointing to the previous and next nodes, allowing traversal in both directions.</li>
          <li><b>Circular Linked List:</b> The last node in the list points back to the first node, creating a circular loop.</li>
        </ul>
        <p>Our focus will be primarily on singly linked lists for simplicity, although the principles discussed apply to all types with minor adjustments.</p>
      </article>

      <article id="linked-list-operations">
        <h3>3. Operations on Linked Lists</h3>
        <p>Three fundamental operations on linked lists we will examine in detail are: Insertion, Deletion, and Traversal.</p>
      </article>

      <article id="insertion-operation">
        <h4>3.1 Insertion Operation</h4>
        <p>The insertion operation adds a new node to the list. Depending on the position where the node is inserted, it can be categorized into three types:</p>
        <ul>
          <li><b>Insertion at the beginning:</b> A new node is added before the current head node, becoming the new head.</li>
          <li><b>Insertion at the end:</b> A new node is added after the last node, becoming the new tail.</li>
          <li><b>Insertion at a given position:</b> A new node is inserted at a specific position, shifting the subsequent nodes.</li>
        </ul>
      </article>

      <article id="insertion-beginning">
        <h5>3.1.1 Insertion at the Beginning</h5>
        <p>

          Inserting a new node at the beginning involves creating a new node, setting its link to point to the current head, and updating the head to the new node. This operation is generally constant time O(1), irrespective of the list's size.</p>
        <pre><code class="language-cpp">// CPP program to insert a new node at the beginning of a Singly Linked List
#include &lt;bits/stdc++.h&gt;
using namespace std;

class Node {
public:
   int data;
   Node* next;
};

void push(Node** head_ref, int new_data) {
    Node* new_node = new Node();
    new_node->data = new_data;
    new_node->next = (*head_ref);
    (*head_ref) = new_node;
}
</code></pre>
      </article>

      <article id="insertion-end">
        <h5>3.1.2 Insertion at the End</h5>
        <p>For inserting at the end, the new node should be linked to the last node in the list. This operation involves traversing the entire list, resulting in a time complexity of O(n), where n is the number of elements in the list.</p>
        <pre><code class="language-cpp">// CPP program to insert a new node at the end of a Singly Linked List
#include &lt;bits/stdc++.h&gt;
using namespace std;

class Node {
public:
   int data;
   Node* next;
};

void append(Node** head_ref, int new_data) {
    Node* new_node = new Node();
    new_node->data = new_data;
    new_node->next = NULL;
    if (*head_ref == NULL) {
       *head_ref = new_node;
       return;
    }
    Node* last = *head_ref;
    while (last->next) {
       last = last->next;
    }
    last->next = new_node;
}
</code></pre>
      </article>

      <article id="insertion-position">
        <h5>3.1.3 Insertion at a Given Position</h5>
        <p>Inserting a node at a given position requires traversing the list to the desired position and adjusting the links accordingly. The new node points to the node previously at this position, and the preceding node now points to the new node. This operation has a time complexity of O(k) where k is the position where the new node will be inserted.</p>
        <pre><code class="language-cpp">// CPP program to insert a new node at a specific position in a Singly Linked List
#include &lt;bits/stdc++.h&gt;
using namespace std;

class Node {
public:
   int data;
   Node* next;
};

void insertAfter(Node* prev_node, int new_data) {
    if (prev_node == NULL) {
       cout &lt;&lt; "The given previous node cannot be NULL";
       return;
    }
    Node* new_node = new Node();
    new_node->data = new_data;
    new_node->next = prev_node->next;
    prev_node->next = new_node;
}
</code></pre>
      </article>

      <article id="deletion-operation">
        <h4>3.2 Deletion Operation</h4>
        <p>The deletion operation removes a node from the linked list. It requires the position or key of the node to be deleted. This operation includes two tasks: locating the node to be deleted and changing the 'next' link of the preceding node. If the head node is deleted, it should be updated to the second node in the list. The deletion operation has a time complexity of O(n) because it might need to traverse the entire list.</p>
        <pre><code class="language-cpp">// CPP program to delete

 a node from a Singly Linked List
#include &lt;bits/stdc++.h&gt;
using namespace std;

class Node {
public:
   int data;
   Node* next;
};

void deleteNode(Node **head_ref, int key) {
    Node* temp = *head_ref;
    Node* prev = NULL;

    if (temp != NULL && temp->data == key) {
       *head_ref = temp->next;
       delete temp;
       return;
    }

    while (temp != NULL && temp->data != key) {
       prev = temp;
       temp = temp->next;
    }

    if (temp == NULL)
       return;

    prev->next = temp->next;
    delete temp;
}
</code></pre>
      </article>

      <article id="traversal-operation">
        <h4>3.3 Traversal Operation</h4>
        <p>The traversal operation visits each node in the linked list. This operation is commonly used to perform actions on each node, such as printing data. The time complexity of this operation is O(n), as it visits each node exactly once.</p>
        <pre><code class="language-cpp">// CPP program to traverse a Singly Linked List
#include &lt;bits/stdc++.h&gt;
using namespace std;

class Node {
public:
   int data;
   Node* next;
};

void printList(Node *node) {
    while (node != NULL) {
       cout << node->data << " ";
       node = node->next;
    }
}
</code></pre>
      </article>

      <article id="conclusion">
        <h3>4. Conquering Linked Lists</h3>
        <p>The power of linked lists lies in their versatility and flexibility, allowing for dynamic memory allocation, efficient insertions and deletions, and ease of implementation. They form the basis for many complex data structures and applications. Whether you're a beginner grasping the ropes or a research scholar seeking deeper insights, we believe this comprehensive exploration of linked lists and their operations has added/revised the valuable layers to your understanding.</p>
        <p>As we wrap up this deep dive, we invite you to look forward to our next expedition. In the upcoming article, we will venture into the intriguing world of 'Trees,' exploring their various types, traversals, and operations. Our journey will delve into fascinating concepts such as binary trees, AVL trees, and B-Trees, unearthing the principles behind database indexing, filesystems, and more. The tree is a fundamental data structure, and its roots reach deep into the core of computer science. So, gear up for another enriching exploration!</p>
      </article>

      </article>
    </main>

    <script>copyright("all");</script>
  </body>

</html>
