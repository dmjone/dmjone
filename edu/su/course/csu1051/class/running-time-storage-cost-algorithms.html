<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
  <!--<![endif]-->

  <head>
    <script src="/js/edu_su_common.js"></script>
    <noscript>
      <style>
        html,
        body {
          margin: 0;
          overflow: hidden;
        }
      </style>
      <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
    </noscript>

    <title>Running Time and Storage Cost of Algorithms - Learn with Examples</title>
    <meta name="description" content="Explore the concepts of running time and storage cost of algorithms in computer science. Learn to analyze time and space complexity with examples of various algorithms.">
    <meta name="keywords" content="running time, storage cost, algorithms, time complexity, space complexity, big O notation, linear search, binary search, factorial calculation, merge sort">

    <meta property="og:title" content="Running Time and Storage Cost of Algorithms - Learn with Examples">
    <meta property="og:description" content="Explore the concepts of running time and storage cost of algorithms in computer science. Learn to analyze time and space complexity with examples of various algorithms.">
    <meta property="og:image" content="/logo.png">
    <meta property="og:type" content="article">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Running Time and Storage Cost of Algorithms - Learn with Examples">
    <meta name="twitter:description" content="Explore the concepts of running time and storage cost of algorithms in computer science. Learn to analyze time and space complexity with examples of various algorithms.">
    <meta name="twitter:image" content="/logo.png">
    <meta name="twitter:site" content="@divyamohan1993">
    <meta name="twitter:creator" content="@divyamohan1993">

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
          // customised options
          // • auto-render specific keys, e.g.:
          delimiters: [
            { left: '$$', right: '$$', display: true },
            { left: '$', right: '$', display: false },
            { left: '\\(', right: '\\)', display: false },
            { left: '\\[', right: '\\]', display: true }
          ],
          // • rendering keys, e.g.:
          throwOnError: false
        });
      });
    </script>
  </head>

  <body>

    <script>header_author("dm");</script>

    <main>
      <article>
        <h2 class="text-center">
          Running Time and Storage Cost of Algorithms
        </h2>
      </article>
      <article>
        <h3>1. Introduction</h3>
        <p>Understanding the efficiency of algorithms is essential in the world of computer science. Running time and storage cost are two crucial factors that contribute to an algorithm's performance. In this comprehensive guide, we will explore the concepts of time complexity, space complexity, and Big O notation, and learn how to analyze the running time and storage cost of various algorithms. From basic to advanced levels, we will walk you through examples that illustrate the process of determining the complexity of different algorithms, such as linear search, binary search, factorial calculation, and merge sort. By the end of this article, you will have a strong foundation in evaluating the efficiency of algorithms and choosing the most appropriate one for your specific computational tasks.</p>
      </article>

      <article>
        <h3>2. Time Complexity</h3>
        <p>Time complexity refers to the amount of time an algorithm takes to execute as a function of the input size. It is a crucial metric for evaluating the efficiency of an algorithm, as it allows us to compare the performance of different algorithms and select the most appropriate one for a particular task. Time complexity is typically expressed using Big O notation, which describes the upper bound of the growth rate of an algorithm.</p>
      </article>
      <article>
        <h4>2.1 Big O Notation</h4>
        <p>Big O notation is a mathematical notation used to express the upper bound on the growth rate of an algorithm's time complexity. It provides an asymptotic bound, which means that it describes the limiting behavior of the function as the input size approaches infinity. In Big O notation, we use the letter O followed by a function that represents the growth rate of the algorithm's time complexity. Some common examples of Big O notation include:</p>
        <ul>
          <li>$O(1)$ - constant time complexity</li>
          <li>$O(\log{n})$ - logarithmic time complexity</li>
          <li>$O(n)$ - linear time complexity</li>
          <li>$O(n\log{n})$ - linearithmic time complexity</li>
          <li>$O(n^2)$ - quadratic time complexity</li>
          <li>$O(n^3)$ - cubic time complexity</li>
          <li>$O(2^n)$ - exponential time complexity</li>
        </ul>
        <p>When analyzing the time complexity of an algorithm, we generally focus on the worst-case scenario, which represents the longest possible execution time for the given input size. This ensures that we have a conservative estimate of the algorithm's performance.</p>
      </article>
      <article>
        <h4>2.2 Time Complexity Examples</h4>
        <p>In this section, we will examine the time complexity of two example algorithms and analyze their complexity step by step.</p>
        <article>
          <h5>2.2.1 Example 1: Linear Search</h5>
          <p>Linear search is a simple algorithm that searches for a target value within an array by iterating through the array's elements one by one. The time complexity of linear search can be analyzed as follows:</p>
          <p><strong>Python</strong></p>
          <pre><code class="language-python">def linear_search(arr, target):
for i in range(len(arr)):
    if arr[i] == target:
        return i
return -1</code></pre>
          <p><strong>C++ Equivalent</strong></p>
          <pre><code class="language-cpp">int linear_search(int arr[], int target, int n) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == target) {
            return i;
        }
    }
    return -1;
}</code></pre>
          <p>The algorithm's time complexity depends on the number of iterations in the for loop, which is determined by the length of the input array. In the worst-case scenario, the target value is not present in the array, and the algorithm must iterate through all of the array's elements. Therefore, the worst-case time complexity of linear search is $O(n)$, where n is the number of elements in the input array.</p>
        </article>
        <article>
          <h5>2.2.2 Example 2: Binary Search</h5>
          <p>Binary search is a more efficient search algorithm that operates on a sorted array. It repeatedly divides the search interval in half and compares the middle element of the interval to the target value. If the middle element is equal to the target, the search is successful; otherwise, the algorithm continues searching in the left or right subinterval, depending on whether the middle element is greater or smaller than the target value. The time complexity of binary search can be analyzed as follows:</p>
          <p><strong>Python</strong></p>
          <pre><code class="language-python">def binary_search(arr, target):
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = (left + right) // 2

        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return -1
</code></pre>
          <p><strong>C++ Equivalent</strong></p>
          <pre><code class="language-cpp">int binary_search(int arr[], int target, int n) {
    int left = 0, right = n - 1;
    while (left <= right) {
        int mid = (left + right) / 2;
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1;
}</code></pre>
          <p>The algorithm's time complexity depends on the number of iterations in the while loop. In each iteration, the search interval is divided in half, reducing the remaining search space by a factor of 2. The worst-case scenario occurs when the target value is not present in the array, requiring the algorithm to narrow the search interval until it becomes empty. In this case, the number of iterations required is $\log_2{n}$, where n is the number of elements in the input array. Therefore, the worst-case time complexity of binary search is $O(\log{n})$.</p>
        </article>
      </article>
      <article>
        <h3>3. Space Complexity</h3>
        <p>Space complexity refers to the amount of memory an algorithm requires to execute as a function of the input size. It is another important metric for evaluating the efficiency of an algorithm, as it helps us determine the memory requirements and select the most suitable algorithm for a given task. Like time complexity, space complexity is typically expressed using Big O notation.</p>
      </article>
      <article>
        <h4>3.1 Space Complexity Examples</h4>
        <p>In this section, we will examine the space complexity of two example algorithms and analyze their complexity step by step.</p>
        <article>
          <h5>3.1.1 Example 1: Factorial Calculation</h5>
          <p>Factorial calculation is a classic problem that can be solved using both iterative and recursive approaches. We will analyze the space complexity of both approaches for calculating the factorial of a non-negative integer n.</p>
          <p><strong>Python</strong></p>
          <pre><code class="language-python">def factorial_iterative(n):
    result = 1
    for i in range(1, n + 1):
    result *= i

return result</code></pre>
          <p><strong>C++ Equivalent</strong></p>
          <pre><code class="language-cpp">int factorial_iterative(int n) {
    int result = 1;
    for (int i = 1; i <= n; i++) {
        result *= i;
    }
    return result;
}</code></pre>
          <p>The iterative approach uses a single variable to store the intermediate results, and its memory requirements do not depend on the input size. Therefore, the space complexity of the iterative approach is $O(1)$, or constant space complexity.</p>
          <p><strong>Python</strong></p>
          <pre><code class="language-python">def factorial_recursive(n):
    if n == 0:
        return 1
    else:
        return n * factorial_recursive(n - 1)
</code></pre>
          <p><strong>C++ Equivalent</strong></p>
          <pre><code class="language-cpp">int factorial_recursive(int n) {
    if (n == 0) {
        return 1;
    } else {
        return n * factorial_recursive(n - 1);
    }
}</code></pre>
          <p>The recursive approach uses the call stack to store the intermediate results, and the depth of the call stack is determined by the input size. In this case, the space complexity is equal to the maximum depth of the call stack, which is n. Therefore, the space complexity of the recursive approach is $O(n)$, or linear space complexity.</p>
        </article>
        <article>
          <h5>3.1.2 Example 2: Merge Sort</h5>
          <p>Merge sort is a divide-and-conquer sorting algorithm that recursively divides the input array into two halves, sorts the halves individually, and then merges the sorted halves to produce the final sorted array. The space complexity of merge sort can be analyzed as follows:</p>
          <p><strong>Python</strong></p>
          <pre><code class="language-python">def merge_sort(arr):
      if len(arr) <= 1:
          return arr
  
      mid = len(arr) // 2
      left = merge_sort(arr[:mid])
      right = merge_sort(arr[mid:])
  
      return merge(left, right)
  
  def merge(left, right):
      result = []
      i = j = 0
  
      while i < len(left) and j < len(right):
          if left[i] < right[j]:
              result.append(left[i])
              i += 1
          else:
              result.append(right[j])
              j += 1
  
      result.extend(left[i:])
      result.extend(right[j:])
  
      return result
  </code></pre>
          <p><strong>C++ Equivalent</strong></p>
          <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

vector&lt;int&gt; merge(vector&lt;int&gt; left, vector&lt;int&gt; right) {
    vector&lt;int&gt; result;
    int i = 0, j = 0;

    while (i &lt; left.size() && j &lt; right.size()) {
        if (left[i] &lt; right[j]) {
            result.push_back(left[i]);
            i++;
        }
        else {
            result.push_back(right[j]);
            j++;
        }
    }

    while (i &lt; left.size()) {
        result.push_back(left[i]);
        i++;
    }

    while (j &lt; right.size()) {
        result.push_back(right[j]);
        j++;
    }

    return result;
}

vector&lt;int&gt; merge_sort(vector&lt;int&gt; arr) {
    if (arr.size() &lt;= 1) {
        return arr;
    }

    int mid = arr.size() / 2;

    vector&lt;int&gt; left(arr.begin(), arr.begin() + mid);
    vector&lt;int&gt; right(arr.begin() + mid, arr.end());

    left = merge_sort(left);
    right = merge_sort(right);

    return merge(left, right);
}

int main() {
    vector&lt;int&gt; arr = { 38, 27, 43, 3, 9, 82, 10 };
    vector&lt;int&gt; sorted_arr = merge_sort(arr);

    for (int i = 0; i &lt; sorted_arr.size(); i++) {
        cout &lt;&lt; sorted_arr[i] &lt;&lt; " ";
    }
    cout &lt;&lt; endl;

    return 0;
}</code></pre>
          <p>The space complexity of merge sort depends on the memory required to store the intermediate results during the merge step. In the worst case, the algorithm needs to allocate an additional array with the same size as the input array to store the merged results. In this case, the space complexity is proportional to the input size, n. Therefore, the worst-case space complexity of merge sort is $O(n)$, or linear space complexity.</p>
        </article>
      </article>
      <article>
        <h3>4. Advanced Algorithm Analysis</h3>
        <p>In this section, we will discuss advanced topics related to algorithm analysis, such as amortized analysis and dynamic programming. These topics are particularly relevant to computer science students and researchers working on more complex algorithmic problems.</p>
      </article>
      <article>
        <h4>4.1 Amortized Analysis</h4>
        <p>Amortized analysis is a technique used to determine the average performance of an algorithm over a sequence of operations. It is particularly useful for analyzing algorithms that exhibit variable performance characteristics depending on the input or operation sequence. Amortized analysis allows us to provide a more accurate estimate of the algorithm's overall performance in such cases.</p>
        <article>
          <h5>4.1.1 Example 1: Dynamic Array</h5>
          <p>Consider a dynamic array, which is a data structure that allows elements to be added or removed and automatically resizes itself as needed. The resizing operation can be expensive, as it may involve allocating a new block of memory and copying elements from the old array to the new one. However, the resizing operation occurs infrequently, and most other operations, such as adding or removing elements, have constant time complexity. We can use amortized analysis to determine the average cost of performing a sequence of operations on a dynamic array.</p>
          <p>Suppose that we start with an empty dynamic array and perform n insertions. Each time the array is full, we double its size. This resizing operation occurs when the array has 1, 2, 4, 8, ..., $2^k$ elements, where $2^k \le n$. The total cost of these resizing operations is:</p>
          <p>$$1 + 2 + 4 + \cdots + 2^k = 2^{k+1} - 1 \le 2n - 1$$</p>
          <p>Therefore, the amortized cost of performing n insertions is:</p>
          <p>$$\frac{2n - 1}{n} = 2 - \frac{1}{n}$$</p>
          <p>Since the amortized cost is constant for a large number of insertions, the overall performance of the dynamic array is efficient, despite the occasional expensive resizing operations.</p>
        </article>
      </article>
      <article>
        <h4>4.2 Dynamic Programming</h4>
        <p>Dynamic programming is a powerful technique used to solve optimization problems by breaking them down into smaller, overlapping subproblems and solving each subproblem only once, storing the results in a table for future reference. This approach can significantly reduce the time complexity of an algorithm by trading off space complexity, as it eliminates redundant computation of subproblems. Dynamic programming is applicable to problems that exhibit the properties of optimal substructure and overlapping subproblems.</p>

        <article>
          <h5>4.2.1 Example 1: Fibonacci Numbers</h5>
          <p>The Fibonacci sequence is a classic example of a problem that can be solved using dynamic programming. The naive recursive implementation of the Fibonacci sequence has exponential time complexity due to the repeated computation of overlapping subproblems. By using dynamic programming, we can significantly improve the time complexity of the algorithm.</p>
          <p><strong>Python</strong></p>
          <pre><code class="language-python">def fibonacci_dp(n):
    if n <= 1:
        return n
    fib = [0] * (n + 1)
fib[1] = 1

for i in range(2, n + 1):
    fib[i] = fib[i - 1] + fib[i - 2]

return fib[n]
</code></pre>
          <p><strong>C++ Equivalent</strong></p>
          <pre><code class="language-cpp">int fibonacci_dp(int n) {
    if (n <= 1) {
        return n;
    }
    int fib[n + 1];
    memset(fib, 0, sizeof(fib));
    fib[1] = 1;
    for (int i = 2; i <= n; i++) {
        fib[i] = fib[i - 1] + fib[i - 2];
    }
    return fib[n];
}</code></pre>
          <p>The dynamic programming implementation of the Fibonacci sequence has a time complexity of $O(n)$ and a space complexity of $O(n)$. By eliminating redundant computation, we have significantly reduced the time complexity at the cost of additional memory.</p>
        </article>
        <article>
          <h5>4.2.2 Example 2: Longest Common Subsequence</h5>
          <p>The longest common subsequence (LCS) problem is another example that can be solved using dynamic programming. Given two sequences, the LCS problem asks to find the length of the longest subsequence that is common to both sequences. The naive approach to solving the LCS problem involves generating all subsequences of both sequences and comparing them, which has exponential time complexity. By using dynamic programming, we can significantly improve the time complexity of the algorithm.</p>
          <p><strong>Python</strong></p>
          <pre><code class="language-python">def longest_common_subsequence(X, Y):
    m, n = len(X), len(Y)
    L = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(m + 1):
    for j in range(n + 1):
        if i == 0 or j == 0:
            L[i][j] = 0
        elif X[i - 1] == Y[j - 1]:
            L[i][j] = L[i - 1][j - 1] + 1
        else:
            L[i][j] = max(L[i - 1][j], L[i][j - 1])

return L[m][n]</code></pre>
          <p><strong>C++ Equivalent</strong></p>
          <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;

int longest_common_subsequence(string X, string Y) {
    int m = X.length(), n = Y.length();
    int L[m + 1][n + 1];
    memset(L, 0, sizeof(L));

    for (int i = 0; i <= m; i++) {
        for (int j = 0; j <= n; j++) {
            if (i == 0 || j == 0) {
                L[i][j] = 0;
            } else if (X[i - 1] == Y[j - 1]) {
                L[i][j] = L[i - 1][j - 1] + 1;
            } else {
                L[i][j] = max(L[i - 1][j], L[i][j - 1]);
            }
        }
    }

    return L[m][n];
}

int main() {
    string X = "ABCDGH";
    string Y = "AEDFHR";
    cout << longest_common_subsequence(X, Y) << endl;
    return 0;
}</code></pre>

          <p>The dynamic programming implementation of the longest common subsequence problem has a time complexity of $O(mn)$ and a space complexity of $O(mn)$, where m and n are the lengths of the input sequences. By exploiting the problem's optimal substructure and overlapping subproblems, we have significantly reduced the time complexity at the cost of additional memory.</p>
        </article>
      </article>
      <article>
        <h3>5. Conclusion</h3>
        <p>In this article, we have discussed the importance of analyzing the running time and storage cost of algorithms in data structures and algorithms. We covered the basics of time complexity and space complexity analysis using Big O notation, and provided examples to illustrate the process of analyzing the complexity of various algorithms. We also discussed advanced topics such as amortized analysis and dynamic programming, which are relevant to computer science students and researchers working on complex algorithmic problems.</p>
        <p>Understanding the running time and storage cost of algorithms is crucial for selecting the most appropriate algorithm for a given task and ensuring the efficient execution of computational tasks. By analyzing the performance of algorithms and optimizing them, we can develop more efficient software and solve complex problems more effectively.</p>

        <p>It is important to remember that the choice of an algorithm depends not only on its theoretical performance characteristics but also on the specific requirements of the problem at hand, the available hardware and software resources, and the trade-offs between time and space complexity. By carefully considering these factors and applying the techniques discussed in this article, one can make informed decisions when designing and implementing algorithms for various applications.</p>
        <p>As a researcher or a student working in the field of data structures and algorithms, it is essential to stay up-to-date with the latest developments in algorithm analysis techniques and emerging algorithms. This knowledge will enable you to tackle new and challenging problems, contribute to the advancement of the field, and develop more efficient solutions for real-world problems.</p>
        <p>In summary, the analysis of running time and storage cost of algorithms is a fundamental aspect of computer science and plays a crucial role in the design and implementation of efficient software systems. By understanding and applying the concepts and techniques presented in this article, you will be better equipped to develop high-performance algorithms and software solutions that meet the demands of today's increasingly complex and data-driven world.</p>
      </article>
    </main>

    <script>copyright("all");</script>
  </body>

</html>