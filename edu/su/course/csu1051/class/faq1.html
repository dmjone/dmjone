<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
  <!--<![endif]-->

  <head>
    <script src="/js/edu_su_common.js"></script>
    <noscript>
      <style>
        html,
        body {
          margin: 0;
          overflow: hidden;
        }
      </style>
      <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
    </noscript>

    <title>Frequently Asked Questions (FAQs) - CSU1051: Data Structures & Algorithms | dmj.one</title>
    <meta name="description" content="Find answers to commonly asked questions about the CSU1051 course on Data Structures & Algorithms. Get insights and clarification on key concepts, assignments, and more. Join us at dmj.one for a comprehensive understanding.">
    
    <meta property="og:image" content="/logo.png">
    <meta property="og:type" content="article">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@divyamohan1993">
    <meta name="twitter:creator" content="@divyamohan1993">
    <meta name="twitter:image" content="/logo.png">

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
          // customised options
          // • auto-render specific keys, e.g.:
          delimiters: [
            { left: '$$', right: '$$', display: true },
            { left: '$', right: '$', display: false },
            { left: '\\(', right: '\\)', display: false },
            { left: '\\[', right: '\\]', display: true }
          ],
          // • rendering keys, e.g.:
          throwOnError: false
        });
      });
    </script>
  </head>

  <body>

    <script>header_author("dm");</script>

    <main>
      <article>
        <h2 class="text-center">
          Frequently Asked Questions - Part 1
        </h2>
      </article>

      <article>
        <h4>1. Differentiate between Union and Structure</h4>
        <div class="table-responsive">
          <table class="table table-striped table-bordered table-hover">
            <thead class="thead-dark">
              <tr>
                <th>Union</th>
                <th>Structure</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>A union is a user-defined data type that allows multiple data types to be stored in the same memory location.</td>
                <td>A structure is a user-defined data type that allows a collection of variables to be grouped together under a single name.</td>
              </tr>
              <tr>
                <td>In a union, only one member can be accessed at a time. Accessing one member overwrites the other members.</td>
                <td>In a structure, all members can be accessed individually.</td>
              </tr>
              <tr>
                <td>The size of a union is determined by the largest member in the union.</td>
                <td>The size of a structure is determined by the sum of the sizes of all its members.</td>
              </tr>
              <tr>
                <td>Unions are typically used when the memory needs to be conserved or when we want to interpret a piece of memory in different ways.</td>
                <td>Structures are typically used when we want to group together related data items.</td>
              </tr>
              <tr>
                <td>Unions are less commonly used compared to structures.</td>
                <td>Structures are more commonly used compared to unions.</td>
              </tr>
            </tbody>
          </table>
        </div>
      </article>

      <article>
        <h4>2. Differentiate between Primitive and Non-Primitive Data Structure</h4>
        <div class="table-responsive">
          <table class="table table-striped table-bordered table-hover">
            <thead class="thead-dark">
              <tr>
                <th>Primitive Data Structure</th>
                <th>Non-Primitive Data Structure</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Primitive data structures are basic data types that can be directly operated upon by the machine.</td>
                <td>Non-primitive data structures are derived data types that are created by combining or aggregating primitive data types.</td>
              </tr>
              <tr>
                <td>Primitive data structures have a fixed size in memory.</td>
                <td>Non-primitive data structures can have a variable size in memory.</td>
              </tr>
              <tr>
                <td>Primitive data structures are usually not dynamic, meaning that their size cannot be changed during runtime.</td>
                <td>Non-primitive data structures are often dynamic, meaning that their size can be changed during runtime.</td>
              </tr>
              <tr>
                <td>Primitive data structures are passed by value, which means that the actual data value is copied to a new location in memory.</td>
                <td>Non-primitive data structures are passed by reference, which means that only the memory address of the data is passed to a new location.</td>
              </tr>
              <tr>
                <td>Examples of primitive data structures include integers, floating-point numbers, characters, and boolean values.</td>
                <td>Examples of non-primitive data structures include arrays, lists, trees, graphs, and objects.</td>
              </tr>
            </tbody>
          </table>
        </div>
      </article>

      <article>
        <h4>3. Differentiate between Linear and Non Linear Data Structure</h4>
        <div class="table-responsive">
          <table class="table table-striped table-bordered table-hover">
            <thead>
              <tr>
                <th>#</th>
                <th>Linear Data Structure</th>
                <th>Non-Linear Data Structure</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>1</td>
                <td>A linear data structure is a data structure where data elements are arranged sequentially or linearly, and each element has a predecessor and a successor except the first and last elements.</td>
                <td>A non-linear data structure is a data structure where data elements are not arranged sequentially or linearly, and each element may have zero, one or many predecessors and successors.</td>
              </tr>
              <tr>
                <td>2</td>
                <td>Linear data structures are easy to traverse and search, and are suitable for many applications such as arrays, stacks, queues, and linked lists.</td>
                <td>Non-linear data structures are more complex to traverse and search, and are suitable for applications such as trees, graphs, and hash tables.</td>
              </tr>
              <tr>
                <td>3</td>
                <td>Examples of linear data structures include arrays, stacks, queues, and linked lists.</td>
                <td>Examples of non-linear data structures include trees, graphs, and hash tables.</td>
              </tr>
              <tr>
                <td>4</td>
                <td>Linear data structures can be easily represented using arrays or linked lists.</td>
                <td>Non-linear data structures require more complex representations such as trees, graphs, or hash tables.</td>
              </tr>
              <tr>
                <td>5</td>
                <td>Linear data structures have a linear space complexity, which means that the amount of memory used is directly proportional to the number of data elements.</td>
                <td>Non-linear data structures can have a non-linear space complexity, which means that the amount of memory used may not be directly proportional to the number of data elements.</td>
              </tr>
            </tbody>
          </table>
        </div>
      </article>

      <article>
        <h4>4. Differentiate between <code>getchar();</code> and <code>putchar()</code></h4>
        <div class="table-responsive">
          <table class="table table-striped table-bordered table-hover">
            <thead class="thead-dark">
              <tr>
                <th></th>
                <th>getchar()</th>
                <th>putchar()</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Definition</td>
                <td>Reads a single character from the standard input stream.</td>
                <td>Writes a single character to the standard output stream.</td>
              </tr>
              <tr>
                <td>Input</td>
                <td>Reads input from the keyboard or a file.</td>
                <td>Writes output to the screen or a file.</td>
              </tr>
              <tr>
                <td>Output</td>
                <td>Does not output anything.</td>
                <td>Outputs a single character to the screen or a file.</td>
              </tr>
              <tr>
                <td>Return value</td>
                <td>Returns the ASCII value of the character read from input.</td>
                <td>Does not return anything.</td>
              </tr>
              <tr>
                <td>Syntax</td>
                <td><code>int getchar(void)</code></td>
                <td><code>int putchar(int character)</code></td>
              </tr>
              <tr>
                <td>Parameters</td>
                <td>Does not take any parameters.</td>
                <td>Takes a single parameter, which is the character to be written to output.</td>
              </tr>
              <tr>
                <td>Looping</td>
                <td>Often used in a loop to read multiple characters from input.</td>
                <td>Often used in a loop to write multiple characters to output.</td>
              </tr>
              <tr>
                <td>Buffering</td>
                <td>Uses buffering; characters are read into a buffer before being processed.</td>
                <td>Uses buffering; characters are written to a buffer before being displayed on the screen or written to a file.</td>
              </tr>
              <tr>
                <td>Error handling</td>
                <td>Returns EOF (End of File) when it encounters an error or reaches the end of a file.</td>
                <td>Does not have any error handling mechanism.</td>
              </tr>
              <tr>
                <td>Examples</td>
                <td>Read input from the keyboard: <code>char c = getchar();</code></td>
                <td>Output a single character to the screen: <code>putchar('A');</code></td>
              </tr>
            </tbody>
          </table>
        </div>
      </article>

      <article>
        <h4>5. How to analyze time complexity of any program. Read about Recursive methods, back-successive methods and master theorem.</h4>
        <p>Time complexity is an abstract way to represent the running time of an algorithm in terms of the rate of growth and Big-O notations only. It is an approximate estimation of how much time an algorithm will take for a large value of input size. To analyze the time complexity of a program, we need to follow the following steps:
        <ol>
          <li>Identify the basic operations: Determine the operations that contribute most to the program's running time, such as comparisons, assignments, and arithmetic operations.</li>
          <li>Determine the input size: Identify the input size (n) that affects the program's running time. It could be the number of elements in an array, the length of a string, or the size of a matrix.</li>
          <li>Count the frequency of basic operations: Analyze the algorithm and count how many times each basic operation is performed in terms of the input size (n).</li>
          <li>Express the total count as a function of the input size (T(n)): Combine the counts of each basic operation and express them as a function of the input size (n).</li>
          <li>Find the highest order term: Identify the highest order term in T(n), as this term will dominate the growth of the function for large values of n.</li>
          <li>Remove the constant factors: Simplify the highest order term by removing any constant factors, as they become less significant as n grows.</li>
          <li>Express the time complexity using Big O notation: Represent the simplified highest order term using Big O notation (e.g., O(n), O(n^2), O(log n), etc.) to provide an upper bound on the program's running time.</li>
        </ol>
        </p>
      </article>

      <article>
        <h4>6. Analyze the complexity of the following program:</h4>
        <pre><code>a() {
  int i, j, k, n;
  for (i = 1; i <= n; i++) {
    for (j = 1; j <= i^2; j++) {
      for (k = 1; k <= n/2; k++) {
        printf("Hello");
      }
    }
  }
}</code></pre>
        <p> The answer is O(n^4). Lets us check how. </p>
        <strong>
          <p>Method 1</p>
        </strong>
        <p>
          The input size affecting the program’s running time is n. The outer loop i runs n times. The middle loop j tuns i^2 times for each outer loop iteration. The inner loop k runs n/2 times for each iteration of the middle loop.
          By expressing the total count as a function of an input size (T(n)), we get T(n) = Σ [i^2 * (n/2)] for i = 1 to n.
          We the find the highest order term: T(n) = (n/2) * Σ [i^2] for i = 1 to n
          The sum of squares of the first n integers is given by the formula:
          Σ [i^2] = n * (n + 1) * (2n + 1) / 6 or it can be written as: T(n) = (n/2) * n * (n + 1) * (2n + 1) / 6
          Removing the constant figures we get: T(n) = n^2 * (n + 1) * (2n + 1) / 12. Thus, as n grows large, the terms n^2, n, and 2n+1 dominate the growth of the function. And so, we get the time complexity of the given program is O(n^4), as the highest order term is n^2 * n * 2n, which is n^4.
        </p>
        <strong>
          <p>Did not understand? Here's the easier Way:</p>
        </strong>
        <p>Let's analyze the time complexity of the given code snippet:</p>
        <ol>
          <li>The outer loop runs n times.</li>
          <li>The middle loop runs i^2 times, where i is the current iteration of the outer loop. Since it is nested inside the outer loop, the number of iterations will be the sum of squares of all integers from 1 to n, which can be expressed as (n * (n + 1) * (2n + 1)) / 6.</li>
          <li>The innermost loop runs n/2 times, and it is nested inside both the outer and middle loops.</li>
        </ol>
        <p>To calculate the total time complexity, we multiply the number of iterations of each loop:</p>
        <ul>
          <li>Outer loop: n</li>
          <li>Middle loop: (n * (n + 1) * (2n + 1)) / 6</li>
          <li>Innermost loop: n/2</li>
        </ul>
        <p>Total time complexity: n * (n * (n + 1) * (2n + 1)) / 6 * n/2</p>
        <p>Now we simplify the expression and keep the highest order term:</p>
        <ul>
          <li>The highest degree term in the expression is n^4, as it is the term that dominates the growth of the function for large values of n.</li>
        </ul>
        <p>Therefore, the time complexity of the given code snippet is O(n^4).</p>
      </article>

      <article>
        <h4>7. How to find the address of an element present in an array</h4>
        <p>Array is a collection of homogeneous data. To find the address of an element present in an array, you can use the following formula:<br>
          Address of element = Base address + (Index of element * Size of data type)<br>
          Here, the base address is the memory location of the first element in the array, the index of the element is its position in the array (starting from 0), and the size of the data type is the memory required for a single element in the array (in bytes).</p>
      </article>

      <article>
        <h4>8. Design an algorithm to find the greatest / largest number within the elements of the array.</h4>
        <p>For finding the largest number within the elements of the array, we can use the following algorithm:</p>
        <ol>
          <li>Initialize a variable max and set its value to the first element of the array.</li>
          <li>Iterate through the array from the second element to the last element.</li>
          <li>For each element, compare it with the max value.
          <li>If the current element is greater than max, update the value of max to the current element.</li>
          </li>
          <li>After iterating through the array, the value of max will be the largest number in the array.</li>
        </ol>
        <p>We can implement the above steps in the following manner:</p>
        <pre><code class="language-cpp">
#include &lt;iostream&gt;
using namespace std;

int main() {
int n, max;

cout << "Enter the number of elements in the array: " ; cin>> n;
  int arr[n];

  cout << "Enter the array elements: " ; 
  for(int i=0; i < n; i++) { 
    cin>> arr[i];
  }

  max = arr[0];
  for(int i = 1; i < n; i++) { 
    if(arr[i]> max) {
      max = arr[i];
    }
  }

  cout << "Largest number in the array: " << max << endl;
  return 0;
}</code></pre>
      </article>

      <article>
        <h4>9. Using the continue statement WAP in C to read 15 integers from the user and print the sum of only the positive integer.</h4>
        <p>In C, we can write the program which follows the above requirements in the following manner:</p>
        <pre><code>#include &lt;stdio.h&gt;

int main() {
    int i, num, sum = 0;
    for (i = 0; i < 15; i++) {
        scanf("%d", &num);
        if (num < 0) {
            continue;
        }
        sum += num;
    }
    printf("Sum of positive integers: %d\n", sum);
    return 0;
}</code></pre>
        <p>And in C++ we can write the program which fulfills the above requirements in the following way:</p>
        <pre><code>
#include &lt;iostream&gt;
using namespace std;

int main() {
    int num, sum = 0;
    for (int i = 0; i < 15; i++) {
        cin >> num;
        if (num < 0) {
            continue;
        }
        sum += num;
    }
    cout << "Sum of positive integers: " << sum << endl;
    return 0;
}</code></pre>
      </article>

      <article>
        <h4>10. Differentiate between an AVL tree and explain the balance factor in an AVL tree.</h4>
        <div class="table-responsive">
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th scope="col">Property</th>
                <th scope="col">Binary Search Tree</th>
                <th scope="col">AVL Tree</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <th scope="row">Definition</th>
                <td>A node-based binary tree data structure.</td>
                <td>A self-balancing binary search tree.</td>
              </tr>
              <tr>
                <th scope="row">Child Nodes</th>
                <td>Each node has at most two child nodes.</td>
                <td>Same as BST but with additional balancing properties.</td>
              </tr>
              <tr>
                <th scope="row">Balancing</th>
                <td>No strict rules for balancing the tree height.</td>
                <td>Strictly balanced based on the balance factor.</td>
              </tr>
              <tr>
                <th scope="row">Time Complexity</th>
                <td>Can become unbalanced, leading to O(n) worst-case time.</td>
                <td>Guarantees O(log n) time complexity for operations.</td>
              </tr>
              <tr>
                <th scope="row">Subtree Constraints</th>
                <td>No additional constraint on the left and right subtree.</td>
                <td>Left & right subtree heights differ by at most 1.</td>
              </tr>
            </tbody>
          </table>
        </div>
        <p>
          The balance factor of a node in an AVL tree is the difference between the height of its left subtree and the height of its right subtree. Mathematically, it can be defined as:<br>
          Balance Factor = Height(Left Subtree) - Height(Right Subtree)<br>
          A node is considered balanced if its balance factor is -1, 0, or 1. If the balance factor of any node becomes less than -1 or greater than 1, the tree is considered unbalanced and needs to be rebalanced through rotations. These rotations can be single (left or right) or double (left-right or right-left) depending on the imbalance scenario.
        </p>
      </article>

    </main>

    <script>copyright("all");</script>
  </body>

</html>
