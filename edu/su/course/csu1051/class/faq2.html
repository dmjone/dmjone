<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
  <!--<![endif]-->

  <head>
    <script src="/js/edu_su_common.js"></script>
    <noscript>
      <style>
        html,
        body {
          margin: 0;
          overflow: hidden;
        }
      </style>
      <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
    </noscript>

    <title>CSU1051: Data Structures & Algorithms FAQ | Clearing Doubts with dmj.one</title>
    <meta name="description" content="Discover frequently asked questions and their answers about the CSU1051 course on Data Structures & Algorithms. Get expert guidance and clarification on important topics, assignments, and assessments. Join dmj.one to have your doubts cleared and excel in your studies.">

    <meta property="og:image" content="/logo.png">
    <meta property="og:type" content="article">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@divyamohan1993">
    <meta name="twitter:creator" content="@divyamohan1993">
    <meta name="twitter:image" content="/logo.png">

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
          // customised options
          // • auto-render specific keys, e.g.:
          delimiters: [
            { left: '$$', right: '$$', display: true },
            { left: '$', right: '$', display: false },
            { left: '\\(', right: '\\)', display: false },
            { left: '\\[', right: '\\]', display: true }
          ],
          // • rendering keys, e.g.:
          throwOnError: false
        });
      });
    </script>
  </head>

  <body>

    <script>header_author("dm");</script>

    <main>
      <article>
        <h2 class="text-center">
          Frequently Asked Questions - Part 2
        </h2>
      </article>

      <article>
        <h3>1. Stack</h3>
        <p>A stack is a linear data structure that follows the Last In First Out (LIFO) principle. It has two major operations: push (insert an element onto the top of the stack) and pop (remove an element from the top of the stack).</p>
        <p>Advantages:</p>
        <ul>
          <li>Simple data structure, easy to implement.</li>
          <li>Provides a systematic way of managing function calls (recursion).</li>
          <li>Efficient in memory utilization.</li>
        </ul>
        <p>Disadvantages:</p>
        <ul>
          <li>Limited in size, prone to overflow.</li>
          <li>Can lead to inefficiency due to the LIFO method if not managed properly.</li>
        </ul>
        <p>Time Complexity:</p>
        <ul>
          <li>Access - O(n)</li>
          <li>Search - O(n)</li>
          <li>Insertion - O(1)</li>
          <li>Deletion - O(1)</li>
        </ul>
        <pre><code class="language-cpp">
// Stack implementation in C++
#include <stack>
int main() {
std::stack<int> s;
s.push(10); // Insert 10 onto the stack
s.pop(); // Remove top element from the stack
return 0;
}
</code></pre>

      </article>
      <article>
        <h3>2. Queue</h3>
        <p>A queue is a linear data structure that follows the First In First Out (FIFO) principle. It has two major operations: enqueue (insert an element at the end of the queue) and dequeue (remove an element from the front of the queue).</p>
        <p>Advantages:</p>
        <ul>
          <li>Efficient when dealing with sequential processes (like a print queue).</li>
          <li>Easy to manage and maintain.</li>
        </ul>
        <p>Disadvantages:</p>
        <ul>
          <li>Fixed size, can lead to queue overflow.</li>
          <li>Inefficient in memory allocation and deallocation.</li>
        </ul>
        <p>Time Complexity:</p>
        <ul>
          <li>Access - O(n)</li>
          <li>Search - O(n)</li>
          <li>Insertion - O(1)</li>
          <li>Deletion - O(1)</li>
        </ul>
        <pre><code class="language-cpp">
// Queue implementation in C++
#include <queue>
int main() {
std::queue<int> q;
q.push(10); // Insert 10 into the queue
q.pop(); // Remove the element from the front of the queue
return 0;
}
</code></pre>

      </article>
      <article>
        <h3>3. Deque (Double Ended Queue)</h3>
        <p>A deque is a type of queue that allows insertion and removal of elements from both the front and back. In a standard deque, no priority is assigned to elements, thus they can be inserted and deleted from both ends.</p>
        <p>Advantages:</p>
        <ul>
          <li>Flexible, as elements can be added or removed from both ends.</li>
          <li>Better memory utilization compared to the stack and queue.</li>
        </ul>
        <p>Disadvantages:</p>
        <ul>
          <li>Complex implementation compared to the stack and queue.</li>
        </ul>
        <p>Time Complexity:</p>
        <ul>
          <li>Access - O(n)</li>
          <li>Search - O(n)</li>
          <li>Insertion - O(1)</li>
          <li>Deletion - O(1)</li>
        </ul>
        <pre><code class="language-cpp">
// Deque implementation in C++
#include <deque>
int main() {
std::deque<int> dq;
dq.push_back(10); // Insert 10 at the end
dq.push_front(20); // Insert 20 at the front
dq.pop_back(); // Remove the element from the end
dq.pop_front(); // Remove the element from the front
return 0;
}
</code></pre>

      </article>
      <article>
        <h3>4. Circular Queue</h3>
        <p>A circular queue is a variant of the linear queue which follows a circular shape. The last element points to the first making the queue behave like a circle. </p>
        <p>Advantages:</p>
        <ul>
          <li>Better memory utilization as any insertion into an empty space is feasible.</li>
          <li>Can be used for repetitive processes where the first process starts after the last process is finished.</li>
        </ul>
        <p>Disadvantages:</p>
        <ul>
          <li>More complex to implement than a linear queue.</li>
        </ul>
        <p>Time Complexity:</p>
        <ul>
          <li>Access - O(n)</li>
          <li>Search - O(n)</li>
          <li>Insertion - O(1)</li>
          <li>Deletion - O(1)</li>
        </ul>
        <pre><code class="language-cpp">
// Circular Queue implementation in C++
#include <queue>
class CircularQueue {
private:
int front, rear, size;
int* queue;

public:
CircularQueue(int size) {
front = rear = -1;
this->size = size;
queue = new int[size];
}
void enQueue(int value) {
    if ((front == 0 && rear == size-1) || (rear == (front-1)%(size-1))) {
        return;
    } else if (front == -1) {
        front = rear = 0;
        queue[rear] = value;
    } else if (rear == size-1 && front != 0) {
        rear = 0;
        queue[rear] = value;
    } else {
        rear++;
        queue[rear] = value;
    }
}

int deQueue() {
    if (front == -1) {
        return -1;
    }
    int temp = queue[front];
    if (front == rear) {
        front = -1;
        rear = -1;
    } else if (front == size-1) {
        front = 0;
    } else {
        front++;
    }
    return temp;
}
};

int main() {
CircularQueue q(5);
q.enQueue(10);
q.enQueue(20);
q.deQueue();
return 0;
}
</code></pre>

      </article>

      <article>
        <h3>5. Array</h3>
        <p>An array is a static linear data structure where elements are placed contiguous in memory. Elements in an array can be directly accessed using indices.</p>
        <p>Advantages:</p>
        <ul>
          <li>Fast access to elements.</li>
          <li>Easy to understand and use.</li>
        </ul>
        <p>Disadvantages:</p>
        <ul>
          <li>Fixed size - Inefficient if the array isn't fully utilized, and limiting if more elements need to be stored.</li>
          <li>Insertion and deletion operations are time consuming due to the need for shifting elements.</li>
        </ul>
        <p>Time Complexity:</p>
        <ul>
          <li>Access - O(1)</li>
          <li>Search - O(n)</li>
          <li>Insertion - O(n)</li>
          <li>Deletion - O(n)</li>
        </ul>
        <pre><code class="language-cpp">
// Array implementation in C++
int main() {
    int array[5];  // Declaration of array
    array[0] = 10;  // Inserting 10 at 0th index
    array[1] = 20;  // Inserting 20 at 1st index
    return 0;
}
</code></pre>
      </article>
      <article>
        <h3>6. Linked List</h3>
        <p>A linked list is a dynamic linear data structure where each element is a separate object. Each element or node contains a pointer that points to the next node in the list.</p>
        <p>Advantages:</p>
        <ul>
          <li>Dynamic size - Size can be increased or decreased at run-time.</li>
          <li>Efficient insertions/deletions at any place in the linked list.</li>
        </ul>
        <p>Disadvantages:</p>
        <ul>
          <li>Random access is not allowed. We have to access elements sequentially starting from the first node.</li>
          <li>Extra memory space is required for a pointer with each element of the list.</li>
        </ul>
        <p>Time Complexity:</p>
        <ul>
          <li>Access - O(n)</li>
          <li>Search - O(n)</li>
          <li>Insertion - O(1)</li>
          <li>Deletion - O(1)</li>
        </ul>
        <pre><code class="language-cpp">
// Linked List implementation in C++
struct Node {
    int data;
    Node* next;
};
int main() {
Node* head = new Node();
head->data = 10; // Inserting 10 at the head
head->next = NULL;
return 0;
}
</code></pre>

      </article>
      <article>
        <h3>7. Tree</h3>
        <p>A tree is a non-linear data structure with hierarchical relationships between its elements, known as nodes. Each node in a tree has a parent node and a set of child nodes. The node without a parent is the root of the tree.</p>
        <p>Types of Trees:</p>
        <ul>
          <li>General Tree</li>
          <li>Binary Tree</li>
          <li>Binary Search Tree</li>
          <li>AVL Tree</li>
          <li>B-tree</li>
          <li>Heap Tree, etc.</li>
        </ul>
        <p>Advantages:</p>
        <ul>
          <li>Reflect hierarchical structure of data.</li>
          <li>Efficient insertion, deletion, and search operations.</li>
        </ul>
        <p>Disadvantages:</p>
        <ul>
          <li>Complex data structure, hence complex to program and manage.</li>
          <li>Space intensive, as pointers are needed to connect nodes.</li>
        </ul>
        <p>Time Complexity:</p>
        <p>The time complexity depends on the type of tree and the operation.</p>
      </article>
      <article>
        <h3>8. Binary Tree</h3>
        <p>A binary tree is a type of tree where each node can have at most two children, known as the left child and the right child.</p>
        <p>Advantages:</p>
        <ul>
          <li>Quick and easy to implement.</li>
          <li>Efficient traversal methods.</li>
        </ul>
        <p>Disadvantages:</p>
        <ul>
          <li>In the worst case, the tree can become skewed, leading to inefficient operations.</li>
        </ul>
        <p>Time Complexity:</p>
        <ul>
          <li>Access - O(n)</li>
          <li>Search - O(n)</li>
          <li>Insertion - O(n)</li>
          <li>Deletion - O(n)</li>
        </ul>
        <pre><code class="language-cpp">
// Binary Tree implementation in C++
struct Node {
    int data;
    Node* left;
    Node* right;
};
Node* newNode(int data) {
Node* node = new Node();
if (node == NULL) {
return NULL;
}
node->data = data;
node->left = node->right = NULL;
return node;
}

int main() {
Node* root = newNode(1);
root->left = newNode(2);
root->right = newNode(3);
return 0;
}
</code></pre>

      </article>
      <article>
        <h3>9. Binary Search Tree (BST)</h3>
        <p>A Binary Search Tree is a type of binary tree where the nodes are arranged in order: for each node, all elements in the left subtree are less-than the node, and all elements in the right subtree are greater-than the node.</p>
        <p>Advantages:</p>
        <ul>
          <li>Provides moderate access/search (quicker than Linked List and slower than arrays).</li>
          <li>Provides moderate insertion/deletion (quicker than arrays and slower than Unordered Linked Lists).</li>
        </ul>
        <p>Disadvantages:</p>
        <ul>
          <li>In worst case, can become skewed like a linked list.</li>
          <li>Complex implementation of deletion operation.</li>
        </ul>
        <p>Time Complexity:</p>
        <ul>
          <li>Access - O(n)</li>
          <li>Search - O(n)</li>
          <li>Insertion - O(n)</li>
          <li>Deletion - O(n)</li>
        </ul>
        <p>However, in a 'balanced' binary search tree (AVL Trees, Red-Black Trees, etc), these operations can be performed in O(log n) time.</p>
        <pre><code class="language-cpp">
// Binary Search Tree implementation in C++
struct Node {
    int data;
    Node* left;
    Node* right;
};
// Function to create a new node
Node* newNode(int data) {
Node* node = new Node();
if (node == NULL) {
return NULL;
}
node->data = data;
node->left = node->right = NULL;
return node;
}

// Function to insert a node in a BST
Node* insert(Node* node, int data) {
if (node == NULL) {
return newNode(data);
}
if (data < node->data) {
node->left = insert(node->left, data);
} else if (data > node->data) {
node->right = insert(node->right, data);
}
return node;
}

int main() {
Node* root = NULL;
root = insert(root, 50);
insert(root, 30);
insert(root, 20);
insert(root, 40);
insert(root, 70);
insert(root, 60);
insert(root, 80);
return 0;
}
</code></pre>

      </article>
      <article>
        <h3>10. AVL Tree and Balance Factor</h3>
        <p>An AVL (Adelson-Velsky and Landis) tree is a self-balancing binary search tree in which the difference between the heights of the left and right subtrees (the balance factor) is not more than one for all nodes.</p>
        <p>Balance factor of a node = height of left subtree - height of right subtree. If this factor is more than 1 or less than -1, the tree is unbalanced, and specific tree rotations are used to rebalance the tree.</p>
        <p>Advantages:</p>
        <ul>
          <li>Ensures O(log n) time complexity for search, insertion and deletion.</li>
        </ul>
        <p>Disadvantages:</p>
        <ul>
          <li>More complex to implement due to the need for maintaining balance.</li>
        </ul>
        <p>Time Complexity:</p>
        <ul>
          <li>Access - O(log n)</li>
          <li>Search - O(log n)</li>
          <li>Insertion - O(log n)</li>
          <li>Deletion - O(log n)</li>
        </ul>
      </article>

      <article>
        <h3>11. Rotation Rules</h3>
        <p>Tree rotations are used in AVL trees to maintain their balance. There are four types of rotations: left-left, left-right, right-left, and right-right. The rotation type is determined by the 'heavy' side of the unbalanced node and its child.</p>
        <ul>
          <li>Left-Left Case: This requires a single right rotation.</li>
          <li>Right-Right Case: This requires a single left rotation.</li>
          <li>Left-Right Case: This requires a left rotation followed by a right rotation.</li>
          <li>Right-Left Case: This requires a right rotation followed by a left rotation.</li>
        </ul>
        <!-- Including the actual code for these rotations would make the answer quite complex. -->
      </article>
      <article>
        <h3>12. Time Complexity</h3>
        <p>Time complexity of an algorithm quantifies the amount of time taken by an algorithm to run as a function of the size of the input to the program. It is usually expressed using Big O notation.</p>
        <p>The most common time complexities are: O(1), O(log n), O(n), O(n log n), O(n^2), O(n^3), and O(2^n), which represent constant time, logarithmic time, linear time, linearithmic time, quadratic time, cubic time, and exponential time, respectively.</p>
      </article>
      <article>
        <h3>13. Calculating Maximum and Minimum Number of Nodes in a Tree</h3>
        <p>The minimum number of nodes in a tree of height h (height of root node = 1) can be calculated as h.</p>
        <p>The maximum number of nodes in a tree of height h can be calculated as 2^h - 1.</p>
        <p>In case of binary trees:</p>
        <ul>
          <li>The minimum number of nodes in a binary tree of height h is h.</li>
          <li>The maximum number of nodes in a binary tree of height h is 2^h - 1.</li>
        </ul>
      </article>
      <article>
        <h3>14. Typecasting</h3>
        <p>Typecasting, or type conversion, is a method of changing an entity from one data type to another. It is used in C++ for various purposes, such as to avoid loss of data, to add greater functionality to a program, or to convert objects of one class type into those of another class type.</p>
        <pre><code class="language-cpp">
// Typecasting in C++
int main() {
    double x = 10.3;
    int y;
    y = (int) x;  // This will assign the value 10 to y
    return 0;
}
</code></pre>
      </article>

      <article>
        <h3>15. BST Traversing (Pre, In, Post Order)</h3>
        <p>Tree traversal is a process of visiting (checking or updating) each node in a tree data structure, exactly once. In case of binary trees, they can be traversed in pre-order, in-order, and post-order.</p>
        <h4>15.1 Pre-order Traversal</h4>
        <p>In a pre-order traversal, the tree nodes are visited in the following order: Root, Left Subtree, Right Subtree.</p>
        <pre><code class="language-cpp">
void preOrder(Node* node) {
    if (node == NULL)
        return;
    cout << node->data << " ";
    preOrder(node->left);
    preOrder(node->right);
}
</code></pre>
        <h4>15.2 In-order Traversal</h4>
        <p>In an in-order traversal, the tree nodes are visited in the following order: Left Subtree, Root, Right Subtree.</p>
        <pre><code class="language-cpp">
void inOrder(Node* node) {
    if (node == NULL)
        return;
    inOrder(node->left);
    cout << node->data << " ";
    inOrder(node->right);
}
</code></pre>
        <h4>15.3 Post-order Traversal</h4>
        <p>In a post-order traversal, the tree nodes are visited in the following order: Left Subtree, Right Subtree, Root.</p>
        <pre><code class="language-cpp">
void postOrder(Node* node) {
    if (node == NULL)
        return;
    postOrder(node->left);
    postOrder(node->right);
    cout << node->data << " ";
}
</code></pre>
      </article>
      <article>
        <h3>16. Spanning Tree</h3>
        <p>A Spanning Tree of a connected, undirected graph is a subgraph that is a tree and connects (spans) all vertices of the graph. In a weighted graph, a Minimum Spanning Tree (MST) is a spanning tree that has minimum weight than all other spanning trees of the same graph.</p>
        <p>Two popular algorithms to find the MST are Kruskal’s Minimum Spanning Tree Algorithm and Prim’s Minimum Spanning Tree Algorithm.</p>
        <!-- The actual code for these algorithms would be quite complex. -->
      </article>
      <article>
        <h3>17. Linear vs Non-linear DS</h3>
        <p>In data structures, linear and non-linear data structures are the classifications based on the arrangement of data and the ability to change its position:</p>
        <h4>17.1 Linear Data Structures</h4>
        <p>Linear data structures have data elements arranged sequentially with each element connected to its previous and next element. The basic operations are performed in a linear order. Examples: Array, Stack, Queue, Linked List.</p>
        <h4>17.2 Non-linear Data Structures</h4>
        <p>Non-linear data structures have data elements arranged hierarchically, and each element can connect to two or more other elements, without a particular sequence. Examples: Trees and Graphs.</p>
      </article>
      <article>
        <h3>18. Types of Trees</h3>
        <p>Trees are a type of non-linear data structure that are used to represent hierarchical structure in a graphical form. Here are some common types of trees:</p>
        <ul>
          <li>General Tree</li>
          <li>Binary Tree</li>
          <li>Binary Search Tree</li>
          <li>AVL Tree</li>
          <li>Heap Tree</li>
          <li>B-Tree</li>
          <li>Red-Black Tree</li>
          <li>2-3 Tree, etc.</li>
        </ul>
      </article>

      <article>
        <h3>19. Quick Summary</h3>
        <h4>19.1 Stack</h4>
        <p>A stack is essentially a list with the restriction that insertions and deletions can only be performed at one end. This end is known as the top. The element at the other end is known as the base. Stacks are useful in various algorithms where we need to temporarily store information and retrieve it in a LIFO manner.</p>
        <p>LIFO structure. Main operations: push (add to top), pop (remove from top), peek (get top without removing it). Useful for reversing, backtracking, and parsing tasks. O(1) for main operations.</p>

        <h4>19.2 FIFO Structure</h4>
        <p>A queue is also a list, but with the condition that insertions are performed at one end (rear), while deletions are performed at the other end (front). It follows a FIFO pattern, making it useful in scenarios where we need to maintain the order of elements.</p>
        <p>FIFO structure. Main operations: enqueue (add to rear), dequeue (remove from front). Useful in CPU scheduling, disk scheduling, data buffering. O(1) for main operations.</p>

        <h4>19.3 Deque (Double Ended Queue)</h4>
        <p>A Deque (Double Ended Queue) is a type of queue in which insertion and removal of elements can be performed from either from the front or rear. Thus, it does not follow the FIFO rule.</p>
        <p>Insertion and deletion can be performed from either end. Combines capabilities of stacks and queues.</p>

        <h4>19.4 Circular Queue</h4>
        <p>A circular queue is a variant of the linear queue which follows a FIFO principle but with a twist: the last position is connected back to the first position making a circle. It efficiently utilizes memory that is freed after a dequeue operation.</p>
        <p>Queue in a circular structure. Maximizes space utilization by using empty slots after dequeue operations.</p>

        <h4>19.5 Array</h4>
        <p>An array is a simple data structure used for storing an ordered list of items. The items can be the same type or different types. Arrays are useful when you need to access items by their numerical position in the list.</p>
        <p>Fixed-size, contains elements of the same type. Random access possible, but insertions/deletions are costly due to shifting. O(1) for access, O(n) for insertion/deletion.</p>

        <h4>19.6 Linked List</h4>
        <p>A linked list is a dynamic data structure, in which data is not stored at contiguous memory locations. The concept of next points to the next node, and the last node points to null. A linked list is not suitable for direct access but efficient for insertions and deletions.</p>
        <p>Dynamic size, contains nodes with data and link to next node. No random access but efficient insertions/deletions. O(n) for access/search, O(1) for insertion/deletion at head.</p>

        <h4>19.7 Tree</h4>
        <p>A tree is a hierarchical data structure that stores data in a sorted manner and enables search, insert, delete operations to be carried out efficiently. It's a powerful tool for organizing data in a natural hierarchy, such as a file system.</p>
        <p>Hierarchical structure with a root node and children nodes. Used to represent hierarchical relationships, enable fast search/insert/delete operations.</p>

        <h4>19.8 Binary Tree</h4>
        <p>A binary tree is a tree-type non-linear data structure with a maximum of two children for each parent. The two children are usually differentiated as left child and right child. It is used in many algorithms due to its simple structure and ease of use.</p>
        <p>Tree with a maximum of two children per node. Used in many algorithms for its simple structure.</p>

        <h4>19.9 Binary Search Tree (BST)</h4>
        <p>BST is a binary tree with a special property: each node has a value greater than all the values in its left subtree and less than all the values in its right subtree. This property provides a balance between the benefits of a sorted array and a linked list, allowing us to quickly search for, insert, and delete items.</p>
        <p>Binary tree with left child node &lt; parent node &lt; right child node. Efficient search, insertion, deletion operations (O(log n) in ideal case).</p>

        <h4>19.10 AVL Tree (BST)</h4>
        <p>AVL tree is a self-balancing binary search tree, which means heights of two subtrees of any node differ by at most one. If at any point they differ by more than one, rebalancing is done to restore the property.</p>
        <p>Self-balancing BST. Balance factor is the height of the left subtree - height of the right subtree and must be -1, 0, or 1. Balancing done via rotations.</p>

        <h4>19.11 Time Complexity</h4>
        <p>Time complexity of an algorithm quantifies the amount of time taken by an algorithm to run, as a function of the length of the input. It is a theoretical estimate of the amount of time an algorithm needs to complete based on the size of the input.</p>
        <p>Measures the time taken by an algorithm to run, as a function of the size of the input. Big O notation describes worst-case time complexity.</p>

        <h4>19.12 Calculating maximum and minimum number of nodes in a tree</h4>
        <p>In a binary tree of height 'h', the minimum number of nodes can be 'h' (if each level only has one node) and the maximum number of nodes can be 2^h - 1 (if each level is fully populated).</p>
        <p>For a binary tree with 'h' height, min nodes = h, max nodes = 2^h - 1.</p>

        <h4>19.13 Typecasting</h4>
        <p>Typecasting is a way to convert a variable from one data type to another. This is used when you want to use a variable of one type as if it were a different type.</p>
        <p>Converting a variable from one data type to another.</p>

        <h4>19.14 BST Traversing</h4>
        <p>Traversing is visiting every node in the BST. There are three common ways to traverse them in a depth-first order: Inorder (Left, Root, Right), Preorder (Root, Left, Right), and Postorder (Left, Right, Root).</p>
        <p>Preorder (root, left, right), Inorder (left, root, right), Postorder (left, right, root).</p>

        <h4>19.15 Spanning Tree</h4>
        <p>In graph theory, a spanning tree T of a connected, undirected graph G is a tree that includes every vertex of G, with minimum possible number of edges.</p>
        <p>Tree that includes all vertices of a graph. Minimum spanning tree (MST) is a spanning tree with minimum total edge weight.</p>

        <h4>19.16 Linear vs Non-linear Data Structures</h4>
        <p>Linear data structures have data elements arranged in a linear order where each element is connected to its previous and next element. Non-linear data structures are those data structures in which data elements are not in sequence, i.e., they are arranged hierarchically.</p>
        <p>Linear - elements arranged in a sequence (Array, Stack, Queue, Linked List). Non-linear - hierarchical arrangement of elements (Trees, Graphs).</p>
      </article>

    </main>

    <script>copyright("all");</script>
  </body>

</html>
