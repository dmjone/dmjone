<!-------------------------- Â© 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>

        <title>Trees vs Graphs: CSU1051P - Shoolini U</title>
        <meta name="description" content="Compare and contrast trees and graphs in the CSU1051P course at Shoolini University. Understand the structural differences, properties, and applications of trees and graphs with dmj.one's educational initiative.">

        <meta property="og:image" content="/logo.png">
        <meta property="og:type" content="article">

        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@divyamohan1993">
        <meta name="twitter:creator" content="@divyamohan1993">
        <meta name="twitter:image" content="/logo.png">

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />
    </head>

    <body>

        <script> header_author("dm"); </script>

        <main>
            <article>
                <h2 class="text-center">Trees vs Graph</h2>
                <div class="container mt-4 w-100 w-xl-75">
                    <div class="accordion" id="toc">
                        <div class="accordion-item">
                            <h2 class="accordion-header" id="h1">
                                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#c1" aria-controls="c1" aria-expanded="false">
                                    <i class="fas fa-book"></i> <strong>&nbsp;Table of Contents</strong>
                                </button>
                            </h2>
                            <div id="c1" class="accordion-collapse collapse" aria-labelledby="h1" data-bs-parent="#toc">
                                <div class="accordion-body">
                                    <ol class="list-unstyled p-0 m-0">
                                        <!-- <li class="p-1"><a href="#left-page"><i class="fas fa-chevron-circle-right"></i> Left Side (Blank Side)</a></li> -->
                                        <li class="p-1"><a href="#difference-between-graphs-and-trees"><i class="fas fa-chevron-circle-right"></i> Right Side (Ruled Side)</a></li>
                                    </ol>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </article>

            <article id="executive-summary">
                <h3>Executive Summary: Navigating the Labyrinth of Trees and Graphs</h3>
                <p>In this detailed exploration, we unravel the intertwined concepts of Trees and Graphs, two fundamental data structures that form the bedrock of advanced computation. We commence with an exploration of the core definitions, followed by a technical dive into various types and properties. This journey delves into their concrete differences, articulated in a 15-point table for a quick overview. We then explore the practical aspects, looking into implementation in C++, using them to solve real-world problems, and discovering the trade-offs between these data structures. The latter sections explore more advanced topics, like spanning trees, graph algorithms, and applications of graphs in areas such as social networks and web page ranking. This comprehensive article aims to invigorate your understanding of these structures, adding to your existing knowledge and presenting new possibilities to ponder. Join us as we venture into the intricate world of Trees and Graphs, leading to a more exciting narrative: traversing the terrain of Graph Isomorphisms.</p>
            </article>

            <article id="problem-statement">
                <h3>1. Problem Statement</h3>
                <p>Imagine you are tasked with designing the navigation system for an autonomous vehicle. The vehicle should optimally traverse from one point to another in a city, considering factors like road conditions, traffic, and distance. This problem, a quintessential instance of a path-finding problem, can be efficiently solved using graph theory, specifically the concept of graphs in data structures.</p>
            </article>

            <article id="graph-introduction">
                <h3>2. Graphs: An Introduction</h3>
                <p>At its most basic, a graph is a mathematical structure used to model pairwise relations between objects. It consists of vertices (or nodes) and edges (or arcs), where each edge connects a pair of vertices. Graphs can be used to represent various physical and abstract concepts like social networks, web pages, and routes in a city, as in our problem statement.</p>
            </article>

            <article id="tree-introduction">
                <h3>3. Trees: An Introduction</h3>
                <p>On the other hand, a tree is a specific type of graph. It is an acyclic (cycle-free), connected graph. Each node in the tree has a specific parent node (except for the root), creating a hierarchical structure. Trees find usage in various areas like organizing hierarchies, managing databases, and enabling quick search and insert operations.</p>
            </article>

            <article id="graphs-and-trees-types">
                <h4>3.1 Types of Graphs and Trees</h4>
                <p>Graphs and trees come in various types and forms. Graphs can be undirected, where edges do not have a direction, or directed (digraph), where edges have a specific direction. They can also be weighted, where each edge carries a specific weight or cost. Trees can be binary trees (each node has at most two children), binary search trees (left child is smaller than the parent, right child is larger), balanced trees (the tree is evenly balanced to minimize search time), and many more.</p>
            </article>

            <article id="graphs-and-trees-properties">
                <h4>3.2 Properties of Graphs and Trees</h4>
                <p>Graphs and trees possess several interesting properties. Graphs can be cyclic or acyclic, dense or sparse, and connected or disconnected. Some properties are unique to special graphs, like Eulerian (a closed trail includes every edge) and Hamiltonian (a closed trail includes every vertex once). Trees, being acyclic connected graphs, have a property that there exists exactly one path between any two nodes. Moreover, adding one edge to

                    a tree creates a cycle, and removing one edge from a tree disconnects it.</p>
            </article>

            <article id="difference-between-graphs-and-trees">
                <h3>4. Distinguishing Graphs and Trees: A 15-Point Difference Table</h3>
                <p>While both graphs and trees can be intertwined conceptually, several key differences distinguish them:</p>
                <div class="table-responsive">
                    <table class="table table-striped table-bordered table-hover">
                        <thead class="thead-dark">
                            <tr>
                                <th scope="col">Aspect</th>
                                <th scope="col">Graph</th>
                                <th scope="col">Tree</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Definition</td>
                                <td>Set of vertices & edges</td>
                                <td>Acyclic graph & connected</td>
                            </tr>
                            <tr>
                                <td>Edge Direction</td>
                                <td>Can be directed/undirected</td>
                                <td>Typically directed (parent to child)</td>
                            </tr>
                            <tr>
                                <td>Cycles</td>
                                <td>May contain cycles</td>
                                <td>No cycles (acyclic)</td>
                            </tr>
                            <tr>
                                <td>Path</td>
                                <td>Any path possible</td>
                                <td>Unique path between nodes</td>
                            </tr>
                            <tr>
                                <td>Root</td>
                                <td>No specific root</td>
                                <td>One root node</td>
                            </tr>
                            <tr>
                                <td>Applications</td>
                                <td>Networks, Path problems, Flow problems</td>
                                <td>Hierarchy representation, Parsing expression, Routing Algorithms</td>
                            </tr>
                            <tr>
                                <td>Loop</td>
                                <td>Loops are permitted</td>
                                <td>No loops</td>
                            </tr>
                            <tr>
                                <td>Traversal</td>
                                <td>BFS, DFS</td>
                                <td>Preorder, Inorder, Postorder</td>
                            </tr>
                            <tr>
                                <td>Edge Classification</td>
                                <td>Can classify edges as bridges, loops, multiple</td>
                                <td>No edge classification</td>
                            </tr>
                            <tr>
                                <td>Disjoint Parts</td>
                                <td>Can have disjoint parts</td>
                                <td>Always connected</td>
                            </tr>
                            <tr>
                                <td>Edge Removal</td>
                                <td>Removing an edge might not disconnect the graph</td>
                                <td>Removing an edge always disconnects the tree</td>
                            </tr>
                            <tr>
                                <td>Node Addition</td>
                                <td>Adding a node increases the degree of freedom</td>
                                <td>Adding a node increases the height or balance of the tree</td>
                            </tr>
                            <tr>
                                <td>Space Complexity</td>
                                <td>O(V^2) for adjacency matrix, O(V+E) for adjacency list</td>
                                <td>O(N) where N is the number of nodes</td>
                            </tr>
                            <tr>
                                <td>Search Mechanism</td>
                                <td>Path-based search, can take any path</td>
                                <td>Hierarchical search, down through branches</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </article>

            <article id="graph-and-tree-implementation">
                <h3>5. Implementations of Graphs and Trees in C++</h3>
                <p>We will now explore the implementation of these data structures in C++. Graphs can be implemented using adjacency matrix, adjacency list, or incidence matrix. Trees are usually implemented as dynamic data structures with pointers.</p>
            </article>

            <article id="graph-implementation">
                <h4>5.1 Graph Implementation</h4>
                <pre><code class="language-cpp">// Using Adjacency List
#include&lt;iostream>
#include&lt;vector>
using namespace std;

// Define the Graph class
class Graph {
  int V; // No. of vertices
  vector&lt;int> *adjList; // Pointer to array containing adjacency lists

public:
  // Constructor
  Graph(int V);

  // Function to add an edge to graph
  void addEdge(int v, int w);

  // Function to print the adjacency list
  void printGraph();
};

Graph::Graph(int V) {
  this->V = V;
  adjList = new vector &lt;int>[V];
}

void Graph::addEdge(int v, int w) {
  adjList[v].push_back(w);
}

void Graph::printGraph() {
for (int v = 0; v < V; ++v) {
    cout << "\n Adjacency list of vertex " << v << "\n head ";
    for (auto x : adjList[v]) 
        cout << "-> " << x; printf("\n"); 
    } 
}
int main() {
    int V=5;
    Graph g(V);
    g.addEdge(0, 1);
    g.addEdge(0, 4);
    g.addEdge(1, 2); 
    g.addEdge(1, 3); 
    g.addEdge(1, 4); 
    g.addEdge(2, 3); 
    g.addEdge(3, 4); 
    g.printGraph(); 
    return 0; 
}</code></pre>
            </article>
            <article id="tree-implementation">
                <h4>5.2 Tree Implementation</h4>
                <pre><code class="language-cpp">// Binary Tree
#include &lt;iostream>
using namespace std;
// Define the Tree node
struct Node {
int data;
Node* left;
Node* right;
};

// Function to create a new node
Node* newNode(int data) {
Node* node = new Node();
node->data = data;
node->left = NULL;
node->right = NULL;
return node;
}

// Function to print the tree in an inorder way
void printInorder(Node* node) {
if (node == NULL)
return;

// first recur on left child
printInorder(node->left);

// then print the data of node
cout << node->data << " ";

// now recur on right child
printInorder(node->right);
}

int main() {
Node* root = newNode(1);
root->left = newNode(2);
root->right = newNode(3);
root->left->left = newNode(4);
root->left->right = newNode(5);

printInorder(root);

return 0;
}
</code></pre>

            </article>
            <article id="graph-algorithms">
                <h3>6. Graph Algorithms</h3>
                <p>Graphs are ubiquitous due to their versatility, and several algorithms operate on graphs, each serving a different purpose. We have traversal algorithms like Depth First Search (DFS) and Breadth First Search (BFS), shortest path algorithms like Dijkstra's and Bellman-Ford, minimum spanning tree algorithms like Prim's and Kruskal's, and many more.</p>
            </article>
            <article id="tree-algorithms">
                <h3>7. Tree Algorithms</h3>
                <p>Trees, particularly binary trees, have their unique set of algorithms. We have tree traversals like inorder, preorder, and postorder. Then, there are algorithms for insertion, deletion, and searching in a Binary Search Tree (BST). For balancing trees, we have algorithms like AVL rotation and Red-Black Tree insertion.</p>
            </article>
            <article id="complexity-analysis">
                <h3>8. Complexity Analysis</h3>
                <p>An understanding of time and space complexity is crucial while working with these data structures. Depending on the implementation, graphs can have a space complexity of O(V^2) for an adjacency matrix and O(V+E) for an adjacency list. Trees usually have a space complexity of O(N) for N nodes. The time complexity for operations can vary depending on the specific algorithm used.</p>
            </article>
            <article id="spanning-trees-and-graphs">
                <h3>9. Spanning Trees and Graphs</h3>
                <p>One interesting area where trees and graphs intersect is the concept of spanning trees. A spanning tree of a connected, undirected graph is a subgraph that is a tree and connects all the vertices. This concept is extensively used in network designs to avoid loops and yet ensure all nodes are reachable.</p>
            </article>
            <article id="conclusion">
                <h3>10. Conclusion: From Graphs and Trees to Graph Isomorphisms</h3>
                <p>Our journey through the labyrinth of trees and graphs illuminates their intrinsic importance in data structures and algorithms. We explored their definitions, implementations, and key distinguishing factors, weaving together the threads of understanding to equip us for more complex concepts. As we conclude this enlightening exploration, we can look forward to our next adventure: delving into the world of Graph Isomorphisms, a captivating study of graph equivalence. Here, we explore how different-looking graphs can be the same and what "sameness" means in a graph context. Keep reading, stay curious, and let's continue exploring the never-ending marvels of computer science!</p>
            </article>

        </main>

        <script> copyright("all"); </script>

    </body>

</html>
