<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>

        <title>Data Structures Revision: CSU1051P - Shoolini U</title>
        <meta name="description" content="Prepare for your data structures revision in the CSU1051P course at Shoolini University. Reinforce your knowledge and review key concepts with dmj.one's educational initiative.">

        <meta property="og:image" content="/logo.png">
        <meta property="og:type" content="article">

        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@divyamohan1993">
        <meta name="twitter:creator" content="@divyamohan1993">
        <meta name="twitter:image" content="/logo.png">

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />


    </head>

    <body>

        <script> header_author("dm"); </script>

        <main>
            <article>
                <h2 class="text-center">Revision</h2>
                <!-- <div class="container mt-4 w-100 w-xl-75">
                    <div class="accordion" id="toc">
                        <div class="accordion-item">
                            <h2 class="accordion-header" id="h1">
                                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#c1" aria-controls="c1" aria-expanded="false">
                                    <i class="fas fa-book"></i> <strong>&nbsp;Table of Contents</strong>
                                </button>
                            </h2>
                            <div id="c1" class="accordion-collapse collapse" aria-labelledby="h1" data-bs-parent="#toc">
                                <div class="accordion-body">
                                    <ol class="list-unstyled p-0 m-0">
                                        <li class="p-1"><a href="#left-page"><i class="fas fa-chevron-circle-right"></i> Left Side (Blank Side)</a></li>
                                        <li class="p-1"><a href="#right-page"><i class="fas fa-chevron-circle-right"></i> Right Side (Ruled Side)</a></li>
                                    </ol>
                                </div>
                            </div>
                        </div>
                    </div>
                </div> -->
            </article>
            <article id="historical-introduction">
                <h3>Pre-Introduction and Historical Development</h3>

                <p>Data Structures and Algorithms are fundamental concepts in computer science that guide us to write efficient and optimized code. These concepts were developed over time, each with their own purposes and improvements over their predecessors. Let's take a look at the historical development and reasons behind the creation of the core data structures and algorithms in our syllabus:</p>

                <article id="history-arrays">
                    <h4>1. Arrays</h4>
                    <p>The concept of Arrays is as old as programming itself. When programming was done using Assembly language in the early days, Arrays were used as a contiguous block of memory used to store multiple values. They are simple and offer direct access to data.</p>
                </article>

                <article id="history-stacks">
                    <h4>2. Stacks</h4>
                    <p>Stacks were also developed early in the history of computing, being used in the evaluation of arithmetic expressions and syntax parsing. They were used for reversing the order of things and providing simple memory management.</p>
                </article>

                <article id="history-queues">
                    <h4>3. Queues</h4>
                    <p>Queues were developed soon after Stacks, providing a mechanism for fairness, ensuring that items that arrived first were processed first (FIFO).</p>
                </article>

                <article id="history-binary-trees">
                    <h4>4. Binary Trees</h4>
                    <p>Binary Trees were developed to organize data in a hierarchical and ordered manner. They were used in various applications like expression parsing and Huffman encoding.</p>
                </article>

                <article id="history-binary-search-trees">
                    <h4>5. Binary Search Trees</h4>
                    <p>Binary Search Trees (BSTs) were developed as an improvement over Binary Trees, providing efficient searching, insertion, and deletion. In BSTs, the left child node is always less than the parent node, and the right child node is always greater.</p>
                </article>

                <article id="history-avl-trees">
                    <h4>6. AVL Trees</h4>
                    <p>As the need for speed became more crucial, AVL Trees were developed from BSTs to maintain balance, ensuring faster operations. AVL Trees introduced the concept of self-balancing, where the difference of heights of left and right subtrees of any node is not more than one.</p>
                </article>

                <article id="history-b-trees">
                    <h4>7. B-Trees</h4>
                    <p>B-Trees were developed for efficient disk access in databases. Each node in a B-Tree contains multiple keys and can have more than two children, which increases efficiency for large data sets.</p>
                </article>

                <article id="history-b-plus-trees">
                    <h4>8. B+ Trees</h4>
                    <p>B+ Trees were an improvement over B-Trees, primarily used in database systems for efficient disk access. In B+ Trees, all keys are stored in the leaf nodes, which makes range queries faster.</p>
                </article>

                <article id="history-dijkstra">
                    <h4>9. Dijkstra's Algorithm</h4>
                    <p>With the increasing complexity and size of data, efficient path-finding algorithms became necessary. Dijkstra's algorithm was one of the first algorithms to find the shortest path in a graph with positive weights.</p>
                </article>

                <article id="history-bellmanford">
                    <h4>10. Bellman Ford Algorithm</h4>
                    <p>The Bellman Ford Algorithm was developed as a more versatile but slower alternative to Dijkstra's Algorithm. It can handle graphs with negative edge weights and is used to detect negative cycles in a graph.</p>
                </article>
            </article>

            <article id="introduction">
                <h3>1. Introduction to Data Structures and Algorithms</h3>
                <p>Data Structures and Algorithms (DSA) form the foundational concepts in computer science, which help in organizing and processing data efficiently. Understanding DSA is key to designing efficient software systems or applications. This article provides an overview of several important data structures and algorithms, their advantages, disadvantages, and applications.</p>
            </article>

            <article id="array">
                <h3>2. Array</h3>
                <p>An Array is a data structure that holds a fixed number of elements of a single type in a contiguous memory location.</p>

                <h4>2.1 Advantages</h4>
                <p>
                <ul>
                    <li>Random access is possible due to contiguous memory.</li>
                    <li>Efficient if the size of the collection is known.</li>
                </ul>
                </p>

                <h4>2.2 Disadvantages</h4>
                <p>
                <ul>
                    <li>Fixed size.</li>
                    <li>Insertion and deletion operations are expensive.</li>
                </ul>
                </p>

                <h4>2.3 Applications</h4>
                <p>Arrays are used to implement other data structures like heaps, hash tables, etc. They are also used in numeric computations, databases, and more.</p>

                <h4>2.4 Basic Structure in C++</h4>
                <pre><code class="language-cpp">
//Declaration
int arr[10];

// Initialization
int arr[5] = {1, 2, 3, 4, 5};
</code></pre>
            </article>

            <article id="linked-list">
                <h3>3. Linked List</h3>
                <p>A Linked List is a linear data structure where each element is a separate object, known as a node, and each node contains a pointer to the next node in the list.</p>

                <h4>3.1 Advantages</h4>
                <p>
                <ul>
                    <li>Dynamic size.</li>
                    <li>Easy to insert or delete elements.</li>
                </ul>
                </p>

                <h4>3.2 Disadvantages</h4>
                <p>
                <ul>
                    <li>No random access to elements.</li>
                    <li>Requires extra space for pointers.</li>
                </ul>
                </p>

                <h4>3.3 Applications</h4>
                <p>Linked Lists are used in various applications where we need to frequently add or remove items, such as implementing stacks, queues, and graphs.</p>

                <h4>3.4 Basic Structure in C++</h4>
                <pre><code class="language-cpp">
// A linked list node
class Node {
public:
   int data;
   Node* next;
};
</code></pre>
            </article>

            <article id="stack">
                <h3>4. Stack</h3>
                <p>A Stack is a linear data structure which follows a particular order in which the operations are performed. The order is Last In First Out (LIFO).</p>

                <h4>4.1 Advantages</h4>
                <p>
                <ul>
                    <li>Follows Last In First Out, which helps in certain use cases like function calling.</li>
                    <li>Easy to implement.</li>
                </ul>
                </p>

                <h4>4.2 Disadvantages</h4>
                <p>
                <ul>
                    <li>No random access to elements.</li>
                    <li>The size needs to be defined at the start, which can lead to wastage of space.</li>
                </ul>
                </p>

                <h4>4.3 Applications</h4>
                <p>Stacks are used in programming languages to implement function calling (function stack), used in algorithm problems like parenthesis checking, infix to postfix conversion, etc.</p>

                <h4>4.4 Basic Structure in C++</h4>
                <pre><code class="language-cpp">
#include&ltstack&gt 
stack<int> s; 
</code></pre>
            </article>

            <article id="queue">
                <h3>5. Queue</h3>
                <p>A Queue is a linear structure which follows a particular order in which the operations are performed. The order is First In First Out (FIFO).</p>

                <h4>5.1 Advantages</h4>
                <p>
                <ul>
                    <li>Ensures fairness as it follows First In First Out.</li>
                    <li>Easy to implement.</li>
                </ul>
                </p>

                <h4>5.2 Disadvantages</h4>
                <p>
                <ul>
                    <li>No random access to elements.</li>
                    <li>The size needs to be defined at the start, which can lead to wastage of space.</li>
                </ul>
                </p>

                <h4>5.3 Applications</h4>
                <p>Queues are used whenever we need to manage objects in order starting with the first one in. Examples include CPU scheduling, Disk Scheduling.</p>

                <h4>5.4 Basic Structure in C++</h4>
                <pre><code class="language-cpp">
#include&ltqueue&gt 
queue<int> q; 
</code></pre>
            </article>

            <article id="binary-tree">
                <h3>6. Binary Tree</h3>
                <p>A Binary Tree is a tree data structure in which each node has at most two children, which are referred to as the left child and the right child.</p>

                <h4>6.1 Advantages</h4>
                <p>
                <ul>
                    <li>Simpler to implement and understand.</li>
                    <li>Used in various applications like expression parsing and Huffman encoding.</li>
                </ul>
                </p>

                <h4>6.2 Disadvantages</h4>
                <p>
                <ul>
                    <li>If not balanced, operations can take O(n) time in the worst case.</li>
                    <li>No direct support for efficient search, insert, and delete operations.</li>
                </ul>
                </p>

                <h4>6.3 Applications</h4>
                <p>Binary Trees are used in many areas including expression parsing, Huffman encoding for data compression, and many more.</p>

                <h4>6.4 Basic Structure in C++</h4>
                <pre><code class="language-cpp">
class Node {
public:
   int data;
   Node* left;
   Node* right;
};
</code></pre>
            </article>

            <article id="binary-search-tree">
                <h3>7. Binary Search Tree</h3>
                <p>A Binary Search Tree is a node-based binary tree data structure which has the following properties: The left subtree of a node contains only nodes with keys lesser than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. The left and right subtree each must also be a binary search tree.</p>

                <h4>7.1 Advantages</h4>
                <p>
                <ul>
                    <li>Search, insert, and delete operations take O(log n) in an average case scenario.</li>
                    <li>Easy to implement.</li>
                </ul>
                </p>

                <h4>7.2 Disadvantages</h4>
                <p>
                <ul>
                    <li>If not balanced, operations can take O(n) time in the worst case.</li>
                    <li>Requires additional memory for pointers.</li>
                </ul>
                </p>

                <h4>7.3 Applications</h4>
                <p>Binary Search Trees are used in search applications where data is constantly entering/leaving, such as the map and set objects in many languages' standard libraries.</p>

                <h4>7.4 Basic Structure in C++</h4>
                <pre><code class="language-cpp">
class Node {
public:
   int data;
   Node* left;
   Node* right;
};
</code></pre>
            </article>

            <article id="avl-tree">
                <h3>8. AVL Tree</h3>
                <p>AVL Tree or Height-Balanced Binary Search Tree is a self-balancing binary search tree, and it was the first such data structure to be invented. In an AVL tree, the heights of the two child subtrees of any node differ by at most one.</p>

                <h4>8.1 Advantages</h4>
                <p>
                <ul>
                    <li>Maintains the tree balanced, ensuring O(log n) time complexity for search, insert, and delete operations.</li>
                    <li>Can be used in situations where frequent data insertions and deletions are involved.</li>
                </ul>
                </p>

                <h4>8.2 Disadvantages</h4>
                <p>
                <ul>
                    <li>More complex to implement as compared to BST.</li>
                    <li>Overhead of balancing the trees.</li>
                </ul>
                </p>

                <h4>8.3 Applications</h4>
                <p>AVL Trees are used in systems where we can't afford any operation to be too slow, such as databases and filesystems.</p>

                <h4>8.4 Basic Structure in C++</h4>
                <pre><code class="language-cpp">
class Node {
public:
   int key;
   Node *left;
   Node *right;
   int height;
};
</code></pre>
            </article>

            <article id="b-tree">
                <h3>9. B-Tree</h3>
                <p>A B-Tree is a self-balancing search tree, in which every node contains multiple keys and has more than two children. Each internal node's keys act as separator values which divide its subtrees.</p>

                <h4>9.1 Advantages</h4>
                <p>
                <ul>
                    <li>Keeps keys sorted and allows for efficient insertion, deletion, and search operations.</li>
                    <li>Designed for systems with large amounts of data and where read and write operations are costly (like disk or database operations).</li>
                </ul>
                </p>

                <h4>9.2 Disadvantages</h4>
                <p>
                <ul>
                    <li>Complex to implement.</li>
                    <li>Overhead of maintaining balance and multiple keys.</li>
                </ul>
                </p>

                <h4>9.3 Applications</h4>
                <p>B-Trees are widely used in filesystems and databases to allow for efficient access to large amounts of data.</p>
            </article>

            <article id="b-plus-tree">
                <h3>10. B+Tree</h3>
                <p>A B+ tree is an n-ary tree with a variable but often large number of children per node. It is a type of tree which represents sorted data in a way that allows for efficient insertion, retrieval and removal of records, each of which is identified by a key. It is a dynamic, multilevel index, with maximum and minimum bounds on the number of keys in the nodes.</p>

                <h4>10.1 Advantages</h4>
                <p>
                <ul>
                    <li>More efficient than B-Trees for disk access in databases.</li>
                    <li>Great for range queries since all keys are stored in the leaves.</li>
                </ul>
                </p>

                <h4>10.2 Disadvantages</h4>
                <p>
                <ul>
                    <li>Complex to implement.</li>
                    <li>Additional overhead of maintaining linked list at the leaf level.</li>
                </ul>
                </p>

                <h4>10.3 Applications</h4>
                <p>B+Trees are often used in databases and file systems for efficient data access and range queries.</p>
            </article>

            <article id="dijkstra">
                <h3>11. Dijkstra's Algorithm</h3>
                <p>Dijkstra's Algorithm is a popular graph algorithm that finds the shortest path from a starting node to all nodes in a weighted graph (the weights must be positive).</p>

                <h4>11.1 Advantages</h4>
                <p>
                <ul>
                    <li>It provides the shortest path from one particular source node to all other nodes in the graph.</li>
                    <li>It is widely used in network routing protocols.</li>
                </ul>
                </p>

                <h4>11.2 Disadvantages</h4>
                <p>
                <ul>
                    <li>Does not work with graphs with negative edge weights.</li>
                    <li>May not work correctly with dynamic graphs where edge weights change over time.</li>
                </ul>
                </p>

                <h4>11.3 Applications</h4>
                <p>Used in network routing protocols, telephone network, traffic engineering, etc.</p>

                <h4>11.4 Basic Structure in C++</h4>
                <pre><code class="language-cpp">
// Dijkstra's algorithm is complex to write. It requires the use of
// a priority queue and additional classes for the graph and edges.
</code></pre>
            </article>

            <article id="bellmanford">
                <h3>12. Bellman Ford Algorithm</h3>
                <p>The Bellman–Ford algorithm is an algorithm that computes shortest paths from a single source vertex to all of the other vertices in a weighted digraph. It is slower than Dijkstra's algorithm for the same problem, but more versatile, as it is capable of handling graphs in which some of the edge weights are negative numbers.</p>

                <h4>12.1 Advantages</h4>
                <p>
                <ul>
                    <li>Can handle negative edge weights.</li>
                    <li>Can be used to detect negative cycles in a graph.</li>
                </ul>
                </p>

                <h4>12.2 Disadvantages</h4>
                <p>
                <ul>
                    <li>Slower than Dijkstra's Algorithm.</li>
                    <li>Does not work with graphs where negative cycles are reachable from the source vertex.</li>
                </ul>
                </p>

                <h4>12.3 Applications</h4>
                <p>Used in routing protocols in networks, arbitrage opportunities in currency exchange rates, etc.</p>

                <h4>12.4 Basic Structure in C++</h4>
                <pre><code class="language-cpp">
// Bellman Ford's algorithm is complex to write. It requires 
// additional classes for the graph and edges.
</code></pre>
            </article>

            <article id="differences">
                <h3>Differences</h3>

                <article id="difference-array-stack-queue">
                    <h4>1. Difference Between Array, Stack, and Queue</h4>
                    <p>An array is a basic data structure that stores elements of the same type, while a stack and a queue are abstract data types that can be implemented using arrays or linked lists. A stack follows the LIFO (Last In First Out) principle, meaning that the last element inserted is the first one to get out. On the other hand, a queue follows the FIFO (First In First Out) principle, meaning the first element inserted is the first one to get out.</p>
                </article>

                <article id="difference-binary-tree-bst">
                    <h4>2. Difference Between Binary Tree and Binary Search Tree</h4>
                    <p>A Binary Tree is a tree data structure where each node has at most two children, referred to as the left child and the right child. A Binary Search Tree (BST) is a special case of a Binary Tree where the data elements of each node are in order, so that for each node, all elements in the left subtree are less to the node and all elements in the right subtree are greater than the node.</p>
                </article>

                <article id="difference-bst-avl-tree">
                    <h4>3. Difference Between BST and AVL Tree</h4>
                    <p>A Binary Search Tree (BST) is a tree in which all the nodes follow the property that they are larger than all the nodes in their left sub-tree and smaller than all the nodes in their right sub-tree. However, BSTs can become unbalanced with multiple insertions and deletions, which can make search operations slower. An AVL Tree, named after its inventors Adelson-Velsky and Landis, is a self-balancing binary search tree. In an AVL tree, the difference of heights of left and right subtrees for any node is less than or equal to one, ensuring it remains balanced and search operations remain faster.</p>
                </article>

                <article id="difference-b-tree-b-plus-tree">
                    <h4>4. Difference Between B-Tree and B+Tree</h4>
                    <p>B-Tree and B+Tree are both self-balancing tree data structures that maintain sorted data and are commonly used for database indexes and filesystems. B-Tree store data at both leaf and internal nodes, whereas B+Tree stores data only at leaf nodes, with internal nodes only used for distribution purposes. This makes B+Tree more efficient for large data and range queries.</p>
                </article>

                <article id="difference-dijkstra-bellmanford">
                    <h4>5. Difference Between Dijkstra's Algorithm and Bellman Ford Algorithm</h4>
                    <p>Both Dijkstra's Algorithm and the Bellman Ford Algorithm are used to find the shortest path in a graph, but they differ in how they handle edge weights. Dijkstra's Algorithm performs better with positive edge weights but fails in the case of negative edge weights. On the other hand, Bellman Ford's Algorithm can handle negative edge weights and is capable of detecting negative cycles in the graph.</p>
                </article>

            </article>
        </main>

        <script> copyright("all"); </script>
    </body>

</html>
