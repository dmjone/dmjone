<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>

        <title>Scanner Class in Java - CSU1291 - Shoolini U</title>
        <meta name="description" content="Master the Scanner class in Java with the CSU1291 course at Shoolini University. From instantiation, understanding basic input methods, pattern matching, to input validation and more, dive deep with dmj.one.">

        <meta property="og:image" content="/logo.png">
        <meta property="og:type" content="article">

        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@divyamohan1993">
        <meta name="twitter:creator" content="@divyamohan1993">
        <meta name="twitter:image" content="/logo.png">

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />

        <meta name="author" content="Divya Mohan">
        <meta name="robots" content="index, follow">

        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                renderMathInElement(document.body, {
                    // customised options
                    // • auto-render specific keys, e.g.:
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\(', right: '\\)', display: false },
                        { left: '\\[', right: '\\]', display: true }
                    ],
                    // • rendering keys, e.g.:
                    throwOnError: false
                });
            });
        </script>
    </head>

    <body>

        <script> header_author("dm"); </script>

        <main>
            <article>
                <h2 class="text-center">
                    Scanner Class in Java
                </h2>
                <div class="container mt-4 w-100 w-xl-75">
                    <div class="accordion" id="toc">
                        <div class="accordion-item">
                            <h2 class="accordion-header" id="h1">
                                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#c1" aria-controls="c1" aria-expanded="false">
                                    <i class="fas fa-book"></i> <strong>&nbsp;Table of Contents</strong>
                                </button>
                            </h2>
                            <div id="c1" class="accordion-collapse collapse" aria-labelledby="h1" data-bs-parent="#toc">
                                <div class="accordion-body">
                                    <ol class="list-unstyled p-0 m-0">
                                        <li class="p-1"><a href="#intro"><i class="fas fa-chevron-circle-right"></i> Introduction</a></li>
                                        <li class="p-1"><a href="#scanner-instantiation"><i class="fas fa-chevron-circle-right"></i> Scanner Instantiation</a></li>
                                        <li class="p-1"><a href="#basic-input-methods"><i class="fas fa-chevron-circle-right"></i> Basic Input Methods of Java</a></li>
                                        <li class="p-1"><a href="#delimiter-and-pattern"><i class="fas fa-chevron-circle-right"></i> Delimiter and Pattern Matching</a></li>
                                        <li class="p-1"><a href="#input-validation"><i class="fas fa-chevron-circle-right"></i> Input Validation</a></li>
                                        <li class="p-1"><a href="#exception-handling"><i class="fas fa-chevron-circle-right"></i> Exception Handling</a></li>
                                        <li class="p-1"><a href="#closing-scanner"><i class="fas fa-chevron-circle-right"></i> Closing Scanner</a></li>
                                    </ol>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <h3></h3>
            </article>

            <article id="intro">
                <h3>1. Introduction to the Scanner Class in Java</h3>
                <p>The Scanner class is a part of Java's standard library, packaged within <code>java.util</code>. It offers functionalities to read input from various sources like the console, files, and strings. It provides methods to parse primitive types and strings using regular expressions.</p>
            </article>

            <article id="scanner-instantiation">
                <h3>2. Instantiating the Scanner Class</h3>
                <p>Before you can read from a source, you need to create an instance of the Scanner class. The class offers multiple constructors, each for a specific input source.</p>
            </article>
            <article>
                <h4>2.1 Using System.in (Keyboard Input)</h4>
                <p>The <code>System.in</code> object is one of Java's standard I/O streams, representing keyboard input (more precisely, the "standard input" stream). It is often used to read data directly from the user. Let's dive deep into how and why we use it with the <code>Scanner</code> class.</p>
            </article>
            <article>
                <h5>2.1.1 What is System.in?</h5>
                <p>In Java, <code>System</code> is a final class in the <code>java.lang</code> package. This class provides several methods and fields, and among them is the <code>System.in</code> input stream. This stream links to the keyboard input, allowing Java programs to read data entered by the user.</p>
            </article>
            <article>
                <h5>2.1.2 Why Use Scanner with System.in?</h5>
                <p>While <code>System.in</code> by itself allows reading input, it doesn't provide a straightforward mechanism to parse and interpret data. That's where the <code>Scanner</code> class steps in. By passing <code>System.in</code> as an argument to the <code>Scanner</code> constructor, you equip your program with the ability to read and process user input effortlessly.</p>
            </article>
            <article>
                <h5>2.1.3 Instantiating Scanner with System.in</h5>
                <p>To start reading input from the keyboard, instantiate the <code>Scanner</code> class using <code>System.in</code>:</p>
                <pre><code class="language-java">
Scanner scanner = new Scanner(System.in);
</code></pre>
                <p>This line creates an object of the Scanner class named 'scanner'. Now, this 'scanner' object can invoke various methods to read different types of data (like integers, strings, etc.) from the keyboard.</p>
            </article>
            <article>
                <h5>2.1.4 Reading User Input</h5>
                <p>With the 'scanner' object ready, reading input becomes intuitive. For instance, to read an integer or a line of text:</p>
                <pre><code class="language-java">
int userNumber = scanner.nextInt();  // Reads an integer from user
String userInput = scanner.nextLine();  // Reads a line of text
</code></pre>
                <p>Note: After reading an integer using <code>nextInt()</code>, it's a good practice to call <code>nextLine()</code> to consume the newline character left in the buffer. This ensures the subsequent reads work as expected.</p>
            </article>
            <article>
                <h5>2.1.5 Closing the Scanner</h5>
                <p>After you're done with the input operations, it's essential to close the scanner to free up the resources:</p>
                <pre><code class="language-java">
scanner.close();
</code></pre>
                <p>Closing the scanner also closes <code>System.in</code>, meaning you cannot read from it afterwards in the same program. Hence, ensure you've gathered all required inputs before calling <code>close()</code>.</p>

                <p>To sum it up, <code>System.in</code> serves as a bridge between the user's keyboard and the program. The <code>Scanner</code> class acts as a proficient interpreter, making the process of reading and parsing inputs a breeze. As you practice more with Java, this combination will become a staple in many of your programs, especially when beginning with console-based applications.</p>
            </article>
            <article>
                <h4>2.2 Using a File</h4>
                <p>To read from a file, ensure you handle the potential <code>FileNotFoundException</code>.</p>
                <pre><code class="language-java">
File file = new File("path_to_file.txt");
try {
    Scanner fileScanner = new Scanner(file);
} catch (FileNotFoundException e) {
    e.printStackTrace();
}
</code></pre>
            </article>
            <article>
                <h4>2.3 Using a String with Scanner</h4>
                <p>While many associate the `Scanner` class primarily with reading input from the console or files, it also provides functionality to scan and tokenize strings. This ability is particularly useful for parsing and dissecting textual data without relying on external input sources. Let's delve into the details of using the `Scanner` class with strings.</p>
            </article>
            <article>
                <h5>2.3.1 Why Scan a String?</h5>
                <p>Imagine you have a string containing structured data, like CSV (Comma-Separated Values) or textual logs. Instead of manually iterating over the string or using complex string operations, the `Scanner` class offers a more straightforward and readable approach to extract specific values.</p>
            </article>
            <article>
                <h5>2.3.2 Instantiating Scanner with a String</h5>
                <p>To use a `Scanner` with a string, you simply pass the string to the `Scanner` constructor:</p>
                <pre><code class="language-java">
String content = "Hello, World!";
Scanner stringScanner = new Scanner(content);
</code></pre>
                <p>The above code snippet initializes the `Scanner` instance `stringScanner` to tokenize and parse the `content` string.</p>
            </article>
            <article>
                <h5>2.3.3 Reading and Tokenizing the String</h5>
                <p>With the scanner set up, you can use the same methods you'd employ for reading from `System.in`:</p>
                <pre><code class="language-java">
String firstWord = stringScanner.next();  // Reads "Hello,"
</code></pre>
                <p>Note that the default delimiter for a scanner is a whitespace. If you're working with structured data like CSV, you'll need to set a custom delimiter, which is covered in the sections on delimiter settings.</p>
            </article>
            <article>
                <h5>2.3.4 Advantages of Scanning Strings</h5>
                <p>Scanning strings can be incredibly advantageous in multiple scenarios:</p>
                <ul>
                    <li><strong>String Manipulation:</strong> Instead of relying on intricate string functions, you can easily extract specific parts of a string.</li>
                    <li><strong>Data Extraction:</strong> For structured text data, like logs or CSV, you can seamlessly parse and tokenize values.</li>
                    <li><strong>Readability:</strong> The scanner's methods are descriptive and intuitive, enhancing code clarity.</li>
                </ul>
            </article>
            <article>
                <h5>2.3.5 Closing the String Scanner</h5>
                <p>After completing the string scanning operations, it's a best practice to close the scanner:</p>
                <pre><code class="language-java">
stringScanner.close();
</code></pre>
                <p>However, unlike closing a scanner linked to `System.in`, closing a string-based scanner doesn't have side-effects on the underlying source since it's merely a string.</p>

                <p>In conclusion, the `Scanner` class's versatility extends beyond console and file inputs. When provided with a string source, it becomes an invaluable tool for parsing, tokenizing, and data extraction. As you advance in Java, you'll encounter countless scenarios where scanning strings can simplify complex operations, ultimately making your code more efficient and readable.</p>
            </article>

            <article id="basic-input-methods">
                <h3>3. Basic Input Methods</h3>
                <p>The `Scanner` class is equipped with a versatile set of methods tailored for reading different types of data from the source, whether it's a console, file, or string. Let's understand each of these fundamental methods in detail.</p>
            </article>
            <article>
                <h4>3.1 Reading an Integer</h4>
                <p>When you expect the user to provide an integer or if the data source contains integer values, the `Scanner` class has a handy method:</p>
                <pre><code class="language-java">
int number = scanner.nextInt();
</code></pre>
                <p>This method attempts to read and convert the next token in the source into an integer. If the input isn't a valid integer, it throws an `InputMismatchException`.</p>
            </article>
            <article>
                <h5>3.1.1 Common Use Case</h5>
                <p>Reading user age, selecting an option from a menu, or counting items are scenarios where integer inputs are commonly expected.</p>
            </article>
            <article>
                <h4>3.2 Reading a Double</h4>
                <p>For floating-point numbers, which include numbers with decimal places, the method to use is:</p>
                <pre><code class="language-java">
double decimalNumber = scanner.nextDouble();
</code></pre>
                <p>Similar to `nextInt()`, this method reads the next token and tries to convert it into a double value. An `InputMismatchException` will be raised if the token doesn't represent a valid double.</p>
            </article>
            <article>
                <h5>3.2.1 Common Use Case</h5>
                <p>Reading measurements like height, weight, or currency values typically requires the ability to handle decimal points, making this method apt for such inputs.</p>
            </article>
            <article>
                <h4>3.3 Reading a Token as a String</h4>
                <p>When you want to read a single word or token from the input, use:</p>
                <pre><code class="language-java">
String token = scanner.next();
</code></pre>
                <p>By default, this method reads characters until it encounters whitespace (like a space or newline). Thus, it's perfect for reading single, space-separated words.</p>
            </article>
            <article>
                <h5>3.3.1 Common Use Case</h5>
                <p>Fetching usernames, first names, or any single-word data from the input stream are situations where this method shines.</p>
            </article>
            <article>
                <h4>3.4 Reading an Entire Line</h4>
                <p>If you want to capture an entire line of input, which might include spaces:</p>
                <pre><code class="language-java">
String fullLine = scanner.nextLine();
</code></pre>
                <p>This method reads all characters until it reaches a newline character. It's ideal for capturing multi-word input or sentences.</p>
            </article>
            <article>
                <h5>3.4.1 Common Use Case</h5>
                <p>Reading user addresses, feedback, or any multi-word data often necessitates using this method to capture the entire input line.</p>

                <p>Mastering these basic input methods is pivotal in your Java journey. They form the backbone of many interactive applications and are your gateway to collecting and manipulating user data. Always be mindful of the type of input you expect, and choose the method that best suits your requirements. As you harness these tools more, you'll develop an intuition on when and how to deploy them optimally.</p>
            </article>
            <article id="delimiter-and-pattern">
                <h3>4. Delimiter and Pattern Matching</h3>
                <p>The <code>Scanner</code> class in Java provides remarkable flexibility not just in reading different types of inputs but also in how those inputs are interpreted and divided. This capability is primarily achieved through delimiters and pattern matching. Let's dive deeper into these functionalities.</p>
            </article>
            <article>
                <h4>4.1 Setting a Custom Delimiter</h4>
                <p>The default behavior of a `Scanner` instance is to tokenize the input based on whitespace. This includes spaces, tabs, and newline characters. However, in many real-world scenarios, data might be separated using other characters like commas in a CSV file or colons in time representations. Here's where the ability to set a custom delimiter comes in handy.</p>
                <pre><code class="language-java">
scanner.useDelimiter(",");
</code></pre>
                <p>In the code snippet above, the scanner will now use a comma as the delimiter. This means <code>scanner.next()</code> will read input until it encounters a comma.</p>
            </article>
            <article>
                <h5>4.1.1 Considerations for Custom Delimiters</h5>
                <p>While using custom delimiters:</p>
                <ul>
                    <li><strong>Regular Expressions:</strong> The delimiter can be a regular expression, allowing complex tokenization rules.</li>
                    <li><strong>Multiple Characters:</strong> Delimiters aren't restricted to single characters. They can be strings, enabling delimitation based on word sequences or specific character combinations.</li>
                    <li><strong>Escaping Characters:</strong> Some characters in regular expressions have special meanings, like the dot (<code>.</code>). To use them as plain characters, they might need to be escaped using a backslash (<code>\</code>).</li>
                </ul>
            </article>
            <article>
                <h4>4.2 Using Pattern Matching</h4>
                <p>Java's <code>Pattern</code> class is a powerful tool for defining and working with regular expressions. In conjunction with the `Scanner`, you can extract inputs that match specific patterns, making data validation and extraction more streamlined.</p>
                <pre><code class="language-java">
Pattern pattern = Pattern.compile("[a-zA-Z]+");
String matchedToken = scanner.next(pattern);
</code></pre>
                <p>The above code defines a pattern to match sequences of one or more alphabetical characters (both uppercase and lowercase). The <code>scanner.next(pattern)</code> method will then attempt to find the next token that matches this pattern.</p>
            </article>
            <article>
                <h5>4.2.1 Benefits of Pattern Matching</h5>
                <p>Pattern matching provides:</p>
                <ul>
                    <li><strong>Data Validation:</strong> Ensure that the input adheres to a specific format or rule.</li>
                    <li><strong>Complex Extractions:</strong> Extract intricate data formats like date-times, email addresses, or URLs from the input.</li>
                    <li><strong>Enhanced Readability:</strong> Regular expressions can be self-descriptive, making code easier to understand for developers familiar with regex.</li>
                </ul>

                <p>Understanding and leveraging the `Scanner` class's delimiter and pattern matching capabilities can greatly elevate your data input and validation operations in Java. It equips you with tools to precisely define what you expect from the input and how to interpret it, making your applications more robust and user-friendly. As you continue exploring Java, these skills will prove invaluable, especially when dealing with complex data formats and user inputs.</p>
            </article>

            <article id="input-validation">
                <h3>5. Input Validation</h3>
                <p>Ensuring that user input (or input from any source) matches our expectations is a cornerstone of robust software development. A well-constructed program must gracefully handle unexpected inputs. The `Scanner` class in Java provides built-in mechanisms for this, making input validation both straightforward and efficient.</p>
            </article>
            <article>
                <h4>5.1 Checking for Next Token</h4>
                <p>Before attempting to read a token, it's often wise to check if a token is available. This is especially crucial if your application expects continuous input. By checking beforehand, you can avoid potential runtime exceptions.</p>
                <pre><code class="language-java">
if (scanner.hasNext()) {
    String nextToken = scanner.next();
}
</code></pre>
                <p>The <code>hasNext()</code> method returns a boolean value indicating whether another token is available in the input. It's a general-purpose check and doesn't concern itself with the type of the next token.</p>
            </article>
            <article>
                <h5>5.1.1 Why use hasNext()?</h5>
                <p>Using <code>hasNext()</code> can help in:</p>
                <ul>
                    <li><strong>Loop Control:</strong> In scenarios where you're reading multiple values in a loop, this method helps determine the loop's continuation condition.</li>
                    <li><strong>Preventing Errors:</strong> Directly calling input methods without checking can lead to exceptions if the expected input isn't available.</li>
                </ul>
            </article>
            <article>
                <h4>5.2 Validating Integer Input</h4>
                <p>If your program expects an integer input, it's essential to verify the incoming token's type. This can prevent type mismatch errors and guide the user to provide correct input.</p>
                <pre><code class="language-java">
if (scanner.hasNextInt()) {
    int number = scanner.nextInt();
}
</code></pre>
                <p>The <code>hasNextInt()</code> method checks if the next token in the input can be interpreted as an integer. It doesn't consume the token but merely inspects it.</p>
            </article>
            <article>
                <h5>5.2.1 Why Validate Integer Input?</h5>
                <p>Consider a program where you ask the user to enter their age. A valid age should be an integer. By validating the input, you can provide useful feedback like "Please enter a valid age" if they enter something non-numeric.</p>
            </article>
            <article>
                <h4>5.3 Validating Double Input</h4>
                <p>In cases where floating-point numbers are expected, you can verify the next token's type using:</p>
                <pre><code class="language-java">
if (scanner.hasNextDouble()) {
    double value = scanner.nextDouble();
}
</code></pre>
                <p>The <code>hasNextDouble()</code> method inspects if the next available token can be mapped to a double value, ensuring the input's validity before actual reading.</p>
            </article>
            <article>
                <h5>5.3.1 The Significance of Double Validation</h5>
                <p>For applications dealing with financial transactions, measurements, or scientific calculations, ensuring that inputs are valid doubles is essential. This prevents computational errors and ensures data consistency.</p>

                <p>Validating input is like constructing a safety net for your application. It keeps unexpected and erroneous inputs at bay and ensures a smooth user experience. As a Java developer, mastering input validation with the `Scanner` class will empower you to create resilient and user-friendly applications. Remember, the quality of an application isn't just about what it can do but also about how gracefully it handles unexpected situations.</p>
            </article>

            <article id="exception-handling">
                <h3>6. Exception Handling with Scanner</h3>
                <p>In Java, exception handling is a powerful mechanism to manage runtime errors, ensuring that your program can respond to unexpected situations gracefully. While working with the `Scanner` class, certain exceptions can emerge based on the input source and the kind of operations we perform. Understanding these exceptions allows us to create more resilient and user-friendly programs.</p>
            </article>
            <article>
                <h4>6.1 InputMismatchException</h4>
                <p>This exception is thrown when an attempt is made to retrieve a token using the next method of a particular type, but the next available token is inconsistent with the expected type.</p>
                <pre><code class="language-java">
try {
    int value = scanner.nextInt();
} catch (InputMismatchException e) {
    System.out.println("Please enter a valid integer.");
    scanner.nextLine(); // clear the invalid token
}
</code></pre>
                <p><strong>Key Takeaways:</strong></p>
                <ul>
                    <li>The <code>nextInt()</code> method expects the next token to be an integer. If it's not, <code>InputMismatchException</code> is thrown.</li>
                    <li>After catching this exception, it's a good practice to clear the invalid token by calling the <code>nextLine()</code> method. This ensures the Scanner is reset, and future reads won't be impacted by the erroneous input.</li>
                </ul>
            </article>
            <article>
                <h4>6.2 NoSuchElementException</h4>
                <p>A <code>NoSuchElementException</code> is thrown when one tries to fetch a token that doesn't exist. It can also occur if you're reading from a file, and you've reached the end without realizing it.</p>
                <pre><code class="language-java">
try {
    String token = scanner.next();
} catch (NoSuchElementException e) {
    System.out.println("No more tokens available.");
}
</code></pre>
                <p><strong>Key Takeaways:</strong></p>
                <ul>
                    <li>Always be cautious when continuously reading tokens, especially when you're uncertain about the input's length or content.</li>
                    <li>Using methods like <code>hasNext()</code> before invoking <code>next()</code> can prevent this exception in many scenarios.</li>
                </ul>
            </article>
            <article>
                <h5>6.3 IllegalStateException</h5>
                <p>This exception emerges when one tries to perform an operation on a Scanner that has been closed.</p>
                <pre><code class="language-java">
try {
    scanner.close();
    String token = scanner.next(); // Scanner is already closed!
} catch (IllegalStateException e) {
    System.out.println("Scanner is closed. Cannot read input.");
}
</code></pre>
                <p><strong>Key Takeaways:</strong></p>
                <ul>
                    <li>Once a `Scanner` is closed, it cannot be reopened. All subsequent operations on it will throw this exception.</li>
                    <li>It's crucial to ensure the sequence of operations, especially when working with resources like files.</li>
                </ul>
            </article>

            <article id="closing-scanner">
                <h3>7. Properly Closing the Scanner</h3>
                <p>The Java platform emphasizes not just on the creation and usage of resources but also on their proper disposal. Every system resource we use, whether it's a file handle, network socket, or simply a Scanner for input, should be managed carefully to ensure system stability and prevent resource leaks.</p>
            </article>
            <article>
                <h4>7.1 Importance of Closing a Scanner</h4>
                <p>When we initialize a `Scanner` object, particularly when linked to external resources like files, it acquires some system resources. Keeping them open indefinitely can lead to:</p>
                <ul>
                    <li><strong>Resource Leaks:</strong> Over time, if resources are repeatedly allocated without being released, the system may run out of these resources.</li>
                    <li><strong>Data Corruption:</strong> When reading/writing from/to files, not closing a Scanner can sometimes prevent other operations on the file, potentially leading to data inconsistencies.</li>
                    <li><strong>Unexpected Behaviors:</strong> Some changes might not reflect immediately if the resource isn't closed, leading to unpredictable behaviors.</li>
                </ul>
            </article>
            <article>
                <h4>7.2 How to Close a Scanner</h4>
                <p>Closing a `Scanner` is straightforward:</p>
                <pre><code class="language-java">scanner.close();</code></pre>
                <p>Once closed, the `Scanner` object cannot be reused to read from the input source unless re-instantiated.</p>
            </article>
            <article>
                <h5>7.2.1 A Word of Caution</h5>
                <p>If a `Scanner` is initialized using `System.in`, be careful when closing it. Once closed, you won't be able to read from `System.in` elsewhere in the program unless you employ alternative methods or restart the application.</p>
            </article>
            <article>
                <h4>7.3 Ensuring Resource Closure with try-with-resources</h4>
                <p>Java 7 introduced the try-with-resources statement, which ensures that each resource is closed at the end of the statement. The `Scanner` class implements the `AutoCloseable` interface, making it eligible for use with try-with-resources:</p>
                <pre><code class="language-java">
try (Scanner scanner = new Scanner(new File("input.txt"))) {
    // Use scanner
} // Scanner will be auto-closed here, no need for explicit scanner.close()
</code></pre>

                <p>Utilizing try-with-resources ensures that resources like `Scanner` are automatically closed, minimizing the risk of resource leaks.</p>

                <p>Always be diligent about resource management in programming. Small habits, like timely closing of resources, can profoundly impact the efficiency, safety, and reliability of your applications. As you journey forward in the vast realm of Java, remember to code responsibly!</p>
            </article>
            <article id="further-adventures">
                <h3>8. Your Journey Ahead</h3>
                <p>With the foundation laid, it's imperative to explore more about Java's vast libraries and capabilities. Don't just read - practice. Every line of code written is a step towards becoming a proficient Java developer. Embrace challenges, foster curiosity, and may your coding journey be ever enlightening!</p>
            </article>
        </main>

        <script> copyright("all"); </script>

    </body>

</html>
