<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>

        <title>Providing Input in Java - CSU1291 - Shoolini U</title>
        <meta name="description" content="Dive into the intricacies of providing input in Java as part of the CSU1291 course at Shoolini University. From Scanner instantiation to input validation, delve into various aspects with dmj.one.">


        <meta property="og:image" content="/logo.png">
        <meta property="og:type" content="article">

        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@divyamohan1993">
        <meta name="twitter:creator" content="@divyamohan1993">
        <meta name="twitter:image" content="/logo.png">

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />

        <meta name="author" content="Divya Mohan">
        <meta name="robots" content="index, follow">

        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                renderMathInElement(document.body, {
                    // customised options
                    // • auto-render specific keys, e.g.:
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\(', right: '\\)', display: false },
                        { left: '\\[', right: '\\]', display: true }
                    ],
                    // • rendering keys, e.g.:
                    throwOnError: false
                });
            });
        </script>
    </head>

    <body>

        <script> header_author("dm"); </script>

        <main>
            <article>
                <h2 class="text-center">
                    Providing Input in Java
                </h2>
                <div class="container mt-4 w-100 w-xl-75">
                    <div class="accordion" id="toc">
                        <div class="accordion-item">
                            <h2 class="accordion-header" id="h1">
                                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#c1" aria-controls="c1" aria-expanded="false">
                                    <i class="fas fa-book"></i> <strong>&nbsp;Table of Contents</strong>
                                </button>
                            </h2>
                            <div id="c1" class="accordion-collapse collapse" aria-labelledby="h1" data-bs-parent="#toc">
                                <div class="accordion-body">
                                    <ol class="list-unstyled p-0 m-0">
                                        <li class="p-1"><a href="#intro"><i class="fas fa-chevron-circle-right"></i> Introduction</a></li>
                                        <li class="p-1"><a href="#using-scanner-class"><i class="fas fa-chevron-circle-right"></i> Input Using Scanner Class in Java</a></li>
                                        <li class="p-1"><a href="#command-line-arguments"><i class="fas fa-chevron-circle-right"></i> Input Using CLI in Java</a></li>
                                        <li class="p-1"><a href="#reading-from-files"><i class="fas fa-chevron-circle-right"></i> Reading from Files in Java</a></li>
                                        <li class="p-1"><a href="#advanced-input-methods"><i class="fas fa-chevron-circle-right"></i> Input Using DataInputStream, GUI, Database in Java</a></li>
                                        <li class="p-1"><a href="#web-based-input"><i class="fas fa-chevron-circle-right"></i> Input Using Web Socket and Web based input in Java</a></li>
                                    </ol>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <h3></h3>
            </article>

            <article id="intro">
                <h3>1. Introduction to Input in Java</h3>
                <p>Every application requires interaction, whether it's fetching data from a file, reading user input, or acquiring information from a network. Java, being a versatile language, provides several methods for accepting inputs. This article explores these methods, ensuring clarity for both beginners and those looking to delve deeper into the language.</p>
            </article>

            <article id="using-scanner-class">
                <h3>2. Using the Scanner Class</h3>
                <p>The <code>Scanner</code> class, part of Java's <code>java.util</code> package, is one of the most common tools for reading input. It can parse various data types and offers methods for reading text, numbers, and even patterns.</p>
            </article>
            <article>
                <h4>2.1 Reading Text Input</h4>

                <p>In Java, the <code>Scanner</code> class is a versatile tool specifically designed to parse primitive types and strings using regular expressions. Its most frequent use is for obtaining user input, as it offers several methods tailored to read various kinds of input from the standard input stream, typically the keyboard.</p>
            </article>
            <article>
                <h5>2.1.1 Initializing the Scanner Class</h5>
                <p>To begin, we need to import the <code>Scanner</code> class from the <code>java.util</code> package. Following this, an instance of the <code>Scanner</code> class is created, taking <code>System.in</code> as a parameter. Here, <code>System.in</code> refers to the standard input stream, which, by default, is the keyboard:</p>
                <pre><code class="language-java">import java.util.Scanner;
Scanner scanner = new Scanner(System.in);
</code></pre>
            </article>
            <article>
                <h5>2.1.2 Reading a Single Word</h5>
                <p>Once the scanner is initialized, we can begin reading input. The <code>next()</code> method is used to obtain the next complete token as a string. By default, a token is considered to be a sequence of characters separated by whitespace:</p>
                <pre><code class="language-java">String word = scanner.next();
</code></pre>
                <p>For instance, if a user enters "John Doe", only "John" would be captured using the <code>next()</code> method, as the space denotes the end of the token.</p>
            </article>
            <article>
                <h5>2.1.3 Displaying User Input</h5>
                <p>After reading the input, it's often necessary to provide feedback to the user. In the example provided, the input (user's name) is displayed back to them using the <code>System.out.println()</code> method. This gives a confirmation of the input received:</p>
                <pre><code class="language-java">System.out.println("Hello, " + name + "!");
</code></pre>
                <p>This line concatenates the literal string "Hello, " with the user's input and an exclamation mark to form a greeting, which is then printed to the console.</p>
            </article>
            <article>
                <h5>2.1.4 Complete Example Explained</h5>
                <p>Let's break down the entire code snippet:</p>
                <pre><code class="language-java">import java.util.Scanner;  // Importing the necessary class

public class InputExample {  // Defining our public class
    public static void main(String[] args) {  // Main method, where our program starts
        Scanner scanner = new Scanner(System.in);  // Creating an instance of the Scanner class
        System.out.println("Enter your name:");  // Prompting the user to enter their name
        String name = scanner.next();  // Reading the user input
        System.out.println("Hello, " + name + "!");  // Displaying the input back to the user
    }
}</code></pre>

                <p>In this example, the program prompts the user to enter their name. When they input a name (e.g., "John"), the program will respond with a greeting like "Hello, John!" However, as mentioned, if the user enters more than one word without any delimiter settings, only the first word will be captured.</p>
            </article>
            <article>
                <h5>2.1.5 Reading a Full Line with Spaces</h5>
                <p>As mentioned earlier, the <code>next()</code> method only captures input until the first whitespace. But what if you want to read an entire line, including spaces? The <code>Scanner</code> class provides a method called <code>nextLine()</code> specifically for this purpose:</p>

                <pre><code class="language-java">String fullLine = scanner.nextLine();</code></pre>

                <p>This method reads all characters input until it encounters a newline character (i.e., when the user presses the Enter key). For instance, if a user inputs "John Doe", the entire string, including the space, will be captured using the <code>nextLine()</code> method.</p>

                <p>However, there's a common pitfall to watch out for when combining <code>next()</code>, <code>nextLine()</code>, or other <code>Scanner</code> methods. The <code>next()</code> methods do not consume the newline character, so if you were to call <code>next()</code> and then <code>nextLine()</code>, the latter would immediately return an empty string because it reads the lingering newline character.</p>
            </article>
            <article>
                <h5>2.1.6 Using Delimiters with Scanner</h5>
                <p>The <code>Scanner</code> class allows you to set custom delimiters using the <code>useDelimiter()</code> method. This can be useful when you want to read input until a specific character or a sequence of characters is encountered.</p>

                <pre><code class="language-java">scanner.useDelimiter(";");
String inputUntilSemicolon = scanner.next();
</code></pre>

                <p>In the above example, the input will be read until a semicolon is encountered. If a user enters "Hello;World", the scanner will capture "Hello" as the input and stop at the semicolon.</p>
            </article>
            <article>
                <h5>2.1.7 Putting It All Together</h5>
                <p>Let's look at a more comprehensive example that combines these methods:</p>

                <pre><code class="language-java">import java.util.Scanner;

public class DetailedInputExample {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.println("Enter your first name:");
        String firstName = scanner.next();  // Reading a single token

        System.out.println("Enter your full name:");
        scanner.nextLine();  // Consume lingering newline
        String fullName = scanner.nextLine();  // Reading a full line

        System.out.println("Enter your favorite quote, terminate with ';':");
        scanner.useDelimiter(";");
        String quote = scanner.next();  // Reading until semicolon

        System.out.println("Hello, " + firstName + "!");
        System.out.println("Your full name is: " + fullName);
        System.out.println("Your favorite quote is: " + quote);
    }
}
</code></pre>

                <p>This code snippet showcases various ways to gather input, depending on the user's needs and the nature of the input being sought. It effectively demonstrates how to fetch single tokens, entire lines, and delimited input.</p>
            </article>

            <article>
                <h4>2.2 Reading Numeric Values</h4>

                <p>Java, as a statically-typed language, differentiates between various numeric data types. The <code>Scanner</code> class simplifies the process of obtaining numeric inputs and automatically converts the textual representation into its corresponding numeric data type. For beginners, this means less hassle with type conversions.</p>
            </article>
            <article>
                <h5>2.2.1 Reading Integers</h5>
                <p>To capture whole numbers provided by the user, the <code>nextInt()</code> method of the <code>Scanner</code> class can be employed. It reads the next token of the input as an <code>int</code>.</p>

                <pre><code class="language-java">System.out.println("Enter an integer:");
int number = scanner.nextInt();
System.out.println("You entered: " + number);
</code></pre>
                <p>In the above example, if the user enters "42", the program will output "You entered: 42". However, if the user inputs a non-integer value or a value outside the range of the <code>int</code> data type, a runtime exception will occur.</p>
            </article>
            <article>
                <h5>2.2.2 Reading Floating-Point Numbers</h5>
                <p>For numbers with decimal points, the <code>Scanner</code> class offers the <code>nextDouble()</code> method. This method captures the next token as a <code>double</code>, a data type that can hold decimal values.</p>

                <pre><code class="language-java">System.out.println("Enter a decimal number:");
double decimal = scanner.nextDouble();
System.out.println("You entered: " + decimal);
</code></pre>
                <p>For instance, inputting "3.14" will result in the output "You entered: 3.14". Similar to <code>nextInt()</code>, if the input doesn't match the expected format (in this case, a valid double representation), a runtime exception is triggered.</p>
            </article>
            <article>
                <h5>2.2.3 Handling Invalid Inputs</h5>
                <p>For beginners, it's crucial to be aware of and handle potential input mismatches. For example, entering a letter when a number is expected can cause an <code>InputMismatchException</code>. One way to handle such scenarios is by using a combination of the <code>hasNextInt()</code> or <code>hasNextDouble()</code> methods with conditional statements and loops.</p>

                <pre><code class="language-java">System.out.println("Enter an integer:");
while(!scanner.hasNextInt()) {
    System.out.println("That's not a valid integer. Try again:");
    scanner.next();  // Clear the invalid input
}
int validNumber = scanner.nextInt();
</code></pre>
                <p>This loop will continue prompting the user for a valid integer until a correct input is provided. The <code>scanner.next()</code> inside the loop serves to clear the invalid input, preventing an infinite loop.</p>
            </article>
            <article>
                <h5>2.2.4 Other Numeric Types</h5>
                <p>While <code>int</code> and <code>double</code> are commonly used numeric data types, the <code>Scanner</code> class also provides methods for other numeric types such as <code>nextFloat()</code> for floating-point numbers with lesser precision and <code>nextLong()</code> for long integers. Choosing the appropriate method and data type depends on the specific needs of your application.</p>

                <p>The <code>Scanner</code> class greatly streamlines the process of reading and converting numeric input in Java. However, as with any tool, understanding its functions and potential pitfalls ensures it's utilized effectively.</p>
            </article>
            <article>
                <h4>2.3 Reading Lines</h4>

                <p>Reading entire lines of input is a common requirement, especially when the input consists of sentences or paragraphs. The <code>Scanner</code> class in Java offers a handy method called <code>nextLine()</code> to achieve this.</p>
            </article>
            <article>
                <h5>2.3.1 Basics of the nextLine() Method</h5>
                <p>The <code>nextLine()</code> method captures all characters from the current position until it encounters a newline character, typically when the user presses the Enter key. This makes it particularly useful for obtaining multi-word inputs, sentences, or any input that can contain spaces.</p>

                <pre><code class="language-java">System.out.println("Enter a sentence:");
String fullText = scanner.nextLine();
System.out.println("You entered: " + fullText);
</code></pre>
                <p>For instance, if the user inputs "Java is awesome!", the program will output "You entered: Java is awesome!"</p>
            </article>
            <article>
                <h5>2.3.2 Considerations with nextLine()</h5>
                <p>While <code>nextLine()</code> is straightforward, there are some aspects to be wary of:</p>
                <ul>
                    <li>If you've previously used methods like <code>nextInt()</code> or <code>nextDouble()</code>, be aware that they don't consume the newline character. This means the subsequent <code>nextLine()</code> call will read that leftover newline and may appear to skip input. To avoid this, you can place an additional <code>nextLine()</code> call to consume the lingering newline character.</li>
                    <li>When reading multiple lines of input in succession, ensure to handle the newline characters appropriately to avoid unexpected behavior.</li>
                </ul>
            </article>
            <article>
                <h5>2.3.3 Example of Combining nextInt() and nextLine()</h5>
                <p>To showcase the potential issue and its solution, let's examine the following code:</p>

                <pre><code class="language-java">System.out.println("Enter your age:");
int age = scanner.nextInt();

// Consume lingering newline
scanner.nextLine();

System.out.println("Enter your favorite quote:");
String quote = scanner.nextLine();

System.out.println("Age: " + age + "\nQuote: " + quote);
</code></pre>
                <p>In this example, after inputting an integer for age, we explicitly consume the lingering newline character using <code>nextLine()</code> before reading the next line of input for the quote.</p>
            </article>
            <article>
                <h5>2.3.4 Real-World Applications</h5>
                <p>Reading full lines of input is beneficial in various scenarios:</p>
                <ul>
                    <li>Collecting full names, addresses, or any data that might contain spaces.</li>
                    <li>Reading entire paragraphs or blocks of text.</li>
                    <li>Processing user commands in CLI (Command Line Interface) applications where commands might have multiple words.</li>
                </ul>

                <p>Understanding the methods like <code>nextLine()</code> and how they interact with other <code>Scanner</code> methods, with practice, you can smoothly handle any user input scenario in your applications.</p>
            </article>
            <article>
                <h4>2.4 Pattern and Token-based Reading</h4>

                <p>The <code>Scanner</code> class is versatile and goes beyond reading simple lines of text or numeric values. It can also be employed for pattern matching and tokenizing input based on a specific delimiter. This functionality is immensely useful when dealing with structured data inputs, such as CSV files or user input in a specific format.</p>
            </article>
            <article>
                <h5>2.4.1 Setting a Delimiter</h5>
                <p>By default, the <code>Scanner</code> uses whitespace as a delimiter. However, you can customize this using the <code>useDelimiter()</code> method. Once set, the <code>next()</code> method will read input until it reaches the specified delimiter.</p>

                <pre><code class="language-java">System.out.println("Enter two values separated by a comma:");
scanner.useDelimiter(",");
String first = scanner.next();
String second = scanner.next();
System.out.println("First value: " + first + "\nSecond value: " + second);
</code></pre>

                <p>For example, if a user enters "apple,orange", the program will display:</p>
                <pre><code>First value: apple
Second value: orange
</code></pre>
            </article>
            <article>
                <h5>2.4.2 Utilizing Patterns with Scanner</h5>
                <p>The true power of the <code>Scanner</code> class lies in its ability to use Java's regular expression capabilities. The delimiter set by <code>useDelimiter()</code> can be a regular expression, enabling more complex pattern matching.</p>

                <pre><code class="language-java">scanner.useDelimiter("\\s*(and|or)\\s*");
while (scanner.hasNext()) {
    System.out.println(scanner.next());
}
</code></pre>
                <p>Given the input "apple and banana or cherry", the output will be:</p>
                <pre><code>apple
banana
cherry
</code></pre>
            </article>
            <article>
                <h5>2.4.3 Reading Input with Multiple Delimiters</h5>
                <p>Often, data inputs might have more than one type of delimiter. In such cases, you can use regular expressions to account for multiple delimiters. For instance, to tokenize input separated by commas, semicolons, or spaces, the code would be:</p>

                <pre><code class="language-java">scanner.useDelimiter("[,;\\s]+");
</code></pre>

                <p>Now, an input like "apple,banana;cherry mango" will be tokenized into "apple", "banana", "cherry", and "mango".</p>

                <h5>2.4.4 Practical Applications</h5>
                <p>Pattern and token-based reading are particularly useful in:</p>
                <ul>
                    <li>Parsing structured data, like CSV or TSV files.</li>
                    <li>Breaking input into meaningful chunks for further processing.</li>
                    <li>Creating simple parsers for domain-specific languages.</li>
                </ul>
            </article>

            <article id="command-line-arguments">
                <h3>3. Command Line Arguments</h3>
                <p>Command-line arguments provide a direct way to pass information to Java applications during their launch. These arguments are stored in the <code>String[] args</code> parameter of the <code>main()</code> method.</p>
                <pre><code class="language-java">public class CmdExample {
    public static void main(String[] args) {
        for (String arg : args) {
            System.out.println(arg);
        }
    }
}
</code></pre>
                <p>When this program is executed with arguments, it will print each argument on a new line.</p>
            </article>

            <article id="reading-from-files">
                <h3>4. Reading from Files</h3>
                <p>Java provides numerous ways to read data from files. This approach is essential for processing large datasets, configurations, or any other file-based data source.</p>
            </article>
            <article>
                <h4>4.1 Using FileReader</h4>
                <p>The <code>FileReader</code> class helps in reading character files. Here’s a simple example:</p>
                <pre><code class="language-java">import java.io.FileReader;

public class FileReaderExample {
    public static void main(String[] args) throws Exception {
        FileReader reader = new FileReader("example.txt");
        int character;
        while ((character = reader.read()) != -1) {
            System.out.print((char) character);
        }
        reader.close();
    }
}
</code></pre>
            </article>
            <article>
                <h4>4.2 Using BufferedReader</h4>
                <p>For efficient reading of characters, arrays, and lines, <code>BufferedReader</code> is preferred, especially for larger files:</p>
                <pre><code class="language-java">import java.io.BufferedReader;
import java.io.FileReader;

public class BufferedReaderExample {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new FileReader("example.txt"));
        String line;
        while ((line = br.readLine()) != null) {
            System.out.println(line);
        }
        br.close();
    }
}
</code></pre>
            </article>
            <article>
                <h4>4.3 Using Scanner with a File</h4>
                <p>The flexibility of the Scanner class extends to files, making reading data types from files effortless:</p>
                <pre><code class="language-java">Scanner fileScanner = new Scanner(new File("example.txt"));
while (fileScanner.hasNextLine()) {
    System.out.println(fileScanner.nextLine());
}
fileScanner.close();
</code></pre>
            </article>

            <article id="advanced-input-methods">
                <h3>5. Advanced Input Methods</h3>
                <p>As applications become more complex, the need for diverse input methods rises. Java addresses this with more advanced techniques such as streams, sockets, and GUI interfaces.</p>
            </article>
            <article>
                <h4>5.1 Using DataInputStream and ObjectInputStream</h4>

                <p>Java provides specialized stream classes for handling different types of I/O requirements. Among these, <code>DataInputStream</code> and <code>ObjectInputStream</code> are essential for reading binary data and Java objects, respectively. Let's delve deeper into their workings and utility.</p>
            </article>
            <article>
                <h5>5.1.1 Basics of DataInputStream</h5>
                <p><code>DataInputStream</code> allows you to read Java primitives in a machine-independent way from a binary stream, typically files. It's essential when handling data that requires a binary representation, like images, audio files, or custom binary file formats.</p>
            </article>
            <article>
                <h5>5.1.2 Example with DataInputStream</h5>
                <p>The following code snippet reads an integer and a double value from a binary file using <code>DataInputStream</code>:</p>

                <pre><code class="language-java">import java.io.DataInputStream;
import java.io.FileInputStream;

public class DataStreamExample {
    public static void main(String[] args) throws Exception {
        DataInputStream in = new DataInputStream(new FileInputStream("data.bin"));
        
        int number = in.readInt();
        double decimalValue = in.readDouble();
        
        in.close();
        
        System.out.println("Read integer: " + number);
        System.out.println("Read double: " + decimalValue);
    }
}
</code></pre>
            </article>
            <article>
                <h5>5.1.3 Reading Objects with ObjectInputStream</h5>
                <p><code>ObjectInputStream</code> and its counterpart, <code>ObjectOutputStream</code>, enable serialization and deserialization of Java objects. Serialization is the process of converting a Java object's state into a byte stream, while deserialization restores these objects.</p>

                <p>For an object to be serializable, its class must implement the <code>Serializable</code> interface. This interface acts as a marker, signaling that the class's objects can be serialized.</p>
            </article>
            <article>
                <h5>5.1.4 Example with ObjectInputStream</h5>
                <p>Consider a simple <code>Person</code> class that implements <code>Serializable</code>:</p>

                <pre><code class="language-java">import java.io.Serializable;

public class Person implements Serializable {
    private String name;
    private int age;
    
    // Constructors, getters, setters...
}
</code></pre>

                <p>Here's how you can deserialize or read an object of this class:</p>

                <pre><code class="language-java">import java.io.ObjectInputStream;
import java.io.FileInputStream;

public class ObjectStreamExample {
    public static void main(String[] args) throws Exception {
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream("person.obj"));
        
        Person person = (Person) ois.readObject();
        
        ois.close();
        
        System.out.println("Name: " + person.getName());
        System.out.println("Age: " + person.getAge());
    }
}
</code></pre>
            </article>
            <article>
                <h5>5.1.5 Practical Applications and Considerations</h5>
                <p>While these stream classes provide powerful tools for data and object I/O, there are aspects to be mindful of:</p>
                <ul>
                    <li>When using <code>ObjectInputStream</code>, ensure the serialized class's structure hasn't changed between serialization and deserialization, as this can lead to errors.</li>
                    <li>While serializing, transient variables and static variables are not saved. Transient variables are those that shouldn't be serialized.</li>
                    <li>Reading data with <code>DataInputStream</code> requires knowledge of the order and type of data written. Mistakes here can lead to <code>EOFException</code> or data corruption.</li>
                </ul>

                <p>These stream classes, when used correctly, form the backbone of many Java applications, enabling them to handle a diverse range of I/O requirements efficiently.</p>
            </article>

            <article>
                <h4>5.2 Reading from a Network Socket</h4>
                <p>Java supports network operations, making reading data over sockets feasible:</p>
                <pre><code class="language-java">import java.io.InputStream;
import java.net.Socket;

public class SocketExample {
    public static void main(String[] args) throws Exception {
        Socket socket = new Socket("example.com", 80);
        InputStream in = socket.getInputStream();
        // read data from the stream...
        in.close();
        socket.close();
    }
}
</code></pre>
            </article>
            <article>
                <h4>5.3 GUI-based Input</h4>
                <p>For desktop applications, Java offers libraries like Swing and JavaFX to build graphical user interfaces that can accept input:</p>
                <pre><code class="language-java">// A simple Swing input example
import javax.swing.JOptionPane;

public class GuiInput {
    public static void main(String[] args) {
        String name = JOptionPane.showInputDialog("Enter your name:");
        JOptionPane.showMessageDialog(null, "Hello, " + name + "!");
    }
}
</code></pre>
            </article>
            <article>
                <h4>5.4 Database Input</h4>
                <p>Using JDBC (Java Database Connectivity), we can read data from databases:</p>
                <pre><code class="language-java">import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;

public class DatabaseInput {
    public static void main(String[] args) throws Exception {
        Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/mydb", "user", "password");
        Statement stmt = conn.createStatement();
        ResultSet rs = stmt.executeQuery("SELECT * FROM users");
        while (rs.next()) {
            System.out

.println(rs.getString("name"));
        }
        rs.close();
        stmt.close();
        conn.close();
    }
}
</code></pre>
            </article>

            <article id="web-based-input">
                <h3>6. Web-based Input</h3>
                <p>Java provides the capability to develop web applications using Servlets and JSPs. These tools enable developers to fetch data input from web forms:</p>
                <pre><code class="language-java">// A simple Servlet example
import javax.servlet.*;
import javax.servlet.http.*;

public class InputServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String name = request.getParameter("name");
        response.getWriter().write("Hello, " + name + "!");
    }
}
</code></pre>
                <p>Here, the data sent via an HTTP POST request from a web form is captured and processed.</p>
            </article>

            <article id="moving-forward">
                <h3>7. Moving Forward</h3>
                <p>Java's vast array of input methods caters to almost every conceivable application need. From console-based input to networked data exchanges, Java has proven its versatility and robustness. It's essential to grasp these foundational concepts as they pave the way to more complex topics in Java. With this knowledge, you're now better equipped to harness Java's power for your applications. Embrace the journey of continuous learning, and let Java's rich ecosystem guide you to new heights!</p>
            </article>
        </main>

        <script> copyright("all"); </script>

    </body>

</html>
