<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>

        <title>Concepts of Java - CSU1291 - Shoolini U</title>
        <meta name="description" content="Kmow more about the core concepts of Java, part of the CSU1291 course at Shoolini University. Covering topics from its characteristics to the JVM, enhance your understanding with dmj.one.">

        <meta property="og:image" content="/logo.png">
        <meta property="og:type" content="article">

        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@divyamohan1993">
        <meta name="twitter:creator" content="@divyamohan1993">
        <meta name="twitter:image" content="/logo.png">

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />

        <meta name="author" content="Divya Mohan">
        <meta name="robots" content="index, follow">

        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                renderMathInElement(document.body, {
                    // customised options
                    // • auto-render specific keys, e.g.:
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\(', right: '\\)', display: false },
                        { left: '\\[', right: '\\]', display: true }
                    ],
                    // • rendering keys, e.g.:
                    throwOnError: false
                });
            });
        </script>
    </head>

    <body>

        <script> header_author("dm"); </script>

        <main>
            <article>
                <h2 class="text-center">
                    Concepts of Java
                </h2>                
                <div class="container mt-4 w-100 w-xl-75">
                    <div class="accordion" id="toc">
                        <div class="accordion-item">
                            <h2 class="accordion-header" id="h1">
                                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#c1" aria-controls="c1" aria-expanded="false">
                                    <i class="fas fa-book"></i> <strong>&nbsp;Table of Contents</strong>
                                </button>
                            </h2>
                            <div id="c1" class="accordion-collapse collapse" aria-labelledby="h1" data-bs-parent="#toc">
                                <div class="accordion-body">
                                    <ol class="list-unstyled p-0 m-0">
                                        <li class="p-1"><a href="#intro"><i class="fas fa-chevron-circle-right"></i> Introduction and Characteristics of Java</a></li>
                                        <li class="p-1"><a href="#core-language-syntax-semantics"><i class="fas fa-chevron-circle-right"></i> Syntax and Semantics</a></li>
                                        <li class="p-1"><a href="#oop-in-java"><i class="fas fa-chevron-circle-right"></i> OOP in Java</a></li>
                                        <li class="p-1"><a href="#core-libraries"><i class="fas fa-chevron-circle-right"></i> Core Libraries</a></li>
                                        <li class="p-1"><a href="#exception-handling"><i class="fas fa-chevron-circle-right"></i> Exception Handling</a></li>
                                        <li class="p-1"><a href="#java-io"><i class="fas fa-chevron-circle-right"></i> Java I/O</a></li>
                                        <li class="p-1"><a href="#concurrency"><i class="fas fa-chevron-circle-right"></i> Concurrency</a></li>
                                        <li class="p-1"><a href="#jvm"><i class="fas fa-chevron-circle-right"></i> JVM</a></li>
                                    </ol>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <h3></h3>
            </article>

            <article id="intro">
                <h3>1. Introduction to Java</h3>
                <p>Java, devised by James Gosling and introduced by Sun Microsystems in 1995, champions the "Write Once, Run Anywhere" philosophy through the Java Virtual Machine (JVM) using bytecode. This versatile, object-oriented language is celebrated for blending simplicity with efficiency.</p>
            </article>
            <article>
                <p>The language's success and longevity can be attributed to several key characteristics:</p>

                <h4>1.1 Simplicity</h4>
                <p>The creators of Java aimed to design a language that was easier to use than C++ but retained its powerful capabilities. In this endeavor:</p>
                <ul>
                    <li>Java discarded the use of pointers, which are notorious for being a source of errors.</li>
                    <li>Memory management in Java is automated, with a feature called Garbage Collection, minimizing the risk of memory leaks.</li>
                    <li>It supports a rich set of APIs (Application Programming Interfaces) which simplify tasks ranging from file handling to network communication.</li>
                    <li>The language syntax is clean, with a focus on readability, which aids in reducing the complexity of code.</li>
                </ul>
            </article>
            <article>
                <h4>1.2 Portability</h4>
                <p>One of the pioneering visions behind Java was its ability to be platform-independent. This is achieved through:</p>
                <ul>
                    <li><b>Bytecode:</b> Instead of compiling code directly into machine language, Java compiles into an intermediate form called bytecode. This bytecode is then interpreted or compiled at runtime by the JVM, making it adaptable to any operating system or platform that has a JVM.</li>
                    <li><b>Standard Libraries:</b> Java provides a standard set of libraries which ensures that Java applications behave consistently across all platforms.</li>
                    <li><b>Network Centric:</b> Java was designed in the early days of the internet, with built-in support for web and network operations, making it ideal for internet-based applications.</li>
                </ul>
            </article>
            <article>
                <h4>1.3 Performance-Oriented</h4>
                <p>While initially, Java faced criticism for its performance, significant advancements have been made over the years:</p>
                <ul>
                    <li><b>Just-In-Time (JIT) Compilation:</b> Instead of interpreting bytecode line by line, the JIT compiler translates bytecode into native machine instructions, which are directly executed by the host machine, drastically improving performance.</li>
                    <li><b>Optimized Libraries:</b> Java's standard libraries have been heavily optimized over the years, providing efficient data structures and algorithms.</li>
                    <li><b>Hardware Acceleration:</b> Modern JVMs can leverage hardware acceleration for tasks like graphics rendering, improving the performance of graphic-intensive applications.</li>
                </ul>
            </article>
            <article>
                <h4>1.4 Security</h4>
                <p>Java places a strong emphasis on security:</p>
                <ul>
                    <li><b>Bytecode Verification:</b> Before execution, bytecode is checked for any malicious code or potential issues.</li>
                    <li><b>Sandboxing:</b> Java applets, which run in web browsers, operate in a sandbox environment, restricting them from accessing certain resources on the local machine, thus safeguarding the user.</li>
                    <li><b>Classloaders:</b> They separate the classes of the Java API from those created by the developer, adding an additional layer of security.</li>
                    <li><b>Public Key Encryption:</b> Java supports public key encryption for authentication and secure data transfer.</li>
                </ul>
            </article>
            <article>
                <h4>1.5 Object-Oriented</h4>
                <p>Java is inherently object-oriented, which fosters:</p>
                <ul>
                    <li><b>Modularity:</b> Code can be organized into objects and classes, making it reusable and modular.</li>
                    <li><b>Real-world Modeling:</b> Real-world scenarios can be easily modeled using classes and objects in Java, aiding in clear conceptualization and solution designing.</li>
                    <li><b>Code Maintenance:</b> OOP principles, when properly applied, make Java code easier to maintain and extend.</li>
                </ul>
            </article>
            <article>
                <h4>1.6 Performance & Architecture</h4>
                <p>Java's efficient architecture boosts performance:</p>
                <ul>
                    <li>Speed enhancement via JIT compilation.</li>
                    <li>Optimized, high-efficiency libraries.</li>
                    <li>Architecture neutrality with universal bytecode.</li>
                    <li>Native support for multithreaded programming.</li>
                </ul>
            </article>
            <article>
                <h4>1.7 Distributed & Dynamic</h4>
                <p>Java's adaptability:</p>
                <ul>
                    <li>Facilitates creation of distributed apps.</li>
                    <li>Integrates seamlessly with protocols.</li>
                    <li>Supports dynamic, on-demand class loading.</li>
                    <li>Compatible with native languages, like C++.</li>
                </ul>

                <p>In conclusion, Java's design principles and its continuous evolution in response to the changing technological landscape make it a robust, secure, and versatile language and ensure its relevance across diverse applications, from web applications to enterprise software systems to mobile applications.</p>
            </article>

            <article id="core-language-syntax-semantics">
                <h3>2. Core Language Syntax and Semantics</h3>
            </article>
            <article>
                <h4>2.1 Data Types</h4>
                <p>In Java, data types define the size and nature of values. They split into primitive and reference categories.</p>
                <ul class="list-unstyled">
                    <li>
                        <b>Primitive data types:</b> These are fundamental data types that include:
                        <ul>
                            <li><code>byte</code>: 8-bit signed integer. Example: <code>byte a = 10;</code></li>
                            <li><code>short</code>: 16-bit signed integer. Example: <code>short b = 5000;</code></li>
                            <li><code>int</code>: 32-bit signed integer. Example: <code>int c = 100000;</code></li>
                            <li><code>long</code>: 64-bit signed integer. Example: <code>long d = 5000000000L;</code></li>
                            <li><code>float</code>: 32-bit floating point. Example: <code>float e = 2.5f;</code></li>
                            <li><code>double</code>: 64-bit floating point. Example: <code>double f = 5.75;</code></li>
                            <li><code>char</code>: 16-bit Unicode character. Example: <code>char g = 'A';</code></li>
                            <li><code>boolean</code>: Represents true or false. Example: <code>boolean h = true;</code></li>
                        </ul>
                    </li>
                    <li>
                        <b>Reference data types:</b> Object-based types that store references to memory locations.
                        <ul>
                            <li><code>String</code>: Represents strings. Example: <code>String name = "Java";</code></li>
                            <li><code>Array</code>: A container object holding a fixed number of elements. Example: <code>int[] array = {1, 2, 3, 4, 5};</code></li>
                            <li>User-defined classes: Custom data types created by users. Example:
                                <pre><code class="language-java">class Person {
    String name;
    int age;
}</code></pre>
                            </li>
                        </ul>
                    </li>
                </ul>
            </article>
            <article>
                <h4>2.2 Operators and Expressions</h4>
                <p>Operators perform tasks on variables/values, while expressions combine these to produce a singular outcome.</p>
                <ul>
                    <li>Arithmetic Operators: <code>+, -, *, /, %</code>. Example: <code>int result = 5 * 10;</code></li>
                    <li>Relational Operators: <code>==, !=, >, <, >=, <=</code>. Example: <code>boolean isEqual = (a == b);</code></li>
                    <li>Logical Operators: <code>&&, ||, !</code>. Example: <code>boolean isTrue = (a > b && c < d);</code></li>
                </ul>
            </article>
            <article>
                <h4>2.3 Control Flow Statements</h4>
                <p>Java employs these to steer execution flow:</p>
                <ul class="list-unstyled">
                    <li>
                        <b>if-else:</b> Checks conditions and dictates the execution block. Example:
                        <pre><code class="language-java">if (age > 18) {
    System.out.println("Adult");
} else {
    System.out.println("Minor");
}</code></pre>
                    </li>
                    <li>
                        <b>loops:</b> Executes code blocks multiple times.
                        <ul>
                            <li>For loop:
                                <pre><code class="language-java">for(int i=0; i < 5; i++) {
    System.out.println(i);
}</code></pre>
                            </li>
                            <li>While loop:
                                <pre><code class="language-java">int i = 0;
while(i < 5) {
    System.out.println(i);
    i++;
}</code></pre>
                            </li>
                            <li>Do-while loop:
                                <pre><code class="language-java">int i = 0;
do {
    System.out.println(i);
    i++;
} while(i < 5);</code></pre>
                            </li>
                        </ul>
                    </li>
                </ul>
            </article>
            <article>
                <h4>2.4 Methods in Java</h4>
                <p>In Java, methods are blocks of code that encapsulate a specific operation or computation. They help organize and reuse code and improve modularity and readability. Here are some key points about methods:</p>

                <ul class="list-unstyled">
                    <li><b>Declaration:</b> A method in Java is declared with a return type, method name, and a pair of parentheses which may include parameters. The syntax for method declaration is:
                        <pre><code class="language-java">
returnType methodName(parameter1Type parameter1Name, parameter2Type parameter2Name, ...);
    </code></pre>
                    </li>

                    <li><b>Method Signature:</b> The combination of the method's name and its parameter list is called its signature. Return type is not a part of the method signature.</li>

                    <li><b>Return Type:</b> Every method in Java is declared with a return type and it is mandatory for all methods. If a method does not return any value, its return type is `void`.</li>

                    <li><b>Method Call:</b> Once a method is defined, it can be called from another method, a constructor, or any block of code. The general form of a method call is:
                        <pre><code class="language-java">
objectReference.methodName(argument1, argument2, ...);
    </code></pre>
                    </li>
                    <li><b>Recursion:</b> In Java, a method can call itself. Such methods are called recursive methods. They are useful for certain tasks, like calculating factorial, but must have a termination condition to prevent infinite looping.</li>
                </ul>
            </article>
            <article>
                <h4>2.5 Java Keywords and Modifiers</h4>
                <p>Java has a set of keywords that have special meanings in the language. These keywords or modifiers determine the visibility, behavior, and other properties of Java classes, methods, and variables.</p>

                <ul class="list-unstyled">
                    <li><b>public:</b> The `public` keyword is an access modifier that means the member (class, method, or variable) is accessible from any other class. It has the widest scope among all other modifiers.</li>

                    <li><b>private:</b> The `private` keyword means the member is only accessible within its own class. It has the narrowest scope.</li>

                    <li><b>protected:</b> The `protected` keyword means the member is accessible within its own package and by subclasses.</li>

                    <li><b>static:</b> The `static` keyword means that a member (method or variable) belongs to the class rather than an instance of the class. It can be accessed without creating an instance of the class. For methods, this means that the method can be called on the class itself, rather than on instances of the class.
                        <pre><code class="language-java">
public class MyClass {
    public static void staticMethod() {
        System.out.println("This is a static method.");
    }
}
MyClass.staticMethod();  // correct way to call a static method
    </code></pre>
                    </li>

                    <li><b>final:</b> The `final` keyword means that the value can't be modified after it's been assigned. For variables, it means they can't be changed. For methods, it means they can't be overridden by subclasses. For classes, it means they can't be subclassed.</li>

                    <li><b>abstract:</b> The `abstract` keyword is used to declare either a method or a class. If a method within an interface or abstract class is declared as abstract, it doesn't have a body and it needs to be implemented by any class that inherits the interface or abstract class.</li>

                    <li><b>transient:</b> The `transient` keyword indicates that a variable should not be serialized when the class instance containing it is persisted to storage.</li>

                    <li><b>volatile:</b> The `volatile` keyword indicates that a variable may change unexpectedly. It tells the JVM that multiple threads might access this variable.</li>
                </ul>
            </article>

            <article id="oop-in-java">
                <h3>3. Object-Oriented Programming (OOP) in Java</h3>
                <p>OOP is a programming paradigm centered around objects, which can contain data and behavior. Java, being an object-oriented language, fully supports these OOP concepts.</p>
            </article>
            <article>
                <h4>3.1 Classes and Objects</h4>
                <p>At the heart of OOP in Java are classes and objects.</p>
                <ul>
                    <li><b>Class:</b> A class serves as a blueprint for objects. It defines the structure and behaviors that its objects will have.</li>
                    <li><b>Object:</b> An instance of a class. It's a self-contained unit that consists of data attributes and methods to perform operations on the data.</li>
                    <pre><code class="language-java">class Car {
    String color;
    int speed;

    void accelerate() {
        speed++;
    }
}
Car myCar = new Car();  // Creating an object of the Car class
    </code></pre>

                    <li><b>Constructors:</b> Special type of method in a class that gets called when an instance of the class is created. It helps in initializing the object.</li>
                    <pre><code class="language-java">class Car {
    String color;
    int speed;

    // Constructor
    Car(String c) {
        color = c;
        speed = 0;
    }
}
Car redCar = new Car("red");  // Using the constructor to create a Car object</code></pre>
                </ul>
            </article>
            <article>
                <h4>3.2 Inheritance</h4>
                <p>Inheritance allows a class to adopt attributes and behaviors from another class.</p>
                <ul class="list-unstyled">
                    <li><b>Base Class (Parent Class):</b> The source of attributes and behaviors for other classes.
                        <pre><code class="language-java">class Vehicle {
    int speed;

    // Method to increase speed
    void accelerate() {
        speed++;
    }

    // Method to display current speed
    void displaySpeed() {
        System.out.println("Speed: " + speed);
    }
}

public class MainBase {
    public static void main(String[] args) {
        Vehicle car = new Vehicle();
        car.accelerate();   // Increase speed
        car.displaySpeed(); // Should display: Speed: 1
    }
}</code></pre>
                    </li>
                    <li><b>Derived Class (Child Class):</b> Inherits attributes and behaviors from the base class.
                        <pre><code class="language-java">class Truck extends Vehicle {
    // Truck-specific attribute
    int cargoCapacity;
}</code></pre>
                    </li>
                    <li><b>`super` keyword:</b> Refers to the parent class's elements in the child class.
                        <pre><code class="language-java">class Parent {
    int value = 100;

    Parent() {
        System.out.println("Parent constructor.");
    }
}

class Child extends Parent {
    int value = 200;

    Child() {
        // Calls parent's constructor
        super();
        System.out.println("Child constructor.");
    }

    void displayValues() {
        // Displays parent's value
        System.out.println("Parent value: " + super.value); 
        // Displays child's value
        System.out.println("Child value: " + value);
    }
}

public class MainDerived {
    public static void main(String[] args) {
        Child child = new Child();
        child.displayValues(); // Should display both values
    }
}</code></pre>
                    </li>
                </ul>

            </article>
            <article>
                <h4>3.3 Polymorphism</h4>
                <p>Polymorphism, derived from Greek meaning "many shapes", allows objects of different classes to be treated as objects of a common superclass.</p>
                <ul>
                    <li><b>Method Overloading:</b> Same method name but with different parameters.
                        <pre><code>class Calculator {

    // Method to add two integers
    public int add(int a, int b) {
        return a + b;
    }

    // Method to add three integers (overloaded)
    public int add(int a, int b, int c) {
        return a + b + c;
    }

    // Method to add two double values (overloaded)
    public double add(double a, double b) {
        return a + b;
    }

    // Method to concatenate two strings (overloaded for demonstration)
    public String add(String a, String b) {
        return a + b;
    }
}

public class Main {
    public static void main(String[] args) {
        Calculator calculator = new Calculator();

        System.out.println("Add two integers: " + calculator.add(5, 3));
        System.out.println("Add three integers: " + calculator.add(5, 3, 2));
        System.out.println("Add two doubles: " + calculator.add(5.5, 3.3));
        System.out.println("Concatenate two strings: " + calculator.add("Hello, ", "world!"));
    }
}</code></pre>
                    </li>
                    <li><b>Method Overriding:</b> Child class provides a specific implementation of a method that is already defined in its parent class.</li>
                    <pre><code class="language-java">class Animal {
    void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Cat extends Animal {
    @Override
    void sound() {
        System.out.println("Cat meows");
    }
}</code></pre>
                </ul>
            </article>
            <article>
                <h4>3.4 Encapsulation</h4>
                <p>Encapsulation is the bundling of data and methods that operate on that data, restricting the access to some of the object's components.</p>
                <ul>
                    <li><b>Access Modifiers:</b> Java provides access modifiers (private, protected, public) to set the level of access.
                        <pre><code class="language-java">// Define a class named "Person"
class Person {

    // PRIVATE member: Can only be accessed within the class itself
    private String name;

    // PROTECTED member: Can be accessed within the class, its subclasses, and within the same package
    protected int age;

    // PUBLIC member: Can be accessed from any other class
    public String address;

    // Constructor to initialize members
    public Person(String name, int age, String address) {
        this.name = name;
        this.age = age;
        this.address = address;
    }

    // PRIVATE method: Can only be accessed within the class
    private void printName() {
        System.out.println("Name: " + name);
    }

    // PROTECTED method: Can be accessed within the class, its subclasses, and within the same package
    protected void printAge() {
        System.out.println("Age: " + age);
    }

    // PUBLIC method: Can be accessed from any other class
    public void printAddress() {
        System.out.println("Address: " + address);
    }

    // Method to demonstrate accessing members/methods
    public void displayInfo() {
        printName();  // Accessing the private method
        printAge();   // Accessing the protected method
        printAddress(); // Accessing the public method
    }
}

// Demonstration
public class Main {
    public static void main(String[] args) {
        // Create an object of the Person class
        Person person = new Person("John", 25, "123 Main St");

        // Call the method to display information
        person.displayInfo();

        // Directly accessing the public member
        System.out.println("Accessing directly: " + person.address);
    }
}</code></pre>
                    </li>
                    <li><b>Getters and Setters:</b> Methods used to access and modify private data members of the class.</li>
                    <pre><code class="language-java">class Circle {
    private double radius;

    public double getRadius() {
        return radius;
    }

    public void setRadius(double r) {
        if(r > 0) {
            radius = r;
        }
    }
}</code></pre>
                </ul>
            </article>
            <article>
                <h4>3.5 Abstraction</h4>
                <p>Abstraction is the concept of hiding the complex implementation details and showing only the essential features of an object.</p>
                <ul>
                    <li><b>Abstract Classes:</b> Cannot be instantiated and may contain abstract (unimplemented) methods.
                        <pre><code class="language-java">// Define an abstract class named "Animal"
abstract class Animal {
    
    // Data member
    private String name;

    // Constructor to set the name
    public Animal(String name) {
        this.name = name;
    }

    // Getter for name
    public String getName() {
        return name;
    }

    // An abstract method named "sound"
    // This method does not have a body (it's unimplemented)
    abstract void sound();

    // A regular method
    public void sleep() {
        System.out.println(name + " is sleeping.");
    }
}

// Define a concrete class "Dog" that extends the abstract class "Animal"
class Dog extends Animal {

    // Constructor to set the name of the dog
    public Dog(String name) {
        super(name);
    }

    // Implement the abstract method "sound"
    @Override
    void sound() {
        System.out.println(getName() + " barks.");
    }
}

// Demonstration
public class Main {
    public static void main(String[] args) {
        // Create an object of the Dog class
        Dog myDog = new Dog("Buddy");

        // Call the methods
        myDog.sound();
        myDog.sleep();
    }
}</code></pre>
                    </li>
                    <li><b>Interfaces:</b> Defines a contract of methods that a class must implement.</li>
                    <pre><code class="language-java">abstract class Animal {
    abstract void sound();
}

interface Runner {
    void run();
}

class Dog extends Animal implements Runner {
    @Override
    void sound() {
        System.out.println("Dog barks");
    }

    @Override
    public void run() {
        System.out.println("Dog runs");
    }
}</code></pre>
                </ul>
            </article>

            <article id="core-libraries">
                <h3>4. Core Libraries</h3>
                <p>Java's power and versatility derive from its comprehensive libraries. These provide predefined methods, simplifying complex tasks and promoting code reusability.</p>
            </article>
            <article>
                <h4>4.1 java.lang</h4>
                <p>The foundational package of Java, <code>java.lang</code>, is automatically imported into every Java program. It offers classes integral to the language's essence.</p>

                <h5>4.1.1 String</h5>
                <p>String represents sequences of characters. Java treats strings as immutable, ensuring memory efficiency and security.</p>
                <pre><code class="language-java">// Initializing a String
String greeting = "Java";
// Using a method from the String class
System.out.println(greeting.toUpperCase()); // JAVA</code></pre>

                <h5>4.1.2 StringBuilder</h5>
                <p>StringBuilder offers a mutable character sequence, ideal for dynamic string manipulations, making operations faster than with String.</p>
                <pre><code class="language-java">// Initializing StringBuilder
StringBuilder builder = new StringBuilder("Hello");
// Appending to StringBuilder
builder.append(" Java");
System.out.println(builder); // Hello Java</code></pre>

                <h5>4.1.3 Math</h5>
                <p>The Math class provides ready-to-use mathematical functions.</p>
                <pre><code class="language-java">// Calculating power using Math class
double square = Math.pow(5, 2); 
System.out.println(square); // 25.0</code></pre>
            </article>
            <article>
                <h4>4.2 java.util</h4>
                <p>The <code>java.util</code> package houses utility functions, ranging from data structures to date-time operations and randomizers.</p>

                <h5>4.2.1 Collections Framework</h5>
                <p>This set of classes and interfaces manages group data efficiently. Structures like ArrayList and HashMap store and organize data in specific ways.</p>
                <pre><code class="language-java">// Creating an ArrayList and adding elements
ArrayList&lt;String&gt; fruits = new ArrayList&lt;&gt;();
fruits.add("Apple");
fruits.add("Mango");
System.out.println(fruits); // [Apple, Mango]</code></pre>

                <h5>4.2.2 Date & Time API</h5>
                <p>Java 8 introduced a revamped Date & Time API, allowing precise and human-readable date-time operations.</p>
                <pre><code class="language-java">// Fetching the current date
LocalDate currentDate = LocalDate.now();
System.out.println(currentDate); // Outputs date in the format: YYYY-MM-DD</code></pre>

                <h5>4.2.3 Utilities</h5>
                <p>Other utilities, such as Random for generating random numbers and Scanner for input, are crucial for diverse tasks.</p>
                <pre><code class="language-java">// Generating a random number between 0 and 99
Random randomizer = new Random();
int randomNum = randomizer.nextInt(100); 
System.out.println(randomNum);</code></pre>
            </article>

            <article id="exception-handling">
                <h3>5. Exception Handling</h3>
                <p>In Java, unexpected events during program execution, like file not found or division by zero, are managed using exceptions. This mechanism helps maintain the program's flow without abrupt halts.</p>
            </article>
            <article>
                <h4>5.1 Understanding Exceptions</h4>
                <p>Exceptions are objects that encapsulate error information. Java has a robust hierarchy of exception classes—broadly classified into checked (handled at compile time) and unchecked (runtime) exceptions.</p>
            </article>
            <article>
                <h4>5.2 try-catch-finally</h4>
                <p>The <code>try-catch-finally</code> construct is used to capture and manage exceptions.</p>
                <ul>
                    <li><b>try:</b> Encloses code that might throw an exception.</li>
                    <li><b>catch:</b> Catches the exception and defines how it should be handled.</li>
                    <li><b>finally:</b> Executes code regardless of whether an exception was thrown or not. Commonly used for cleanup operations.</li>
                </ul>
                <pre><code class="language-java">try {
   int result = 10 / 0; // This will throw an ArithmeticException
} catch (ArithmeticException e) {
   System.out.println("Division by zero is not allowed!");
} finally {
   System.out.println("Execution completed.");
}</code></pre>
            </article>
            <article>
                <h4>5.3 Custom exceptions</h4>
                <p>You can create tailored exception types to depict specific error scenarios by extending the <code>Exception</code> class or its descendants.</p>
                <pre><code class="language-java">// Custom exception
class AgeOutOfRangeException extends Exception {
    public AgeOutOfRangeException(String message) {
        super(message);
    }
}

public class Main {
    static void checkAge(int age) throws AgeOutOfRangeException {
        if(age < 18 || age > 60) {
            throw new AgeOutOfRangeException("Age out of valid range!");
        } else {
            System.out.println("Age is within the valid range.");
        }
    }

    public static void main(String[] args) {
        try {
            checkAge(65);  // This will throw the custom exception
        } catch (AgeOutOfRangeException e) {
            System.out.println(e.getMessage());
        }
    }
}</code></pre>
            </article>
            <article>
                <h4>5.4 throw and throws</h4>
                <p>
                    <b>throw:</b> Used within methods to throw an exception.<br>
                    <b>throws:</b> Used in method signatures to declare the exceptions the method might throw, alerting callers to handle or propagate them.
                </p>
            </article>


            <article id="java-io">
                <h3>6. Java I/O</h3>
                <p>Java I/O (Input/Output) allows programs to read from and write to various data sources, be it files, network sockets, or console.</p>
            </article>
            <article>
                <h4>6.1 Streams</h4>
                <p>Streams are sequences of data that can be read from (input stream) or written to (output stream). They are categorized based on the type of data they handle:</p>
                <ul>
                    <li><b>Byte Streams:</b> Handle I/O of raw binary data.</li>
                    <li><b>Character Streams:</b> Handle I/O of character data, automatically considering character encoding.</li>
                </ul>
                <pre><code class="language-java">// Byte stream example
FileInputStream fis = new FileInputStream("example.txt");
int data = fis.read();  // Reads a single byte
fis.close();

// Character stream example
FileReader fr = new FileReader("example.txt");
int charData = fr.read();  // Reads a single character
fr.close();
</code></pre>
            </article>
            <article>
                <h4>6.2 File Handling</h4>
                <p>The <code>File</code> class offers an abstraction for file and directory paths. It doesn't read/write, but allows operations like checking if a file exists, directory listing, etc.</p>
                <pre><code class="language-java">File file = new File("example.txt");
if(file.exists()) {
    System.out.println("File exists!");
} else {
    System.out.println("File not found.");
}
</code></pre>
            </article>
            <article>
                <h4>6.3 Reader and Writer classes</h4>
                <p>These are higher-level I/O classes focused on character data. They include useful subclasses like <code>BufferedReader</code> and <code>PrintWriter</code>, which offer efficient reading/writing and formatting capabilities, respectively.</p>
                <pre><code class="language-java">// Using BufferedReader for efficient reading
BufferedReader br = new BufferedReader(new FileReader("example.txt"));
String line;
while((line = br.readLine()) != null) {
    System.out.println(line);
}
br.close();

// Using PrintWriter for easy formatted writing
PrintWriter pw = new PrintWriter("output.txt");
pw.println("Hello, World!");
pw.close();
</code></pre>
            </article>


            <article id="concurrency">
                <h3>7. Concurrency</h3>
                <p>Concurrency in Java allows multiple threads to execute tasks in parallel, boosting performance, especially in CPU-bound applications.</p>
            </article>
            <article>
                <h4>7.1 Threads and the java.util.concurrent package</h4>
                <p>Threads represent individual units of concurrent execution. Java provides tools to manage and control these threads efficiently.</p>
                <pre><code class="language-java">// Creating and starting a thread
Thread thread = new Thread(() -> {
    System.out.println("Thread is running!");
});
thread.start();

// Using the concurrent package for thread-safe collections
java.util.concurrent.ConcurrentHashMap<String, Integer> concurrentMap = new java.util.concurrent.ConcurrentHashMap<>();
concurrentMap.put("Key", 1);
</code></pre>
            </article>
            <article>
                <h4>7.2 Synchronization and locks</h4>
                <p>When multiple threads access shared resources, synchronization is used to ensure that resource access remains consistent and thread-safe.</p>
                <pre><code class="language-java">// Synchronized method
synchronized void synchronizedMethod() {
    // code...
}

// Using ReentrantLock from java.util.concurrent.locks for more advanced synchronization
java.util.concurrent.locks.ReentrantLock lock = new java.util.concurrent.locks.ReentrantLock();
lock.lock();
try {
    // access shared resources
} finally {
    lock.unlock();
}
</code></pre>
            </article>
            <article>
                <h4>7.3 Java Memory Model</h4>
                <p>The Java Memory Model (JMM) defines how Java threads interact through memory. It ensures that consistent values are seen by each thread, even when changes are made by other threads concurrently.</p>
                <pre><code class="language-java">// volatile keyword ensures a variable's updates are visible to all threads
volatile boolean flag = false;
</code></pre>
                <p>The JMM ensures that threads have a consistent view of memory. Understanding the JMM is crucial for writing safe multithreaded code.</p>
            </article>


            <article id="java-annotations-reflection">
                <h3>8. Java Annotations and Reflection</h3>
                <p>Annotations provide metadata about code, whereas Reflection enables dynamic runtime behavior analysis and manipulation of Java applications.</p>
            </article>
            <article>
                <h4>8.1 Built-in annotations</h4>
                <p>Java offers predefined annotations to convey additional information about your code, aiding both the compiler and developers.</p>
                <pre><code class="language-java">// Using @Override to indicate that a subclass method is intended to override a superclass method
@Override
public String toString() {
    return "ExampleClass{}";
}

// Marking a method as no longer recommended for use with @Deprecated
@Deprecated
public void oldMethod() {
    // ...
}
</code></pre>
            </article>
            <article>
                <h4>8.2 Creating custom annotations</h4>
                <p>You can create your own annotations to add custom metadata to your code, often used in frameworks and libraries.</p>
                <pre><code class="language-java">// Defining a custom annotation
public @interface CustomAnnotation {
    String author() default "Unknown";
    String date();
}

// Using the custom annotation
@CustomAnnotation(date = "2023-09-10")
public class ExampleClass {
    // ...
}
</code></pre>
            </article>
            <article>
                <h4>8.3 Reflection API</h4>
                <p>Reflection enables Java code to inspect and manipulate the structure and behavior of applications at runtime, making it powerful but also risky if misused.</p>
                <pre><code class="language-java">// Using Reflection API to get class name and methods
Class<?> exampleClass = ExampleClass.class;
System.out.println("Class Name: " + exampleClass.getName());

for (Method method : exampleClass.getMethods()) {
    System.out.println("Method: " + method.getName());
}
</code></pre>
                <p>While the Reflection API is powerful, use it judiciously as it can compromise security, increase overhead, and lead to code complexity.</p>
            </article>

            <article id="jvm">
                <h3>9. Java Virtual Machine (JVM)</h3>
                <p>The JVM runs Java bytecode, making Java's "write once, run anywhere" promise a reality.</p>
            </article>
            <article>
                <h4>9.1 Understanding JVM architecture</h4>
                <p>The JVM is the cornerstone of Java's runtime environment, designed with a rich architecture that optimally executes Java applications.</p>
                <ul>
                    <li><b>Classloader:</b> JVM employs a classloader to load .class files (compiled Java code) when they are required. It works in three phases:
                        <ul>
                            <li>Loading: Loads the binary data from the .class file.</li>
                            <li>Linking: Verifies the loaded class, prepares static variables, and stores the bytecode in the method area.</li>
                            <li>Initialization: Executes static initializers and static initialization blocks.</li>
                        </ul>
                    </li>
                    <li><b>Runtime Data Area:</b> The JVM's memory is segmented for different kinds of data:
                        <ul>
                            <li><b>Method Area:</b> Stores per-class structures, such as runtime constant pool, field and method data, and the code for methods and constructors.</li>
                            <li><b>Heap:</b> All objects are allocated here. It is further divided into Young and Old generations for garbage collection optimization.</li>
                            <li><b>Stack:</b> Java Stack stores frames and holds local variables and partial results. Each thread in Java has a private JVM stack.</li>
                            <li><b>Program Counter (PC) Register:</b> Contains the address of the current instruction being executed.</li>
                            <li><b>Native Method Stack:</b> Similar to the Java Stack, but for native methods written in other languages.</li>
                        </ul>
                    </li>
                    <li><b>Execution Engine:</b> Converts bytecode into machine code.
                        <ul>
                            <li><b>Interpreter:</b> Reads bytecode instructions and executes them directly.</li>
                            <li><b>Just-In-Time Compiler (JIT):</b> Optimizes the process by converting bytecode to native machine code, which is then executed directly by the host operating system.</li>
                        </ul>
                    </li>
                    <li><b>Java Native Interface (JNI):</b> JNI allows Java code to interoperate with applications and libraries written in other programming languages. JNI provides a bridge to invoke functions written in languages like C and C++.</li>
                    <li><b>Native Method Libraries:</b> This is a collection of native libraries (C, C++ libraries) necessary for the Execution Engine.</li>
                </ul>
            </article>
            <article>
                <h4>9.2 Class loading</h4>
                <p>Java classes aren't loaded all at once, but only when they're needed. This dynamic class loading is the Classloader's responsibility.</p>
                <pre><code class="language-java">// Dynamically loading a class using the ClassLoader
Class<?> loadedClass = Class.forName("com.example.MyClass");
</code></pre>
                <p>There are three primary types of Classloaders: Bootstrap, Extension, and System (or Application). They follow a parent-child relationship to ensure safe class loading.</p>
            </article>
            <article>
                <h4>9.3 Just-In-Time (JIT) compilation</h4>
                <p>While the JVM can interpret bytecode, this isn't always the fastest way to execute code. Enter the JIT compiler, which converts bytecode into native machine code just before execution, significantly speeding up the process.</p>
                <pre><code class="language-java">// A sample code snippet that gets optimized by JIT over time
for (int i = 0; i < 100000; i++) {
    // Repeated computations here are optimized by the JIT compiler.
}
</code></pre>
                <p>JIT works alongside the JVM's interpreter. While the interpreter quickly translates individual bytecode instructions into machine code, JIT takes larger chunks, optimizes them, and then translates. This synergy helps Java maintain both portability and performance.</p>
            </article>

            <article id="design-patterns">
                <h3>10. Design Patterns</h3>
                <p>Design patterns offer standard solutions to recurring problems encountered during software development. They represent best practices, derived from the collective experience of software professionals.</p>
            </article>
            <article>
                <h4>10.1 Singleton</h4>
                <p>This pattern restricts a class from instantiating multiple objects. It's often used for things like database connections or logging where you want a single instance to coordinate actions across a system.</p>
                <pre><code class="language-java">public class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}</code></pre>
            </article>
            <article>
                <h4>10.2 Factory</h4>
                <p>The Factory pattern provides an interface for creating instances of a class, with its subclasses deciding which class to instantiate.</p>
                <pre><code class="language-java">interface Product {}
class ConcreteProductA implements Product {}
class ConcreteProductB implements Product {}

class Factory {
    public Product createProduct(String type) {
        if ("A".equals(type)) {
            return new ConcreteProductA();
        } else if ("B".equals(type)) {
            return new ConcreteProductB();
        }
        return null;
    }
}</code></pre>
            </article>
            <article>
                <h4>10.3 Observer</h4>
                <p>Defines a one-to-many dependency between objects. When one object (the subject) changes state, all its dependents are notified.</p>
                <pre><code class="language-java">interface Observer {
    void update();
}
class ConcreteObserver implements Observer {
    public void update() {
        // React to the update
    }
}

class Subject {
    private List&lt;Observer> observers = new ArrayList<>();

    public void addObserver(Observer observer) {
        observers.add(observer);
    }

    public void removeObserver(Observer observer) {
        observers.remove(observer);
    }

    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update();
        }
    }
}</code></pre>
            </article>
            <article>
                <h4>10.4 Decorator</h4>
                <p>Adds additional responsibilities to objects dynamically, providing a flexible alternative to subclassing for extending functionality.</p>
                <pre><code class="language-java">interface Coffee {
    double cost();
}

class SimpleCoffee implements Coffee {
    public double cost() {
        return 5;
    }
}

class MilkDecorator implements Coffee {
    Coffee coffee;
    
    MilkDecorator(Coffee coffee) {
        this.coffee = coffee;
    }
    
    public double cost() {
        return coffee.cost() + 2;
    }
}</code></pre>
            </article>
            <article>
                <h4>10.5 Strategy</h4>
                <p>Defines a set of encapsulated algorithms that can be swapped to carry out a specific behavior.</p>
                <pre><code class="language-java">interface Strategy {
    void execute();
}

class ConcreteStrategyA implements Strategy {
    public void execute() {
        // Implementation of A
    }
}

class Context {
    private Strategy strategy;

    Context(Strategy strategy) {
        this.strategy = strategy;
    }

    public void executeStrategy() {
        strategy.execute();
    }
}</code></pre>

            </article>

            <article id="conclusion">
                <h3>11. Conclusion</h3>
                <p>Java, with its versatility, has found its place in various domains of software development. Whether you're a beginner looking to dip your toes in programming or a PhD scholar diving deep into complex systems, Java offers a world of opportunities. Its rich set of features, combined with a robust architecture, makes it a top choice for developers around the world.</p>
            </article>
        </main>

        <script> copyright("all"); </script>

    </body>

</html>
