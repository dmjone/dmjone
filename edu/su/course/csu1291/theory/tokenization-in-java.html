<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>

        <title>Scanner Class in Java - CSU1291 - Shoolini U</title>
        <meta name="description" content="Know the Origins of Java Programming of the course CSU1291. Learn the history of the Java Programming Language from a course of Shoolini University with dmj.one">

        <meta property="og:image" content="/logo.png">
        <meta property="og:type" content="article">

        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@divyamohan1993">
        <meta name="twitter:creator" content="@divyamohan1993">
        <meta name="twitter:image" content="/logo.png">

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />

        <meta name="author" content="Divya Mohan">
        <meta name="robots" content="index, follow">

        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                renderMathInElement(document.body, {
                    // customised options
                    // • auto-render specific keys, e.g.:
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\(', right: '\\)', display: false },
                        { left: '\\[', right: '\\]', display: true }
                    ],
                    // • rendering keys, e.g.:
                    throwOnError: false
                });
            });
        </script>
    </head>

    <body>

        <script> header_author("dm"); </script>

        <main>
            <article>
                <h2 class="text-center">
                    Tokenization in Java
                </h2>
                <div class="container mt-4 w-100 w-xl-75">
                    <div class="accordion" id="toc">
                        <div class="accordion-item">
                            <h2 class="accordion-header" id="h1">
                                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#c1" aria-controls="c1" aria-expanded="false">
                                    <i class="fas fa-book"></i> <strong>&nbsp;Table of Contents</strong>
                                </button>
                            </h2>
                            <div id="c1" class="accordion-collapse collapse" aria-labelledby="h1" data-bs-parent="#toc">
                                <div class="accordion-body">
                                    <ol class="list-unstyled p-0 m-0">
                                        <li class="p-1"><a href="#intro"><i class="fas fa-chevron-circle-right"></i> Overview</a></li>
                                        <li class="p-1"><a href="#features"><i class="fas fa-chevron-circle-right"></i> Features of Java</a></li>
                                        <li class="p-1"><a href="#essentials"><i class="fas fa-chevron-circle-right"></i> Essentials of Java</a></li>
                                        <li class="p-1"><a href="#code-section"><i class="fas fa-chevron-circle-right"></i> Code</a></li>
                                    </ol>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <h3></h3>
            </article>

            <article id="introduction-to-tokenization-in-java">
                <h3>1. Introduction to Tokenization in Java</h3>
                <p>Tokenization is the process of splitting a large paragraph into sentences or words. In the context of Java, tokenization involves dividing a string into a series of tokens. This article aims to provide an all-encompassing guide on tokenization in Java for both beginners and advanced users. You will get to learn about String handling, regular expressions, and specialized Java classes for this purpose.</p>
            </article>

            <article id="basics-of-strings-in-java">
                <h3>2. Basics of Strings in Java</h3>
            </article>
            <article>
                <h4>2.1 String Class and Methods</h4>

                <p>In Java, text data is primarily represented using the <code>String</code> class. A string is essentially a sequence of characters. The <code>String</code> class is part of Java's standard library and offers a plethora of methods to interact with and manipulate string data. Let's delve deeper:</p>
            </article>
            <article id="what-is-a-string">
                <h5>2.1.1 What is a String?</h5>
                <p>A string is a sequence of characters. In Java, strings are not primitive data types; they are instances of the <code>String</code> class. This means strings in Java come with built-in methods and properties.</p>
            </article>

            <article id="initializing-strings">
                <h5>2.1.2 Initializing Strings</h5>
                <p>There are multiple ways to initialize a string in Java. The most common approach is by using double quotes. When a string is created, it is stored in the string pool.</p>
                <pre><code class="language-java">// Initializing a String
String myString = "Hello, World!";
</code></pre>
            </article>

            <article>
                <h5>2.1.3 Common String Methods</h5>
                <p>The <code>String</code> class comes packed with a suite of methods to make string handling efficient and intuitive. Here are some of the commonly used methods:</p>
            </article>
            <article>
                <h5>2.1.3.1 Method: length()</h5>
                <p>This method returns the number of characters in the string. It helps when you need to know the size of a string, for instance, when iterating over its characters.</p>
                <pre><code class="language-java">// Getting the length of the string
int length = myString.length();  // Outputs 13
</code></pre>
            </article>

            <article id="method-charAt">
                <h5>2.1.3.2 Method: charAt(int index)</h5>
                <p>The <code>charAt()</code> method returns the character at the specified index of the string. Remember, string indices start at 0. So, the first character is at index 0, the second at index 1, and so forth.</p>
                <pre><code class="language-java">
// Getting a character at a specific index
char character = myString.charAt(4);  // Outputs 'o'
</code></pre>
            </article>

            <article id="method-substring">
                <h5>2.1.3.3 Method: substring(int beginIndex, int endIndex)</h5>
                <p>The <code>substring()</code> method returns a new string that is a substring of the original string. The substring starts at the specified <code>beginIndex</code> and extends to the character at index <code>endIndex - 1</code>. If only one parameter is provided, the substring starts from the given index and goes till the end of the string.</p>
                <pre><code class="language-java">
// Extracting a substring from the string
String sub = myString.substring(0, 5);  // Outputs "Hello"
</code></pre>
            </article>


            <article id="understanding-of-immutable-strings">
                <h4>2.2 Understanding of Immutable Strings</h4>
                <p>In Java, the immutability of strings is an essential concept to grasp. Immutability implies that an object, once created, cannot be altered. With respect to strings, any operation that appears to modify a string does not actually change the original string. Instead, it results in a new string object being created. This has several implications for programming and performance.</p>
            </article>

            <article id="why-strings-are-immutable">
                <h5>2.2.1 Why are Strings Immutable?</h5>
                <p>There are several reasons why the Java creators chose to design the <code>String</code> class as immutable:</p>

                <ul>
                    <li><strong>Security:</strong> String objects, especially those related to class loading and file paths, are often involved in security-sensitive operations. Immutability ensures that these strings can't be altered maliciously.</li>
                    <li><strong>Thread Safety:</strong> Immutable objects are inherently thread-safe. They can be shared across multiple threads without any synchronization overhead or risks of inconsistencies.</li>
                    <li><strong>Performance:</strong> Immutability allows strings to be pooled. The JVM maintains a special pool of strings, which reduces the overhead of creating a new string every time one is needed.</li>
                    <li><strong>Hashcode Caching:</strong> Since strings are immutable, their hashcode value remains constant. This allows the <code>String</code> class to cache the hashcode, resulting in faster hash-based collection operations.</li>
                </ul>
            </article>

            <article id="implications-of-immutability">
                <h5>2.2.2 Implications of Immutability</h5>
                <p>The immutability of strings in Java has several implications:</p>

                <ul>
                    <li><strong>Memory Overhead:</strong> Operations that appear to modify strings, like concatenation, result in new string objects. This can lead to increased memory usage, especially in scenarios where strings are manipulated extensively.</li>
                    <li><strong>Performance Overhead:</strong> Repeated string modifications can lead to performance bottlenecks. In such cases, classes like <code>StringBuilder</code> or <code>StringBuffer</code> should be considered.</li>
                    <li><strong>Reliability:</strong> Immutability provides inherent safety against unintended modifications. This results in more predictable and reliable code.</li>
                </ul>
            </article>

            <article id="demonstration-of-immutability">
                <h5>2.2.3 Demonstration of Immutability</h5>
                <p>Let's observe the immutable nature of strings with a simple code snippet:</p>
                <pre><code class="language-java">// Initializing a String
String originalString = "Java";
String modifiedString = originalString.concat("Rocks");
// Check if the original string is altered
System.out.println(originalString);  // Outputs "Java"
System.out.println(modifiedString);  // Outputs "JavaRocks"</code></pre>
                <p>In the above code, although we seemed to concatenate "Rocks" to the <code>originalString</code>, it remains unchanged. Instead, a new string <code>modifiedString</code> is created.</p>
            </article>

            <article id="string-concatenation-and-its-implications">
                <h4>2.3 String Concatenation and Its Implications</h4>
                <p>Concatenation is the process of joining two or more strings into a single string. While string concatenation in Java appears straightforward and frequently used, understanding its underlying workings and performance implications is crucial, especially when working with large volumes of text or within performance-critical applications.</p>
            </article>
            <article>
                <h5>2.3.1 Using the + Operator for Concatenation</h5>
                <p>The <code>+</code> operator is the most direct method to concatenate strings. It allows strings and other data types to be combined easily.</p>
                <pre><code class="language-java">// Concatenating strings using +
String firstName = "John";
String lastName = "Doe";
String fullName = firstName + " " + lastName;  // "John Doe"</code></pre>
                <p>It's also possible to concatenate strings with other data types directly:</p>
                <pre><code class="language-java">int age = 30;
String text = "His age is " + age;  // "His age is 30"</code></pre>
            </article>

            <article id="performance-implications-of-plus-operator">
                <h5>2.3.2 Performance Implications of the + Operator</h5>
                <p>While using the <code>+</code> operator for string concatenation seems convenient, there are hidden performance implications:</p>

                <ul>
                    <li><strong>Creation of New Objects:</strong> Remember, strings in Java are immutable. Every time we use the <code>+</code> operator, a new string object is created. This can lead to excessive memory use and garbage collection overhead when concatenating strings in loops or frequent operations.</li>
                    <li><strong>Use in Loops:</strong> Using the <code>+</code> operator for concatenation within a loop is a common performance pitfall. With each iteration, a new string is created, leading to performance degradation.</li>
                </ul>

                <p>For example, consider the following code:</p>
                <pre><code class="language-java">
String result = "";
for (int i = 0; i < 1000; i++) {
result += i;
}
</code></pre>
                <p>This code will create 999 new string objects, most of which will be discarded immediately, leading to inefficiencies.</p>
            </article>

            <article id="alternatives-to-plus-operator">
                <h5>2.3.3 Alternatives to the + Operator</h5>
                <p>Due to the performance implications of the <code>+</code> operator, Java provides alternative classes designed for mutable string operations.</p>

                <article id="using-stringbuilder-and-stringbuffer">
                    <h5>2.3.3.1 Using StringBuilder and StringBuffer</h5>
                    <p>Both <code>StringBuilder</code> and <code>StringBuffer</code> are mutable classes that provide methods for string manipulation without creating new objects for each operation. The difference between them is that <code>StringBuffer</code> is thread-safe (and hence a bit slower due to synchronization) while <code>StringBuilder</code> is not thread-safe but faster.</p>

                    <pre><code class="language-java">
StringBuilder builder = new StringBuilder();
for (int i = 0; i < 1000; i++) {
builder.append(i);
}
String result = builder.toString();
</code></pre>
                    <p>This code performs much faster and is more memory-efficient than the previous example using the <code>+</code> operator in a loop.</p>
                </article>
            </article>

            <article id="regular-expressions-in-java">
                <h3>3. Regular Expressions in Java</h3>
            </article>
            <article id="basics-of-regex-patterns">
                <h4>3.1 Basics of Regex Patterns</h4>

                <p>Regular expressions, often abbreviated as regex or regexp, provide a powerful means to describe and identify textual patterns. Whether it's validating email addresses, extracting parts of a string, or even performing search and replace operations, regex offers a compact and expressive language for text manipulation.</p>
            </article>
            <article id="what-is-regex">
                <h5>3.1.1 What is Regex?</h5>

                <p>A regular expression is a sequence of characters that defines a search pattern. When you search for data in text, you can use this search pattern to describe what you are seeking. The pattern is composed of simple characters, like alphabets or numbers, and special symbols which hold a particular meaning within the regex language.</p>
            </article>

            <article id="basic-regex-symbols">
                <h5>3.1.2 Basic Regex Symbols</h5>

                <p>Here are some foundational regex symbols and their descriptions:</p>

                <ul>
                    <li><code>.</code> - Matches any single character, except newline characters.</li>
                    <li><code>\d</code> - Matches any digit (equivalent to [0-9]).</li>
                    <li><code>\D</code> - Matches any non-digit character.</li>
                    <li><code>\w</code> - Matches any word character (equivalent to [a-zA-Z0-9_]).</li>
                    <li><code>\W</code> - Matches any non-word character.</li>
                    <li><code>\s</code> - Matches any whitespace character (spaces, tabs, line breaks).</li>
                    <li><code>\S</code> - Matches any non-whitespace character.</li>
                    <li><code>^</code> - Matches the beginning of the string.</li>
                    <li><code>$</code> - Matches the end of the string.</li>
                    <li><code>*</code> - Matches 0 or more repetitions of the preceding regex.</li>
                    <li><code>+</code> - Matches 1 or more repetitions of the preceding regex.</li>
                    <li><code>?</code> - Matches 0 or 1 repetition of the preceding regex.</li>
                </ul>
            </article>

            <article id="example-regex-patterns">
                <h5>3.1.3 Example Regex Patterns</h5>

                <p>Let's delve into a few examples to understand the practical application of regex:</p>

                <pre><code class="language-java">
// A regex pattern to match a simple email
String emailPattern = "^[a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,4}$";

// A regex pattern to match a date format (e.g., dd/mm/yyyy)
String datePattern = "^\\d{2}/\\d{2}/\\d{4}$";

// A regex pattern to match a phone number (e.g., (123) 456-7890)
String phonePattern = "^\\(\\d{3}\\) \\d{3}-\\d{4}$";
</code></pre>

                <p>These patterns employ the basic symbols and combinations we discussed to match specific structures within text strings. Testing a string against these patterns will confirm whether the string fits the specified format or not.</p>
            </article>

            <article id="pattern-and-matcher-classes">
                <h4>3.2 Java's Pattern and Matcher Classes</h4>

                <p>The Java programming language provides a comprehensive API for regex-based pattern matching using the <code>Pattern</code> and <code>Matcher</code> classes, both of which reside in the <code>java.util.regex</code> package. These classes allow you to perform advanced pattern matching, searching, and string manipulations.</p>
            </article>
            <article id="pattern-class-overview">
                <h5>3.2.1 The Pattern Class</h5>

                <p>The <code>Pattern</code> class encapsulates the compiled representation of a regular expression. It offers various static methods and constants to aid regex operations. The primary steps involve:</p>

                <ol>
                    <li>Defining a regex pattern.</li>
                    <li>Compiling the pattern using <code>Pattern.compile()</code>.</li>
                </ol>

                <p>For instance, the method <code>Pattern.matches()</code> can be employed for a quick check if a text matches a given pattern:</p>

                <pre><code class="language-java">boolean isMatch = Pattern.matches("\\d+", "12345");  // true, as "12345" are all digits</code></pre>
            </article>

            <article id="matcher-class-overview">
                <h5>3.2.2 The Matcher Class</h5>

                <p>The <code>Matcher</code> class interprets the pattern and provides methods for pattern-matching operations. Once you've created a <code>Pattern</code> object, you can derive a <code>Matcher</code> object from it to match the pattern against a sequence of characters.</p>

                <p>The <code>Matcher</code> class offers numerous methods, including:</p>

                <ul>
                    <li><code>find()</code> - Searches for the next occurrence of the pattern.</li>
                    <li><code>matches()</code> - Tests if the entire region matches the pattern.</li>
                    <li><code>start()</code> and <code>end()</code> - Return the start and end positions of the last match, respectively.</li>
                    <li><code>group()</code> - Returns the matched subsequence.</li>
                </ul>

                <p>Here's a deeper look at the provided example:</p>

                <pre><code class="language-java">// Importing required classes
import java.util.regex.Matcher;
import java.util.regex.Pattern;

// Define and compile the pattern
Pattern pattern = Pattern.compile("Java");
// Create a matcher for the pattern against a sequence
Matcher matcher = pattern.matcher("I love Java!");

// Search for occurrences of the pattern in the sequence
while (matcher.find()) {
    System.out.println("Pattern found from index " + matcher.start() +
                       " to index " + (matcher.end()-1));
}
</code></pre>

                <p>In this code, the output will indicate that the pattern "Java" is found between indices 7 and 10 in the string "I love Java!".</p>
            </article>

            <article id="practical-applications">
                <h5>3.2.3 Practical Applications</h5>

                <p>The power of the <code>Pattern</code> and <code>Matcher</code> classes lies in their wide range of applications:</p>

                <ul>
                    <li><strong>Data Validation:</strong> Ensure strings conform to expected formats, like phone numbers, emails, and dates.</li>
                    <li><strong>Text Searching:</strong> Locate specific patterns or sequences in larger text bodies.</li>
                    <li><strong>Text Manipulation:</strong> Replace, split, or extract portions of strings based on patterns.</li>
                </ul>

                <p>For instance, you can easily extract all email addresses from a text, split a string at every number, or replace specific patterns with alternatives.</p>
            </article>



            <article id="stringtokenizer-class">
                <h3>4. StringTokenizer Class</h3>
                <p>The <code>StringTokenizer</code> class is a legacy class in Java and is a part of the <code>java.util</code> package. It is used primarily to split a string into multiple tokens based on specified delimiters. While it serves the purpose of string tokenization, many modern Java developers prefer using the <code>split()</code> method of the <code>String</code> class due to its flexibility and more intuitive interface. However, understanding <code>StringTokenizer</code> is valuable, especially when maintaining older Java applications.</p>
            </article>

            <article id="basics-and-methods-of-stringtokenizer">
                <h4>4.1 Basics and Methods of StringTokenizer</h4>
                <p>The primary purpose of the <code>StringTokenizer</code> class is to split strings based on specified delimiters, which are whitespace characters (like spaces, tabs, and newlines) by default. However, custom delimiters can be defined when instantiating a <code>StringTokenizer</code> object.</p>
            </article>
            <article>
                <h5>4.1.1 Key Methods of StringTokenizer</h5>
                <ul>
                    <li><code>hasMoreTokens()</code>: This method returns a boolean indicating whether there are more tokens available in the string.</li>
                    <li><code>nextToken()</code>: Returns the next token (substring) from the string.</li>
                    <li><code>nextToken(String delim)</code>: Returns the next token based on the specified delimiter.</li>
                    <li><code>countTokens()</code>: Returns the number of remaining tokens in the string.</li>
                </ul>

                <p>Here's a deeper look into the provided example and an additional demonstration using custom delimiters:</p>

                <pre><code class="language-java">// Importing required class
import java.util.StringTokenizer;

// Using default delimiters (whitespace)
StringTokenizer defaultDelimiterST = new StringTokenizer("Hello World!");
while (defaultDelimiterST.hasMoreTokens()) {
    System.out.println(defaultDelimiterST.nextToken());
}

// Using custom delimiters
StringTokenizer customDelimiterST = new StringTokenizer("apple,banana,grape", ",");
while (customDelimiterST.hasMoreTokens()) {
    System.out.println(customDelimiterST.nextToken());
}
</code></pre>

                <p>The first tokenizer will print "Hello" and "World!" on separate lines. The second tokenizer, with a comma delimiter, will print "apple", "banana", and "grape" on separate lines.</p>
            </article>
            <article>
                <h5>4.1.2 Considerations when using StringTokenizer</h5>
                <p>Though <code>StringTokenizer</code> is effective for simpler string tokenizing tasks, it has its limitations. For instance:</p>
                <ul>
                    <li>It cannot handle regular expressions like the <code>split()</code> method.</li>
                    <li>It treats consecutive delimiters as one. If you need to recognize empty tokens between delimiters, <code>StringTokenizer</code> might not be the best choice.</li>
                </ul>

                <p>It's also worth noting that the class is considered "legacy" and its use is discouraged in new development in favor of the <code>split()</code> method or the regex API.</p>
            </article>

            <article id="differences-between-split-and-stringtokenizer">
                <h4>4.2 Differences Between split() and StringTokenizer</h4>
                <p>The <code>split()</code> method and the <code>StringTokenizer</code> class in Java are both mechanisms for dividing strings into smaller components or tokens based on specified delimiters. However, they differ in many ways, and their applications can vary depending on the requirements of the task. Here's a detailed comparison:</p>
            </article>
            <article>
                <h5>4.2.1 Usage and Flexibility</h5>
                <ul>
                    <li><strong>split() Method:</strong> Part of the <code>String</code> class, it splits a string based on the provided regular expression and returns an array of substrings. Because it accepts regex, it provides more flexibility in matching complex patterns.</li>
                    <li><strong>StringTokenizer:</strong> A class from the <code>java.util</code> package, it tokenizes a string based on specified delimiters. Unlike <code>split()</code>, it doesn't support regex, making it suitable for simpler tokenizing tasks.</li>
                </ul>
            </article>
            <article>
                <h5>4.2.2 Handling Multiple Delimiters</h5>
                <ul>
                    <li><strong>split() Method:</strong> Requires a more complex regex pattern to handle multiple delimiters.</li>
                    <li><strong>StringTokenizer:</strong> Easily handles multiple delimiters by specifying them all in the constructor string without any spaces.</li>
                </ul>
            </article>
            <article>
                <h5>4.2.3 Consecutive Delimiters</h5>
                <ul>
                    <li><strong>split() Method:</strong> Recognizes consecutive delimiters and returns empty strings for each one.</li>
                    <li><strong>StringTokenizer:</strong> Treats consecutive delimiters as one, so it doesn't recognize empty tokens between them.</li>
                </ul>
            </article>
            <article>
                <h5>4.2.4 Performance</h5>
                <ul>
                    <li><strong>split() Method:</strong> Generally slower than <code>StringTokenizer</code> for simple tasks since it uses regular expressions, which involves compiling and matching the pattern.</li>
                    <li><strong>StringTokenizer:</strong> Usually faster for straightforward delimiter-based tokenizing tasks.</li>
                </ul>
            </article>
            <article>
                <h5>4.2.5 Modernity and Recommendations</h5>
                <ul>
                    <li><strong>split() Method:</strong> Considered modern and is more commonly used in recent Java applications due to its flexibility and integration with the <code>String</code> class.</li>
                    <li><strong>StringTokenizer:</strong> A legacy class; its use is discouraged in new development. It's often encountered in older Java applications.</li>
                </ul>
            </article>


            <article id="scanner-class">
                <h3>5. Scanner Class</h3>
                <p>The <code>Scanner</code> class, part of the <code>java.util</code> package, is a versatile tool for parsing text and converting it into different data types. It's commonly used to read input from various sources such as the console, files, and streams. With the help of regular expressions, the <code>Scanner</code> class provides methods to read and convert text into various primitive data types and strings.</p>
            </article>

            <article id="basics-of-scanner-for-parsing-input">
                <h4>5.1 Basics of Scanner for Parsing Input</h4>
                <p>One of the primary uses of the <code>Scanner</code> class is to obtain user input from the console. Its functionality isn't just limited to reading strings. The class offers a variety of methods to read other data types as well, making it a robust tool for parsing inputs.</p>
            </article>
            <article>
                <h5>5.1.1 Key Methods of Scanner</h5>
                <ul>
                    <li><code>next()</code>: Reads the next token (word) from the input.</li>
                    <li><code>nextLine()</code>: Reads the entire line of input.</li>
                    <li><code>nextInt()</code>, <code>nextDouble()</code>, etc.: Read and convert the next token to the specified type, like an integer or a double.</li>
                    <li><code>hasNext()</code>, <code>hasNextInt()</code>, etc.: Check if there's another token in the input that can be interpreted as a particular type.</li>
                    <li><code>useDelimiter(String pattern)</code>: Sets a specific delimiter pattern for this scanner.</li>
                </ul>

                <p>Here's an elaboration on the provided example, demonstrating the use of <code>Scanner</code> to read different data types:</p>

                <pre><code class="language-java">// Importing Scanner class
import java.util.Scanner;

public class ScannerDemo {
    public static void main(String[] args) {
        // Creating Scanner object
        Scanner sc = new Scanner(System.in);

        // Prompting user for input
        System.out.println("Enter your name:");
        String name = sc.nextLine();

        System.out.println("Enter your age:");
        int age = sc.nextInt();

        System.out.println("Enter your weight (in kg):");
        double weight = sc.nextDouble();

        // Displaying entered data
        System.out.println("Name: " + name);
        System.out.println("Age: " + age);
        System.out.println("Weight: " + weight + " kg");

        // Always close the scanner to avoid resource leak
        sc.close();
    }
}
</code></pre>

                <p>It's worth noting the importance of closing the <code>Scanner</code> object using the <code>close()</code> method after use. This is essential to release the resources associated with it and avoid potential memory leaks.</p>
            </article>
            <article>
                <h5>5.1.2 Common Pitfalls</h5>
                <p>When using <code>Scanner</code>, especially when reading multiple types of data, developers often encounter a common issue related to line ending characters. For instance, after reading an integer with <code>nextInt()</code>, attempting to read a string with <code>nextLine()</code> can unintentionally capture the remaining line ending. To mitigate this, it's a common practice to add an additional <code>nextLine()</code> call to consume the newline character before reading the next string input.</p>
            </article>

            <article id="using-delimiters-with-scanner">
                <h4>5.2 Using Delimiters with Scanner</h4>
                <p>By default, the <code>Scanner</code> class uses whitespace as its delimiter, breaking input into tokens wherever spaces, tabs, or newline characters occur. However, often you may want to parse input data that is separated by a different character or sequence of characters, such as CSV (comma-separated values) files, logs, or any structured text.</p>
            </article>
            <article>
                <h5>5.2.1 Setting a Delimiter</h5>
                <p>With the <code>useDelimiter()</code> method, you can specify a custom delimiter for your scanner. This delimiter can be a plain string or a regular expression pattern, which makes <code>Scanner</code> extremely flexible for text parsing tasks.</p>

                <pre><code class="language-java">// Using a comma as a delimiter
Scanner sc = new Scanner("John,Doe,30");
sc.useDelimiter(",");
while (sc.hasNext()) {
    System.out.println(sc.next());
}

// This will print:
// John
// Doe
// 30
</code></pre>
            </article>
            <article>
                <h5>5.2.2 Advanced Delimiter Patterns</h5>
                <p>By harnessing the power of regular expressions, you can create more complex delimiters. This capability allows you to parse a wide range of text formats.</p>

                <pre><code class="language-java">// Using multiple delimiters: comma or semicolon
Scanner sc2 = new Scanner("Apple,Orange;Grapes,Mango;Blueberry");
sc2.useDelimiter(",|;");
while (sc2.hasNext()) {
    System.out.println(sc2.next());
}

// This will print:
// Apple
// Orange
// Grapes
// Mango
// Blueberry
</code></pre>

                <p>Here, the delimiter pattern <code>",|;"</code> instructs the scanner to treat either a comma or a semicolon as a delimiter.</p>
            </article>
            <article>
                <h5>5.2.3 Best Practices</h5>
                <p>When working with custom delimiters:</p>
                <ul>
                    <li>Be explicit about your delimiter to make your code's intention clear.</li>
                    <li>Regular expression patterns can be complex, so always comment or document intricate delimiter choices.</li>
                    <li>Remember to reset the delimiter to its default (whitespace) if the same scanner instance is being used elsewhere without the custom delimiter.</li>
                </ul>

                <p>Understanding and using delimiters effectively can vastly simplify the process of parsing structured text and data.</p>
            </article>

            <article id="stream-tokenization">
                <h3>6. Stream Tokenization</h3>
            </article>

            <article id="understanding-of-java-streams">
                <h4>6.1 Understanding of Java Streams</h4>
                <p>Introduced in Java 8, the Streams API marked a significant addition to the Java standard library, ushering in a new functional programming paradigm for the language. Instead of explicitly writing iterative loops to process collections of data, with streams, developers can describe the operations they want to perform in a declarative manner.</p>
            </article>
            <article>
                <h5>6.1.1 Basics of Java Streams</h5>
                <p>At its core, a stream is a sequence of elements (e.g., numbers, strings) that can be processed in parallel or sequentially. These elements are derived from a source, such as collections, arrays, or I/O channels.</p>

                <pre><code class="language-java">// Creating a stream from a list and filtering even numbers
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);
Stream<Integer> evenNumbers = numbers.stream().filter(n -> n % 2 == 0);
evenNumbers.forEach(System.out::println); // This will print: 2 4 6
</code></pre>
            </article>
            <article>
                <h5>6.1.2 Intermediate and Terminal Operations</h5>
                <p>Stream operations are divided into intermediate and terminal operations:</p>
                <ul>
                    <li><strong>Intermediate Operations:</strong> Operations that transform a stream into another stream. Examples include <code>map</code>, <code>filter</code>, and <code>sorted</code>. They return a new stream and are always lazy, executing only when a terminal operation is invoked on the stream pipeline.</li>

                    <li><strong>Terminal Operations:</strong> Operations that produce a result or a side-effect. Examples include <code>collect</code>, <code>forEach</code>, <code>reduce</code>, and <code>sum</code>.</li>
                </ul>
            </article>
            <article>
                <h5>6.1.3 Benefits of Using Streams</h5>
                <p>Some of the advantages include:</p>
                <ul>
                    <li>Declarative code style which is often more concise and readable.</li>
                    <li>Parallel processing capabilities for potentially improved performance.</li>
                    <li>Chaining of operations for complex data manipulations.</li>
                    <li>Reusable functional logic.</li>
                </ul>
            </article>

            <article id="tokenizing-streams-using-java-stream-api">
                <h4>6.2 Tokenizing Streams Using Java's Stream API</h4>
                <p>Tokenization, which is essentially the process of converting a sequence of text into distinct pieces or "tokens", often finds its need in text processing and analysis. With Java's Stream API, this becomes a simplified and efficient task.</p>
            </article>
            <article>
                <h5>6.2.1 Using the Pattern class</h5>
                <p>The <code>Pattern</code> class in Java, which provides regex pattern-matching operations, has a method called <code>splitAsStream()</code>. This method can split a given character sequence around matches of the pattern into a stream of tokens.</p>

                <pre><code class="language-java">// Tokenizing a string into a stream using whitespace as a delimiter
Pattern pattern = Pattern.compile(" ");
Stream<String> tokenStream = pattern.splitAsStream("Hello World");
tokenStream.forEach(System.out::println); // This will print: Hello \n World
</code></pre>
            </article>
            <article>
                <h5>6.2.2 Working with Advanced Delimiters</h5>
                <p>Just as with simple delimiters, using the Stream API, you can handle more complex tokenization tasks.</p>

                <pre><code class="language-java">// Tokenizing a string using comma or semicolon as delimiters
Pattern complexPattern = Pattern.compile(",|;");
Stream<String> complexTokenStream = complexPattern.splitAsStream("Apple,Orange;Grapes,Mango;Blueberry");
complexTokenStream.forEach(System.out::println);
// This will print:
// Apple
// Orange
// Grapes
// Mango
// Blueberry
</code></pre>
            </article>
            <article>
                <h5>6.2.3 Further Stream Operations</h5>
                <p>Once tokenized, the stream can be processed further using various Stream operations, such as filtering, mapping, and collecting.</p>

                <pre><code class="language-java">// Filtering and mapping operations on tokenized stream
Stream<String> fruitsStream = Pattern.compile(",|;").splitAsStream("Apple,Orange;Grapes,Mango;Blueberry");
fruitsStream.filter(fruit -> fruit.length() > 5).map(String::toUpperCase).forEach(System.out::println); 
// This will print:
// ORANGE
// GRAPES
// BLUEBERRY
</code></pre>

                <p>Such operations help in refining the tokens as per the specific requirements of a task, showcasing the power and flexibility of Java's Stream API in the realm of text processing.</p>
            </article>

            <article id="practical-applications">
                <h3>7. Practical Applications</h3>
            </article>
            <article id="use-cases-of-tokenization">
                <h4>7.1 Use Cases of Tokenization</h4>
                <p>Tokenization, the process of breaking down a sequence into smaller parts or "tokens", is fundamental in computer science and finds its utility in several domains:</p>
            </article>
            <article>
                <h5>7.1.1 Configuration Parsing</h5>
                <p>Modern applications often rely on configuration files to determine their behavior at runtime. These files, whether in XML, JSON, or .ini formats, contain key-value pairs. Tokenizing these files allows applications to fetch configuration values efficiently.</p>
            </article>
            <article>
                <h5>7.1.2 Natural Language Processing (NLP)</h5>
                <p>Tokenization is a foundational step in NLP. Whether analyzing sentiment, translating languages, or extracting information, breaking down text into tokens (like words or phrases) facilitates further processing such as tagging parts of speech or feeding into machine learning models.</p>
            </article>
            <article>
                <h5>7.1.3 Search Engines</h5>
                <p>Tokenization aids in indexing content. For example, web pages can be tokenized into words or phrases, making it possible for search engines to quickly find and rank relevant pages based on user queries.</p>
            </article>
            <article>
                <h5>7.1.4 Text Editors and IDEs</h5>
                <p>Tokenization enables features like syntax highlighting, autocompletion, and error detection. By recognizing and classifying tokens, editors can offer rich user experiences to programmers.</p>
            </article>
            <article>
                <h5>7.1.5 Data Analysis and Visualization</h5>
                <p>Data often comes in unstructured formats. Tokenization assists in converting such data into structured formats, facilitating analysis, and representation in charts, graphs, or tables.</p>
            </article>
            <article>
                <h5>7.1.6 Cybersecurity</h5>
                <p>In data protection, tokenization replaces sensitive data elements with non-sensitive equivalents, called tokens. This approach is often used in payment processing systems to enhance security.</p>
            </article>

            <article id="common-pitfalls-and-best-practices">
                <h4>7.2 Common Pitfalls and Best Practices</h4>
                <p>While tokenization is powerful, certain pitfalls and best practices should be observed:</p>
            </article>
            <article>
                <h5>7.2.1 Misuse of Regular Expressions</h5>
                <p>While regex is a potent tool for pattern matching and text manipulation, misuse can lead to inefficient code. Overly complex regular expressions can be hard to read and maintain, and can also degrade performance.</p>
            </article>
            <article>
                <h5>7.2.2 Resource Management</h5>
                <p>Objects like <code>Scanner</code> consume system resources. Neglecting to close them can result in resource leaks which degrade system performance. Ensure resources are closed after use, preferably in a <code>finally</code> block or using try-with-resources.</p>
            </article>
            <article>
                <h5>7.2.3 Ignoring Locale-Specific Behavior</h5>
                <p>Tokenization can behave differently across locales. For instance, the way words are separated might vary. Being aware of locale-specific nuances ensures consistent behavior across different environments.</p>
            </article>
            <article>
                <h5>7.2.4 Over-tokenization</h5>
                <p>Breaking text into too many tokens can lead to a loss of context or meaning. It's essential to choose delimiters wisely, especially in NLP tasks.</p>
            </article>
            <article>
                <h5>7.2.5 Not Handling Edge Cases</h5>
                <p>Special characters, escape sequences, and other edge cases can trip up naive tokenization. It's crucial to test tokenization against varied inputs to catch and handle such cases.</p>
            </article>

            <article id="comparative-analysis">
                <h3>8. Comparative Analysis</h3>
            </article>

            <article id="when-to-use-which-tokenization-method">
                <h4>8.1 When to Use Which Tokenization Method</h4>
                <p>Java provides multiple ways to tokenize strings, each having its strengths and use-cases:</p>
            </article>
            <article>
                <h5>8.1.1 String's split() Method</h5>
                <p>This is one of the simplest ways to tokenize a string based on a specific delimiter. The method is efficient for straightforward tokenization tasks, where there is a clear delimiter that separates tokens.</p>
            </article>
            <article>
                <h5>8.1.2 StringTokenizer Class</h5>
                <p>StringTokenizer is more flexible compared to <code>split()</code> and is designed explicitly for tokenization. It's beneficial when the delimiter set is known and fixed, or when we require to handle multiple delimiters.</p>
            </article>
            <article>
                <h5>8.1.3 Java's Regex Pattern and Matcher</h5>
                <p>For complex tokenization tasks that involve patterns or when greater control over the matching process is needed, using the Pattern and Matcher classes is recommended. This is particularly useful in situations that involve intricate patterns or require validation alongside tokenization.</p>
            </article>
            <article>
                <h5>8.1.4 Java Stream API</h5>
                <p>Streams offer a more functional approach to tokenization, making it easier to integrate with other stream operations. They are especially powerful when combined with other transformations or filters. This method is suited for complex data manipulations and when working with larger datasets.</p>
            </article>

            <article id="performance-implications">
                <h4>8.2 Performance Implications</h4>
                <p>Performance is a critical aspect when choosing a tokenization approach, especially in applications that deal with a large amount of text data. Here are some considerations:</p>
            </article>
            <article>
                <h5>8.2.1 Regular Expressions</h5>
                <p>While regular expressions are powerful, they can be computationally expensive, especially if not optimized or used inappropriately. For example, using '.*' or '.+' recklessly can cause catastrophic backtracking and slow down the processing.</p>
            </article>
            <article>
                <h5>8.2.2 String Concatenation</h5>
                <p>As strings in Java are immutable, each string concatenation creates a new object. This can have significant performance implications, especially in loops. StringBuilder or StringBuffer is recommended for intensive string manipulations.</p>
            </article>
            <article>
                <h5>8.2.3 Libraries and Utilities</h5>
                <p>For repetitive and common tasks, consider using third-party libraries like Apache's StringUtils or Google's Guava. These libraries often have optimized implementations that can handle large datasets efficiently.</p>
            </article>
            <article>
                <h5>8.2.4 Benchmarking</h5>
                <p>It's essential to benchmark different tokenization methods, especially in performance-critical applications. Java's JMH (Java Microbenchmarking Harness) can be useful in assessing the performance of various approaches.</p>
            </article>
            </article>

            <article id="inspire-to-learn-more">
                <h3>9. Embark on a Journey to Mastery</h3>
                <p>Having gained insights into tokenization in Java, envision the vast landscapes of programming yet to be explored. Use this newfound knowledge as a stepping stone to dive deeper into the world of Java and software development. The horizon beckons!</p>
            </article>

        </main>

        <script> copyright("all"); </script>

    </body>

</html>
