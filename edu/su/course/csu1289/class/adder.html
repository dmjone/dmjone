<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
  <!--<![endif]-->

  <head>
    <script src="/js/edu_su_common.js"></script>
    <noscript>
      <style>
        html,
        body {
          margin: 0;
          overflow: hidden;
        }
      </style>
      <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
    </noscript>

    <title>Exploring Adders: Half & Full - CSU1289 - Shoolini U</title>
    <meta name="description" content="Dive deep into the world of Digital Electronics, exploring the dynamics of Half & Full Adders in our CSU1289 course at Shoolini University.">

    <meta property="og:image" content="/logo.png">
    <meta property="og:type" content="article">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@divyamohan1993">
    <meta name="twitter:creator" content="@divyamohan1993">
    <meta name="twitter:image" content="/logo.png">

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />

    <meta name="author" content="Divya Mohan">
    <meta name="robots" content="index, follow">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
          // customised options
          // • auto-render specific keys, e.g.:
          delimiters: [
            { left: '$$', right: '$$', display: true },
            { left: '$', right: '$', display: false },
            { left: '\\(', right: '\\)', display: false },
            { left: '\\[', right: '\\]', display: true }
          ],
          // • rendering keys, e.g.:
          throwOnError: false
        });
      });
    </script>
  </head>

  <body>

    <script>header_author("dm");</script>

    <main>
      <article class="agen-tableofcontents">
        <h2 class="text-center">
          Adders
        </h2>
      </article>
      <article>
        <h3>1. The Puzzle of Binary Addition</h3>
        <p>Imagine a situation where you're working on a project that involves a digital system, such as a computer. You have to handle binary data, and you need to add two binary numbers together. Sure, you could convert them to decimal, add them, and then convert back, but that would be inefficient and time-consuming. This is where the concept of adders in digital electronics comes to the rescue. They are devices capable of performing binary addition directly, without the need for such roundabout conversions.</p>
        <p>Adders are fundamental building blocks in digital electronics. They perform the basic arithmetic operation of addition in computers and other digital systems. They are the core elements of arithmetic logic units and processors, facilitating the execution of complex mathematical and logical functions.</p>
        <p>With this in mind, let's dive into the world of adders and explore the inner workings of half adders and full adders.</p>
      </article>
      <article>
        <h3>2. The Half Adder</h3>
        <p>Before we can appreciate the intricacy of a full adder, we need to understand its simpler sibling, the half adder. A half adder is a simple digital circuit that performs the addition of two binary digits. However, its simplicity comes with a limitation—it doesn't account for any carry from a previous addition.</p>
        <p>The half adder is constructed using two basic logic gates, the XOR gate (74LS86) and the AND gate (7408). Now, what is a logic gate? In the simplest terms, it's a basic building block of a digital circuit that performs a specific logical function. The XOR gate delivers an output of 1 if the number of 1's in the input is odd, while the AND gate gives an output of 1 only if both inputs are 1.</p>
        <article>
          <h4>2.1 Half Adder: Design and Function</h4>
          <p>Let's consider a half adder receiving two binary inputs A and B. The XOR gate computes the sum, denoted as S, and the AND gate generates the carry, represented as C.</p>
          <p>The XOR operation mimics the basic principles of addition we learned in grade school. Consider the addition of two binary digits: 0+0=0, 0+1=1, and 1+1=10. The rightmost digit of each sum corresponds to the XOR operation. The AND gate, on the other hand, identifies if a carry is generated. The carry is 1 only when both A and B are 1, which is precisely the operation of the AND gate.</p>
          <p>So, a half adder can be viewed as a combination of these two operations.</p>
          <pre><code class="language-cpp">// C++ code for Half Adder

#include &lt;iostream>
using namespace std;

// Function to implement half adder
void HalfAdder(bool A, bool B, bool &S, bool &C)
{
    // XOR operation for sum
    S = A ^ B;
    
    // AND operation for carry
    C = A & B;
}

int main()
{
    bool A = 1;
    bool B = 0;
    bool S; // Sum
    bool C; // Carry
    HalfAdder(A, B, S, C);
    cout<<"Sum = "<< S<<"\nCarry = "<< C<< endl;
    return 0;
}</code></pre>
          <p>Running the above C++ program with inputs A=1 and B=0 will give you the Sum = 1 and Carry = 0, which corresponds to the binary addition of the inputs.</p>

          <p>The half adder, while useful, has a limitation. It doesn't consider any carry input from a previous stage of addition, and hence it's called a "half" adder. But what if we want to add binary numbers with more than one bit? We need a way to include the carry from the previous bit's addition, and this leads us to the concept of a full adder.</p>
        </article>
      </article>
      <article>
        <h3>3. The Full Adder</h3>
        <p>When we are dealing with binary numbers larger than one bit, we need to account for the carry generated in the previous bit's addition. This is where the full adder comes into play. A full adder is a digital circuit that not only adds two binary digits but also accounts for an input carry.</p>
        <p>The full adder is constructed using the XOR, AND, and OR gates. Here, the OR gate (7432) joins the team. An OR gate delivers an output of 1 if at least one of the inputs is 1. It's used in a full adder to combine the carry outputs.</p>
        <article>
          <h4>3.1 Full Adder: Design and Function</h4>
          <p>A full adder takes three inputs: A, B, and an input Carry (C<sub>in</sub>). It generates two outputs: a Sum (S) and an output Carry (C<sub>out</sub>). Here, the XOR operation is performed twice, first between A and B, and then between the result and C<sub>in</sub>. The carry is generated by two AND gates and an OR gate. One AND gate takes A and B as inputs, and the other takes the XOR output of A and B and C<sub>in</sub>. The outputs of these AND gates are then given to the OR gate, which generates C<sub>out</sub>.</p>
          <p>This design ensures that the carry is forwarded when either of the following conditions is met: both A and B are 1, or one of A or B is 1 and C<sub>in</sub> is also 1. This aligns with our understanding of binary addition.</p>
          <pre><code class="language-cpp">// C++ code for Full Adder

#include &lt;iostream>
using namespace std;

// Function to implement full adder
void FullAdder(bool A, bool B, bool Cin, bool &S, bool &Cout)
{
    // XOR operation for sum
    S = A ^ B ^ Cin;
    
    // AND-OR operation for carry
    Cout = (A & B) | ((A ^ B) & Cin);
}

int main()
{
    bool A = 1;
    bool B = 1;
    bool Cin = 1;
    bool S; // Sum
    bool Cout; // Carry
    FullAdder(A, B, Cin, S, Cout);
    cout<<"Sum = "<< S<<"\nCarry = "<< Cout<< endl;
    return 0;
}
          </code></pre>
          <p>Running the above C++ program with inputs A=1, B=1, and Cin=1 will give you the Sum = 1 and Carry = 1, which corresponds to the binary addition of the inputs along with the input carry.</p>
          <p>The full adder is a significant advancement over the half adder as it can be used to add larger binary numbers by cascading several full adders into a ripple carry adder. However, the discussion of ripple carry adders is beyond the scope of this article.</p>
        </article>
      </article>
      <article>
        <h3>4. Conclusion</h3>
        <p>As we've seen, adders are at the very heart of digital systems, playing a crucial role in data processing and management. Whether it's a simple half adder or a more complex full adder, each performs a pivotal function in binary data manipulation. Understanding how these basic building blocks operate is essential to comprehending more complex digital systems.</p>
        <p>With just XOR, AND, and OR gates, we've constructed devices that can add binary numbers, a task that is seemingly simple yet involves a profound understanding of logic and digital principles. Through our exploration of half adders and full adders, we've seen the elegance and efficiency of digital electronics, demonstrating how simple logic gates can result in powerful computational devices.</p>
        <p>After this exploration, we can summarize our findings as follows:</p>
        <ul>
          <li>A half adder is a digital circuit that performs the addition of two binary digits using XOR and AND gates. It doesn't account for any carry from a previous addition.</li>
          <li>A full adder, on the other hand, takes into account an input carry along with the two binary digits. It's designed using XOR, AND, and OR gates.</li>
          <li>Both half adders and full adders are fundamental components of arithmetic logic units and processors, facilitating mathematical and logical functions in digital systems.</li>
        </ul>
        <p>Through the detailed discussion and C++ implementations of half adders and full adders, we have gained valuable insights into the workings of these fundamental digital devices.</p>
        <p>Although adders are incredibly useful, there are times when we need to subtract binary numbers rather than add them. How do we handle such scenarios? Just as adders help us with addition, there are digital circuits known as subtractors that aid us in subtraction. Let us also <a href="subtractor">explore the world of subtractors</a>, delving into the intricacies of half subtractors and full subtractors, and seeing how they manage the task of binary subtraction.</p>
        <p>Having journeyed this far into the world of digital electronics, we're ready to venture deeper. In the next section, we will explore how multiple full adders can be combined to form a ripple carry adder, enabling the addition of multi-bit binary numbers. We will delve into the structure, operation, and implementation of a ripple carry adder, uncovering the intricacies and marvels of digital addition at a larger scale. The journey continues!</p>
      </article>
    </main>

    <script>copyright("all");</script>
  </body>

</html>
