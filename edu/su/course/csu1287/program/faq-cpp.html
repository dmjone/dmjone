<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
  <!--<![endif]-->

  <head>
    <script src="/js/edu_su_common.js"></script>
    <noscript>
      <style>
        html,
        body {
          margin: 0;
          overflow: hidden;
        }
      </style>
      <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
    </noscript>

    <title>C++ Knowledge Challenge - CSU1287 - Shoolini U</title>
    <meta name="description" content="Brush up for exams or interviews with our C++ knowledge test. Part of our CSU1287 course at dmj.one with Shoolini University, suitable for all learning levels.">

    <meta property="og:image" content="/logo.png">
    <meta property="og:type" content="article">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@divyamohan1993">
    <meta name="twitter:creator" content="@divyamohan1993">
    <meta name="twitter:image" content="/logo.png">

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />

  </head>

  <body>

    <script>header_author("dm");</script>

    <main>
      <article>
        <h2 class="text-center">
          FAQ's / Test Your Knowledge in C++
        </h2>
      </article>

      <article id="question-1">
        <h3>1. What is the primary purpose of the keyword "virtual" in C++?</h3>
        <p>A) To provide polymorphism </p>
        <p>B) To provide dynamic binding</p>
        <p>C) To allow overriding of base class functions in derived classes</p>
        <p>D) All of the above</p>
        <p><i>The key to this answer lies in your understanding of OOP concepts.</i></p>
      </article>
      <article id="question-2">
        <h3>2. What is the output of the following program snippet?</h3>
        <pre><code class="language-cpp">
class Base {
public:
    virtual void show() { cout<<" In Base \n"; }
};
class Derived: public Base {
public:
    void show() { cout<<"In Derived \n"; }
};
int main(void) {
    Base *bp = new Derived;
    bp->show();
}
</code></pre>
        <p>A) In Base </p>
        <p>B) In Derived</p>
        <p>C) Compilation Error</p>
        <p>D) None of the above</p>
        <p><i>Here's a clue: "virtual" and "override" can often lead to surprising results...</i></p>
      </article>
      <article id="question-3">
        <h3>3. What does the following C++ statement mean?</h3>
        <pre><code class="language-cpp">int *ptr = new int[10];</code></pre>
        <p>A) ptr is a pointer to an array of integers of size 10</p>
        <p>B) ptr is an array of pointers to integers</p>
        <p>C) ptr is a pointer to the first element of an array of 10 integers</p>
        <p>D) ptr is a pointer to an integer array of 10 bytes</p>
        <p><i>The answer reveals the power of dynamic memory allocation.</i></p>
      </article>
      <article id="question-4">
        <h3>4. If class B is publicly derived from class A, which of the following is not true?</h3>
        <p>A) Each object of class B includes an object of class A</p>
        <p>B) Class B can access protected members of class A, but not its private members</p>
        <p>C) Class B is a subtype of class A</p>
        <p>D) Class B can change the value of private data members of class A</p>
        <p><strong>Answer: D</strong></p>
      </article>
      <article id="question-5">
        <h3>5. What does the keyword "friend" do in a class definition?</h3>
        <p>A) It gives another class or function access to the private and protected members of the class</p>
        <p>B) It makes a class or function a member of the class</p>
        <p>C) It provides a way for a class to hide data from other classes</p>
        <p>D) It makes a class or function a subclass of the class</p>
        <p><i>Here's a hint: Think about the intimacy of the term "friend."</i></p>
      </article>
      <article id="question-6">
        <h3>6. Which one is NOT a characteristic of Object Oriented Programming?</h3>
        <p>A) Inheritance</p>
        <p>B) Data hiding</p>
        <p>C) Polymorphism</p>
        <p>D) Direct access to private data of classes</p>
        <p><strong>Answer: D</strong></p>
      </article>
      <article id="question-7">
        <h3>7. When does the constructor for a derived class call the constructor for the base class?</h3>
        <p>A) Whenever an object of the derived class is created</p>
        <p>B) Only when the programmer specifically writes code to call the base class constructor</p>
        <p>C) Whenever an object of the base class is created</p>
        <p>D) Only when the derived class constructor is not defined</p>
        <p><i>Recall the order of construction in inheritance...</i></p>
      </article>
      <article id="question-8">
        <h3>8. Which one is not an access specifier in C++?</h3>
        <p>A) Public</p>
        <p>B) Private</p>
        <p>C) Protected</p>
        <p>D) Confidential</p>
        <p><strong>Answer: D</strong></p>
      </article>
      <article id="question-9">
        <h3>9. What is the output of the following code snippet?</h3>
        <pre><code class="language-cpp">
#include &lt;iostream>
using namespace std;
class A {
public:
A() {cout << "Constructor A " << endl;}
~A() {cout << "Destructor A " << endl;}
};

class B : public A {
public:
B() {cout << "Constructor B " << endl;}
~B() {cout << "Destructor B " << endl;}
};

int main() {
B obj;
return 0;
}
</code></pre>

        <p>A) Constructor A Constructor B Destructor B Destructor A</p>
        <p>B) Constructor B Constructor A Destructor A Destructor B</p>
        <p>C) Constructor A Constructor B Destructor A Destructor B</p>
        <p>D) Constructor B Constructor A Destructor B Destructor A</p>
        <p><i>Hint: Destruction is the reverse of construction...</i></p>
      </article>
      <article id="question-10">
        <h3>10. Which statement about copy constructors is correct?</h3>
        <p>A) Copy constructor is called when an object is returned by value</p>
        <p>B) Copy constructor is called when an object is passed by value as an argument</p>
        <p>C) Copy constructor is called when compiler generates a temporary object</p>
        <p>D) All of the above</p>
        <p><i>Ponder this, the secret lies within the name itself...</i></p>
      </article>
      <article id="question-11">
        <h3>11. What is the output of the following code snippet?</h3>
        <pre><code class="language-cpp">
class A
{
public:
    A() { cout << "A's constructor called" << endl; }
};
class B
{
public:
B() { cout << "B's constructor called" << endl; }
};

class C: public B, public A
{
public:
C() { cout << "C's constructor called" << endl; }
};

int main()
{
C c;
return 0;
}
</code></pre>

        <p>A) C's constructor called, B's constructor called, A's constructor called</p>
        <p>B) A's constructor called, B's constructor called, C's constructor called</p>
        <p>C) B's constructor called, A's constructor called, C's constructor called</p>
        <p>D) None of the above</p>
        <p><i>This question tests your understanding of constructor order in multiple inheritance...</i></p>
      </article>
      <article id="question-12">
        <h3>12. What is a pure virtual function in C++?</h3>
        <p>A) A virtual function that must be overridden in every derived class</p>
        <p>B) A virtual function that has no definition in the base class</p>
        <p>C) A virtual function that can be overridden in the derived class</p>
        <p>D) Both A and B</p>
        <p><strong>Answer: D</strong></p>
      </article>
      <article id="question-13">
        <h3>13. If you do not provide a constructor for a class, the compiler provides one for you. What does this constructor do?</h3>
        <p>A) Initializes all data members to zero</p>
        <p>B) Allocates memory for the object</p>
        <p>C) Does nothing</p>
        <p>D) Both A and B</p>
        <p><i>What secrets are hidden in the unseen code?</i></p>
      </article>
      <article id="question-14">
        <h3>14. What is meant by function overriding in C++?</h3>
        <p>A) It refers to a derived class defining a function that is already defined in its base class</p>
        <p>B) It refers to a class defining a function that is already defined in its base class</p>
        <p>C) It refers to a derived class defining a function that is already defined in another derived class</p>
        <p>D) It refers to a base class defining a function that is already defined in its derived class</p>
        <p><strong>Answer: A</strong></p>
      </article>
      <article id="question-15">
        <h3>15. What is the purpose of the "this" pointer?</h3>
        <p>A) To allow functions to reference the object that invoked them</p>
        <p>B) To allow functions to reference any object of the class</p>
        <p>C) To allow functions to modify the data members of the class</p>
        <p>D) To allow functions to access private members of the class</p>
        <p><i>A small keyword, yet its significance is deep...</i></p>
      </article>
      <article id="question-16">
        <h3>16. What is the "diamond problem" in C++?</h3>
        <p>A) It is a problem caused by multiple inheritance</p>
        <p>B) It is a problem caused by private inheritance</p>
        <p>C) It is a problem caused by public inheritance</p>
        <p>D) It is a problem caused by the "virtual" keyword</p>
        <p><strong>Answer: A</strong></p>
      </article>
      <article id="question-17">
        <h3>17. When does a compiler create a default copy constructor?</h3>
        <p>A) When we define a parameterized constructor</p>
        <p>B) When we donâ€™t define any constructor in the class</p>
        <p>C) When we define an overloaded constructor</p>
        <p>D) Both A and B</p>
        <p><i>The compiler's duty is more than just error checking...</i></p>
      </article>
      <article id="question-18">
        <h3>18. What is a namespace in C++?</h3>
        <p>A) It is a container for identifiers. It puts the names of its members in a distinct space so that they don't conflict with the names in other namespaces or global namespace</p>
        <p>B) It is a class of objects</p>
        <p>C) It is a special function used in classes</p>
        <p>D) None of the above</p>
        <p><strong>Answer: A</strong></p>
      </article>
      <article id="question-19">
        <h3>19. What is the output of the following code snippet?</h3>
        <pre><code class="language-cpp">
#include &lt;iostream>
using namespace std;
class MyClass {
int x;
public:
MyClass(int val) : x(val) {}
int get() {return x;}
};

int main() {
MyClass obj(100);
cout << obj.get();
return 0;
}
</code></pre>

        <p>A) 0</p>
        <p>B) 1</p>
        <p>C) 100</p>
        <p>D) Compilation error</p>
        <p><i>Remember, initializations occur before the body of constructors...</i></p>
      </article>
      <article id="question-20">
        <h3>20. Can we have a class in C++ without any data member?</h3>
        <p>A) Yes</p>
        <p>B) No</p>
        <p>C) Only if it is a derived class</p>
        <p>D) Only if it is a base class</p>
        <p><strong>Answer: A</strong></p>
      </article>
      <article id="question-21">
        <h3>21. When are static member functions invoked?</h3>
        <p>A) When an object of the class is created</p>
        <p>B) When only static data members are accessed</p>
        <p>C) Without the creation of an object</p>
        <p>D) Both A and C</p>
        <p><i>A hint: The keyword "static" comes with special privileges...</i></p>
      </article>
      <article id="question-22">
        <h3>22. What is a conversion constructor in C++?</h3>
        <p>A) It is a constructor that can be used to convert a type to a class type</p>
        <p>B) It is a constructor that converts the values of data members of a class</p>
        <p>C) It is a constructor that is used for type conversion</p>
        <p>D) It is a constructor that can be called with a single argument</p>
        <p><i>Consider the essence of conversion...</i></p>
      </article>
      <article id="question-23">
        <h3>23. What is the output of the following code snippet?</h3>
        <pre><code class="language-cpp">
#include &lt;iostream>
using namespace std;
class A {
public:
void print() { cout << "Class A" << endl; }
};

class B : public A {
public:
void print() { cout << "Class B" << endl; }
};

int main() {
A* a = new B();
a->print();
return 0;
}
</code></pre>

        <p>A) Class A</p>
        <p>B) Class B</p>
        <p>C) Compilation error</p>
        <p>D) None of the above</p>
        <p><strong>Answer: A</strong></p>
      </article>
      <article id="question-24">
        <h3>24. Which statement about virtual functions in C++ is NOT true?</h3>
        <p>A) They support dynamic binding</p>
        <p>B) They are defined in the base class and overridden in the derived class</p>
        <p>C) They cannot be static</p>
        <p>D) They are invoked based on the type of the object, not the type of the pointer/reference</p>
        <p><strong>Answer: D</strong></p>
      </article>
      <article id="question-25">
        <h3>25. What is the output of the following code snippet?</h3>
        <pre><code class="language-cpp">
#include &lt;iostream>
using namespace std;
class A {
public:
A() { cout << "A's constructor called" << endl; }
};

class B {
public:
B() { cout << "B's constructor called" << endl; }
};

class C: public B, public A {
public:
C() { cout << "C's constructor called" << endl; }
};

int main() {
C c;
return 0;
}
</code></pre>

        <p>A) C's constructor called, B's constructor called, A's constructor called</p>
        <p>B) A's constructor called, B's constructor called, C's constructor called</p>
        <p>C) B's constructor called, A's constructor called, C's constructor called</p>
        <p>D) None of the above</p>
        <p><i>Revisit your knowledge on the sequence of constructor calls...</i></p>
      </article>
      <article id="question-26">
        <h3>26. Can a friend function be used to override a member function?</h3>
        <p>A) Yes</p>
        <p>B) No</p>
        <p>C) Only in derived classes</p>
        <p>D) Only in base classes</p>
        <p><strong>Answer: B</strong></p>
      </article>
      <article id="question-27">
        <h3>27. What is a virtual destructor?</h3>
        <p>A) A destructor that is called virtually</p>
        <p>B) A destructor that is used to destroy virtual objects</p>
        <p>C) A destructor that can be overridden in derived classes</p>
        <p>D) A destructor that can be used to delete a polymorphic object</p>
        <p><i>Contemplate the purpose of destructors in a polymorphic scenario...</i></p>
      </article>
      <article id="question-28">
        <h3>28. What is the use of the "explicit" keyword in C++?</h3>
        <p>A) To convert implicit constructors to explicit</p>
        <p>B) To prevent the compiler from using a constructor for implicit conversion</p>
        <p>C) To specify explicit values for data members</p>
        <p>D) To specify explicit functions in a class</p>
        <p><strong>Answer: B</strong></p>
      </article>
      <article id="question-29">
        <h3>29. What is the output of the following code snippet?</h3>
        <pre><code class="language-cpp">
#include &lt;iostream>
using namespace std;
class A {
public:
A(int x) { cout << "A's constructor called" << endl; }
};

class B: public A {
public:
B(): A(10) { cout << "B's constructor called" << endl; }
};

int main() {
B b;
return 0;
}
</code></pre>

        <p>A) B's constructor called, A's constructor called</p>
        <p>B) A's constructor called, B's constructor called</p>
        <p>C) Compilation error</p>
        <p>D) None of the above</p>
        <p><i>Reflect upon the sequence of constructor calls in inheritance...</i></p>
      </article>
      <article id="question-30">
        <h3>30. How does protected access specifier differ from private in classes?</h3>
        <p>A) Members declared as private are accessible from within the same class only</p>
        <p>B) Members declared as protected are accessible from the class they are declared in and from any class derived from it</p>
        <p>C) Members declared as protected are accessible from any class</p>
        <p>D) Both A and B</p>
        <p><strong>Answer: D</strong></p>
      </article>
      <article id="question-31">
        <h3>31. What is the purpose of a destructor?</h3>
        <p>A) To initialize objects</p>
        <p>B) To destroy objects</p>
        <p>C) To allocate memory to objects</p>
        <p>D) To copy objects</p>
        <p><i>A little pondering and the name shall reveal itself...</i></p>
      </article>
      <article id="question-32">
        <h3>32. What is the order of destruction for objects created from derived and base classes?</h3>
        <p>A) The derived class is destroyed first, followed by the base class</p>
        <p>B) The base class is destroyed first, followed by the derived class</p>
        <p>C) The order of destruction is random</p>
        <p>D) None of the above</p>
        <p><strong>Answer: A</strong></p>
      </article>
      <article id="question-33">
        <h3>33. Which of the following is not a type of inheritance in C++?</h3>
        <p>A) Single inheritance</p>
        <p>B) Multiple inheritance</p>
        <p>C) Multilevel inheritance</p>
        <p>D) Bilateral inheritance</p>
        <p><strong>Answer: D</strong></p>
      </article>
      <article id="question-34">
        <h3>34. What is the output of the following code snippet?</h3>
        <pre><code class="language-cpp">
#include &lt;iostream>
using namespace std;
class A {
public:
A() { cout << "A's constructor called" << endl; }
};

class B {
public:
B() { cout << "B's constructor called" << endl; }
};

class C: public A, public B {
public:
C() { cout << "C's constructor called" << endl; }
};

int main() {
C c;
return 0;
}
</code></pre>

        <p>A) C's constructor called, B's constructor called, A's constructor called</p>
        <p>B) A's constructor called, B's constructor called, C's constructor called</p>
        <p>C) B's constructor called, A's constructor called, C's constructor called</p>
        <p>D) None of the above</p>
        <p><strong>Answer: B</strong></p>
      </article>
      <article id="question-35">
        <h3>35. Can pure virtual functions be private in C++?</h3>
        <p>A) Yes</p>
        <p>B) No</p>
        <p>C) Only in base classes</p>
        <p>D) Only in derived classes</p>
        <p><i>Dive deep into the realms of access specifiers and virtual functions...</i></p>
      </article>
      <article id="question-36">
        <h3>36. What is the purpose of a pure virtual function?</h3>
        <p>A) To provide a base for other classes to inherit from</p>
        <p>B) To create abstract base classes</p>
        <p>C) To ensure that derived classes provide their own implementation of the function</p>
        <p>D) Both B and C</p>
        <p><strong>Answer: D</strong></p>
      </article>
      <article id="question-37">
        <h3>37. What is the output of the following code snippet?</h3>
        <pre><code class="language-cpp">
#include &lt;iostream>
using namespace std;
class A {
public:
A() { cout << "A's constructor called" << endl; }
~A() { cout << "A's destructor called" << endl; }
};

class B: public A {
public:
B() { cout << "B's constructor called" << endl; }
~B() { cout << "B's destructor called" << endl; }
};

int main() {
B b;
return 0;
}
</code></pre>

        <p>A) A's constructor called, B's constructor called, B's destructor called, A's destructor called</p>
        <p>B) A's constructor called, B's constructor called, A's destructor called, B's destructor called</p>
        <p>C) B's constructor called, A's constructor called, A's destructor called, B's destructor called</p>
        <p>D) B's constructor called, A's constructor called, B's destructor called, A's destructor called</p>
        <p><strong>Answer: A</strong></p>
      </article>
      <article id="question-38">
        <h3>38. What is the use of a copy constructor in C++?</h3>
        <p>A) To initialize an object from another of the same type</p>
        <p>B) To make a copy of an existing object</p>
        <p>C) To perform deep copy</p>
        <p>D) All of the above</p>
        <p><i>Think about copying...</i></p>
      </article>
      <article id="question-39">
        <h3>39. Which of the following concepts makes C++ a multi-paradigm language?</h3>
        <p>A) Procedural programming</p>
        <p>B) Object-oriented programming</p>
        <p>C) Generic programming</p>
        <p>D) All of the above</p>
        <p><strong>Answer: D</strong></p>
      </article>
      <article id="question-40">
        <h3>40. What is the diamond problem in multiple inheritance?</h3>
        <p>A) It is a problem when a class inherits from two classes that have a common base class</p>
        <p>B) It is a problem when a class inherits from two classes that have the same method</p>
        <p>C) It is a problem when a class inherits from two classes that have a common derived class</p>
        <p>D) None of the above</p>
        <p><i>Ponder upon the complexities of multiple inheritance...</i></p>
      </article>
      <article id="question-41">
        <h3>41. In what scenario is a virtual destructor required?</h3>
        <p>A) When the base class has a virtual function</p>
        <p>B) When the derived class has a virtual function</p>
        <p>C) When we deal with a polymorphic object</p>
        <p>D) All of the above</p>
        <p><strong>Answer: C</strong></p>
      </article>
      <article id="question-42">
        <h3>42. What happens when we attempt to delete a NULL pointer in C++?</h3>
        <p>A) Nothing</p>
        <p>B) It results in a compile-time error</p>
        <p>C) It results in a runtime error</p>
        <p>D) It results in a segmentation fault</p>
        <p><i>Think about the nature of NULL...</i></p>
      </article>
      <article id="question-43">
        <h3>43. What is the default access specifier in a C++ class?</h3>
        <p>A) Public</p>
        <p>B) Private</p>
        <p>C) Protected</p>
        <p>D) None</p>
        <p><strong>Answer: B</strong></p>
      </article>
      <article id="question-44">
        <h3>44. Which of the following is NOT a feature of Object-Oriented Programming?</h3>
        <p>A) Encapsulation</p>
        <p>B) Polymorphism</p>
        <p>C) Inheritance</p>
        <p>D) Late Binding</p>
        <p>E) Recursion</p>
        <p><i>Try to picture the key pillars of OOP...</i></p>
      </article>
      <article id="question-45">
        <h3>45. What is RTTI in C++?</h3>
        <p>A) Real Time Type Information</p>
        <p>B) Run Time Type Information</p>
        <p>C) Real Type Time Information</p>
        <p>D) Run Time Type Interface</p>
        <p><strong>Answer: B</strong></p>
      </article>
      <article id="question-46">
        <h3>46. Can we use the "this" pointer in a static member function?</h3>
        <p>A) Yes</p>
        <p>B) No</p>
        <p>C) Only in derived classes</p>
        <p>D) Only in base classes</p>
        <p><i>Reflect on the nature of static functions...</i></p>
      </article>
      <article id="question-47">
        <h3>47. What is a conversion constructor in C++?</h3>
        <p>A) A constructor that converts an object of one class to another class</p>
        <p>B) A constructor that converts basic data types to objects</p>
        <p>C) A constructor that takes one argument of a different type</p>
        <p>D) None of the above</p>
        <p><strong>Answer: C</strong></p>
      </article>
      <article id="question-48">
        <h3>48. Which of the following correctly describes Object-Oriented Programming?</h3>
        <p>A) OOP is a programming paradigm based on the concept of "objects", which may contain data, in the form of fields, often known as attributes; and code, in the form of procedures, often known as methods.</p>
        <p>B) OOP is a programming style that is associated with the concept of Class, Objects and various other concepts revolving around these two, like Inheritance, Polymorphism, Abstraction, Encapsulation etc.</p>
        <p>C) OOP allows for simplified programming. Its benefits include reusability, refactoring, extensibility, maintenance and efficiency.</p>
        <p>D) All of the above</p>
        <p><strong>Answer: D</strong></p>
      </article>
      <article id="question-49">
        <h3>49. When does the compiler provide a default constructor?</h3>
        <p>A) If no constructor is defined</p>
        <p>B) If a parameterized constructor is defined</p>
        <p>C) If a destructor is not defined</p>
        <p>D) None of the above</p>
        <p><i>Think about the compiler's role in providing constructors...</i></p>
      </article>
      <article id="question-50">
        <h3>50. Can we have a function overloading in different scopes?</h3>
        <p>A) Yes</p>
        <p>B) No</p>
        <p>C) Only in the global scope</p>
        <p>D) Only in the local scope</p>
        <p><strong>Answer: A</strong></p>
      </article>


    </main>

    <script>copyright("all");</script>
  </body>

</html>