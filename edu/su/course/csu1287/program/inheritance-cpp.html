<!-------------------------- Â© 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
  <!--<![endif]-->

  <head>
    <script src="/js/edu_su_common.js"></script>
    <noscript>
      <style>
        html,
        body {
          margin: 0;
          overflow: hidden;
        }
      </style>
      <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
    </noscript>

    <title>C++ Inheritance: Coding Legacy - CSU1287 - Shoolini U</title>
    <meta name="description" content="Explore the hierarchical magic of Inheritance in C++ and streamline your coding journey. CSU1287 at dmj.one with Shoolini University welcomes all learners.">

    <meta property="og:image" content="/logo.png">
    <meta property="og:type" content="article">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@divyamohan1993">
    <meta name="twitter:creator" content="@divyamohan1993">
    <meta name="twitter:image" content="/logo.png">

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />

  </head>

  <body>

    <script>header_author("dm");</script>

    <main>
      <article>
        <h2 class="text-center">
          Inheritance in C++
        </h2>
      </article>
      <article>
        <h3>1. Introduction to Inheritance</h3>
        <p>Inheritance is one of the four fundamental principles of object-oriented programming (OOP), along with encapsulation, polymorphism, and abstraction. Inheritance enables the creation of new classes that inherit the properties and methods of existing classes, promoting code reuse and modularity. This allows developers to build on existing code, extending or modifying its functionality as needed, without having to rewrite or duplicate large portions of code.</p>
      </article>
      <article>
        <h3>2. Benefits of Inheritance</h3>
        <p>Some benefits of inheritance in C++ include:</p>
        <ul>
          <li><strong>Code Reuse:</strong> Inheritance promotes the reuse of code by enabling new classes to inherit the properties and methods of existing classes.</li>
          <li><strong>Modularity:</strong> By organizing code into classes and inheritance hierarchies, developers can create more modular and maintainable code.</li>
          <li><strong>Extensibility:</strong> Inheritance makes it easy to extend or modify existing code by creating new classes that inherit from existing ones, without having to modify the original classes.</li>
          <li><strong>Abstraction:</strong> Inheritance enables the creation of abstract base classes that define the interface for a set of derived classes, making it easier to reason about the code and manage complexity.</li>
        </ul>
      </article>
      <article>
        <h3>3. Implementing Inheritance in C++</h3>
        <p>In C++, inheritance is achieved through the use of classes and the colon (:) operator. In this section, we will discuss how to implement inheritance in C++ and explore various aspects of this principle.</p>
      </article>
      <article>
        <h4>3.1 Base and Derived Classes</h4>
        <p>Inheritance involves two types of classes: base classes and derived classes. The base class is the existing class from which the new class inherits its properties and methods. The derived class is the new class that inherits the properties and methods of the base class.</p>
        <p>Here's a simple example of a base class and a derived class in C++:</p>
        <pre><code class="language-cpp">class Shape {
public:
    void setPosition(int x, int y) {
        x_ = x;
        y_ = y;
    }

protected:
    int x_;
    int y_;
};

class Circle : public Shape {
public:
    void setRadius(int radius) {
        radius_ = radius;
    }

private:
    int radius_;
};</code></pre>
        <p>In this example, the 'Shape' class is the base class, and the 'Circle' class is the derived class. The 'Circle' class inherits the 'setPosition' method and the 'x_' and 'y_' data members from the 'Shape' class, and it adds its own 'setRadius' method and 'radius_' data member.</p>
      </article>
      <article>
        <h4>3.2 Access Specifiers and Inheritance</h4>
        <p>When inheriting from a base class, it is important to consider the access specifiers of the base class members. As a reminder, C++ provides three access specifiers:</p>
        <ul>
          <li><strong>public:</strong> Members declared as public are accessible from any part of the code.</li>
          <li><strong>private:</strong> Members declared as private are only accessible from within the class and its member functions. Private members are not accessible in derived classes.</li>
          <li><strong>protected:</strong> Members declared as protected are accessible from within the class, its subclasses, and their member functions. Protected members are accessible in derived classes.</li>
        </ul>
        <p>In the 'Shape' class example, the 'x_' and 'y_' data members are declared as protected, which means they can be accessed from the 'Circle' derived class. If they were declared as private, the 'Circle' class would not be able to access them directly.</p>

      </article>
      <article>
        <h4>3.3 Inheritance Types</h4>
        <p>In C++, there are three types of inheritance, depending on the access specifier used when inheriting from a base class:</p>
        <ul>
          <li><strong>Public Inheritance:</strong> When a class is derived publicly from a base class, the public members of the base class become public members of the derived class, and the protected members of the base class become protected members of the derived class.</li>
          <li><strong>Protected Inheritance:</strong> When a class is derived with protected inheritance, both the public and protected members of the base class become protected members of the derived class.</li>
          <li><strong>Private Inheritance:</strong> When a class is derived privately, both the public and protected members of the base class become private members of the derived class.</li>
        </ul>
        <p>Here's an example illustrating the different inheritance types:</p>
        <pre><code class="language-cpp">class A {
public:
    int public_var;
protected:
    int protected_var;
private:
    int private_var;
};

class B : public A {
    // 'public_var' is public
    // 'protected_var' is protected
    // 'private_var' is not accessible
};

class C : protected A {
    // 'public_var' is protected
    // 'protected_var' is protected
    // 'private_var' is not accessible
};

class D : private A {
    // 'public_var' is private
    // 'protected_var' is private
    // 'private_var' is not accessible
};</code></pre>
        <p>In most cases, public inheritance is the preferred choice, as it maintains the original access levels of the base class members. However, protected and private inheritance can be useful in specific situations where more restricted access is desired.</p>
      </article>
      <article>
        <h4>3.4 Constructors and Destructors in Inheritance</h4>
        <p>When a derived class object is created or destroyed, the constructors and destructors of the base class and derived class are called in a specific order:</p>
        <ul>
          <li><strong>Construction:</strong> When a derived class object is created, the base class constructor is called first, followed by the derived class constructor. If the derived class has multiple base classes, their constructors are called in the order they are declared in the derived class.</li>
          <li><strong>Destruction:</strong> When a derived class object is destroyed, the derived class destructor is called first, followed by the base class destructor.</li>
        </ul>
        <p>If the base class has a constructor with arguments, the derived class constructor must explicitly call the base class constructor and pass the appropriate arguments. Here's an example:</p>
        <pre><code class="language-cpp">class Base {
public:
    Base(int x) : x_(x) {}

private:
    int x_;
};

class Derived : public Base {
public:
    Derived(int x, int y) : Base(x), y_(y) {}

private:
    int y_;
};</code></pre>
        <p>In this example, the 'Derived' class constructor explicitly calls the 'Base' class constructor with the 'x' argument and initializes its own 'y_' data member.</p>
      </article>
      <article>
        <h3>4. Advanced Concepts in Inheritance</h3>
        <p>Inheritance in C++ can be further refined and enhanced through several advanced concepts, including:</p>
      </article>
      <article>
        <h4>4.1 Multiple Inheritance</h4>
        <p>Multiple inheritance is a feature in C++ that allows a class to inherit from more than one base class. This enables the derived class to inherit the properties and methods of multiple base classes. However, multiple inheritance can also introduce complexity and potential issues, such as the diamond problem, which we will discuss later in this section.</p>
        <p>Here's an example of multiple inheritance in C++:</p>
        <pre><code class="language-cpp">class A {
public:
    void methodA() {}
};

class B {
public:
    void methodB() {}
};

class C : public A, public B {
    // Inherits 'methodA' from class A
    // Inherits 'methodB' from class B
};</code></pre>
        <p>In this example, the 'C' class inherits from both the 'A' and 'B' classes, inheriting their 'methodA' and 'methodB' methods, respectively.</p>
      </article>
      <article>
        <h4>4.2 Virtual Base Classes and the Diamond Problem</h4>
        <p>The diamond problem occurs in multiple inheritance scenarios when a class inherits from two or more classes that share a common base class. This can lead to ambiguity and potential issues with the inheritance hierarchy.</p>
        <p>Consider the following example:</p>
        <pre><code class="language-cpp">class A {
public:
    void methodA() {}
};

class B : public A {
    // Inherits 'methodA' from class A
};

class C : public A {
    // Inherits 'methodA' from class A
};

class D : public B, public C {
    // Inherits 'methodA' from both class B and class C
};</code></pre>
        <p>In this example, the 'D' class inherits from both 'B' and 'C' classes, which in turn inherit from the 'A' class. This creates ambiguity regarding which 'methodA' implementation the 'D' class should inherit.</p>
        <p>To resolve the diamond problem, C++ provides the concept of virtual base classes. By using the 'virtual' keyword when inheriting a base class, you can ensure that only a single instance of the base class is included in the inheritance hierarchy.</p>
        <p>Here's the modified example using a virtual base class:</p>
        <pre><code class="language-cpp">class A {
public:
    void methodA() {}
};

class B : virtual public A {
    // Inherits 'methodA' from class A
};

class C : virtual public A {
    // Inherits 'methodA' from class A
};

class D : public B, public C {
    // Inherits a single 'methodA' from class A
};</code></pre>
        <p>Now, the 'D' class inherits a single 'methodA' implementation from the 'A' class, avoiding ambiguity and resolving the diamond problem.</p>
      </article>
      <article>
        <h4>4.3 Polymorphism and Virtual Functions</h4>
        <p>Polymorphism is another key principle of OOP that enables the same function to have different implementations in the base class and its derived classes. In C++, polymorphism is achieved using virtual functions, which are declared using the 'virtual' keyword.</p>
        <p>Here's an example of polymorphism using virtual functions:</p>
        <pre><code class="language-cpp">class Shape {
public:
    virtual void draw() {
        // Default implementation for drawing a shape
    }
};

class Circle : public Shape {
public:
    void draw() override {
        // Implementation for drawing a circle
    }
};

class Rectangle : public Shape {
public:
    void draw() override {
        // Implementation for drawing a rectangle
    }
};</code></pre>

        <p>In this example, the 'Shape' class defines a virtual 'draw' function, which provides a default implementation for drawing a shape. The 'Circle' and 'Rectangle' classes, derived from the 'Shape' class, override the 'draw' function to provide their own implementations for drawing a circle and a rectangle, respectively.</p>
        <p>When working with polymorphism, it is common to use pointers or references to base class objects to call the appropriate virtual function implementation. Here's an example of how to use polymorphism with virtual functions:</p>
        <pre><code class="language-cpp">Shape* shape1 = new Circle();
Shape* shape2 = new Rectangle();

shape1->draw(); // Calls the 'draw' function of the 'Circle' class
shape2->draw(); // Calls the 'draw' function of the 'Rectangle' class

delete shape1;
delete shape2;</code></pre>
        <p>In this example, we create pointers to 'Shape' objects that point to instances of the 'Circle' and 'Rectangle' classes. When calling the 'draw' function through these pointers, the appropriate implementation for each derived class is called, demonstrating polymorphism.</p>
      </article>
      <article>
        <h4>4.4 Abstract Base Classes</h4>
        <p>Abstract base classes are classes that define an interface for a set of derived classes but cannot be instantiated on their own. In C++, abstract base classes are created by declaring one or more virtual functions as pure virtual, using the '= 0' syntax.</p>
        <p>Here's an example of an abstract base class:</p>
        <pre><code class="language-cpp">class Shape {
public:
    virtual void draw() = 0; // Pure virtual function
};

class Circle : public Shape {
public:
    void draw() override {
        // Implementation for drawing a circle
    }
};

class Rectangle : public Shape {
public:
    void draw() override {
        // Implementation for drawing a rectangle
    }
};</code></pre>
        <p>In this example, the 'Shape' class is an abstract base class because it has a pure virtual 'draw' function. This means that it is not possible to create an instance of the 'Shape' class, and it can only be used as a base class for other classes, like the 'Circle' and 'Rectangle' classes in this example.</p>
      </article>
      <article>
        <h3>5. Categories of Inheritance</h3>
        <p>C++ is an object-oriented programming language that provides support for inheritance, which is a mechanism that allows a class (derived class) to inherit the properties and methods of another class (base class). This enables code reusability and the creation of more complex data structures. Inheritance in C++ can be categorized into the following types:</p>
      </article>
      <article>
        <h4>5.1 Single Inheritance</h4>
        <p>In single inheritance, a derived class inherits from a single base class. This is the simplest form of inheritance in C++. The derived class can use the features (properties and methods) of the base class, and it can also have its own unique features.</p>
        <pre><code class="language-cpp">class Base {
public:
  void baseFunction();
};

class Derived : public Base {
public:
  void derivedFunction();
};
</code></pre>
      </article>
      <article>
        <h4>5.2 Multiple Inheritance</h4>
        <p>In multiple inheritance, a derived class can inherit from more than one base class. The derived class inherits the features of all the base classes, which allows for more complex and versatile class structures.</p>
        <pre><code class="language-cpp">class Base1 {
public:
  void base1Function();
};

class Base2 {
public:
  void base2Function();
};

class Derived : public Base1, public Base2 {
public:
  void derivedFunction();
};
</code></pre>
      </article>
      <article>
        <h4>5.3 Multilevel Inheritance</h4>
        <p>Multilevel inheritance occurs when a derived class inherits from another derived class, which in turn, inherits from a base class. This creates a chain of inheritance with multiple levels.</p>
        <pre><code class="language-cpp">class Base {
public:
  void baseFunction();
};

class Derived1 : public Base {
public:
  void derived1Function();
};

class Derived2 : public Derived1 {
public:
  void derived2Function();
};</code></pre>
      </article>
      <article>
        <h4>5.4 Hierarchical Inheritance</h4>
        <p>In hierarchical inheritance, multiple derived classes inherit from a single base class. The derived classes can have their own unique features, in addition to those inherited from the base class.</p>
        <pre><code class="language-cpp">class Base {
public:
  void baseFunction();
};

class Derived1 : public Base {
public:
  void derived1Function();
};

class Derived2 : public Base {
public:
  void derived2Function();
};</code></pre>
      </article>
      <article>
        <h4>5.5 Hybrid Inheritance</h4>
        <p>Hybrid inheritance is a combination of more than one type of inheritance (such as multiple and hierarchical inheritance) in a single program. It allows for complex class structures and relationships.</p>
        <pre><code class="language-cpp">class Base {
public:
  void baseFunction();
};

class Derived1 : public Base {
public:
  void derived1Function();
};

class Derived2 : public Base {
public:
  void derived2Function();
};

class Derived3 : public Derived1, public Derived2 {
public:
  void derived3Function();
};</code></pre>
      </article>
      <article>
        <h4>5.6 Virtual Inheritance</h4>
        <p>Virtual inheritance is a technique used to solve the diamond problem, which occurs in multiple inheritance when a derived class inherits from two or more classes that have a common ancestor. This can cause ambiguity and duplication of inherited members. Virtual inheritance ensures that only one copy of the common ancestor's members is present in the derived class.</p>
        <pre><code class="language-cpp">class Base {
public:
  void baseFunction();
};

class Derived1 : virtual public Base {
public:
  void derived1Function();
};

class Derived2 : virtual public Base {
public:
  void derived2Function();
};

class Derived3 : public Derived1, public Derived2 {
public:
  void derived3Function();
};</code></pre>
        <p>These are the major types of inheritance in C++. Keep in mind that inheritance should be used judiciously to ensure maintainability, readability, and proper code organization. Inheritance is a powerful tool in C++ programming, but it should be employed</p>
      </article>
      <article>
        <h3>6. Best Practices</h4>
          <p>In addition to the types of inheritance mentioned earlier, there are a few more concepts and best practices to consider when working with inheritance in C++:</p>
      </article>
      <article>
        <h4>6.1 Access Specifiers</h4>
        When inheriting from a base class, you need to specify the access level at which the derived class inherits the base class's members. The three access specifiers are public, protected, and private. These determine the visibility of the inherited members in the derived class.
        <ul>
          <li><strong>public</strong>: Inherited members will have the same access level in the derived class as in the base class.</li>
          <li><strong>protected</strong>: Inherited members will have protected access level in the derived class, regardless of their access level in the base class.</li>
          <li><strong>private</strong>: Inherited members will have private access level in the derived class, regardless of their access level in the base class.</li>
        </ul>
      </article>
      <article>
        <h4>6.2 Constructors and Destructors</h4>
        <p>When a derived class object is created, the base class constructor is called before the derived class constructor. Similarly, when the derived class object is destroyed, the derived class destructor is called before the base class destructor.</p>
      </article>
      <article>
        <h4>6.3 Function Overriding</h4>
        <p>A derived class can provide a new implementation for a function inherited from the base class. This is called function overriding. When an overridden function is called through a derived class object, the derived class's version of the function is executed instead of the base class's version.</p>
      </article>
      <article>
        <h4>6.4 Abstract Classes and Pure Virtual Functions</h4>
        <p>An abstract class is a class that cannot be instantiated and is meant to be subclassed by other classes. It can have one or more pure virtual functions, which are functions declared in the base class without an implementation. Derived classes must provide an implementation for these functions to be considered a concrete class.</p>
      </article>
      <article>
        <h4>6.5 Composition over Inheritance</h4>
        <p>In some cases, it may be more appropriate to use composition instead of inheritance. Composition involves building complex objects by combining simpler objects, rather than relying on inheritance to create new classes. This can lead to more modular and maintainable code. It's essential to evaluate the requirements of your program and choose the most suitable approach.</p>
      </article>
      <article>
        <h3>7. Conclusion</h3>
        <p>Inheritance is a powerful principle of object-oriented programming that promotes code reuse, modularity, and extensibility in C++. Through the use of base and derived classes, inheritance types, and advanced concepts such as multiple inheritance, virtual base classes, polymorphism, and abstract base classes, C++ provides a flexible and robust framework for building complex software systems.</p>
        <p>By understanding and applying the concepts discussed in this article, you can create more efficient, maintainable, and scalable code that is easier to understand and modify, making you a more effective C++ programmer, from the basics to the computer science level.</p>
      </article>
    </main>

    <script>copyright("all");</script>
  </body>

</html>
