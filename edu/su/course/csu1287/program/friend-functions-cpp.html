<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
  <!--<![endif]-->

  <head>
    <script src="/js/edu_su_common.js"></script>
    <noscript>
      <style>
        html,
        body {
          margin: 0;
          overflow: hidden;
        }
      </style>
      <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
    </noscript>

    <title>Unraveling C++ Friend Functions - CSU1287 - Shoolini U</title>
    <meta name="description" content="Dive into the world of Friend Functions in C++. Learn more in our CSU1287 course at dmj.one with Shoolini University, suitable for all learning levels.">

    <meta property="og:image" content="/logo.png">
    <meta property="og:type" content="article">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@divyamohan1993">
    <meta name="twitter:creator" content="@divyamohan1993">
    <meta name="twitter:image" content="/logo.png">

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />

  </head>

  <body>

    <script>header_author("dm");</script>

    <main>
      <article>
        <h2 class="text-center">
          Friend Functions in C++
        </h2>

        <div class="container mt-4 w-100 w-xl-75">
          <div class="accordion" id="toc">
            <div class="accordion-item">
              <h2 class="accordion-header" id="h1">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#c1" aria-controls="c1" aria-expanded="false">
                  <i class="fas fa-book"></i> <strong>&nbsp;Table of Contents</strong>
                </button>
              </h2>
              <div id="c1" class="accordion-collapse collapse" aria-labelledby="h1" data-bs-parent="#toc">
                <div class="accordion-body">
                  <ol class="list-unstyled p-0 m-0">
                    <li class="p-1"><a href="#exec-summary"><i class="fas fa-chevron-circle-right"></i> Executive Summary</a> - Low on Time? Get the most important concepts within seconds.</li>
                    <li class="p-1"><a href="#intro"><i class="fas fa-chevron-circle-right"></i> Introduction</a></li>
                    <li class="p-1"><a href="#define"><i class="fas fa-chevron-circle-right"></i> Understanding Friend Functions</a></li>
                    <li class="p-1"><a href="#friend-function-and-operator-overloading"><i class="fas fa-chevron-circle-right"></i> Friend Function and Operator Overloading</a></li>
                    <li class="p-1"><a href="#friend-class"><i class="fas fa-chevron-circle-right"></i> Friend Class</a></li>
                    <li class="p-1"><a href="#conclusion"><i class="fas fa-chevron-circle-right"></i> Conclusion</a></li>
                    <li class="p-1"><a href="#whats-next"><i class="fas fa-chevron-circle-right"></i> What's Next</a></li>
                  </ol>
                </div>
              </div>
            </div>
          </div>
        </div>
      </article>

      <article id=”intro”>
        <h3>1. Introduction to Friend Functions in C++</h3>
        <p>
          Imagine you are building a complex machine. This machine contains many parts that work independently, and yet need to occasionally interact with each other to ensure the smooth operation of the entire mechanism. However, you want to keep these interactions to a minimum to preserve the integrity and independence of each part. How would you design this mechanism?
          In object-oriented programming, one might encounter a similar situation. Objects, akin to the parts of our complex machine, interact to bring an application to life. Yet, we want to maintain the integrity and encapsulation of these objects. This is where 'friend functions' in C++ can prove to be invaluable.

        </p>
        <p>
          Simply put, a friend function in C++ is a special type of function that has the ability to access the private and protected members of a class. It acts as a 'friend' to the class, hence the name. As an analogy, you can think of friend functions as trusted technicians who are allowed access to the internal mechanisms of our complex machine, even when others aren't. Friend functions are an important aspect of C++, offering flexibility in accessing encapsulated members of a class, while keeping in mind principles of object-oriented programming.
        </p>
      </article>
      <article id="define">
        <h3>2. Understanding Friend Functions</h3>
        <p>
          Let's delve deeper into the mechanics of friend functions.
        </p>
      </article>
      <article>
        <h4>2.1 Defining a Friend Function</h4>
        <p>
          A friend function is defined using the keyword 'friend' preceding its declaration inside the class whose members it is intended to access. It's important to note that although the declaration of the friend function appears inside the class's scope, it's not a member function of the class.
        </p>
        <pre><code class="language-cpp">
class SampleClass {
private:
   int private_member;
public:
friend void FriendFunction(SampleClass &);
};
</code></pre>
        <p>
          In the above code, we have a class named 'SampleClass' with a private member 'private_member'. We have also declared a friend function 'FriendFunction' that can access the private members of this class. Notice how the friend function is not a member of the 'SampleClass', and doesn't use any membership operator like '.' or '->'.
        </p>
      </article>
      <article>
        <h4>2.2 Friend Function Implementation</h4>
        <p>
          A friend function is implemented outside the scope of the class, similarly to a normal function. Despite this, it can access the private and protected members of the class because it's declared as a friend of the class.
        </p>
        <pre><code class="language-cpp">
void FriendFunction(SampleClass &obj) {
   obj.private_member = 10;
   cout << "Private Member Value: " << obj.private_member << endl;
}
</code></pre>
        <p>
          In the above implementation, the friend function 'FriendFunction' is able to access and modify the private member 'private_member' of the class 'SampleClass'.
        </p>

        <h5>2.2.1 Why Use Friend Functions?</h5>
        <p>
          Friend functions increase the versatility of class design by enabling an external function to access the private and protected members of a class. This can be useful in scenarios where we need to carry out operations that involve the internals of multiple classes or when creating some types of operator overloads.
        </p>
        <p>
          However, use of friend functions should be done judiciously as it can violate the principles of data encapsulation, a fundamental concept in object-oriented programming. Essentially, while friend functions can help us build our complex machine, their misuse can also potentially lead to breakdowns.
        </p>
      </article>
      <article id="friend-function-and-operator-overloading">
        <h3>3. Friend Functions and Operator Overloading</h3>
        <p>
          One of the most common uses of friend functions is in operator overloading. In C++, we can redefine the way operators (like +, -, *, etc.) work for user-defined types like classes. This is called operator overloading, and it allows us to perform operations on objects just like we would with primitive data types.
        </p>
      </article>
      <article>
        <h4>3.1 Overloading an Operator Using a Friend Function</h4>
        <p>
          Let's consider a class 'Complex' representing a complex number. We want to add two complex numbers using the '+' operator. Since the '+' operator doesn't know how to add two objects of the class 'Complex', we need to define this behaviour using operator overloading.
        </p>
        <pre><code class="language-cpp">
class Complex {
private:
   double real, imag;
public:
Complex(double r = 0.0, double i = 0.0) : real(r), imag(i) {}

// Friend function declaration
friend Complex operator+(const Complex &, const Complex &);
};

// Friend function definition
Complex operator+(const Complex &c1, const Complex &c2) {
return Complex(c1.real + c2.real, c1.imag + c2.imag);
}
</code></pre>

        <p>
          In the above example, we have a class 'Complex' with private members 'real' and 'imag' representing the real and imaginary parts of a complex number, respectively. We also have a friend function that overloads the '+' operator. This function can access the private members of 'Complex' and define how two complex numbers should be added.
        </p>
      </article>
      <article id="friend-class">
        <h3>4. Friend Classes in C++</h3>
        <p>
          In addition to friend functions, C++ also supports the concept of friend classes. A friend class is a class whose member functions can access the private and protected members of the class in which it is declared as a friend.
        </p>
      </article>
      <article>
        <h4>4.1 Defining a Friend Class</h4>
        <p>
          Just like friend functions, a friend class is declared in the class whose members it will access. The keyword 'friend' is used before the class declaration inside the class body.
        </p>
        <pre><code class="language-cpp">
class ClassA {
private:
   int private_member;
public:
friend class ClassB;
};
</code></pre>

        <p>
          In this example, 'ClassB' is declared as a friend class of 'ClassA'. This means that any member function of 'ClassB' can access the private members of 'ClassA'.
        </p>
      </article>
      <article>
        <h4>4.2 Friend Classes and Inheritance</h4>
        <p>
          Friendship is not inherited in C++. If 'ClassB' is a friend of 'ClassA', and 'ClassC' is a subclass of 'ClassB', 'ClassC' is not considered a friend of 'ClassA'. This means that 'ClassC' can't access the private and protected members of 'ClassA' even though it's a subclass of a friend class.
        </p>
      </article>
      <article id="conclusion">
        <h3>5. Conclusion</h3>
        <p>
          The concept of friend functions and friend classes in C++ is a powerful tool that provides greater flexibility in designing classes, especially when dealing with operator overloading and interactions between multiple classes. However, these features should be used judiciously, keeping in mind the principles of data encapsulation and abstraction in object-oriented programming.
        </p>
        <p>
          Just like our trusted technician, friend functions and friend classes can provide necessary maintenance and fine-tuning to keep our machine running smoothly. But remember, the more we expose the internal workings of our machine, the more we open it to potential disruptions. Thus, striking a balance between encapsulation and flexibility is crucial when using these advanced features of C++.
        </p>
      </article>
      <article id="whats-next">
        <h3>6. What's Next?</h3>
        <p>
          Now that we have explored friend functions and friend classes in C++, we are ready to take a leap into another exciting feature of C++: Templates. In the next section, we will delve into the world of templates, exploring their purpose, syntax, and various use cases. From creating generic functions to implementing sophisticated data structures like a dynamic array or a hash map, templates provide a powerful means of adding versatility and reusability to your C++ programs. So gear up, for an exciting journey into the depth of C++ awaits!
        </p>
      </article>
    </main>

    <script>copyright("all");</script>
  </body>

</html>
