<!-------------------------- Â© 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
  <!--<![endif]-->

  <head>
    <script src="/js/edu_su_common.js"></script>
    <noscript>
      <style>
        html,
        body {
          margin: 0;
          overflow: hidden;
        }
      </style>
      <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
    </noscript>

    <title>Virtual Functions Unveiled: C++ - CSU1287 - Shoolini U</title>
    <meta name="description" content="Unravel the magic of virtual functions in C++. Step into the realm of dynamic binding with CSU1287 of Shoolini University at dmj.one">

    <meta property="og:image" content="/logo.png">
    <meta property="og:type" content="article">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@divyamohan1993">
    <meta name="twitter:creator" content="@divyamohan1993">
    <meta name="twitter:image" content="/logo.png">

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />

  </head>

  <body>

    <script>header_author("dm");</script>

    <main>
      <article>
        <h2 class="text-center">
          Virtual Functions in C++
        </h2>
      </article>
      <article>
        <h3>1. Introduction to Virtual Functions in C++</h3>
        <p>In object-oriented programming, polymorphism is one of the key principles that allows developers to create extensible and maintainable code. Polymorphism is a concept where an object of a derived class can be treated as an object of its base class. Virtual functions in C++ are a powerful mechanism that enables polymorphism by allowing derived classes to override the behavior of base class functions.</p>
        <p>This article will provide a comprehensive discussion of virtual functions, along with other related topics such as friend functions, static functions, assignment and copy initialization, the 'this' pointer, and dynamic type information. The aim is to cover the topic of virtual functions from the basics to a level suitable for computer science students, making it an informative and valuable resource for anyone interested in learning about this core aspect of C++ programming.</p>
      </article>
      <article>
        <h3>2. Virtual Functions</h3>
        <p>A virtual function is a member function of a base class that can be overridden in a derived class. This allows derived classes to provide their own implementation for the function while maintaining the same function signature as the base class. When a derived class object is accessed through a pointer or reference to the base class, the appropriate derived class function is called, even if the base class pointer or reference is used. This dynamic binding enables polymorphism in C++.</p>
      </article>
      <article>
        <h4>2.1 Declaration and Usage of Virtual Functions</h4>
        <p>To declare a function as virtual, you simply use the 'virtual' keyword in the function declaration within the base class. This tells the compiler to generate a virtual table (vtable) containing pointers to the virtual functions for each class that contains or inherits a virtual function. When an object is created, a pointer to the vtable for its class is set up, allowing dynamic dispatch of the virtual function calls at runtime.</p>
        <pre><code class="language-cpp">class Base {
public:
    virtual void print() {
        cout &lt;&lt; "Base class print function." &lt;&lt; endl;
    }
};

class Derived : public Base {
public:
    void print() override {
        cout &lt;&lt; "Derived class print function." &lt;&lt; endl;
    }
};</code></pre>
        <p>In the example above, the 'print' function is declared as virtual in the 'Base' class and overridden in the 'Derived' class. When a 'Derived' class object is accessed through a 'Base' class pointer or reference, the 'print' function of the 'Derived' class will be called, illustrating polymorphism in action.</p>
      </article>
      <article>
        <h4>2.2 Pure Virtual Functions and Abstract Classes</h4>
        <p>A pure virtual function is a virtual function with no implementation in the base class. A class containing at least one pure virtual function is considered an abstract class and cannot be instantiated. Derived classes must provide an implementation for all pure virtual functions in the base class; otherwise, the derived class will also be considered abstract.</p>
        <p>To declare a pure virtual function, use the 'virtual' keyword followed by the function declaration and assign it to 0, as shown below:</p>
        <pre><code class="language-cpp">class AbstractBase {
public:
    virtual void pure_virtual_function() = 0;
};</code></pre>
        <p>Derived classes must override the pure virtual function(s) to become a concrete class, which can then be instantiated. Abstract classes serve as a foundation for other classes, ensuring a consistent interface and promoting code reusability.</p>
      </article>
      <article>
        <h3>3. Friend Functions</h3>
        <p>Friend functions are a special kind of function in C++ that can access the private and protected members of a class, even though they are not member functions of the class. Friend functions are declared using the 'friend' keyword inside the class definition, and they are used when it is necessary to allow external functions to interact with the class internals.</p>
      </article>
      <article>
        <h4>3.1 Declaration and Usage of Friend Functions</h4>
        <p>Friend functions are not part of the class, so they do not have access to the 'this' pointer. To declare a friend function, you must use the 'friend' keyword followed by the function prototype inside the class definition. The friend function should be defined outside of the class.</p>
        <pre><code class="language-cpp">class MyClass {
    int x;

public:
    MyClass(int a) : x(a) {}
    friend void printX(MyClass& obj);
};

void printX(MyClass& obj) {
    cout &lt;&lt; "Value of x: " &lt;&lt; obj.x &lt;&lt; endl;
}</code></pre>
        <p>In the example above, the 'printX' function is declared as a friend of the 'MyClass' class. This allows 'printX' to access the private member 'x' of 'MyClass' objects.</p>
      </article>
      <article>
        <h4>3.2 Friend Classes</h4>
        <p>It is also possible to declare an entire class as a friend of another class. This means that all member functions of the friend class have access to the private and protected members of the class in which the friend declaration is made.</p>
        <pre><code class="language-cpp">class MyClassA {
    int x;

public:
    MyClassA(int a) : x(a) {}
    friend class MyClassB;
};

class MyClassB {
public:
    void printX(MyClassA& obj) {
        cout &lt;&lt; "Value of x: " &lt;&lt; obj.x &lt;&lt; endl;
    }
};</code></pre>
        <p>In the example above, the 'MyClassB' class is declared as a friend of the 'MyClassA' class, allowing its member functions to access the private member 'x' of 'MyClassA' objects.</p>
      </article>
      <article>
        <h3>4. Static Functions</h3>
        <p>Static functions are member functions of a class that are associated with the class itself rather than instances of the class. They can only access static members of the class and cannot access non-static members or the 'this' pointer. Static functions are declared using the 'static' keyword inside the class definition.</p>
      </article>
      <article>
        <h4>4.1 Declaration and Usage of Static Functions</h4>
        <p>To declare a static function, use the 'static' keyword followed by the function prototype inside the class definition. The function should be defined outside the class, and it does not have access to the 'this' pointer or non-static members of the class. Static functions are called using the class name and the scope resolution operator (::).</p>
        <pre><code class="language-cpp">class MyClass {
    static int counter;

public:
    static int getCounter() {
        return counter;
    }
};

int MyClass::counter = 0;</code></pre>
        <p>In the example above, the 'getCounter' function is declared as a static member function of the 'MyClass' class. It can be called using the class name and the scope resolution operator, like this: 'MyClass::getCounter()'.</p>
      </article>
      <article>
        <h3>5. Assignment and Copy Initialization</h3>

        <p>Assignment and copy initialization are important concepts in C++ related to object creation and assignment. Copy initialization occurs when an object is initialized using another object of the same type. Assignment occurs when an object is assigned the value of another object of the same type after both objects have been initialized.</p>
      </article>
      <article>
        <h4>5.1 Copy Constructor</h4>
        <p>A copy constructor is a special member function of a class that is used to initialize an object with another object of the same type. The copy constructor has a single parameter, which is a reference to a const object of the same class.</p>
        <pre><code class="language-cpp">class MyClass {
  int x;

public:
    MyClass(int a) : x(a) {}
    MyClass(const MyClass& obj) : x(obj.x) {}
};</code></pre>
        <p>In the example above, a copy constructor is defined for the 'MyClass' class. When an object is initialized using another object of the same type, the copy constructor is called to create a new object with the same value as the original object.</p>
      </article>
      <article>
        <h4>5.2 Assignment Operator Overloading</h4>
        <p>The assignment operator is used to assign the value of one object to another object of the same type. By default, the assignment operator performs a member-wise copy of the source object's members to the target object. However, you can overload the assignment operator to provide custom assignment behavior for your class.</p>
        <pre><code class="language-cpp">class MyClass {
  int x;
public:
    MyClass(int a) : x(a) {}
    MyClass& operator=(const MyClass& obj) {
        if (this == &amp;obj) {
            return *this;
        }
        x = obj.x;
        return *this;
    }
};</code></pre>
        <p>In the example above, the assignment operator is overloaded for the 'MyClass' class. The overloaded assignment operator checks for self-assignment and then assigns the value of the 'x' member from the source object to the target object.</p>
      </article>
      <article>
        <h3>6. The 'this' Pointer</h3>
        <p>The 'this' pointer is an implicit pointer in C++ that points to the object for which a member function is called. It allows you to access the object's members and methods within the member function. The 'this' pointer is especially useful when overloading operators or when working with functions that require a reference to the current object.</p>
        <article>
          <h4>6.1 Usage of the 'this' Pointer</h4>
          <p>Inside a member function, you can use the 'this' pointer to access the object's members and methods. The 'this' pointer is automatically passed to the member function when it is called.</p>
          <pre><code class="language-cpp">class MyClass {
    int x;

public:
    MyClass(int a) : x(a) {}
    void setX(int a) {
        this->x = a;
    }
};</code></pre>
          <p>In the example above, the 'setX' function uses the 'this' pointer to access the 'x' member of the 'MyClass' object for which the function is called.</p>
        </article>
      </article>
      <article>
        <h3>7. Dynamic Type Information</h3>
        <p>Dynamic type information (RTTI) is a feature in C++ that allows you to obtain information about the type of an object at runtime. This can be useful for implementing polymorphic behavior in your code. The primary components of RTTI are the 'typeid' operator and the 'dynamic_cast' operator.</p>
      </article>
      <article>
        <h4>7.1 Typeid Operator</h4>
        <p>The 'typeid' operator is used to obtain information about the type of an object or expression at runtime. The 'typeid' operator returns a reference to a 'std::type_info' object, which can be used to query information about the type, such as the type's name.</p>
        <pre><code class="language-cpp">class Base {
public:
    virtual ~Base() {}
};

class Derived : public Base {};

void printTypeInfo(Base* obj) {
    std::cout &lt;&lt; "Type: " &lt;&lt; typeid(*obj).name() &lt;&lt; std::endl;
}</code></pre>
        <p>In the example above, the 'printTypeInfo' function uses the 'typeid' operator to print the name of the type of the object pointed to by 'obj'. Since the 'Base' class has a virtual function, the 'typeid' operator will return the correct type information even when called with a pointer to a 'Derived' object.</p>
      </article>
      <article>
        <h4>7.2 Dynamic_cast Operator</h4>
        <p>The 'dynamic_cast' operator is used to safely convert a pointer or reference of a base class type to a pointer or reference of a derived class type. If the conversion is not possible, 'dynamic_cast' returns a null pointer (for pointers) or throws a 'std::bad_cast' exception (for references).</p>
        <pre><code class="language-cpp">class Base {
public:
    virtual ~Base() {}
};

class Derived : public Base {};

void exampleFunction(Base* obj) {
    Derived* derivedObj = dynamic_cast&lt;Derived*&gt;(obj);
    if (derivedObj) {
        std::cout &lt;&lt; "Conversion successful." &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "Conversion failed." &lt;&lt; std::endl;
    }
}</code></pre>
        <p>In the example above, the 'exampleFunction' function uses the 'dynamic_cast' operator to attempt to convert a 'Base' pointer to a 'Derived' pointer. If the conversion is successful, the 'derivedObj' pointer will point to the 'Derived' object; otherwise, it will be a null pointer.</p>
      </article>
      <article>
        <h3>8. Conclusion</h3>
        <p>Virtual functions are a powerful feature of C++ that enable polymorphism and help create extensible, maintainable code. By understanding the concepts and techniques surrounding virtual functions, friend functions, static functions, assignment and copy initialization, the 'this' pointer, and dynamic type information, you can effectively leverage the power of object-oriented programming in C++ and create complex, robust software solutions.</p>
      </article>
    </main>

    <script>copyright("all");</script>
  </body>

</html>
