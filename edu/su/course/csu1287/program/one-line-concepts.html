<!-------------------------- Â© 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
  <!--<![endif]-->

  <head>
    <script src="/js/edu_su_common.js"></script>
    <noscript>
      <style>
        html,
        body {
          margin: 0;
          overflow: hidden;
        }
      </style>
      <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
    </noscript>

    <title>1 line C++ Concepts - CSU1287 - CSE 2026 - Shoolini U</title>
    <meta name="description" content="Want to Brush up your C++ knowledge but in hurry?! Revisit key concepts and strengthen your understanding in just 1 line.">

    <meta property="og:image" content="/logo.png">
    <meta property="og:type" content="article">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@divyamohan1993">
    <meta name="twitter:creator" content="@divyamohan1993">
    <meta name="twitter:image" content="/logo.png">

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />

  </head>

  <body>

    <script>header_author("dm");</script>

    <main>
      <article>
        <h2 class="text-center">
          1 Line Concepts in C++
        </h2>

        <div class="container mt-4 w-100 w-xl-75">
          <div class="accordion" id="toc">
            <div class="accordion-item">
              <h2 class="accordion-header" id="h1">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#c1" aria-controls="c1" aria-expanded="false">
                  <i class="fas fa-book"></i> <strong>&nbsp;Table of Contents</strong>
                </button>
              </h2>
              <div id="c1" class="accordion-collapse collapse" aria-labelledby="h1" data-bs-parent="#toc">
                <div class="accordion-body">
                  <ol class="list-unstyled p-0 m-0">
                    <li class="p-1"><a href="#basics-of-cpp"><i class="fas fa-chevron-circle-right"></i> Basics of C++</a></li>
                    <li class="p-1"><a href="#classes-and-objects"><i class="fas fa-chevron-circle-right"></i> Classes and Objects</a></li>
                    <li class="p-1"><a href="#inheritance"><i class="fas fa-chevron-circle-right"></i> Inheritance</a></li>
                    <li class="p-1"><a href="#polymorphism"><i class="fas fa-chevron-circle-right"></i> Polymorphism</a></li>
                    <li class="p-1"><a href="#encapsulation"><i class="fas fa-chevron-circle-right"></i> Encapsulation</a></li>
                    <li class="p-1"><a href="#abstraction"><i class="fas fa-chevron-circle-right"></i> Abstraction</a></li>
                    <li class="p-1"><a href="#constructors-destructors"><i class="fas fa-chevron-circle-right"></i> Constructors & Destructors</a></li>
                    <li class="p-1"><a href="#exception-handling"><i class="fas fa-chevron-circle-right"></i> Exception Handling</a></li>
                    <li class="p-1"><a href="#file-handling"><i class="fas fa-chevron-circle-right"></i> File Handling</a></li>
                    <li class="p-1"><a href="#templates"><i class="fas fa-chevron-circle-right"></i> Templates</a></li>
                    <li class="p-1"><a href="#stl"><i class="fas fa-chevron-circle-right"></i> Standard Template Library</a></li>
                    <li class="p-1"><a href="#memory-management"><i class="fas fa-chevron-circle-right"></i> Memory Management</a></li>
                    <li class="p-1"><a href="#oop-design-principles"><i class="fas fa-chevron-circle-right"></i> OOP Design Principles</a></li>
                    <li class="p-1"><a href="#advanced-topics"><i class="fas fa-chevron-circle-right"></i> Advanced Topics</a></li>
                    </ul>
                </div>
              </div>
            </div>
          </div>
        </div>
      </article>

      <article id="basics-of-cpp">
        <h3>1. Basics of C++</h3>
        <p>Basics of C++ refers to understanding the fundamental syntax, data types, operators, and control structures of the C++ language.</p>
      </article>

      <article>
        <h4>1.1 Syntax</h4>
        <p>C++ syntax includes the rules and conventions that define the structure of the C++ programming language.</p>
      </article>

      <article>
        <h4>1.2 Data Types</h4>
        <p>Data types in C++ refer to the different types of data that can be used in the program, such as int for integers, float for floating-point numbers, and char for characters.</p>
      </article>

      <article>
        <h4>1.3 Operators</h4>
        <p>Operators in C++ are symbols that perform operations on variables and values. Examples include '+' for addition, '-' for subtraction, '*' for multiplication, and '/' for division.</p>
      </article>

      <article>
        <h4>1.4 Control Structures</h4>
        <p>Control structures in C++ manage the flow of a program. They include loops (for, while, do-while) and conditionals (if, else if, else, switch-case).</p>
      </article>

      <article id="classes-and-objects">
        <h3>2. Classes and Objects</h3>
        <p>A class in C++ is a blueprint for creating objects (a particular data structure), providing initial values for state (member variables) and implementations of behavior (member functions, also known as methods).</p>
        <pre><code class="language-cpp">class ClassName {
  // member variables
  // member functions
};</code></pre>
      </article>

      <article>
        <h4>2.1 Class Declaration</h4>
        <p>Class declaration involves defining the class name and the data members and member functions inside it.</p>
        <pre><code class="language-cpp">class ClassName {
  int dataMember1;
  char dataMember2;
  void memberFunction1() {}
};</code></pre>
      </article>

      <article>
        <h4>2.2 Object Creation</h4>
        <p>Object creation is the process of declaring an instance of a class.</p>
        <pre><code class="language-cpp">ClassName objectName;</code></pre>
      </article>

      <article id="inheritance">
        <h3>3. Inheritance</h3>
        <p>Inheritance in C++ is a process of creating new classes from existing ones, which allows for code reusability and is a key feature of OOP.</p>
        <pre><code class="language-cpp">class DerivedClass: public BaseClass {
};</code></pre>
      </article>

      <article>
        <h4>3.1 Single Inheritance</h4>
        <p>Single inheritance is when a class inherits from a single base class.</p>
        <pre><code class="language-cpp">class DerivedClass: public BaseClass {
};</code></pre>
      </article>

      <article>
        <h4>3.2 Multiple Inheritance</h4>
        <p>Multiple inheritance is when a class inherits from more than one base class.</p>
        <pre><code class="language-cpp">class DerivedClass: public BaseClass1, public BaseClass2 {
};</code></pre>
      </article>

      <article>
        <h4>3.3 Multilevel Inheritance</h4>
        <p>Multilevel inheritance is when a class inherits from a base class, which in turn inherits from another base class.</p>
        <pre><code class="language-cpp">class DerivedClass1: public BaseClass {
};
class DerivedClass2: public DerivedClass1 {
};</code></pre>
      </article>

      <article>
        <h4>3.4 Hierarchical Inheritance</h4>
        <p>Hierarchical inheritance is when one base class is inherited by more than one derived class.</p>
        <pre><code class="language-cpp">class DerivedClass1: public BaseClass {
};
class DerivedClass2: public BaseClass {
};</code></pre>
      </article>

      <article>
        <h4>3.5 Hybrid Inheritance</h4>
        <p>Hybrid inheritance is a combination of more than one types of inheritance.</p>
        <pre><code class="language-cpp">class DerivedClass1: public BaseClass1, public BaseClass2 {
};
class DerivedClass2: public DerivedClass1 {
};</code></pre>
      </article>

      <article id="polymorphism">
        <h3>4. Polymorphism</h3>
        <p>Polymorphism is a concept where a function behaves differently in different contexts. It includes function overloading and operator overloading (compile-time polymorphism), and virtual functions (runtime polymorphism).</p>
      </article>

      <article>
        <h4>4.1 Function Overloading</h4>
        <p>Function overloading is the ability of a function to perform different tasks, depending on the number or type of arguments.</p>
        <pre><code class="language-cpp">void functionName(int a) {}
void functionName(double a) {}</code></pre>
      </article>

      <article>
        <h4>4.2 Operator Overloading</h4>
        <p>Operator overloading allows operators to have user-defined meanings on user-defined types (classes).</p>
        <pre><code class="language-cpp">ClassName operator+(const ClassName&)</code></pre>
      </article>

      <article>
        <h4>4.3 Virtual Functions</h4>
        <p>Virtual functions are used in a class hierarchy and can be overridden in derived classes to ensure the correct function is called for an object, regardless of the type of reference (or pointer) used for function call.</p>
        <pre><code class="language-cpp">virtual returnType functionName(ArgumentType);</code></pre>
      </article>

      <article id="encapsulation">
        <h3>5. Encapsulation</h3>
        <p>Encapsulation in C++ is the idea of bundling data and functions into a single unit (a class), and restricting access to the data (using access modifiers like public, private, and protected).</p>
        <pre><code class="language-cpp">class ClassName {
  private:
    int data;
  public:
    void setData(int a) {
        data = a;
    }
    int getData() {
        return data;
    }
};</code></pre>
      </article>

      <article id="abstraction">
        <h3>6. Abstraction</h3>
        <p>Abstraction in C++ is a concept that allows hiding complex implementation details and providing a simple interface for users. It can be achieved using abstract classes and interfaces.</p>
      </article>

      <article>
        <h4>6.1 Abstract Classes</h4>
        <p>An abstract class is a class that has at least one pure virtual function, and cannot be instantiated.</p>
        <pre><code class="language-cpp">class AbstractClass {
  virtual void functionName() = 0; // Pure virtual function
};</code></pre>
      </article>

      <article id="constructors-destructors">
        <h3>7. Constructors and Destructors</h3>
        <p>Constructors and destructors in C++ are special member functions of a class that are automatically called when objects are created and destroyed.</p>
      </article>

      <article>
        <h4>7.1 Constructors</h4>
        <p>A constructor is a special function that initializes an object. They have the same name as the class and have no return type. There are three types of constructors: default, parameterized, and copy constructors.</p>
        <pre><code class="language-cpp">class ClassName {
  ClassName() {} // Default constructor
  ClassName(int a) {} // Parameterized constructor
  ClassName(const ClassName& obj) {} // Copy constructor
};</code></pre>
      </article>

      <article>
        <h4>7.2 Destructors</h4>
        <p>A destructor is a special function that is called when an object goes out of scope. It has the same name as the class, preceded by a tilde (~).</p>
        <pre><code class="language-cpp">class ClassName {
  ~ClassName() {} // Destructor
};</code></pre>
      </article>

      <article id="exception-handling">
        <h3>8. Exception Handling</h3>
        <p>Exception handling in C++ involves dealing with runtime errors using try, catch, and throw blocks.</p>
        <pre><code class="language-cpp">try {
  // Code that might throw an exception
} catch (ExceptionType1 ex1) {
  // Code to handle exception of type ExceptionType1
} catch (ExceptionType2 ex2) {
  // Code to handle exception of type ExceptionType2
}</code></pre>
      </article>

      <article id="file-handling">
        <h3>9. File Handling</h3>
        <p>File handling in C++ involves reading from and writing to files.</p>
        <pre><code class="language-cpp">fstream file;
file.open("example.txt", ios::out); // Writing to a file
file << "Writing to a file.";
file.close();

file.open("example.txt", ios::in); // Reading from a file
char ch;
while (file >> ch) {
  cout << ch;
}
file.close();</code></pre>
      </article>

      <article id="templates">
        <h3>10. Templates</h3>
        <p>Templates in C++ allow functions and classes to operate with generic types, allowing for more reusable and flexible code.</p>
      </article>

      <article>
        <h4>10.1 Function Templates</h4>
        <p>Function templates are functions that can be used with any data type.</p>
        <pre><code class="language-cpp">template &lt;typename T>
T functionName(T a, T b) {
  return a + b;
}</code></pre>
      </article>

      <article>
        <h4>10.2 Class Templates</h4>
        <p>Class templates allow classes to have members that use template parameters as types.</p>
        <pre><code class="language-cpp">template &lt;typename T>
class ClassName {
  T data;
  public:
    ClassName(T a) {
        data = a;
    }
    T getData() {
        return data;
    }
};</code></pre>
      </article>

      <article id="stl">
        <h3>11. STL - Standard Template Library</h3>
        <p>The STL is a library in C++ that provides several generic classes and functions, including containers, algorithms, iterators, and function objects.</p>
      </article>

      <article>
        <h4>11.1 Containers</h4>
        <p>Containers in the STL are classes that can hold and manage collections of elements. They include vector, list, deque, set, map, etc.</p>
      </article>

      <article>
        <h4>11.2 Algorithms</h4>
        <p>Algorithms in the STL are functions for processing sequences of elements. They include sort, reverse, find, etc.</p>
      </article>

      <article>
        <h4>11.3 Iterators</h4>
        <p>Iterators in the STL are used to iterate through elements of containers.</p>
      </article>

      <article>
        <h4>11.4 Function Objects</h4>
        <p>Function objects, also known as functors, are objects that can be called as if they are functions.</p>
      </article>

      <article id="memory-management">
        <h3>12. Memory Management</h3>
        <p>Memory management in C++ involves managing the memory allocated to your application, including allocation (using new), deallocation (using delete), and the concept of stack and heap.</p>
      </article>

      <article>
        <h4>12.1 Stack and Heap</h4>
        <p>The stack is used for static memory allocation and the heap is used for dynamic memory allocation.</p>
      </article>

      <article id="oop-design-principles">
        <h3>13. OOP Design Principles</h3>
        <p>OOP Design Principles guide the design of object-oriented software, including Single Responsibility Principle, Open-Closed Principle, Liskov Substitution Principle, Interface Segregation Principle, and Dependency Inversion Principle.</p>
      </article>

      <article>
        <h4>13.1 Single Responsibility Principle</h4>
        <p>Single Responsibility Principle states that a class should have one, and only one, reason to change.</p>
      </article>

      <article>
        <h4>13.2 Open-Closed Principle</h4>
        <p>Open-Closed Principle states that software entities should be open for extension but closed for modification.</p>
      </article>

      <article>
        <h4>13.3 Liskov Substitution Principle</h4>
        <p>Liskov Substitution Principle states that functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.</p>
      </article>

      <article>
        <h4>13.4 Interface Segregation Principle</h4>
        <p>Interface Segregation Principle states that clients should not be forced to depend on interfaces they do not use.</p>
      </article>

      <article>
        <h4>13.5 Dependency Inversion Principle</h4>
        <p>Dependency Inversion Principle states that high-level modules should not depend on low-level modules, both should depend on abstractions.</p>
      </article>

      <article id="binding">
        <h3>14. Binding</h3>
        <p>Binding in C++ refers to the process of associating a method call to the method body. It includes early (static) binding and late (dynamic) binding.</p>
      </article>

      <article>
        <h4>14.1 Early Binding (Static Binding)</h4>
        <p>Early binding in C++ is when the compiler directly associates a function call with the function to be executed. It includes function overloading and operator overloading.</p>
      </article>

      <article>
        <h4>14.2 Late Binding (Dynamic Binding)</h4>
        <p>Late binding in C++ is when the compiler is unable to associate a function call with the function to be executed. The correct function to be executed is determined at runtime. This includes the use of virtual functions.</p>
      </article>

      <article id="advanced-topics">
        <h3>15. Advanced Topics</h3>
        <p>Advanced topics in C++ include a variety of complex programming techniques and constructs.</p>
      </article>

      <article>
        <h4>15.1 Friend Classes and Functions</h4>
        <p>A friend function in C++ is a function that can access the private and protected members of a class as if it were a member of that class. A friend class is a class whose members have such access.</p>
        <pre><code class="language-cpp">class ClassName {
  friend class FriendClass;
  friend void friendFunction(ClassName&);
};</code></pre>
      </article>

      <article>
        <h4>15.2 Virtual Destructors</h4>
        <p>A virtual destructor in C++ ensures that the destructors for derived classes are called properly when an object is deleted through a base-class pointer.</p>
        <pre><code class="language-cpp">class BaseClass {
  virtual ~BaseClass() {}
};</code></pre>
      </article>

      <article>
        <h4>15.3 Smart Pointers</h4>
        <p>Smart pointers in C++ are a type of pointer that provides enhanced memory management features, like automatic deletion when no longer in use.</p>
        <pre><code class="language-cpp">std::unique_ptr<ClassName> ptr(new ClassName);</code></pre>
      </article>

      <article>
        <h4>15.4 Lambda Expressions</h4>
        <p>A lambda expression in C++ is an anonymous function that can be used to create anonymous objects for short sections of code.</p>
        <pre><code class="language-cpp">auto lambda = [](int a, int b) { return a + b; };</code></pre>
      </article>

      <article>
        <h4>15.5 Multithreading</h4>
        <p>Multithreading is a specialized form of multitasking that allows multiple threads of execution to run concurrently within a single program.</p>
        <pre><code class="language-cpp">#include &lt;thread>

void function_name() {
    // thread function code
}

std::thread t1(function_name);  // t1 starts running
t1.join();  // main thread waits for t1 to finish</code></pre>
      </article>

      <article>
        <h4>15.6 Exception Handling</h4>
        <p>Exception handling in C++ involves identifying and handling potential runtime errors.</p>
        <pre><code class="language-cpp">try {
  // code here
}
catch (const std::exception& e) {
  // catch and handle exception here
}</code></pre>
      </article>

      <article>
        <h4>15.7 NameSpaces</h4>
        <p>Namespaces in C++ are used to organize code into logical groups and to prevent name collisions that can occur especially when your code base includes multiple libraries.</p>
        <pre><code class="language-cpp">namespace namespace_name {
  // code here
}</code></pre>
      </article>

      <article>
        <h4>15.8 Regular Expressions</h4>
        <p>Regular expressions provide a concise and flexible means for matching strings of text, such as particular characters, words, or patterns of characters.</p>
        <pre><code class="language-cpp">#include &lt;regex>

std::string s ("subject");
std::regex e ("(sub)(.*)");   // matches words beginning by "sub"
std::cout << std::regex_replace (s,e,"replace") << std::endl;</code></pre>
      </article>

      <article>
        <h4>15.9 RAII (Resource Acquisition Is Initialization)</h4>
        <p>RAII is a programming idiom used in several object-oriented, statically-typed programming languages to describe a particular language behavior. In RAII, holding a resource is tied to object lifetime: resource allocation (acquisition) is done during object creation (specifically initialization), by the constructor, while resource deallocation (release) is done during object destruction, by the destructor.</p>
      </article>

      <article>
        <h4>15.10 Move Semantics and Rvalue References</h4>
        <p>Move semantics is a way to avoid expensive deep copy operations and improve performance by simply transferring the resources of one object to another. Rvalue references are a type of reference that can only bind to temporary objects.</p>
        <pre><code class="language-cpp">ClassName(ClassName&& other) { // Move constructor
  // steal the resources of other
}

ClassName& operator=(ClassName&& other) { // Move assignment
  if (this != &other) {
    // release any resources this object is holding
    // steal the resources of other
  }
  return *this;
}</code></pre>
      </article>
      <article>
        <h4>15.11 Core Object Concepts</h4>
        <p>Understanding core object concepts such as encapsulation, abstraction, polymorphism, classes, messages, association, and interfaces is essential for object-oriented programming.</p>
      </article>
      <article>
        <h4>15.12 Arrays as Class Member Data</h4>
        <p>Arrays can be defined as member data within classes, and the arrays can contain objects of another class. These arrays can be manipulated via member functions.</p>
      </article>
      <article>
        <h4>15.13 Data Conversions</h4>
        <p>Data conversion in C++ is the process of converting one data type to another. This can be done explicitly using type casting, or implicitly by the compiler.</p>
      </article>
      <article>
        <h4>15.14 Pitfalls of Operator Overloading and Conversion</h4>
        <p>While operator overloading can increase the readability and performance of your program, misuse can lead to confusion and errors. Similarly, data conversion can cause loss of data or precision if not used carefully.</p>
      </article>
      <article>
        <h4>15.15 Aggregation</h4>
        <p>Aggregation in C++ is a process where one class defines another class as any entity reference. It is another way to reuse the class. It is a form of association that represents HAS-A relationship.</p>
      </article>
      <article>
        <h4>15.16 Class Hierarchies</h4>
        <p>Class hierarchies are a way of organizing classes where one class inherits characteristics from one or more classes.</p>
      </article>
      <article>
        <h4>15.17 Public and Private Inheritance</h4>
        <p>Public inheritance means the public and protected members of the base class listed after the specifier keep their access permissions. Private inheritance means all public and protected members of the base class are private to the derived class.</p>
      </article>
      <article>
        <h4>15.18 The Address-of Operator</h4>
        <p>The address-of operator (&) in C++ is used to get the memory address of a variable.</p>
        <pre><code class="language-cpp">int var = 5;
std::cout << &var;  // Outputs the memory address of var</code></pre>
      </article>
      <article>
        <h4>15.19 Memory Management: New and Delete</h4>
        <p>The new operator is used to allocate memory dynamically on the heap for the object/variable. Conversely, the delete operator is used to deallocate memory from the heap.</p>
        <pre><code class="language-cpp">int* ptr = new int; // Allocation
delete ptr;  // Deallocation</code></pre>
      </article>
      <article>
        <h4>15.20 Friend Functions and Static Functions</h4>
        <p>A friend function is a function that has access to the private and protected members of a class. A static function is a function that belongs to the class rather than any object of the class.</p>
      </article>
      <article>
        <h4>15.21 Disk File I/O with Streams</h4>
        <p>Disk File I/O with streams involves reading from or writing to a file on the disk using stream operations.</p>
        <pre><code class="language-cpp">std::ifstream inFile("input.txt");  // Create an input file stream
std::ofstream outFile("output.txt");  // Create an output file stream</code></pre>
      </article>
      <article>
        <h4>15.22 Error Handling in File I/O</h4>
        <p>Error handling in file I/O involves checking whether a file was successfully opened before attempting to read from or write to it, and handling errors appropriately when they do occur.</p>
      </article>
      <article>
        <h4>15.23 Memory as a Stream Object</h4>
        <p>Memory can be used as a stream object through the use of stringstream in C++.</p>
        <pre><code class="language-cpp">std::stringstream ss;
ss << "Example of memory as a stream";</code></pre>
      </article>
      <article>
        <h4>15.24 Command Line Arguments</h4>
        <p>Command line arguments are parameters provided at the command line when running a program. These arguments are used to control the program from outside instead of hard coding those values inside the code.</p>
      </article>


      <hr>
      <article>
        <h3>In Short,</h3>
        <article>
          <h4>Basics of OOPS</h4>
          <p>Classes and objects: Classes are blueprints that define the structure and behavior of objects. Objects are instances of classes that hold data and perform actions.</p>
          <p>Encapsulation: Encapsulation is the bundling of data and functions within a class, allowing control over access to the data and hiding internal implementation details.</p>
          <p>Inheritance: Inheritance allows the creation of new classes by inheriting properties and behaviors from existing classes, enabling code reuse and creating class hierarchies.</p>
          <p>Polymorphism: Polymorphism refers to the ability to use objects of different types interchangeably. It allows objects to be treated as instances of their own class or any of its base classes.</p>
        </article>
        <article>
          <h4>C++ Language Features:</h4>
          <p>Classes and objects: Classes define the structure of objects, including their properties (data) and behaviors (functions). Objects are specific instances of classes.</p>
          <p>Constructors and destructors: Constructors are special functions used to initialize objects, while destructors are used to clean up resources when objects are destroyed.</p>
          <p>Static and constant members: Static members are shared by all objects of a class, while constant members cannot be modified once initialized.</p>
          <p>Operator overloading: Operator overloading allows defining custom behaviors for operators such as +, -, *, and /, enabling objects to be manipulated using familiar syntax.</p>
        </article>
        <article>
          <h4>Inheritance and Polymorphism:</h4>
          <p>Inheritance types: Single inheritance involves creating a new class from a single base class. Multiple inheritance allows inheriting from multiple base classes. Multilevel inheritance involves creating a chain of derived classes.</p>
          <p>Base and derived classes: Base classes are the existing classes from which new classes are derived. Derived classes inherit properties and behaviors from base classes.</p>
          <p>Virtual functions and function overriding: Virtual functions are functions declared in base classes that can be overridden in derived classes, enabling runtime polymorphism.</p>
          <p>Object slicing: Object slicing occurs when a derived class object is assigned to a base class object, leading to the loss of derived class-specific features.</p>
        </article>
        <article>
          <h4>Data Abstraction and Encapsulation:</h4>
          <p>Access specifiers: Access specifiers (public, private, and protected) control the visibility of class members. Public members are accessible outside the class, private members are accessible only within the class, and protected members are accessible within the class and its derived classes.</p>
          <p>Data encapsulation: Encapsulation is the process of bundling data and related functions within a class. It allows for data hiding and providing controlled access through public interfaces.</p>
          <p>Getters and setters: Getters and setters are methods used to access and modify private data members, ensuring controlled access to the data.</p>
          <p>Friend functions and classes: Friend functions or classes have access to private and protected members of a class, even though they are not members of the class.</p>
        </article>
        <article>
          <h4>Advanced OOPS Concepts:</h4>
          <p>Templates and generic programming: Templates allow writing generic code that can work with different data types, enabling code reusability and flexibility.</p>
          <p>Exception handling in classes: Exception handling mechanisms, such as try-catch blocks, can be used within classes to handle and manage errors and exceptional conditions.</p>
          <p>Virtual base classes and the diamond problem: Virtual base classes are used to resolve the diamond problem, which occurs in multiple inheritance when a derived class has two base classes that share a common base class.</p>
          <p>RTTI (Run-Time Type Identification): RTTI allows determining the type of an object at runtime, enabling dynamic type checking and casting.</p>
          <p>Object-oriented design patterns: Design patterns are reusable solutions to common design problems. Examples include Singleton (ensuring a class has only one instance), Factory (creating objects without specifying their concrete classes), Observer (defining a one-to-many dependency between objects), and Strategy (defining a family of algorithms and making them interchangeable).</p>
        </article>
        <article>
          <h4>Object-Oriented Analysis and Design (OOAD):</h4>
          <p>UML diagrams: UML is a visual modeling language used to represent classes, objects, relationships, and interactions. Class diagrams show the structure of classes, while object diagrams depict instances of classes.</p>
          <p>Use cases, actors, and scenarios: Use cases define interactions between actors (users or systems) and the system being developed. Actors represent entities interacting with the system, and scenarios describe specific interactions or sequences of actions.</p>
          <p>Design principles: SOLID principles (Single Responsibility, Open-Closed, Liskov Substitution, Interface Segregation, and Dependency Inversion) guide software design by promoting modularity, maintainability, and extensibility.</p>
          <p>Design patterns: Design patterns provide proven solutions for common design problems. Examples include Singleton, Factory, Observer, Strategy, and many others.</p>
        </article>
        <article>
          <h4>Standard Template Library (STL):</h4>
          <p>Containers: STL provides various containers such as vector (dynamic array), list (linked list), map (associative array), and more, for storing and manipulating data.</p>
          <p>Iterators and algorithms: Iterators are used to traverse and access elements within containers. Algorithms are generic functions that operate on containers using iterators, performing tasks like sorting, searching, and modifying elements.</p>
          <p>Function objects and predicates: Function objects (functors) are objects that can be called like functions, enabling custom behaviors in algorithms. Predicates are functions or function objects that return a Boolean value, used for conditions in algorithms.</p>
          <p>Generic algorithms and data structures: STL provides a rich collection of generic algorithms and data structures that can be readily used in C++ programs, promoting code reuse and efficient programming.</p>
        </article>
        <article>
          <h4>Memory Management and Resource Handling:</h4>
          <p>Dynamic memory allocation: C++ allows allocating memory dynamically using the new operator and deallocating it using the delete operator. This allows for flexible memory management during program execution.</p>
          <p>Memory leaks and smart pointers: Memory leaks occur when dynamically allocated memory is not freed, resulting in wasted memory. Smart pointers (e.g., unique_ptr, shared_ptr, weak_ptr) are smart memory management objects that automatically deallocate memory when it is no longer needed.</p>
          <p>RAII (Resource Acquisition Is Initialization) principle: RAII is a technique where resources (such as memory, file handles, etc.) are tied to the lifespan of objects. Resources are acquired during object initialization and released during object destruction, ensuring proper resource handling and preventing resource leaks.</p>
        </article>
        <article>
          <h4>Object-Oriented Software Development Principles:</h4>
          <p>Modularization and code organization: Modularization involves dividing code into smaller, manageable modules, improving readability, maintainability, and reusability.</p>
          <p>Code reusability and maintainability: Object-oriented programming emphasizes reusable code components, reducing code duplication and making maintenance easier.</p>
          <p>Testing and debugging techniques: Testing ensures the correctness of code through techniques like unit testing, integration testing, and debugging. These processes identify and fix errors and ensure the software functions as expected.</p>
          <p>Documentation and software development life cycle: Documentation provides descriptive information about code, APIs, and system functionality. The software development life cycle encompasses the stages of software development, including requirements gathering, design, implementation, testing, deployment, and maintenance.</p>
        </article>
      </article>
    </main>

    <script>copyright("all");</script>
  </body>

</html>
