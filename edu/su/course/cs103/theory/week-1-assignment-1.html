<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>

        <title>Week 1 - Assignment 1 - CS103 - Swayam</title>
        <meta name="description" content="Eren is on a spree to conquer as many cities as possible in his journey of the rumbling. Each city is connected to one or more city in a directed or undirected way. Directed edges (a,b) mean he can go from city a to city b, but not the other way around. Undirected edges mean both directions are viable for the path. After careful consideration, he has finalized a path from his starting city to the last destination city he wants to rumble. There are some cities in the path which can be pillaged multiple times, these are marked by self loops in the graph.">        

        <meta property="og:image" content="/logo.png">
        <meta property="og:type" content="article">

        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@divyamohan1993">
        <meta name="twitter:creator" content="@divyamohan1993">
        <meta name="twitter:image" content="/logo.png">

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />

        <meta name="author" content="Divya Mohan">
        <meta name="robots" content="index, follow">

        <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                renderMathInElement(document.body, {
                    // customised options
                    // • auto-render specific keys, e.g.:
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\(', right: '\\)', display: false },
                        { left: '\\[', right: '\\]', display: true }
                    ],
                    // • rendering keys, e.g.:
                    throwOnError: false
                });
            });
        </script> -->

        <style>

        </style>

    </head>

    <body>

        <script> header_author("dm"); </script>

        <main>
            <article class="agen-tableofcontents">
                <h2 class="text-center">
                    Week 1 - Assignment 1
                </h2>                
            </article>
            
            <div class="alert text-center alert-warning m-0" role="alert">
                <div class="fw-bold h5">Notice</div>
                <span class="text-center">The following content is the property of Swayam used for explaining the solution. All rights reserved by Swayam and their publishers. Do not copy the solution directly.</span>
            </div>

            <article class="autoid">
                <h3>Problem Statement</h3>
                <p>Eren is on a spree to conquer as many cities as possible in his journey of the rumbling. Each city is connected to one or more city in a directed or undirected way. Directed edges (a,b) mean he can go from city a to city b, but not the other way around. Undirected edges mean both directions are viable for the path. After careful consideration, he has finalized a path from his starting city to the last destination city he wants to rumble. There are some cities in the path which can be pillaged multiple times, these are marked by self loops in the graph.</p>
                <p>A self-loop in a graph is when a node's outgoing edge goes to the same node, or in short, when the Edge List (E) contains one (or more) entries of the form (n,n).</p>
                <div class="my-3 text-center">
                    <svg width="281" height="324" version="1.1" xmlns="http://www.w3.org/2000/svg">
                        <ellipse stroke="black" stroke-width="1" fill="none" cx="50.5" cy="83.5" rx="30" ry="30" /><text x="45.5" y="89.5" font-family="Times New Roman" font-size="20">1</text>
                        <ellipse stroke="black" stroke-width="1" fill="none" cx="231.5" cy="83.5" rx="30" ry="30" /><text x="226.5" y="89.5" font-family="Times New Roman" font-size="20">2</text>
                        <ellipse stroke="black" stroke-width="1" fill="none" cx="50.5" cy="258.5" rx="30" ry="30" /><text x="45.5" y="264.5" font-family="Times New Roman" font-size="20">3</text>
                        <ellipse stroke="black" stroke-width="1" fill="none" cx="231.5" cy="258.5" rx="30" ry="30" /><text x="226.5" y="264.5" font-family="Times New Roman" font-size="20">4</text>
                        <polygon stroke="black" stroke-width="1" points="72.068,104.353 209.932,237.647" />
                        <polygon fill="black" stroke-width="1" points="209.932,237.647 207.656,228.492 200.706,235.681" />
                        <polygon stroke="black" stroke-width="1" points="209.932,237.647 72.068,104.353" />
                        <polygon fill="black" stroke-width="1" points="72.068,104.353 74.344,113.508 81.294,106.319" />
                        <polygon stroke="black" stroke-width="1" points="72.068,237.647 209.932,104.353" />
                        <polygon fill="black" stroke-width="1" points="209.932,104.353 200.706,106.319 207.656,113.508" />
                        <polygon stroke="black" stroke-width="1" points="209.932,104.353 72.068,237.647" />
                        <polygon fill="black" stroke-width="1" points="72.068,237.647 81.294,235.681 74.344,228.492" />
                        <polygon stroke="black" stroke-width="1" points="80.5,258.5 201.5,258.5" />
                        <polygon fill="black" stroke-width="1" points="201.5,258.5 193.5,253.5 193.5,263.5" />
                        <polygon stroke="black" stroke-width="1" points="201.5,258.5 80.5,258.5" />
                        <polygon fill="black" stroke-width="1" points="80.5,258.5 88.5,263.5 88.5,253.5" />
                        <polygon stroke="black" stroke-width="1" points="80.5,83.5 201.5,83.5" />
                        <polygon fill="black" stroke-width="1" points="201.5,83.5 193.5,78.5 193.5,88.5" />
                        <polygon stroke="black" stroke-width="1" points="201.5,83.5 80.5,83.5" />
                        <polygon fill="black" stroke-width="1" points="80.5,83.5 88.5,88.5 88.5,78.5" />
                        <path stroke="black" stroke-width="1" fill="none" d="M 51.357,288.371 A 22.5,22.5 0 1 1 27.312,277.35" />
                        <polygon fill="black" stroke-width="1" points="27.312,277.35 17.888,276.917 22.794,285.631" />
                        <path stroke="black" stroke-width="1" fill="none" d="M 257.193,273.76 A 22.5,22.5 0 1 1 235.016,288.175" />
                        <polygon fill="black" stroke-width="1" points="235.016,288.175 229.607,295.905 239.593,296.424" />
                        <path stroke="black" stroke-width="1" fill="none" d="M 235.36,53.867 A 22.5,22.5 0 1 1 257.368,68.539" />
                        <polygon fill="black" stroke-width="1" points="257.368,68.539 266.606,70.452 263.136,61.074" />
                        <path stroke="black" stroke-width="1" fill="none" d="M 24.632,68.539 A 22.5,22.5 0 1 1 46.64,53.867" />
                        <polygon fill="black" stroke-width="1" points="46.64,53.867 51.958,46.075 41.966,45.672" />
                    </svg>
                </div>
                <p>In the decided optimum path, the self loops are represented by repeating the same node twice. For example, the optimal path for the above graph may be 1,1,2,2,3,3,4,4. However, if we pillage more than one city more than once, we may not have enough time to reach the destination in time. So, only one of the self-loop cities will be pillaged twice. The city with the highest node value would give the most benefit if pillaged multiple times.</p>
                <p>Given the path representation of the cities, find out the best city to pillage.</p>
            </article>
            <article class="autoid">
                <h4>Input Format</h4>
                <p>The first line of input is a single integer t, denoting the number of test cases. t test cases follow.</p>
                <p>Each test case has two lines of input.</p>
                <ul>
                    <li><strong>First line</strong>: two space-separated integers n and m, n denoting the length of the path representation, and m being the total number of cities.</li>
                    <li><strong>Second line</strong>: a string s of length n, which is the path representation of the optimum path, with repeated nodes marking self loops.</li>
                </ul>
            </article>
            <article class="autoid">
                <h4>Constraints</h4>
                <p>1 ≤ t ≤ 100</p>
                <p>1 ≤ m ≤ 9</p>
                <p>1 ≤ s<sub>i</sub> ≤ m ∀i[1,n]</p>
                <p>m ≤ n ≤ 2 × m</p>
                <p>Loops bigger than self loops are not viable paths.</p>
            </article>
            <article class="autoid">
                <h4>Output Format</h4>
                <p>For each test case, the output should be a single number x ∈ [1,m] denoting the city best suited for repeated pillaging. If there are no viable cities, return -1.</p>
            </article>
            <article class="autoid">
                <h4>Sample Input 1</h4>
                <pre><code>Input:
1
5 3
12233
</code></pre>
                <h4>Output:</h4>
                <pre><code>3</code></pre>
            </article>
            <article class="autoid">
                <h4>Explanation</h4>
                <p>There are three cities that can be pillaged repeatedly, they are 1, 2, 3. Out of the three, 3 has the highest node value, thus being the best choice for pillaging.</p>
            </article>

            <article class="autoid">
                <h4>Solution</h4>
                <pre class="language-python"><code>def find_best_city(t, test_cases):
    # Initialize an empty list to store results of each test case
    results = []

    # Loop through each test case
    for case in test_cases:
        n, m = case[0]  # Ignore n and take m as the highest number
        s = case[1]     # The path representation as a string

        # Check for the highest number (m) that is repeated in the string
        while m > 0:
            if s.count(str(m)) > 1:  # If m is repeated more than once in the string
                results.append(m)    # Store m as the result for this test case
                break                # Exit the loop since we found the answer
            m -= 1  # Decrement m to check for the next highest number
        else:
            # If no repeated number is found, append -1
            results.append(-1)

    return results  # Return the list of results for all test cases


# Reading the number of test cases from input
t = int(input())
# Initialize a list to store all test cases
test_cases = []

# Loop to read each test case
for _ in range(t):
    # Read n and m (we ignore n and only use m)
    n, m = map(int, input().split())
    # Read the path representation string s
    s = input().strip()
    # Append the test case as a tuple of ((n, m), s)
    test_cases.append(((n, m), s))

# Get the results for all test cases by calling the function
results = find_best_city(t, test_cases)

# Print the results for each test case
for result in results:
    print(result)
</code></pre>
            </article>

            <article>
                <h4>Sample Solution Provided by Instructor</h4>
                <pre class="language-python"><code>def solve(num):
    # Initialize a variable to keep track of the maximum digit found
    # that is repeated consecutively in the string. We start with a 
    # placeholder character that is less than any possible digit.
    max_digit = '\0'

    # Loop through the string 'num', but stop one character early to 
    # avoid out-of-bounds access when checking the next character.
    for index in range(len(num) - 1):
        # Check if the current character is the same as the next character.
        if num[index] == num[index + 1]:
            # If it is, update max_digit to the maximum value between
            # the current max_digit and the current character.
            max_digit = max(max_digit, num[index])
    
    # After the loop, if no consecutive repeated digit was found,
    # max_digit would still be the initial placeholder '\0'.
    # We return '-1' to indicate that no such digit exists.
    # Otherwise, we return the largest digit that was found to be repeated consecutively.
    return '-1' if max_digit == '\0' else max_digit

# Read the number of test cases (t) from the input.
t = int(input())

# Loop through each test case.
for _ in range(t):
    # Read two integers 'n' and 'm' from the input.
    # These integers are currently unused in the solve function.
    n, m = map(int, input().split())
    
    # Read the string 'num' from the input, which represents the number 
    # in which we are supposed to find the largest consecutive repeated digit.
    num = input()
    
    # Call the solve function with the input string 'num' and print the result.
    print(solve(num))
</code></pre>
            </article>
            
        </main>

        <script> copyright("some"); </script>

    </body>

</html>