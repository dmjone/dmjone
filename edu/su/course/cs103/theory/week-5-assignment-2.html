<!-------------------------- © 2007 - present, dmj.one and contributors. ----------------------------------
   Part of the dmjone project. Licensed under the GNU AGPL. Provided as-is, without warranty of any kind. 
-------------------- Redistribution and modifications must retain this notice. --------------------------->


<!DOCTYPE html>
<!--[if lte 8]><html class="pre-ie9" lang="en"><![endif]-->
<!--[if gte IE 9]><!-->
<html lang="en">
    <!--<![endif]-->

    <head>
        <script src="/js/edu_su_common.js"></script>
        <noscript>
            <style>
                html,
                body {
                    margin: 0;
                    overflow: hidden;
                }
            </style>
            <iframe src="/frame_noscript.html" style="width:100%;height:100vh;border:none;display:block"></iframe>
        </noscript>

        <title>Week 5 - Assignment 2 - CS103 - Swayam</title>


        <meta property="og:image" content="/logo.png">
        <meta property="og:type" content="article">

        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@divyamohan1993">
        <meta name="twitter:creator" content="@divyamohan1993">
        <meta name="twitter:image" content="/logo.png">

        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />

        <meta name="author" content="Divya Mohan">
        <meta name="robots" content="index, follow">

        <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js" integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js" integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                renderMathInElement(document.body, {
                    // customised options
                    // • auto-render specific keys, e.g.:
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\(', right: '\\)', display: false },
                        { left: '\\[', right: '\\]', display: true }
                    ],
                    // • rendering keys, e.g.:
                    throwOnError: false
                });
            });
        </script> -->

        <style>

        </style>

    </head>

    <body>

        <script> header_author("dm"); </script>

        <main>
            <article class="agen-tableofcontents">
                <h2 class="text-center">
                    Week 5 - Assignment 2
                </h2>
            </article>

            <div class="alert text-center alert-warning m-0" role="alert">
                <div class="fw-bold h5">Notice</div>
                <span class="text-center">The following content is the property of Swayam used for explaining the solution. All rights reserved by Swayam and their publishers. Do not copy the solution directly.</span>
            </div>
<article>
    <h3>Problem Statement</h3>
    <p>You are teaching a class of <em>n</em> students. Each student may be friends with some other students or may have no friends. Students who are friends with each other sit adjacent to each other in the class. If a student <em>a</em> is friends with a student <em>b</em>, but not with a student <em>c</em>, but <em>b</em> is friends with <em>c</em>, then they still sit together as both <em>a</em> and <em>c</em> will sit adjacent to <em>b</em>, their mutual friend. All friendships are symmetric, meaning that if <em>a</em> is a friend of <em>b</em>, then <em>b</em> is a friend of <em>a</em> for all <em>a, b ∈ Students</em>.</p>
    <p>You are trying to give the students a group project, but the students are adamant and will not agree to random grouping. You are thus left with no choice but to let them create groups with their friends. This may lead to unequal size groups.</p>
    <p>You don't know which student is friends with which student, and asking the same from all <em>n</em> students will require a lot of time. Thus, you decide to simply look at how they are sitting and form groups that way.</p>
    <p>A student <em>a</em> will be in the same project group with a student <em>b</em> if either <em>a</em> and <em>b</em> are friends, or <em>a</em> and <em>c</em> are friends and <em>b</em> and <em>c</em> are friends, for any arbitrary student <em>c</em>, such that <em>c ≠ a</em> and <em>c ≠ b</em>. Two students are friends with each other if they are sitting adjacent (horizontally or vertically, but not diagonally) to each other.</p>
    <p>Given the sitting arrangement of the students in a rectangular classroom, output the number of groups they will form for the project.</p>
</article>

<article>
    <h4>Input Format</h4>
    <p>The first line of input contains a single integer <em>t</em>, which is the number of test cases.</p>
    <p>Each test case contains several lines of input:</p>
    <ul>
        <li>The first line of input for each test case contains two space-separated integers <em>n</em> and <em>m</em>, which represent the dimensions of the room.</li>
        <li>The next <em>n</em> lines each contain <em>m</em> space-separated bits, where <em>0</em> represents no student is sitting there, and <em>1</em> represents a student is sitting there.</li>
    </ul>
</article>

<article>
    <h4>Constraints</h4>
    <ul>
        <li><em>1 ≤ t ≤ 10<sup>2</sup></em></li>
        <li><em>1 ≤ n, m ≤ 10<sup>2</sup></em></li>
        <li><em>B<sub>ij</sub> ∈ {0, 1}</em></li>
    </ul>
</article>

<article>
    <h4>Output Format</h4>
    <p>For each test case, output a single integer <em>x</em>, which is the number of groups the students will form.</p>
</article>

<article>
    <h4>Sample Input</h4>
    <pre><code class="language-auto">1
4 4
1 0 0 1
0 1 1 0
1 0 0 0
1 1 1 1
</code></pre>
</article>

<article>
    <h4>Sample Output</h4>
    <pre><code class="language-auto">4
</code></pre>
</article>

<article>
    <h4>Explanation</h4>
    <p>In the classroom, there are 4 connected groups of students with sizes {1, 1, 2, 5} sitting together. Thus, they will form 4 groups for the group project.</p>
</article>


            <article>
                <h4>Solution</h4>
                <pre class="language-python"><code>def dfs(grid, visited, i, j, n, m):
    # Check if the current cell is out of bounds or has been visited already,
    # or if the cell is not a student (represented by 1 in the grid).
    if i < 0 or j < 0 or i >= n or j >= m or visited[i][j] or grid[i][j] == 0:
        return  # If any of these conditions are met, return and do not proceed further.
    
    # Mark the current cell as visited
    visited[i][j] = True
    
    # Recursively explore all four possible directions: up, down, left, right
    # Move up (row - 1)
    dfs(grid, visited, i - 1, j, n, m)
    # Move down (row + 1)
    dfs(grid, visited, i + 1, j, n, m)
    # Move left (column - 1)
    dfs(grid, visited, i, j - 1, n, m)
    # Move right (column + 1)
    dfs(grid, visited, i, j + 1, n, m)

def count_groups(grid, n, m):
    # Initialize a 2D list `visited` to keep track of which cells have been visited.
    # Initially, all cells are unvisited, so all values are set to False.
    visited = [[False for _ in range(m)] for _ in range(n)]
    
    # Variable to keep count of the number of groups (connected components)
    group_count = 0
    
    # Iterate over every cell in the grid
    for i in range(n):
        for j in range(m):
            # If the current cell contains a student (1) and hasn't been visited yet,
            # it's the start of a new group.
            if grid[i][j] == 1 and not visited[i][j]:
                # Perform DFS to visit all connected cells (part of the same group)
                dfs(grid, visited, i, j, n, m)
                # Increment the group count after finishing the DFS, indicating one complete group has been found
                group_count += 1
    
    # Return the total number of groups found in the grid
    return group_count

# Reading input
t = int(input())  # Read the number of test cases
for _ in range(t):
    n, m = map(int, input().split())  # Read the dimensions of the grid (n: rows, m: columns)
    
    # Initialize the grid as an empty list
    grid = []
    
    # Read each row of the grid
    for _ in range(n):
        # Convert each input line to a list of integers and append it to the grid
        grid.append(list(map(int, input().split())))
    
    # Output the number of groups (connected components of students) for each test case
    print(count_groups(grid, n, m))
</code></pre>
            </article>

            <article>
                <h4>Sample Solution Provided by Instructor</h4>
                <pre class="language-python"><code>def groups(grid):
    if not grid:
        return 0  # If the grid is empty, return 0 as there are no groups.

    # Helper function to perform DFS and mark visited cells.
    def dfs(i, j):
        # If the current cell is out of bounds or not a '1', return (stop recursion).
        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1:
            return
        grid[i][j] = 0  # Mark the cell as visited by setting it to '0'.

        # Recursively visit all adjacent cells (up, down, left, right).
        dfs(i+1, j)  # Move down
        dfs(i-1, j)  # Move up
        dfs(i, j+1)  # Move right
        dfs(i, j-1)  # Move left

    ngroups = 0  # Initialize the group counter.

    # Iterate over all cells in the grid.
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == 1:  # Found an unvisited '1', which is the start of a new group.
                ngroups += 1  # Increment the group counter.
                dfs(i, j)  # Perform DFS to visit the entire group.

    return ngroups  # Return the total number of groups found.

# Main logic to handle multiple test cases.
t = int(input())  # Read the number of test cases.
for _ in range(t):
    n, m = list(map(int, input().split()))  # Read the dimensions of the grid.
    grid = []
    for _ in range(n):
        grid.append(list(map(int, input().split())))  # Read the grid row by row.
    print(groups(grid))  # Print the number of groups for the current grid.
</code></pre>
            </article>


        </main>

        <script> copyright("all"); </script>

    </body>

</html>
